// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export playerVehicles ; export beriaBase ; export kirovBase ; export meetBelkovBrother ; export platonovOpinion ; export belkovReturn ; export meetPlatonov ; export labConstructed , workshopConstructed , engineResearched , canBuildSameBuilding ; export constructedFirstVehicle , firstVeh ; export vehicleForKurin ; export backToBeria1 , backToBeria2 ; export construcMoreVehicles , constructedVehiclesCounter ; export canExitBase , canExploreMap ; export spawnCrates ; export canRemoveBelkovUnits , removedBelkovUntis , immortalBelkovTeam , immortalVehLive ; export kirovConstructedBunkers ; export activateAMAI , activateBelkovAI ; export sawLeftBunker , sawRightBunker ; export dialogAttackLeftBunkers , dialogAttackRightBunkers , dialogLoopBlocker ; export playerGetSupport ; export saveBelkovDecision ; export saveBelkovObjective , belkovSaved ; export captureBelkovVehicle ; export raportForPlatonov , medalForGetSupport ; export northMapExplored ; export initiative ; export lostComradesCounter ; export achievement_ConstructVehicles ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 373 0 0
// PrepareRussian ;
  24: CALL 1112 0 0
// PrepareNature ;
  28: CALL 16474 0 0
// playerVehicles = [ ] ;
  32: LD_ADDR_EXP 1
  36: PUSH
  37: EMPTY
  38: ST_TO_ADDR
// beriaBase = [ ] ;
  39: LD_ADDR_EXP 2
  43: PUSH
  44: EMPTY
  45: ST_TO_ADDR
// kirovBase = [ ] ;
  46: LD_ADDR_EXP 3
  50: PUSH
  51: EMPTY
  52: ST_TO_ADDR
// meetBelkovBrother = false ;
  53: LD_ADDR_EXP 4
  57: PUSH
  58: LD_INT 0
  60: ST_TO_ADDR
// platonovOpinion = - 1 ;
  61: LD_ADDR_EXP 5
  65: PUSH
  66: LD_INT 1
  68: NEG
  69: ST_TO_ADDR
// belkovReturn = TestCharacters ( 01_Belkov ) ;
  70: LD_ADDR_EXP 6
  74: PUSH
  75: LD_STRING 01_Belkov
  77: PPUSH
  78: CALL_OW 28
  82: ST_TO_ADDR
// meetPlatonov = false ;
  83: LD_ADDR_EXP 7
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// labConstructed = false ;
  91: LD_ADDR_EXP 8
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// workshopConstructed = false ;
  99: LD_ADDR_EXP 9
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// engineResearched = false ;
 107: LD_ADDR_EXP 10
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// canBuildSameBuilding = false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// constructedFirstVehicle = false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// vehicleForKurin = false ;
 131: LD_ADDR_EXP 14
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// backToBeria1 = false ;
 139: LD_ADDR_EXP 15
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// backToBeria2 = false ;
 147: LD_ADDR_EXP 16
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// construcMoreVehicles = false ;
 155: LD_ADDR_EXP 17
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// constructedVehiclesCounter = 0 ;
 163: LD_ADDR_EXP 18
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// spawnCrates = false ;
 171: LD_ADDR_EXP 21
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// canRemoveBelkovUnits = false ;
 179: LD_ADDR_EXP 22
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// removedBelkovUntis = 0 ;
 187: LD_ADDR_EXP 23
 191: PUSH
 192: LD_INT 0
 194: ST_TO_ADDR
// immortalBelkovTeam = false ;
 195: LD_ADDR_EXP 24
 199: PUSH
 200: LD_INT 0
 202: ST_TO_ADDR
// immortalVehLive = 1000 ;
 203: LD_ADDR_EXP 25
 207: PUSH
 208: LD_INT 1000
 210: ST_TO_ADDR
// canExitBase = true ;
 211: LD_ADDR_EXP 19
 215: PUSH
 216: LD_INT 1
 218: ST_TO_ADDR
// canExploreMap = false ;
 219: LD_ADDR_EXP 20
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// sawLeftBunker = false ;
 227: LD_ADDR_EXP 29
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// sawRightBunker = false ;
 235: LD_ADDR_EXP 30
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// dialogLoopBlocker = false ;
 243: LD_ADDR_EXP 33
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// dialogAttackLeftBunkers = false ;
 251: LD_ADDR_EXP 31
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// dialogAttackRightBunkers = false ;
 259: LD_ADDR_EXP 32
 263: PUSH
 264: LD_INT 0
 266: ST_TO_ADDR
// playerGetSupport = false ;
 267: LD_ADDR_EXP 34
 271: PUSH
 272: LD_INT 0
 274: ST_TO_ADDR
// captureBelkovVehicle = false ;
 275: LD_ADDR_EXP 38
 279: PUSH
 280: LD_INT 0
 282: ST_TO_ADDR
// saveBelkovObjective = false ;
 283: LD_ADDR_EXP 36
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// medalForGetSupport = true ;
 291: LD_ADDR_EXP 40
 295: PUSH
 296: LD_INT 1
 298: ST_TO_ADDR
// raportForPlatonov = - 1 ;
 299: LD_ADDR_EXP 39
 303: PUSH
 304: LD_INT 1
 306: NEG
 307: ST_TO_ADDR
// initiative = 0 ;
 308: LD_ADDR_EXP 42
 312: PUSH
 313: LD_INT 0
 315: ST_TO_ADDR
// lostComradesCounter = 0 ;
 316: LD_ADDR_EXP 43
 320: PUSH
 321: LD_INT 0
 323: ST_TO_ADDR
// northMapExplored = false ;
 324: LD_ADDR_EXP 41
 328: PUSH
 329: LD_INT 0
 331: ST_TO_ADDR
// kirovConstructedBunkers = 0 ;
 332: LD_ADDR_EXP 26
 336: PUSH
 337: LD_INT 0
 339: ST_TO_ADDR
// activateAMAI = false ;
 340: LD_ADDR_EXP 27
 344: PUSH
 345: LD_INT 0
 347: ST_TO_ADDR
// activateBelkovAI = false ;
 348: LD_ADDR_EXP 28
 352: PUSH
 353: LD_INT 0
 355: ST_TO_ADDR
// achievement_ConstructVehicles = 0 ;
 356: LD_ADDR_EXP 44
 360: PUSH
 361: LD_INT 0
 363: ST_TO_ADDR
// MissionIntro ;
 364: CALL 6834 0 0
// end ; end_of_file
 368: LD_VAR 0 1
 372: RET
// export function InitMapConfig ; begin
 373: LD_INT 0
 375: PPUSH
// BaseMapConfig ;
 376: CALL 389 0 0
// MissionMapConfig ;
 380: CALL 475 0 0
// end ;
 384: LD_VAR 0 1
 388: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 389: LD_INT 0
 391: PPUSH
// animalsAmount = [ 2 , 4 , 1 , 0 ] ;
 392: LD_ADDR_EXP 45
 396: PUSH
 397: LD_INT 2
 399: PUSH
 400: LD_INT 4
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: EMPTY
 410: LIST
 411: LIST
 412: LIST
 413: LIST
 414: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 415: LD_ADDR_EXP 46
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 2
 425: PUSH
 426: LD_INT 2
 428: PUSH
 429: LD_INT 2
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: ST_TO_ADDR
// animalsAgression = 0 ;
 438: LD_ADDR_EXP 47
 442: PUSH
 443: LD_INT 0
 445: ST_TO_ADDR
// debugMode = 0 ;
 446: LD_ADDR_EXP 50
 450: PUSH
 451: LD_INT 0
 453: ST_TO_ADDR
// missionPrefix = 02_ ;
 454: LD_ADDR_EXP 48
 458: PUSH
 459: LD_STRING 02_
 461: ST_TO_ADDR
// previousMissionPrefix = 01_ ;
 462: LD_ADDR_EXP 49
 466: PUSH
 467: LD_STRING 01_
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export kirovAmountPeople ; export meetWithKurinPositions , meetWithPlatonovPositions ; export labCratesRefund , workshopCratesRefund , oilPowerCratesRefund , armouryCratesRefund , bunkerCratesRefund ; export enemySkillLevel ; export trapAmountPeople ; export belkovAttackTime ; function MissionMapConfig ; begin
 475: LD_INT 0
 477: PPUSH
// meetWithKurinPositions = [ [ 162 , 107 ] , [ 162 , 108 ] , [ 163 , 109 ] , [ 163 , 110 ] , [ 162 , 109 ] , [ 161 , 107 ] , [ 161 , 106 ] ] ;
 478: LD_ADDR_EXP 52
 482: PUSH
 483: LD_INT 162
 485: PUSH
 486: LD_INT 107
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 162
 495: PUSH
 496: LD_INT 108
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: PUSH
 503: LD_INT 163
 505: PUSH
 506: LD_INT 109
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 163
 515: PUSH
 516: LD_INT 110
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 162
 525: PUSH
 526: LD_INT 109
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 161
 535: PUSH
 536: LD_INT 107
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: PUSH
 543: LD_INT 161
 545: PUSH
 546: LD_INT 106
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: ST_TO_ADDR
// meetWithPlatonovPositions = [ [ 113 , 96 ] , [ 114 , 97 ] , [ 114 , 98 ] ] ;
 562: LD_ADDR_EXP 53
 566: PUSH
 567: LD_INT 113
 569: PUSH
 570: LD_INT 96
 572: PUSH
 573: EMPTY
 574: LIST
 575: LIST
 576: PUSH
 577: LD_INT 114
 579: PUSH
 580: LD_INT 97
 582: PUSH
 583: EMPTY
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 114
 589: PUSH
 590: LD_INT 98
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: ST_TO_ADDR
// kirovAmountPeople = [ 10 , 1 , 2 , 1 ] ;
 602: LD_ADDR_EXP 51
 606: PUSH
 607: LD_INT 10
 609: PUSH
 610: LD_INT 1
 612: PUSH
 613: LD_INT 2
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: ST_TO_ADDR
// labCratesRefund = 20 ;
 625: LD_ADDR_EXP 54
 629: PUSH
 630: LD_INT 20
 632: ST_TO_ADDR
// workshopCratesRefund = 40 ;
 633: LD_ADDR_EXP 55
 637: PUSH
 638: LD_INT 40
 640: ST_TO_ADDR
// oilPowerCratesRefund = 20 ;
 641: LD_ADDR_EXP 56
 645: PUSH
 646: LD_INT 20
 648: ST_TO_ADDR
// armouryCratesRefund = 30 ;
 649: LD_ADDR_EXP 57
 653: PUSH
 654: LD_INT 30
 656: ST_TO_ADDR
// bunkerCratesRefund = 10 ;
 657: LD_ADDR_EXP 58
 661: PUSH
 662: LD_INT 10
 664: ST_TO_ADDR
// enemySkillLevel = [ 1 , 2 , 2 ] [ Difficulty ] ;
 665: LD_ADDR_EXP 59
 669: PUSH
 670: LD_INT 1
 672: PUSH
 673: LD_INT 2
 675: PUSH
 676: LD_INT 2
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: LD_OWVAR 67
 688: ARRAY
 689: ST_TO_ADDR
// trapAmountPeople = [ [ 3 , 2 , 1 , 1 ] , [ 3 , 2 , 1 , 1 ] , [ 3 , 2 , 1 , 1 ] ] [ Difficulty ] ;
 690: LD_ADDR_EXP 60
 694: PUSH
 695: LD_INT 3
 697: PUSH
 698: LD_INT 2
 700: PUSH
 701: LD_INT 1
 703: PUSH
 704: LD_INT 1
 706: PUSH
 707: EMPTY
 708: LIST
 709: LIST
 710: LIST
 711: LIST
 712: PUSH
 713: LD_INT 3
 715: PUSH
 716: LD_INT 2
 718: PUSH
 719: LD_INT 1
 721: PUSH
 722: LD_INT 1
 724: PUSH
 725: EMPTY
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PUSH
 731: LD_INT 3
 733: PUSH
 734: LD_INT 2
 736: PUSH
 737: LD_INT 1
 739: PUSH
 740: LD_INT 1
 742: PUSH
 743: EMPTY
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: PUSH
 749: EMPTY
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_OWVAR 67
 758: ARRAY
 759: ST_TO_ADDR
// belkovAttackTime = [ 10 10$0 , 8 8$0 , 6 6$0 ] [ Difficulty ] ;
 760: LD_ADDR_EXP 61
 764: PUSH
 765: LD_INT 21000
 767: PUSH
 768: LD_INT 16800
 770: PUSH
 771: LD_INT 12600
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: PUSH
 779: LD_OWVAR 67
 783: ARRAY
 784: ST_TO_ADDR
// end ;
 785: LD_VAR 0 1
 789: RET
// every 0 0$1 trigger debugMode do var i ;
 790: LD_EXP 50
 794: IFFALSE 1109
 796: GO 798
 798: DISABLE
 799: LD_INT 0
 801: PPUSH
// begin enable ;
 802: ENABLE
// FogOff ( your_side ) ;
 803: LD_OWVAR 2
 807: PPUSH
 808: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 812: LD_ADDR_VAR 0 1
 816: PUSH
 817: LD_INT 22
 819: PUSH
 820: LD_OWVAR 2
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: PUSH
 829: LD_INT 2
 831: PUSH
 832: LD_INT 21
 834: PUSH
 835: LD_INT 1
 837: PUSH
 838: EMPTY
 839: LIST
 840: LIST
 841: PUSH
 842: LD_INT 21
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: EMPTY
 849: LIST
 850: LIST
 851: PUSH
 852: EMPTY
 853: LIST
 854: LIST
 855: LIST
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PPUSH
 861: CALL_OW 69
 865: PUSH
 866: FOR_IN
 867: IFFALSE 883
// SetLives ( i , 1000 ) ;
 869: LD_VAR 0 1
 873: PPUSH
 874: LD_INT 1000
 876: PPUSH
 877: CALL_OW 234
 881: GO 866
 883: POP
 884: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
 885: LD_ADDR_VAR 0 1
 889: PUSH
 890: LD_INT 22
 892: PUSH
 893: LD_OWVAR 2
 897: PUSH
 898: EMPTY
 899: LIST
 900: LIST
 901: PUSH
 902: LD_INT 21
 904: PUSH
 905: LD_INT 1
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: PUSH
 912: EMPTY
 913: LIST
 914: LIST
 915: PPUSH
 916: CALL_OW 69
 920: PUSH
 921: FOR_IN
 922: IFFALSE 986
// begin SetSkill ( i , skill_combat , 10 ) ;
 924: LD_VAR 0 1
 928: PPUSH
 929: LD_INT 1
 931: PPUSH
 932: LD_INT 10
 934: PPUSH
 935: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
 939: LD_VAR 0 1
 943: PPUSH
 944: LD_INT 2
 946: PPUSH
 947: LD_INT 10
 949: PPUSH
 950: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
 954: LD_VAR 0 1
 958: PPUSH
 959: LD_INT 3
 961: PPUSH
 962: LD_INT 10
 964: PPUSH
 965: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
 969: LD_VAR 0 1
 973: PPUSH
 974: LD_INT 4
 976: PPUSH
 977: LD_INT 10
 979: PPUSH
 980: CALL_OW 237
// end ;
 984: GO 921
 986: POP
 987: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
 988: LD_ADDR_VAR 0 1
 992: PUSH
 993: LD_INT 22
 995: PUSH
 996: LD_OWVAR 2
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: PUSH
1005: LD_INT 2
1007: PUSH
1008: LD_INT 30
1010: PUSH
1011: LD_INT 0
1013: PUSH
1014: EMPTY
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 30
1020: PUSH
1021: LD_INT 1
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL_OW 69
1041: PUSH
1042: FOR_IN
1043: IFFALSE 1107
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1045: LD_VAR 0 1
1049: PPUSH
1050: CALL_OW 274
1054: PPUSH
1055: LD_INT 1
1057: PPUSH
1058: LD_INT 9999
1060: PPUSH
1061: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1065: LD_VAR 0 1
1069: PPUSH
1070: CALL_OW 274
1074: PPUSH
1075: LD_INT 2
1077: PPUSH
1078: LD_INT 9999
1080: PPUSH
1081: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1085: LD_VAR 0 1
1089: PPUSH
1090: CALL_OW 274
1094: PPUSH
1095: LD_INT 3
1097: PPUSH
1098: LD_INT 9999
1100: PPUSH
1101: CALL_OW 277
// end ;
1105: GO 1042
1107: POP
1108: POP
// end ; end_of_file
1109: PPOPN 1
1111: END
// export Burlak , Gnyevko , Belkov , Kirilenkova ; export other_survivors ; export Kurin , Belkov2 , otherKirovUnits ; export Kovalyuk , randomMech ; export kirovVehicle ; export belkovTeam ; export removedBelkovUntisSaved ; export removedBelkovVehicleSaved ; export Platonov , platSoldiers ; export Kuklajs , Benko ; export function PrepareRussian ; begin
1112: LD_INT 0
1114: PPUSH
// PrepareCharactersFromPreviousMission ;
1115: CALL 1534 0 0
// PrepareKirovBase ;
1119: CALL 1729 0 0
// PrepareBeriaBase ;
1123: CALL 2494 0 0
// end ;
1127: LD_VAR 0 1
1131: RET
// export function PrepareBelkovReturnTeam ; var unit , others , tmp ; begin
1132: LD_INT 0
1134: PPUSH
1135: PPUSH
1136: PPUSH
1137: PPUSH
// belkovTeam = [ ] ;
1138: LD_ADDR_EXP 73
1142: PUSH
1143: EMPTY
1144: ST_TO_ADDR
// uc_side = 6 ;
1145: LD_ADDR_OWVAR 20
1149: PUSH
1150: LD_INT 6
1152: ST_TO_ADDR
// uc_nation = nation_russian ;
1153: LD_ADDR_OWVAR 21
1157: PUSH
1158: LD_INT 3
1160: ST_TO_ADDR
// vc_chassis = removedBelkovVehicleSaved [ 1 ] ;
1161: LD_ADDR_OWVAR 37
1165: PUSH
1166: LD_EXP 75
1170: PUSH
1171: LD_INT 1
1173: ARRAY
1174: ST_TO_ADDR
// vc_engine = removedBelkovVehicleSaved [ 2 ] ;
1175: LD_ADDR_OWVAR 39
1179: PUSH
1180: LD_EXP 75
1184: PUSH
1185: LD_INT 2
1187: ARRAY
1188: ST_TO_ADDR
// vc_control = removedBelkovVehicleSaved [ 3 ] ;
1189: LD_ADDR_OWVAR 38
1193: PUSH
1194: LD_EXP 75
1198: PUSH
1199: LD_INT 3
1201: ARRAY
1202: ST_TO_ADDR
// vc_weapon = removedBelkovVehicleSaved [ 4 ] ;
1203: LD_ADDR_OWVAR 40
1207: PUSH
1208: LD_EXP 75
1212: PUSH
1213: LD_INT 4
1215: ARRAY
1216: ST_TO_ADDR
// vc_fuel_battery = removedBelkovVehicleSaved [ 5 ] ;
1217: LD_ADDR_OWVAR 41
1221: PUSH
1222: LD_EXP 75
1226: PUSH
1227: LD_INT 5
1229: ARRAY
1230: ST_TO_ADDR
// kirovVehicle = CreateVehicle ;
1231: LD_ADDR_EXP 72
1235: PUSH
1236: CALL_OW 45
1240: ST_TO_ADDR
// SetDir ( kirovVehicle , 3 ) ;
1241: LD_EXP 72
1245: PPUSH
1246: LD_INT 3
1248: PPUSH
1249: CALL_OW 233
// PlaceUnitArea ( kirovVehicle , BelkovReturnArea , false ) ;
1253: LD_EXP 72
1257: PPUSH
1258: LD_INT 11
1260: PPUSH
1261: LD_INT 0
1263: PPUSH
1264: CALL_OW 49
// belkovTeam = belkovTeam ^ kirovVehicle ;
1268: LD_ADDR_EXP 73
1272: PUSH
1273: LD_EXP 73
1277: PUSH
1278: LD_EXP 72
1282: ADD
1283: ST_TO_ADDR
// if TestCharacters ( 02_TmpBelkov ) then
1284: LD_STRING 02_TmpBelkov
1286: PPUSH
1287: CALL_OW 28
1291: IFFALSE 1336
// begin Belkov = CreateCharacter ( 02_TmpBelkov ) ;
1293: LD_ADDR_EXP 64
1297: PUSH
1298: LD_STRING 02_TmpBelkov
1300: PPUSH
1301: CALL_OW 34
1305: ST_TO_ADDR
// PlaceHumanInUnit ( Belkov , kirovVehicle ) ;
1306: LD_EXP 64
1310: PPUSH
1311: LD_EXP 72
1315: PPUSH
1316: CALL_OW 52
// belkovTeam = belkovTeam ^ Belkov ;
1320: LD_ADDR_EXP 73
1324: PUSH
1325: LD_EXP 73
1329: PUSH
1330: LD_EXP 64
1334: ADD
1335: ST_TO_ADDR
// end ; if TestCharacters ( 02_TmpBelkov2 ) then
1336: LD_STRING 02_TmpBelkov2
1338: PPUSH
1339: CALL_OW 28
1343: IFFALSE 1415
// begin Belkov2 = CreateCharacter ( 02_TmpBelkov2 ) ;
1345: LD_ADDR_EXP 68
1349: PUSH
1350: LD_STRING 02_TmpBelkov2
1352: PPUSH
1353: CALL_OW 34
1357: ST_TO_ADDR
// if not TestCharacters ( 02_TmpBelkov ) then
1358: LD_STRING 02_TmpBelkov
1360: PPUSH
1361: CALL_OW 28
1365: NOT
1366: IFFALSE 1384
// PlaceHumanInUnit ( Belkov2 , kirovVehicle ) else
1368: LD_EXP 68
1372: PPUSH
1373: LD_EXP 72
1377: PPUSH
1378: CALL_OW 52
1382: GO 1399
// PlaceUnitArea ( Belkov2 , BelkovReturnArea , false ) ;
1384: LD_EXP 68
1388: PPUSH
1389: LD_INT 11
1391: PPUSH
1392: LD_INT 0
1394: PPUSH
1395: CALL_OW 49
// belkovTeam = belkovTeam ^ Belkov2 ;
1399: LD_ADDR_EXP 73
1403: PUSH
1404: LD_EXP 73
1408: PUSH
1409: LD_EXP 68
1413: ADD
1414: ST_TO_ADDR
// end ; if TestCharacters ( 02_TmpKirilenkova ) then
1415: LD_STRING 02_TmpKirilenkova
1417: PPUSH
1418: CALL_OW 28
1422: IFFALSE 1468
// begin Kirilenkova = CreateCharacter ( 02_TmpKirilenkova ) ;
1424: LD_ADDR_EXP 65
1428: PUSH
1429: LD_STRING 02_TmpKirilenkova
1431: PPUSH
1432: CALL_OW 34
1436: ST_TO_ADDR
// PlaceUnitArea ( Kirilenkova , BelkovReturnArea , false ) ;
1437: LD_EXP 65
1441: PPUSH
1442: LD_INT 11
1444: PPUSH
1445: LD_INT 0
1447: PPUSH
1448: CALL_OW 49
// belkovTeam = belkovTeam ^ Kirilenkova ;
1452: LD_ADDR_EXP 73
1456: PUSH
1457: LD_EXP 73
1461: PUSH
1462: LD_EXP 65
1466: ADD
1467: ST_TO_ADDR
// end ; others = CreateCharacterSet ( 02_TmpBelkovTeam ) ;
1468: LD_ADDR_VAR 0 3
1472: PUSH
1473: LD_STRING 02_TmpBelkovTeam
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// for unit in others do
1481: LD_ADDR_VAR 0 2
1485: PUSH
1486: LD_VAR 0 3
1490: PUSH
1491: FOR_IN
1492: IFFALSE 1527
// begin PlaceUnitArea ( unit , BelkovReturnArea , false ) ;
1494: LD_VAR 0 2
1498: PPUSH
1499: LD_INT 11
1501: PPUSH
1502: LD_INT 0
1504: PPUSH
1505: CALL_OW 49
// belkovTeam = belkovTeam ^ unit ;
1509: LD_ADDR_EXP 73
1513: PUSH
1514: LD_EXP 73
1518: PUSH
1519: LD_VAR 0 2
1523: ADD
1524: ST_TO_ADDR
// end ;
1525: GO 1491
1527: POP
1528: POP
// end ;
1529: LD_VAR 0 1
1533: RET
// function PrepareCharactersFromPreviousMission ; var i ; begin
1534: LD_INT 0
1536: PPUSH
1537: PPUSH
// uc_side = 3 ;
1538: LD_ADDR_OWVAR 20
1542: PUSH
1543: LD_INT 3
1545: ST_TO_ADDR
// Burlak = PrepareUnit ( Burlak , true ) ;
1546: LD_ADDR_EXP 62
1550: PUSH
1551: LD_STRING Burlak
1553: PPUSH
1554: LD_INT 1
1556: PPUSH
1557: CALL 4030 0 2
1561: ST_TO_ADDR
// Gnyevko = PrepareUnit ( Gnyevko , true ) ;
1562: LD_ADDR_EXP 63
1566: PUSH
1567: LD_STRING Gnyevko
1569: PPUSH
1570: LD_INT 1
1572: PPUSH
1573: CALL 4030 0 2
1577: ST_TO_ADDR
// Belkov = PrepareUnit ( Belkov , true ) ;
1578: LD_ADDR_EXP 64
1582: PUSH
1583: LD_STRING Belkov
1585: PPUSH
1586: LD_INT 1
1588: PPUSH
1589: CALL 4030 0 2
1593: ST_TO_ADDR
// Kirilenkova = PrepareUnit ( Kirilenkova , true ) ;
1594: LD_ADDR_EXP 65
1598: PUSH
1599: LD_STRING Kirilenkova
1601: PPUSH
1602: LD_INT 1
1604: PPUSH
1605: CALL 4030 0 2
1609: ST_TO_ADDR
// PlaceUnitArea ( Burlak , BurlakSpawnArea , false ) ;
1610: LD_EXP 62
1614: PPUSH
1615: LD_INT 5
1617: PPUSH
1618: LD_INT 0
1620: PPUSH
1621: CALL_OW 49
// PlaceUnitArea ( Gnyevko , BurlakTeamSpawnArea , false ) ;
1625: LD_EXP 63
1629: PPUSH
1630: LD_INT 3
1632: PPUSH
1633: LD_INT 0
1635: PPUSH
1636: CALL_OW 49
// PlaceUnitArea ( Belkov , BurlakTeamSpawnArea , false ) ;
1640: LD_EXP 64
1644: PPUSH
1645: LD_INT 3
1647: PPUSH
1648: LD_INT 0
1650: PPUSH
1651: CALL_OW 49
// PlaceUnitArea ( Kirilenkova , BurlakTeamSpawnArea , false ) ;
1655: LD_EXP 65
1659: PPUSH
1660: LD_INT 3
1662: PPUSH
1663: LD_INT 0
1665: PPUSH
1666: CALL_OW 49
// CenterNowOnUnits ( Burlak ) ;
1670: LD_EXP 62
1674: PPUSH
1675: CALL_OW 87
// other_survivors = CreateCharacterSet ( 01_other_survivors ) ;
1679: LD_ADDR_EXP 66
1683: PUSH
1684: LD_STRING 01_other_survivors
1686: PPUSH
1687: CALL_OW 31
1691: ST_TO_ADDR
// for i in other_survivors do
1692: LD_ADDR_VAR 0 2
1696: PUSH
1697: LD_EXP 66
1701: PUSH
1702: FOR_IN
1703: IFFALSE 1722
// PlaceUnitArea ( i , BurlakTeamSpawnArea , false ) ;
1705: LD_VAR 0 2
1709: PPUSH
1710: LD_INT 3
1712: PPUSH
1713: LD_INT 0
1715: PPUSH
1716: CALL_OW 49
1720: GO 1702
1722: POP
1723: POP
// end ;
1724: LD_VAR 0 1
1728: RET
// function PrepareKirovBase ; var i , un ; begin
1729: LD_INT 0
1731: PPUSH
1732: PPUSH
1733: PPUSH
// SetBName ( kirov , kirov ) ;
1734: LD_INT 71
1736: PPUSH
1737: LD_STRING kirov
1739: PPUSH
1740: CALL_OW 500
// uc_side = 6 ;
1744: LD_ADDR_OWVAR 20
1748: PUSH
1749: LD_INT 6
1751: ST_TO_ADDR
// uc_nation = 3 ;
1752: LD_ADDR_OWVAR 21
1756: PUSH
1757: LD_INT 3
1759: ST_TO_ADDR
// hc_gallery =  ;
1760: LD_ADDR_OWVAR 33
1764: PUSH
1765: LD_STRING 
1767: ST_TO_ADDR
// hc_name =  ;
1768: LD_ADDR_OWVAR 26
1772: PUSH
1773: LD_STRING 
1775: ST_TO_ADDR
// Kurin = PrepareUnit ( Kurin , false ) ;
1776: LD_ADDR_EXP 67
1780: PUSH
1781: LD_STRING Kurin
1783: PPUSH
1784: LD_INT 0
1786: PPUSH
1787: CALL 4030 0 2
1791: ST_TO_ADDR
// Kovalyuk = PrepareUnit ( Kovalyuk , false ) ;
1792: LD_ADDR_EXP 70
1796: PUSH
1797: LD_STRING Kovalyuk
1799: PPUSH
1800: LD_INT 0
1802: PPUSH
1803: CALL 4030 0 2
1807: ST_TO_ADDR
// Belkov2 = PrepareUnit ( Belkov2 , false ) ;
1808: LD_ADDR_EXP 68
1812: PUSH
1813: LD_STRING Belkov2
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: CALL 4030 0 2
1823: ST_TO_ADDR
// PlaceUnitArea ( Kurin , KurinSpawnArea , false ) ;
1824: LD_EXP 67
1828: PPUSH
1829: LD_INT 4
1831: PPUSH
1832: LD_INT 0
1834: PPUSH
1835: CALL_OW 49
// PlaceUnitXYR ( Kovalyuk , 161 , 108 , 6 , false ) ;
1839: LD_EXP 70
1843: PPUSH
1844: LD_INT 161
1846: PPUSH
1847: LD_INT 108
1849: PPUSH
1850: LD_INT 6
1852: PPUSH
1853: LD_INT 0
1855: PPUSH
1856: CALL_OW 50
// ComHold ( Kurin ) ;
1860: LD_EXP 67
1864: PPUSH
1865: CALL_OW 140
// otherKirovUnits = [ ] ;
1869: LD_ADDR_EXP 69
1873: PUSH
1874: EMPTY
1875: ST_TO_ADDR
// kirovAmountPeople = Replace ( kirovAmountPeople , 1 , kirovAmountPeople [ 1 ] - UnitFilter ( other_survivors , [ f_class , class_soldier ] ) ) ;
1876: LD_ADDR_EXP 51
1880: PUSH
1881: LD_EXP 51
1885: PPUSH
1886: LD_INT 1
1888: PPUSH
1889: LD_EXP 51
1893: PUSH
1894: LD_INT 1
1896: ARRAY
1897: PUSH
1898: LD_EXP 66
1902: PPUSH
1903: LD_INT 25
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: EMPTY
1910: LIST
1911: LIST
1912: PPUSH
1913: CALL_OW 72
1917: MINUS
1918: PPUSH
1919: CALL_OW 1
1923: ST_TO_ADDR
// for i := 1 to kirovAmountPeople [ 1 ] do
1924: LD_ADDR_VAR 0 2
1928: PUSH
1929: DOUBLE
1930: LD_INT 1
1932: DEC
1933: ST_TO_ADDR
1934: LD_EXP 51
1938: PUSH
1939: LD_INT 1
1941: ARRAY
1942: PUSH
1943: FOR_TO
1944: IFFALSE 2123
// begin PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
1946: LD_INT 0
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 1
1954: PPUSH
1955: LD_INT 3
1957: PPUSH
1958: CALL_OW 12
1962: PPUSH
1963: CALL_OW 380
// un = CreateHuman ;
1967: LD_ADDR_VAR 0 3
1971: PUSH
1972: CALL_OW 44
1976: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
1977: LD_ADDR_EXP 69
1981: PUSH
1982: LD_EXP 69
1986: PUSH
1987: LD_VAR 0 3
1991: ADD
1992: ST_TO_ADDR
// if FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) then
1993: LD_INT 9
1995: PPUSH
1996: LD_INT 22
1998: PUSH
1999: LD_INT 6
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: PUSH
2006: LD_INT 21
2008: PUSH
2009: LD_INT 3
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: PUSH
2016: LD_INT 30
2018: PUSH
2019: LD_INT 31
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: PUSH
2026: LD_INT 58
2028: PUSH
2029: EMPTY
2030: LIST
2031: PUSH
2032: EMPTY
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL_OW 70
2042: IFFALSE 2109
// PlaceSolBun ( un , FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) [ 1 ] ) else
2044: LD_VAR 0 3
2048: PPUSH
2049: LD_INT 9
2051: PPUSH
2052: LD_INT 22
2054: PUSH
2055: LD_INT 6
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: PUSH
2062: LD_INT 21
2064: PUSH
2065: LD_INT 3
2067: PUSH
2068: EMPTY
2069: LIST
2070: LIST
2071: PUSH
2072: LD_INT 30
2074: PUSH
2075: LD_INT 31
2077: PUSH
2078: EMPTY
2079: LIST
2080: LIST
2081: PUSH
2082: LD_INT 58
2084: PUSH
2085: EMPTY
2086: LIST
2087: PUSH
2088: EMPTY
2089: LIST
2090: LIST
2091: LIST
2092: LIST
2093: PPUSH
2094: CALL_OW 70
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: CALL 5232 0 2
2107: GO 2121
// PlaceHumanInUnit ( un , ru2_arm2 ) ;
2109: LD_VAR 0 3
2113: PPUSH
2114: LD_INT 209
2116: PPUSH
2117: CALL_OW 52
// end ;
2121: GO 1943
2123: POP
2124: POP
// PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
2125: LD_INT 0
2127: PPUSH
2128: LD_INT 1
2130: PPUSH
2131: LD_INT 1
2133: PPUSH
2134: LD_INT 3
2136: PPUSH
2137: CALL_OW 12
2141: PPUSH
2142: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru2_arm2 ) ;
2146: CALL_OW 44
2150: PPUSH
2151: LD_INT 209
2153: PPUSH
2154: CALL_OW 52
// for i := 1 to kirovAmountPeople [ 2 ] do
2158: LD_ADDR_VAR 0 2
2162: PUSH
2163: DOUBLE
2164: LD_INT 1
2166: DEC
2167: ST_TO_ADDR
2168: LD_EXP 51
2172: PUSH
2173: LD_INT 2
2175: ARRAY
2176: PUSH
2177: FOR_TO
2178: IFFALSE 2241
// begin PrepareHuman ( false , 2 , rand ( 1 , 3 ) ) ;
2180: LD_INT 0
2182: PPUSH
2183: LD_INT 2
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 3
2191: PPUSH
2192: CALL_OW 12
2196: PPUSH
2197: CALL_OW 380
// un = CreateHuman ;
2201: LD_ADDR_VAR 0 3
2205: PUSH
2206: CALL_OW 44
2210: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2211: LD_ADDR_EXP 69
2215: PUSH
2216: LD_EXP 69
2220: PUSH
2221: LD_VAR 0 3
2225: ADD
2226: ST_TO_ADDR
// PlaceHumanInUnit ( un , kirov ) ;
2227: LD_VAR 0 3
2231: PPUSH
2232: LD_INT 71
2234: PPUSH
2235: CALL_OW 52
// end ;
2239: GO 2177
2241: POP
2242: POP
// for i := 1 to kirovAmountPeople [ 3 ] do
2243: LD_ADDR_VAR 0 2
2247: PUSH
2248: DOUBLE
2249: LD_INT 1
2251: DEC
2252: ST_TO_ADDR
2253: LD_EXP 51
2257: PUSH
2258: LD_INT 3
2260: ARRAY
2261: PUSH
2262: FOR_TO
2263: IFFALSE 2326
// begin PrepareHuman ( false , 3 , rand ( 1 , 3 ) ) ;
2265: LD_INT 0
2267: PPUSH
2268: LD_INT 3
2270: PPUSH
2271: LD_INT 1
2273: PPUSH
2274: LD_INT 3
2276: PPUSH
2277: CALL_OW 12
2281: PPUSH
2282: CALL_OW 380
// un = CreateHuman ;
2286: LD_ADDR_VAR 0 3
2290: PUSH
2291: CALL_OW 44
2295: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2296: LD_ADDR_EXP 69
2300: PUSH
2301: LD_EXP 69
2305: PUSH
2306: LD_VAR 0 3
2310: ADD
2311: ST_TO_ADDR
// PlaceHumanInUnit ( un , kirov ) ;
2312: LD_VAR 0 3
2316: PPUSH
2317: LD_INT 71
2319: PPUSH
2320: CALL_OW 52
// end ;
2324: GO 2262
2326: POP
2327: POP
// for i := 1 to kirovAmountPeople [ 4 ] do
2328: LD_ADDR_VAR 0 2
2332: PUSH
2333: DOUBLE
2334: LD_INT 1
2336: DEC
2337: ST_TO_ADDR
2338: LD_EXP 51
2342: PUSH
2343: LD_INT 4
2345: ARRAY
2346: PUSH
2347: FOR_TO
2348: IFFALSE 2411
// begin PrepareHuman ( false , 4 , rand ( 1 , 3 ) ) ;
2350: LD_INT 0
2352: PPUSH
2353: LD_INT 4
2355: PPUSH
2356: LD_INT 1
2358: PPUSH
2359: LD_INT 3
2361: PPUSH
2362: CALL_OW 12
2366: PPUSH
2367: CALL_OW 380
// un = CreateHuman ;
2371: LD_ADDR_VAR 0 3
2375: PUSH
2376: CALL_OW 44
2380: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2381: LD_ADDR_EXP 69
2385: PUSH
2386: LD_EXP 69
2390: PUSH
2391: LD_VAR 0 3
2395: ADD
2396: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
2397: LD_VAR 0 3
2401: PPUSH
2402: LD_INT 83
2404: PPUSH
2405: CALL_OW 52
// end ;
2409: GO 2347
2411: POP
2412: POP
// ResAllTechs ( 6 , ru_lab , 3 ) ;
2413: LD_INT 6
2415: PPUSH
2416: LD_INT 83
2418: PPUSH
2419: LD_INT 3
2421: PPUSH
2422: CALL 4845 0 3
// if not TestCharacters ( 01_Gnyevko ) then
2426: LD_STRING 01_Gnyevko
2428: PPUSH
2429: CALL_OW 28
2433: NOT
2434: IFFALSE 2477
// begin PrepareMechanic ( sex_male , 3 ) ;
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 3
2441: PPUSH
2442: CALL_OW 383
// randomMech = CreateHuman ;
2446: LD_ADDR_EXP 71
2450: PUSH
2451: CALL_OW 44
2455: ST_TO_ADDR
// PlaceUnitXYR ( randomMech , 161 , 108 , 6 , false ) ;
2456: LD_EXP 71
2460: PPUSH
2461: LD_INT 161
2463: PPUSH
2464: LD_INT 108
2466: PPUSH
2467: LD_INT 6
2469: PPUSH
2470: LD_INT 0
2472: PPUSH
2473: CALL_OW 50
// end ; PlaceHumanInUnit ( Belkov2 , ru2_arm1 ) ;
2477: LD_EXP 68
2481: PPUSH
2482: LD_INT 95
2484: PPUSH
2485: CALL_OW 52
// end ;
2489: LD_VAR 0 1
2493: RET
// function PrepareBeriaBase ; var i , un , unitsTemp , bunker ; begin
2494: LD_INT 0
2496: PPUSH
2497: PPUSH
2498: PPUSH
2499: PPUSH
2500: PPUSH
// SetBName ( beria , beria ) ;
2501: LD_INT 106
2503: PPUSH
2504: LD_STRING beria
2506: PPUSH
2507: CALL_OW 500
// uc_side = 6 ;
2511: LD_ADDR_OWVAR 20
2515: PUSH
2516: LD_INT 6
2518: ST_TO_ADDR
// uc_nation = 3 ;
2519: LD_ADDR_OWVAR 21
2523: PUSH
2524: LD_INT 3
2526: ST_TO_ADDR
// Platonov = PrepareUnit ( Platonov , false ) ;
2527: LD_ADDR_EXP 76
2531: PUSH
2532: LD_STRING Platonov
2534: PPUSH
2535: LD_INT 0
2537: PPUSH
2538: CALL 4030 0 2
2542: ST_TO_ADDR
// PlaceUnitXY ( Platonov , 112 , 97 , false ) ;
2543: LD_EXP 76
2547: PPUSH
2548: LD_INT 112
2550: PPUSH
2551: LD_INT 97
2553: PPUSH
2554: LD_INT 0
2556: PPUSH
2557: CALL_OW 48
// ComHold ( Platonov ) ;
2561: LD_EXP 76
2565: PPUSH
2566: CALL_OW 140
// platSoldiers = [ ] ;
2570: LD_ADDR_EXP 77
2574: PUSH
2575: EMPTY
2576: ST_TO_ADDR
// unitsTemp = [ ] ;
2577: LD_ADDR_VAR 0 4
2581: PUSH
2582: EMPTY
2583: ST_TO_ADDR
// Kuklajs = PrepareUnit ( Kuklajs , false ) ;
2584: LD_ADDR_EXP 78
2588: PUSH
2589: LD_STRING Kuklajs
2591: PPUSH
2592: LD_INT 0
2594: PPUSH
2595: CALL 4030 0 2
2599: ST_TO_ADDR
// platSoldiers = platSoldiers ^ Kuklajs ;
2600: LD_ADDR_EXP 77
2604: PUSH
2605: LD_EXP 77
2609: PUSH
2610: LD_EXP 78
2614: ADD
2615: ST_TO_ADDR
// PlaceUnitXYR ( Kuklajs , 110 , 97 , 6 , false ) ;
2616: LD_EXP 78
2620: PPUSH
2621: LD_INT 110
2623: PPUSH
2624: LD_INT 97
2626: PPUSH
2627: LD_INT 6
2629: PPUSH
2630: LD_INT 0
2632: PPUSH
2633: CALL_OW 50
// Benko = PrepareUnit ( Benko , false ) ;
2637: LD_ADDR_EXP 79
2641: PUSH
2642: LD_STRING Benko
2644: PPUSH
2645: LD_INT 0
2647: PPUSH
2648: CALL 4030 0 2
2652: ST_TO_ADDR
// platSoldiers = platSoldiers ^ Benko ;
2653: LD_ADDR_EXP 77
2657: PUSH
2658: LD_EXP 77
2662: PUSH
2663: LD_EXP 79
2667: ADD
2668: ST_TO_ADDR
// unitsTemp = unitsTemp ^ Benko ;
2669: LD_ADDR_VAR 0 4
2673: PUSH
2674: LD_VAR 0 4
2678: PUSH
2679: LD_EXP 79
2683: ADD
2684: ST_TO_ADDR
// for i := 1 to 2 do
2685: LD_ADDR_VAR 0 2
2689: PUSH
2690: DOUBLE
2691: LD_INT 1
2693: DEC
2694: ST_TO_ADDR
2695: LD_INT 2
2697: PUSH
2698: FOR_TO
2699: IFFALSE 2766
// begin PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
2701: LD_INT 0
2703: PPUSH
2704: LD_INT 1
2706: PPUSH
2707: LD_INT 1
2709: PPUSH
2710: LD_INT 3
2712: PPUSH
2713: CALL_OW 12
2717: PPUSH
2718: CALL_OW 380
// un = CreateHuman ;
2722: LD_ADDR_VAR 0 3
2726: PUSH
2727: CALL_OW 44
2731: ST_TO_ADDR
// platSoldiers = platSoldiers ^ un ;
2732: LD_ADDR_EXP 77
2736: PUSH
2737: LD_EXP 77
2741: PUSH
2742: LD_VAR 0 3
2746: ADD
2747: ST_TO_ADDR
// unitsTemp = unitsTemp ^ un ;
2748: LD_ADDR_VAR 0 4
2752: PUSH
2753: LD_VAR 0 4
2757: PUSH
2758: LD_VAR 0 3
2762: ADD
2763: ST_TO_ADDR
// end ;
2764: GO 2698
2766: POP
2767: POP
// for i := 1 to unitsTemp do
2768: LD_ADDR_VAR 0 2
2772: PUSH
2773: DOUBLE
2774: LD_INT 1
2776: DEC
2777: ST_TO_ADDR
2778: LD_VAR 0 4
2782: PUSH
2783: FOR_TO
2784: IFFALSE 2872
// begin bunker = FilterUnitsInArea ( BeriaBaseArea , [ [ f_side , 6 ] , [ f_btype , b_breastwork ] ] ) [ i ] ;
2786: LD_ADDR_VAR 0 5
2790: PUSH
2791: LD_INT 8
2793: PPUSH
2794: LD_INT 22
2796: PUSH
2797: LD_INT 6
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PUSH
2804: LD_INT 30
2806: PUSH
2807: LD_INT 31
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PPUSH
2818: CALL_OW 70
2822: PUSH
2823: LD_VAR 0 2
2827: ARRAY
2828: ST_TO_ADDR
// PlaceUnitXYR ( unitsTemp [ i ] , GetX ( bunker ) , GetY ( bunker ) , 2 , false ) ;
2829: LD_VAR 0 4
2833: PUSH
2834: LD_VAR 0 2
2838: ARRAY
2839: PPUSH
2840: LD_VAR 0 5
2844: PPUSH
2845: CALL_OW 250
2849: PPUSH
2850: LD_VAR 0 5
2854: PPUSH
2855: CALL_OW 251
2859: PPUSH
2860: LD_INT 2
2862: PPUSH
2863: LD_INT 0
2865: PPUSH
2866: CALL_OW 50
// end ;
2870: GO 2783
2872: POP
2873: POP
// end ; end_of_file
2874: LD_VAR 0 1
2878: RET
// export trapCommander ; export trapTeam ; export leftBunkers , rightBunkers ; export amLeftDepot , amRightDepot ; export amLeftEngs , amRightEngs ; export amVeh , amMech ; export function PrepareAmerican ; begin
2879: LD_INT 0
2881: PPUSH
// PrepareTrap ;
2882: CALL 2895 0 0
// PrepareBunkiers ;
2886: CALL 3485 0 0
// end ;
2890: LD_VAR 0 1
2894: RET
// function PrepareTrap ; var i , un ; begin
2895: LD_INT 0
2897: PPUSH
2898: PPUSH
2899: PPUSH
// trapTeam = [ ] ;
2900: LD_ADDR_EXP 81
2904: PUSH
2905: EMPTY
2906: ST_TO_ADDR
// uc_nation = 1 ;
2907: LD_ADDR_OWVAR 21
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
// uc_side = 1 ;
2915: LD_ADDR_OWVAR 20
2919: PUSH
2920: LD_INT 1
2922: ST_TO_ADDR
// hc_gallery =  ;
2923: LD_ADDR_OWVAR 33
2927: PUSH
2928: LD_STRING 
2930: ST_TO_ADDR
// hc_name =  ;
2931: LD_ADDR_OWVAR 26
2935: PUSH
2936: LD_STRING 
2938: ST_TO_ADDR
// hc_importance = 100 ;
2939: LD_ADDR_OWVAR 32
2943: PUSH
2944: LD_INT 100
2946: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , enemySkillLevel + 1 ) ;
2947: LD_INT 1
2949: PPUSH
2950: LD_INT 1
2952: PPUSH
2953: LD_EXP 59
2957: PUSH
2958: LD_INT 1
2960: PLUS
2961: PPUSH
2962: CALL_OW 380
// trapCommander = CreateHuman ;
2966: LD_ADDR_EXP 80
2970: PUSH
2971: CALL_OW 44
2975: ST_TO_ADDR
// PlaceUnitArea ( trapCommander , AmCommanderSpawn , false ) ;
2976: LD_EXP 80
2980: PPUSH
2981: LD_INT 13
2983: PPUSH
2984: LD_INT 0
2986: PPUSH
2987: CALL_OW 49
// ComCrawl ( trapCommander ) ;
2991: LD_EXP 80
2995: PPUSH
2996: CALL_OW 137
// trapTeam = trapTeam ^ trapCommander ;
3000: LD_ADDR_EXP 81
3004: PUSH
3005: LD_EXP 81
3009: PUSH
3010: LD_EXP 80
3014: ADD
3015: ST_TO_ADDR
// hc_importance = 0 ;
3016: LD_ADDR_OWVAR 32
3020: PUSH
3021: LD_INT 0
3023: ST_TO_ADDR
// for i := 1 to trapAmountPeople [ 1 ] do
3024: LD_ADDR_VAR 0 2
3028: PUSH
3029: DOUBLE
3030: LD_INT 1
3032: DEC
3033: ST_TO_ADDR
3034: LD_EXP 60
3038: PUSH
3039: LD_INT 1
3041: ARRAY
3042: PUSH
3043: FOR_TO
3044: IFFALSE 3136
// begin hc_name =  ;
3046: LD_ADDR_OWVAR 26
3050: PUSH
3051: LD_STRING 
3053: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3054: LD_INT 0
3056: PPUSH
3057: LD_INT 1
3059: PPUSH
3060: LD_EXP 59
3064: PPUSH
3065: CALL_OW 380
// un = CreateHuman ;
3069: LD_ADDR_VAR 0 3
3073: PUSH
3074: CALL_OW 44
3078: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn1 , false ) ;
3079: LD_VAR 0 3
3083: PPUSH
3084: LD_INT 12
3086: PPUSH
3087: LD_INT 0
3089: PPUSH
3090: CALL_OW 49
// ComCrawl ( un ) ;
3094: LD_VAR 0 3
3098: PPUSH
3099: CALL_OW 137
// AddComTurnXY ( un , 116 , 21 ) ;
3103: LD_VAR 0 3
3107: PPUSH
3108: LD_INT 116
3110: PPUSH
3111: LD_INT 21
3113: PPUSH
3114: CALL_OW 178
// trapTeam = trapTeam ^ un ;
3118: LD_ADDR_EXP 81
3122: PUSH
3123: LD_EXP 81
3127: PUSH
3128: LD_VAR 0 3
3132: ADD
3133: ST_TO_ADDR
// end ;
3134: GO 3043
3136: POP
3137: POP
// for i := 1 to trapAmountPeople [ 2 ] do
3138: LD_ADDR_VAR 0 2
3142: PUSH
3143: DOUBLE
3144: LD_INT 1
3146: DEC
3147: ST_TO_ADDR
3148: LD_EXP 60
3152: PUSH
3153: LD_INT 2
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3250
// begin hc_name =  ;
3160: LD_ADDR_OWVAR 26
3164: PUSH
3165: LD_STRING 
3167: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3168: LD_INT 0
3170: PPUSH
3171: LD_INT 1
3173: PPUSH
3174: LD_EXP 59
3178: PPUSH
3179: CALL_OW 380
// un = CreateHuman ;
3183: LD_ADDR_VAR 0 3
3187: PUSH
3188: CALL_OW 44
3192: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn2 , false ) ;
3193: LD_VAR 0 3
3197: PPUSH
3198: LD_INT 14
3200: PPUSH
3201: LD_INT 0
3203: PPUSH
3204: CALL_OW 49
// ComCrawl ( un ) ;
3208: LD_VAR 0 3
3212: PPUSH
3213: CALL_OW 137
// AddComTurnXY ( un , 116 , 21 ) ;
3217: LD_VAR 0 3
3221: PPUSH
3222: LD_INT 116
3224: PPUSH
3225: LD_INT 21
3227: PPUSH
3228: CALL_OW 178
// trapTeam = trapTeam ^ un ;
3232: LD_ADDR_EXP 81
3236: PUSH
3237: LD_EXP 81
3241: PUSH
3242: LD_VAR 0 3
3246: ADD
3247: ST_TO_ADDR
// end ;
3248: GO 3157
3250: POP
3251: POP
// for i := 1 to trapAmountPeople [ 3 ] do
3252: LD_ADDR_VAR 0 2
3256: PUSH
3257: DOUBLE
3258: LD_INT 1
3260: DEC
3261: ST_TO_ADDR
3262: LD_EXP 60
3266: PUSH
3267: LD_INT 3
3269: ARRAY
3270: PUSH
3271: FOR_TO
3272: IFFALSE 3364
// begin hc_name =  ;
3274: LD_ADDR_OWVAR 26
3278: PUSH
3279: LD_STRING 
3281: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3282: LD_INT 0
3284: PPUSH
3285: LD_INT 1
3287: PPUSH
3288: LD_EXP 59
3292: PPUSH
3293: CALL_OW 380
// un = CreateHuman ;
3297: LD_ADDR_VAR 0 3
3301: PUSH
3302: CALL_OW 44
3306: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn3 , false ) ;
3307: LD_VAR 0 3
3311: PPUSH
3312: LD_INT 23
3314: PPUSH
3315: LD_INT 0
3317: PPUSH
3318: CALL_OW 49
// ComCrawl ( un ) ;
3322: LD_VAR 0 3
3326: PPUSH
3327: CALL_OW 137
// AddComTurnXY ( un , 109 , 8 ) ;
3331: LD_VAR 0 3
3335: PPUSH
3336: LD_INT 109
3338: PPUSH
3339: LD_INT 8
3341: PPUSH
3342: CALL_OW 178
// trapTeam = trapTeam ^ un ;
3346: LD_ADDR_EXP 81
3350: PUSH
3351: LD_EXP 81
3355: PUSH
3356: LD_VAR 0 3
3360: ADD
3361: ST_TO_ADDR
// end ;
3362: GO 3271
3364: POP
3365: POP
// for i := 1 to trapAmountPeople [ 4 ] do
3366: LD_ADDR_VAR 0 2
3370: PUSH
3371: DOUBLE
3372: LD_INT 1
3374: DEC
3375: ST_TO_ADDR
3376: LD_EXP 60
3380: PUSH
3381: LD_INT 4
3383: ARRAY
3384: PUSH
3385: FOR_TO
3386: IFFALSE 3478
// begin hc_name =  ;
3388: LD_ADDR_OWVAR 26
3392: PUSH
3393: LD_STRING 
3395: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3396: LD_INT 0
3398: PPUSH
3399: LD_INT 1
3401: PPUSH
3402: LD_EXP 59
3406: PPUSH
3407: CALL_OW 380
// un = CreateHuman ;
3411: LD_ADDR_VAR 0 3
3415: PUSH
3416: CALL_OW 44
3420: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn4 , false ) ;
3421: LD_VAR 0 3
3425: PPUSH
3426: LD_INT 24
3428: PPUSH
3429: LD_INT 0
3431: PPUSH
3432: CALL_OW 49
// ComCrawl ( un ) ;
3436: LD_VAR 0 3
3440: PPUSH
3441: CALL_OW 137
// AddComTurnXY ( un , 109 , 8 ) ;
3445: LD_VAR 0 3
3449: PPUSH
3450: LD_INT 109
3452: PPUSH
3453: LD_INT 8
3455: PPUSH
3456: CALL_OW 178
// trapTeam = trapTeam ^ un ;
3460: LD_ADDR_EXP 81
3464: PUSH
3465: LD_EXP 81
3469: PUSH
3470: LD_VAR 0 3
3474: ADD
3475: ST_TO_ADDR
// end ;
3476: GO 3385
3478: POP
3479: POP
// end ;
3480: LD_VAR 0 1
3484: RET
// function PrepareBunkiers ; var i , un , bunker ; begin
3485: LD_INT 0
3487: PPUSH
3488: PPUSH
3489: PPUSH
3490: PPUSH
// uc_side = 1 ;
3491: LD_ADDR_OWVAR 20
3495: PUSH
3496: LD_INT 1
3498: ST_TO_ADDR
// uc_nation = nation_american ;
3499: LD_ADDR_OWVAR 21
3503: PUSH
3504: LD_INT 1
3506: ST_TO_ADDR
// bc_level = 1 ;
3507: LD_ADDR_OWVAR 43
3511: PUSH
3512: LD_INT 1
3514: ST_TO_ADDR
// bc_type = b_breastwork ;
3515: LD_ADDR_OWVAR 42
3519: PUSH
3520: LD_INT 31
3522: ST_TO_ADDR
// bunker = CreateAndPlaceBuildingXYD ( 104 , 59 , 4 ) ;
3523: LD_ADDR_VAR 0 4
3527: PUSH
3528: LD_INT 104
3530: PPUSH
3531: LD_INT 59
3533: PPUSH
3534: LD_INT 4
3536: PPUSH
3537: CALL_OW 47
3541: ST_TO_ADDR
// leftBunkers = leftBunkers ^ bunker ;
3542: LD_ADDR_EXP 82
3546: PUSH
3547: LD_EXP 82
3551: PUSH
3552: LD_VAR 0 4
3556: ADD
3557: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3558: LD_EXP 59
3562: PPUSH
3563: LD_VAR 0 4
3567: PPUSH
3568: CALL 5086 0 2
// bunker = CreateAndPlaceBuildingXYD ( 101 , 55 , 4 ) ;
3572: LD_ADDR_VAR 0 4
3576: PUSH
3577: LD_INT 101
3579: PPUSH
3580: LD_INT 55
3582: PPUSH
3583: LD_INT 4
3585: PPUSH
3586: CALL_OW 47
3590: ST_TO_ADDR
// leftBunkers = leftBunkers ^ bunker ;
3591: LD_ADDR_EXP 82
3595: PUSH
3596: LD_EXP 82
3600: PUSH
3601: LD_VAR 0 4
3605: ADD
3606: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3607: LD_EXP 59
3611: PPUSH
3612: LD_VAR 0 4
3616: PPUSH
3617: CALL 5086 0 2
// bunker = CreateAndPlaceBuildingXYD ( 132 , 62 , 1 ) ;
3621: LD_ADDR_VAR 0 4
3625: PUSH
3626: LD_INT 132
3628: PPUSH
3629: LD_INT 62
3631: PPUSH
3632: LD_INT 1
3634: PPUSH
3635: CALL_OW 47
3639: ST_TO_ADDR
// rightBunkers = rightBunkers ^ bunker ;
3640: LD_ADDR_EXP 83
3644: PUSH
3645: LD_EXP 83
3649: PUSH
3650: LD_VAR 0 4
3654: ADD
3655: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3656: LD_EXP 59
3660: PPUSH
3661: LD_VAR 0 4
3665: PPUSH
3666: CALL 5086 0 2
// bunker = CreateAndPlaceBuildingXYD ( 134 , 66 , 1 ) ;
3670: LD_ADDR_VAR 0 4
3674: PUSH
3675: LD_INT 134
3677: PPUSH
3678: LD_INT 66
3680: PPUSH
3681: LD_INT 1
3683: PPUSH
3684: CALL_OW 47
3688: ST_TO_ADDR
// rightBunkers = rightBunkers ^ bunker ;
3689: LD_ADDR_EXP 83
3693: PUSH
3694: LD_EXP 83
3698: PUSH
3699: LD_VAR 0 4
3703: ADD
3704: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3705: LD_EXP 59
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL 5086 0 2
// bc_type = b_depot ;
3719: LD_ADDR_OWVAR 42
3723: PUSH
3724: LD_INT 0
3726: ST_TO_ADDR
// amLeftDepot = CreateAndPlaceBuildingXYD ( 92 , 51 , 2 ) ;
3727: LD_ADDR_EXP 84
3731: PUSH
3732: LD_INT 92
3734: PPUSH
3735: LD_INT 51
3737: PPUSH
3738: LD_INT 2
3740: PPUSH
3741: CALL_OW 47
3745: ST_TO_ADDR
// amRightDepot = am_dep1 ;
3746: LD_ADDR_EXP 85
3750: PUSH
3751: LD_INT 193
3753: ST_TO_ADDR
// amLeftEngs = [ ] ;
3754: LD_ADDR_EXP 86
3758: PUSH
3759: EMPTY
3760: ST_TO_ADDR
// for i := 1 to [ 1 , 1 , rand ( 1 , 2 ) ] [ Difficulty ] do
3761: LD_ADDR_VAR 0 2
3765: PUSH
3766: DOUBLE
3767: LD_INT 1
3769: DEC
3770: ST_TO_ADDR
3771: LD_INT 1
3773: PUSH
3774: LD_INT 1
3776: PUSH
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 2
3782: PPUSH
3783: CALL_OW 12
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: LIST
3792: PUSH
3793: LD_OWVAR 67
3797: ARRAY
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3891
// begin uc_nation = 1 ;
3802: LD_ADDR_OWVAR 21
3806: PUSH
3807: LD_INT 1
3809: ST_TO_ADDR
// uc_side = 1 ;
3810: LD_ADDR_OWVAR 20
3814: PUSH
3815: LD_INT 1
3817: ST_TO_ADDR
// hc_gallery =  ;
3818: LD_ADDR_OWVAR 33
3822: PUSH
3823: LD_STRING 
3825: ST_TO_ADDR
// hc_name =  ;
3826: LD_ADDR_OWVAR 26
3830: PUSH
3831: LD_STRING 
3833: ST_TO_ADDR
// PrepareHuman ( false , 2 , enemySkillLevel ) ;
3834: LD_INT 0
3836: PPUSH
3837: LD_INT 2
3839: PPUSH
3840: LD_EXP 59
3844: PPUSH
3845: CALL_OW 380
// un = CreateHuman ;
3849: LD_ADDR_VAR 0 3
3853: PUSH
3854: CALL_OW 44
3858: ST_TO_ADDR
// amLeftEngs = amLeftEngs ^ un ;
3859: LD_ADDR_EXP 86
3863: PUSH
3864: LD_EXP 86
3868: PUSH
3869: LD_VAR 0 3
3873: ADD
3874: ST_TO_ADDR
// PlaceHumanInUnit ( un , amLeftDepot ) ;
3875: LD_VAR 0 3
3879: PPUSH
3880: LD_EXP 84
3884: PPUSH
3885: CALL_OW 52
// end ;
3889: GO 3799
3891: POP
3892: POP
// if Difficulty = 3 then
3893: LD_OWVAR 67
3897: PUSH
3898: LD_INT 3
3900: EQUAL
3901: IFFALSE 4025
// begin amRightEngs = [ ] ;
3903: LD_ADDR_EXP 87
3907: PUSH
3908: EMPTY
3909: ST_TO_ADDR
// for i := 1 to rand ( 1 , 2 ) do
3910: LD_ADDR_VAR 0 2
3914: PUSH
3915: DOUBLE
3916: LD_INT 1
3918: DEC
3919: ST_TO_ADDR
3920: LD_INT 1
3922: PPUSH
3923: LD_INT 2
3925: PPUSH
3926: CALL_OW 12
3930: PUSH
3931: FOR_TO
3932: IFFALSE 4023
// begin uc_nation = 1 ;
3934: LD_ADDR_OWVAR 21
3938: PUSH
3939: LD_INT 1
3941: ST_TO_ADDR
// uc_side = 1 ;
3942: LD_ADDR_OWVAR 20
3946: PUSH
3947: LD_INT 1
3949: ST_TO_ADDR
// hc_gallery =  ;
3950: LD_ADDR_OWVAR 33
3954: PUSH
3955: LD_STRING 
3957: ST_TO_ADDR
// hc_name =  ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING 
3965: ST_TO_ADDR
// PrepareHuman ( false , 2 , enemySkillLevel ) ;
3966: LD_INT 0
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: LD_EXP 59
3976: PPUSH
3977: CALL_OW 380
// un = CreateHuman ;
3981: LD_ADDR_VAR 0 3
3985: PUSH
3986: CALL_OW 44
3990: ST_TO_ADDR
// amRightEngs = amRightEngs ^ un ;
3991: LD_ADDR_EXP 87
3995: PUSH
3996: LD_EXP 87
4000: PUSH
4001: LD_VAR 0 3
4005: ADD
4006: ST_TO_ADDR
// PlaceHumanInUnit ( un , amRightDepot ) ;
4007: LD_VAR 0 3
4011: PPUSH
4012: LD_EXP 85
4016: PPUSH
4017: CALL_OW 52
// end ;
4021: GO 3931
4023: POP
4024: POP
// end ; end ; end_of_file
4025: LD_VAR 0 1
4029: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4030: LD_INT 0
4032: PPUSH
4033: PPUSH
// if exist_mode then
4034: LD_VAR 0 2
4038: IFFALSE 4063
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
4040: LD_ADDR_VAR 0 4
4044: PUSH
4045: LD_EXP 49
4049: PUSH
4050: LD_VAR 0 1
4054: STR
4055: PPUSH
4056: CALL_OW 34
4060: ST_TO_ADDR
4061: GO 4078
// unit := NewCharacter ( ident ) ;
4063: LD_ADDR_VAR 0 4
4067: PUSH
4068: LD_VAR 0 1
4072: PPUSH
4073: CALL_OW 25
4077: ST_TO_ADDR
// result := unit ;
4078: LD_ADDR_VAR 0 3
4082: PUSH
4083: LD_VAR 0 4
4087: ST_TO_ADDR
// end ;
4088: LD_VAR 0 3
4092: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio ) ; var i , speaker ; begin
4093: LD_INT 0
4095: PPUSH
4096: PPUSH
4097: PPUSH
// characters := characters diff [ Burlak , Gnyevko , Belkov , Kirilenkova ] ;
4098: LD_ADDR_VAR 0 1
4102: PUSH
4103: LD_VAR 0 1
4107: PUSH
4108: LD_EXP 62
4112: PUSH
4113: LD_EXP 63
4117: PUSH
4118: LD_EXP 64
4122: PUSH
4123: LD_EXP 65
4127: PUSH
4128: EMPTY
4129: LIST
4130: LIST
4131: LIST
4132: LIST
4133: DIFF
4134: ST_TO_ADDR
// speaker := characters [ rand ( 1 , characters ) ] ;
4135: LD_ADDR_VAR 0 7
4139: PUSH
4140: LD_VAR 0 1
4144: PUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_VAR 0 1
4152: PPUSH
4153: CALL_OW 12
4157: ARRAY
4158: ST_TO_ADDR
// if radio then
4159: LD_VAR 0 4
4163: IFFALSE 4212
// begin if GetSex ( speaker ) = sex_male then
4165: LD_VAR 0 7
4169: PPUSH
4170: CALL_OW 258
4174: PUSH
4175: LD_INT 1
4177: EQUAL
4178: IFFALSE 4196
// SayRadio ( speaker , dialogMID ) else
4180: LD_VAR 0 7
4184: PPUSH
4185: LD_VAR 0 2
4189: PPUSH
4190: CALL_OW 94
4194: GO 4210
// SayRadio ( speaker , dialogFID ) ;
4196: LD_VAR 0 7
4200: PPUSH
4201: LD_VAR 0 3
4205: PPUSH
4206: CALL_OW 94
// end else
4210: GO 4257
// begin if GetSex ( speaker ) = sex_male then
4212: LD_VAR 0 7
4216: PPUSH
4217: CALL_OW 258
4221: PUSH
4222: LD_INT 1
4224: EQUAL
4225: IFFALSE 4243
// Say ( speaker , dialogMID ) else
4227: LD_VAR 0 7
4231: PPUSH
4232: LD_VAR 0 2
4236: PPUSH
4237: CALL_OW 88
4241: GO 4257
// Say ( speaker , dialogFID ) ;
4243: LD_VAR 0 7
4247: PPUSH
4248: LD_VAR 0 3
4252: PPUSH
4253: CALL_OW 88
// end ; result := speaker ;
4257: LD_ADDR_VAR 0 5
4261: PUSH
4262: LD_VAR 0 7
4266: ST_TO_ADDR
// end ;
4267: LD_VAR 0 5
4271: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
4272: LD_INT 0
4274: PPUSH
// if GetSide ( character ) = side and IsOK ( character ) then
4275: LD_VAR 0 1
4279: PPUSH
4280: CALL_OW 255
4284: PUSH
4285: LD_VAR 0 3
4289: EQUAL
4290: PUSH
4291: LD_VAR 0 1
4295: PPUSH
4296: CALL_OW 302
4300: AND
4301: IFFALSE 4323
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
4303: LD_VAR 0 1
4307: PPUSH
4308: LD_EXP 48
4312: PUSH
4313: LD_VAR 0 2
4317: STR
4318: PPUSH
4319: CALL_OW 38
// end ;
4323: LD_VAR 0 4
4327: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
4328: LD_INT 0
4330: PPUSH
4331: PPUSH
4332: PPUSH
// resultCharactersToSave = [ ] ;
4333: LD_ADDR_VAR 0 6
4337: PUSH
4338: EMPTY
4339: ST_TO_ADDR
// for unit in characters do
4340: LD_ADDR_VAR 0 5
4344: PUSH
4345: LD_VAR 0 1
4349: PUSH
4350: FOR_IN
4351: IFFALSE 4399
// if GetSide ( unit ) = side and IsOK ( unit ) then
4353: LD_VAR 0 5
4357: PPUSH
4358: CALL_OW 255
4362: PUSH
4363: LD_VAR 0 3
4367: EQUAL
4368: PUSH
4369: LD_VAR 0 5
4373: PPUSH
4374: CALL_OW 302
4378: AND
4379: IFFALSE 4397
// resultCharactersToSave = resultCharactersToSave ^ unit ;
4381: LD_ADDR_VAR 0 6
4385: PUSH
4386: LD_VAR 0 6
4390: PUSH
4391: LD_VAR 0 5
4395: ADD
4396: ST_TO_ADDR
4397: GO 4350
4399: POP
4400: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
4401: LD_VAR 0 6
4405: PPUSH
4406: LD_EXP 48
4410: PUSH
4411: LD_VAR 0 2
4415: STR
4416: PPUSH
4417: CALL_OW 38
// end ;
4421: LD_VAR 0 4
4425: RET
// export function Question1 ( q ) ; var dec , q1 ; begin
4426: LD_INT 0
4428: PPUSH
4429: PPUSH
4430: PPUSH
// dec = SelectiveQuery ( QMoreInfo , q ) ;
4431: LD_ADDR_VAR 0 3
4435: PUSH
4436: LD_STRING QMoreInfo
4438: PPUSH
4439: LD_VAR 0 1
4443: PPUSH
4444: CALL_OW 98
4448: ST_TO_ADDR
// case dec of 1 :
4449: LD_VAR 0 3
4453: PUSH
4454: LD_INT 1
4456: DOUBLE
4457: EQUAL
4458: IFTRUE 4462
4460: GO 4522
4462: POP
// begin Say ( Burlak , D2a-Bur-1 ) ;
4463: LD_EXP 62
4467: PPUSH
4468: LD_STRING D2a-Bur-1
4470: PPUSH
4471: CALL_OW 88
// Say ( Platonov , D2a-Pla-1 ) ;
4475: LD_EXP 76
4479: PPUSH
4480: LD_STRING D2a-Pla-1
4482: PPUSH
4483: CALL_OW 88
// q1 = q diff 1 ;
4487: LD_ADDR_VAR 0 4
4491: PUSH
4492: LD_VAR 0 1
4496: PUSH
4497: LD_INT 1
4499: DIFF
4500: ST_TO_ADDR
// if q1 >= 2 then
4501: LD_VAR 0 4
4505: PUSH
4506: LD_INT 2
4508: GREATEREQUAL
4509: IFFALSE 4520
// Question1 ( q1 ) ;
4511: LD_VAR 0 4
4515: PPUSH
4516: CALL 4426 0 1
// end ; 2 :
4520: GO 4659
4522: LD_INT 2
4524: DOUBLE
4525: EQUAL
4526: IFTRUE 4530
4528: GO 4590
4530: POP
// begin Say ( Burlak , D2b-Bur-1 ) ;
4531: LD_EXP 62
4535: PPUSH
4536: LD_STRING D2b-Bur-1
4538: PPUSH
4539: CALL_OW 88
// Say ( Platonov , D2b-Pla-1 ) ;
4543: LD_EXP 76
4547: PPUSH
4548: LD_STRING D2b-Pla-1
4550: PPUSH
4551: CALL_OW 88
// q1 = q diff 2 ;
4555: LD_ADDR_VAR 0 4
4559: PUSH
4560: LD_VAR 0 1
4564: PUSH
4565: LD_INT 2
4567: DIFF
4568: ST_TO_ADDR
// if q1 >= 2 then
4569: LD_VAR 0 4
4573: PUSH
4574: LD_INT 2
4576: GREATEREQUAL
4577: IFFALSE 4588
// Question1 ( q1 ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: CALL 4426 0 1
// end ; 3 :
4588: GO 4659
4590: LD_INT 3
4592: DOUBLE
4593: EQUAL
4594: IFTRUE 4598
4596: GO 4658
4598: POP
// begin Say ( Burlak , D2c-Bur-1 ) ;
4599: LD_EXP 62
4603: PPUSH
4604: LD_STRING D2c-Bur-1
4606: PPUSH
4607: CALL_OW 88
// Say ( Platonov , D2c-Pla-1 ) ;
4611: LD_EXP 76
4615: PPUSH
4616: LD_STRING D2c-Pla-1
4618: PPUSH
4619: CALL_OW 88
// q1 = q diff 3 ;
4623: LD_ADDR_VAR 0 4
4627: PUSH
4628: LD_VAR 0 1
4632: PUSH
4633: LD_INT 3
4635: DIFF
4636: ST_TO_ADDR
// if q1 >= 2 then
4637: LD_VAR 0 4
4641: PUSH
4642: LD_INT 2
4644: GREATEREQUAL
4645: IFFALSE 4656
// Question1 ( q1 ) ;
4647: LD_VAR 0 4
4651: PPUSH
4652: CALL 4426 0 1
// end ; end ;
4656: GO 4659
4658: POP
// end ;
4659: LD_VAR 0 2
4663: RET
// export function ExtAddComRefuel ( engineer , depot , vehicle ) ; var taskList ; begin
4664: LD_INT 0
4666: PPUSH
4667: PPUSH
// if not IsOK ( engineer ) or not IsOK ( depot ) or not IsOK ( vehicle ) or GetFuel ( vehicle ) = 100 then
4668: LD_VAR 0 1
4672: PPUSH
4673: CALL_OW 302
4677: NOT
4678: PUSH
4679: LD_VAR 0 2
4683: PPUSH
4684: CALL_OW 302
4688: NOT
4689: OR
4690: PUSH
4691: LD_VAR 0 3
4695: PPUSH
4696: CALL_OW 302
4700: NOT
4701: OR
4702: PUSH
4703: LD_VAR 0 3
4707: PPUSH
4708: CALL_OW 261
4712: PUSH
4713: LD_INT 100
4715: EQUAL
4716: OR
4717: IFFALSE 4721
// exit ;
4719: GO 4840
// AddComTransport ( engineer , depot , mat_oil ) ;
4721: LD_VAR 0 1
4725: PPUSH
4726: LD_VAR 0 2
4730: PPUSH
4731: LD_INT 2
4733: PPUSH
4734: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
4738: LD_INT 35
4740: PPUSH
4741: CALL_OW 67
// until Carry ( engineer ) ;
4745: LD_VAR 0 1
4749: PPUSH
4750: CALL_OW 281
4754: IFFALSE 4738
// RemoveTasks ( engineer ) ;
4756: LD_VAR 0 1
4760: PPUSH
4761: CALL_OW 493
// SetTaskList ( engineer , [ [ O , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
4765: LD_VAR 0 1
4769: PPUSH
4770: LD_STRING O
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: LD_INT 0
4778: PUSH
4779: LD_VAR 0 3
4783: PUSH
4784: LD_INT 0
4786: PUSH
4787: LD_INT 0
4789: PUSH
4790: LD_INT 0
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: PUSH
4802: EMPTY
4803: LIST
4804: PPUSH
4805: CALL_OW 446
// repeat wait ( 0 0$1 ) ;
4809: LD_INT 35
4811: PPUSH
4812: CALL_OW 67
// until not Carry ( engineer ) ;
4816: LD_VAR 0 1
4820: PPUSH
4821: CALL_OW 281
4825: NOT
4826: IFFALSE 4809
// SetFuel ( vehicle , 100 ) ;
4828: LD_VAR 0 3
4832: PPUSH
4833: LD_INT 100
4835: PPUSH
4836: CALL_OW 240
// end ;
4840: LD_VAR 0 4
4844: RET
// export function ResAllTechs ( side , lab , nation ) ; var i , tech , cout , ru_tech_list ; begin
4845: LD_INT 0
4847: PPUSH
4848: PPUSH
4849: PPUSH
4850: PPUSH
4851: PPUSH
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
4852: LD_ADDR_VAR 0 8
4856: PUSH
4857: LD_INT 48
4859: PUSH
4860: LD_INT 49
4862: PUSH
4863: LD_INT 50
4865: PUSH
4866: LD_INT 20
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 51
4874: PUSH
4875: LD_INT 52
4877: PUSH
4878: LD_INT 69
4880: PUSH
4881: LD_INT 39
4883: PUSH
4884: LD_INT 34
4886: PUSH
4887: LD_INT 40
4889: PUSH
4890: LD_INT 53
4892: PUSH
4893: LD_INT 71
4895: PUSH
4896: LD_INT 57
4898: PUSH
4899: LD_INT 58
4901: PUSH
4902: LD_INT 44
4904: PUSH
4905: LD_INT 32
4907: PUSH
4908: LD_INT 27
4910: PUSH
4911: LD_INT 23
4913: PUSH
4914: LD_INT 33
4916: PUSH
4917: LD_INT 59
4919: PUSH
4920: LD_INT 54
4922: PUSH
4923: LD_INT 55
4925: PUSH
4926: LD_INT 56
4928: PUSH
4929: LD_INT 63
4931: PUSH
4932: LD_INT 64
4934: PUSH
4935: LD_INT 65
4937: PUSH
4938: LD_INT 30
4940: PUSH
4941: LD_INT 31
4943: PUSH
4944: LD_INT 21
4946: PUSH
4947: LD_INT 22
4949: PUSH
4950: LD_INT 25
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: LIST
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: LIST
4962: LIST
4963: LIST
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: LIST
4974: LIST
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: ST_TO_ADDR
// for i = 1 to ru_tech_list do
4987: LD_ADDR_VAR 0 5
4991: PUSH
4992: DOUBLE
4993: LD_INT 1
4995: DEC
4996: ST_TO_ADDR
4997: LD_VAR 0 8
5001: PUSH
5002: FOR_TO
5003: IFFALSE 5079
// if GetTech ( ru_tech_list [ i ] , side ) = state_enabled and TechNationAvailable ( ru_tech_list [ i ] , nation ) = true then
5005: LD_VAR 0 8
5009: PUSH
5010: LD_VAR 0 5
5014: ARRAY
5015: PPUSH
5016: LD_VAR 0 1
5020: PPUSH
5021: CALL_OW 321
5025: PUSH
5026: LD_INT 1
5028: EQUAL
5029: PUSH
5030: LD_VAR 0 8
5034: PUSH
5035: LD_VAR 0 5
5039: ARRAY
5040: PPUSH
5041: LD_VAR 0 3
5045: PPUSH
5046: CALL_OW 482
5050: PUSH
5051: LD_INT 1
5053: EQUAL
5054: AND
5055: IFFALSE 5077
// AddComResearch ( lab , ru_tech_list [ i ] ) ;
5057: LD_VAR 0 2
5061: PPUSH
5062: LD_VAR 0 8
5066: PUSH
5067: LD_VAR 0 5
5071: ARRAY
5072: PPUSH
5073: CALL_OW 184
5077: GO 5002
5079: POP
5080: POP
// end ;
5081: LD_VAR 0 4
5085: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
5086: LD_INT 0
5088: PPUSH
5089: PPUSH
5090: PPUSH
// uc_side := GetSide ( b ) ;
5091: LD_ADDR_OWVAR 20
5095: PUSH
5096: LD_VAR 0 2
5100: PPUSH
5101: CALL_OW 255
5105: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
5106: LD_ADDR_OWVAR 21
5110: PUSH
5111: LD_VAR 0 2
5115: PPUSH
5116: CALL_OW 248
5120: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5121: LD_INT 0
5123: PPUSH
5124: LD_INT 1
5126: PPUSH
5127: LD_VAR 0 1
5131: PPUSH
5132: CALL_OW 380
// un = CreateHuman ;
5136: LD_ADDR_VAR 0 4
5140: PUSH
5141: CALL_OW 44
5145: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
5146: LD_ADDR_VAR 0 5
5150: PUSH
5151: LD_VAR 0 2
5155: PPUSH
5156: CALL_OW 254
5160: PUSH
5161: LD_INT 3
5163: MINUS
5164: ST_TO_ADDR
// if dir < 0 then
5165: LD_VAR 0 5
5169: PUSH
5170: LD_INT 0
5172: LESS
5173: IFFALSE 5189
// dir := 6 + dir ;
5175: LD_ADDR_VAR 0 5
5179: PUSH
5180: LD_INT 6
5182: PUSH
5183: LD_VAR 0 5
5187: PLUS
5188: ST_TO_ADDR
// SetDir ( un , dir ) ;
5189: LD_VAR 0 4
5193: PPUSH
5194: LD_VAR 0 5
5198: PPUSH
5199: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5203: LD_VAR 0 4
5207: PPUSH
5208: LD_VAR 0 2
5212: PPUSH
5213: CALL_OW 52
// result = un ;
5217: LD_ADDR_VAR 0 3
5221: PUSH
5222: LD_VAR 0 4
5226: ST_TO_ADDR
// end ;
5227: LD_VAR 0 3
5231: RET
// export function PlaceSolBun ( un , b ) ; var dir ; begin
5232: LD_INT 0
5234: PPUSH
5235: PPUSH
// dir := GetDir ( b ) - 3 ;
5236: LD_ADDR_VAR 0 4
5240: PUSH
5241: LD_VAR 0 2
5245: PPUSH
5246: CALL_OW 254
5250: PUSH
5251: LD_INT 3
5253: MINUS
5254: ST_TO_ADDR
// if dir < 0 then
5255: LD_VAR 0 4
5259: PUSH
5260: LD_INT 0
5262: LESS
5263: IFFALSE 5279
// dir := 6 + dir ;
5265: LD_ADDR_VAR 0 4
5269: PUSH
5270: LD_INT 6
5272: PUSH
5273: LD_VAR 0 4
5277: PLUS
5278: ST_TO_ADDR
// SetDir ( un , dir ) ;
5279: LD_VAR 0 1
5283: PPUSH
5284: LD_VAR 0 4
5288: PPUSH
5289: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5293: LD_VAR 0 1
5297: PPUSH
5298: LD_VAR 0 2
5302: PPUSH
5303: CALL_OW 52
// result = un ;
5307: LD_ADDR_VAR 0 3
5311: PUSH
5312: LD_VAR 0 1
5316: ST_TO_ADDR
// end ;
5317: LD_VAR 0 3
5321: RET
// export function SaveVehicles ( vehicles , ident ) ; var i , tmp ; begin
5322: LD_INT 0
5324: PPUSH
5325: PPUSH
5326: PPUSH
// tmp = [ ] ;
5327: LD_ADDR_VAR 0 5
5331: PUSH
5332: EMPTY
5333: ST_TO_ADDR
// if not vehicles then
5334: LD_VAR 0 1
5338: NOT
5339: IFFALSE 5343
// exit ;
5341: GO 5460
// for i in vehicles do
5343: LD_ADDR_VAR 0 4
5347: PUSH
5348: LD_VAR 0 1
5352: PUSH
5353: FOR_IN
5354: IFFALSE 5444
// tmp := Insert ( tmp , 1 , [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) , GetFuel ( i ) , GetLives ( i ) ] ) ;
5356: LD_ADDR_VAR 0 5
5360: PUSH
5361: LD_VAR 0 5
5365: PPUSH
5366: LD_INT 1
5368: PPUSH
5369: LD_VAR 0 4
5373: PPUSH
5374: CALL_OW 265
5378: PUSH
5379: LD_VAR 0 4
5383: PPUSH
5384: CALL_OW 262
5388: PUSH
5389: LD_VAR 0 4
5393: PPUSH
5394: CALL_OW 263
5398: PUSH
5399: LD_VAR 0 4
5403: PPUSH
5404: CALL_OW 264
5408: PUSH
5409: LD_VAR 0 4
5413: PPUSH
5414: CALL_OW 261
5418: PUSH
5419: LD_VAR 0 4
5423: PPUSH
5424: CALL_OW 256
5428: PUSH
5429: EMPTY
5430: LIST
5431: LIST
5432: LIST
5433: LIST
5434: LIST
5435: LIST
5436: PPUSH
5437: CALL_OW 2
5441: ST_TO_ADDR
5442: GO 5353
5444: POP
5445: POP
// SaveVariable ( tmp , ident ) ;
5446: LD_VAR 0 5
5450: PPUSH
5451: LD_VAR 0 2
5455: PPUSH
5456: CALL_OW 39
// end ;
5460: LD_VAR 0 3
5464: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
5465: LD_INT 0
5467: PPUSH
5468: PPUSH
5469: PPUSH
// buildingsToSave = [ ] ;
5470: LD_ADDR_VAR 0 5
5474: PUSH
5475: EMPTY
5476: ST_TO_ADDR
// if not buildings then
5477: LD_VAR 0 1
5481: NOT
5482: IFFALSE 5486
// exit ;
5484: GO 6061
// for i in buildings do
5486: LD_ADDR_VAR 0 4
5490: PUSH
5491: LD_VAR 0 1
5495: PUSH
5496: FOR_IN
5497: IFFALSE 6045
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
5499: LD_VAR 0 4
5503: PPUSH
5504: CALL_OW 266
5508: PUSH
5509: LD_INT 6
5511: PUSH
5512: LD_INT 7
5514: PUSH
5515: LD_INT 8
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: LIST
5522: IN
5523: IFFALSE 5648
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
5525: LD_ADDR_VAR 0 5
5529: PUSH
5530: LD_VAR 0 5
5534: PUSH
5535: LD_VAR 0 4
5539: PPUSH
5540: CALL_OW 266
5544: PUSH
5545: LD_VAR 0 4
5549: PPUSH
5550: CALL_OW 250
5554: PUSH
5555: LD_VAR 0 4
5559: PPUSH
5560: CALL_OW 251
5564: PUSH
5565: LD_VAR 0 4
5569: PPUSH
5570: CALL_OW 254
5574: PUSH
5575: LD_VAR 0 4
5579: PPUSH
5580: CALL_OW 267
5584: PUSH
5585: LD_VAR 0 4
5589: PPUSH
5590: CALL_OW 248
5594: PUSH
5595: LD_VAR 0 4
5599: PPUSH
5600: CALL_OW 256
5604: PUSH
5605: LD_VAR 0 4
5609: PPUSH
5610: LD_INT 1
5612: PPUSH
5613: CALL_OW 268
5617: PUSH
5618: LD_VAR 0 4
5622: PPUSH
5623: LD_INT 2
5625: PPUSH
5626: CALL_OW 268
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: LIST
5641: PUSH
5642: EMPTY
5643: LIST
5644: ADD
5645: ST_TO_ADDR
5646: GO 6043
// if GetBType ( i ) in [ b_bunker , b_turret ] then
5648: LD_VAR 0 4
5652: PPUSH
5653: CALL_OW 266
5657: PUSH
5658: LD_INT 32
5660: PUSH
5661: LD_INT 33
5663: PUSH
5664: EMPTY
5665: LIST
5666: LIST
5667: IN
5668: IFFALSE 5776
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
5670: LD_ADDR_VAR 0 5
5674: PUSH
5675: LD_VAR 0 5
5679: PUSH
5680: LD_VAR 0 4
5684: PPUSH
5685: CALL_OW 266
5689: PUSH
5690: LD_VAR 0 4
5694: PPUSH
5695: CALL_OW 250
5699: PUSH
5700: LD_VAR 0 4
5704: PPUSH
5705: CALL_OW 251
5709: PUSH
5710: LD_VAR 0 4
5714: PPUSH
5715: CALL_OW 254
5719: PUSH
5720: LD_VAR 0 4
5724: PPUSH
5725: CALL_OW 267
5729: PUSH
5730: LD_VAR 0 4
5734: PPUSH
5735: CALL_OW 248
5739: PUSH
5740: LD_VAR 0 4
5744: PPUSH
5745: CALL_OW 256
5749: PUSH
5750: LD_VAR 0 4
5754: PPUSH
5755: CALL_OW 269
5759: PUSH
5760: EMPTY
5761: LIST
5762: LIST
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: LIST
5769: PUSH
5770: EMPTY
5771: LIST
5772: ADD
5773: ST_TO_ADDR
5774: GO 6043
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
5776: LD_VAR 0 4
5780: PPUSH
5781: CALL_OW 266
5785: PUSH
5786: LD_INT 0
5788: PUSH
5789: LD_INT 1
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: IN
5796: IFFALSE 5950
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
5798: LD_ADDR_VAR 0 5
5802: PUSH
5803: LD_VAR 0 5
5807: PUSH
5808: LD_VAR 0 4
5812: PPUSH
5813: CALL_OW 266
5817: PUSH
5818: LD_VAR 0 4
5822: PPUSH
5823: CALL_OW 250
5827: PUSH
5828: LD_VAR 0 4
5832: PPUSH
5833: CALL_OW 251
5837: PUSH
5838: LD_VAR 0 4
5842: PPUSH
5843: CALL_OW 254
5847: PUSH
5848: LD_VAR 0 4
5852: PPUSH
5853: CALL_OW 267
5857: PUSH
5858: LD_VAR 0 4
5862: PPUSH
5863: CALL_OW 248
5867: PUSH
5868: LD_VAR 0 4
5872: PPUSH
5873: CALL_OW 256
5877: PUSH
5878: LD_VAR 0 4
5882: PPUSH
5883: CALL_OW 274
5887: PPUSH
5888: LD_INT 1
5890: PPUSH
5891: CALL_OW 275
5895: PUSH
5896: LD_VAR 0 4
5900: PPUSH
5901: CALL_OW 274
5905: PPUSH
5906: LD_INT 2
5908: PPUSH
5909: CALL_OW 275
5913: PUSH
5914: LD_VAR 0 4
5918: PPUSH
5919: CALL_OW 274
5923: PPUSH
5924: LD_INT 3
5926: PPUSH
5927: CALL_OW 275
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: PUSH
5944: EMPTY
5945: LIST
5946: ADD
5947: ST_TO_ADDR
5948: GO 6043
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
5950: LD_ADDR_VAR 0 5
5954: PUSH
5955: LD_VAR 0 5
5959: PUSH
5960: LD_VAR 0 4
5964: PPUSH
5965: CALL_OW 266
5969: PUSH
5970: LD_VAR 0 4
5974: PPUSH
5975: CALL_OW 250
5979: PUSH
5980: LD_VAR 0 4
5984: PPUSH
5985: CALL_OW 251
5989: PUSH
5990: LD_VAR 0 4
5994: PPUSH
5995: CALL_OW 254
5999: PUSH
6000: LD_VAR 0 4
6004: PPUSH
6005: CALL_OW 267
6009: PUSH
6010: LD_VAR 0 4
6014: PPUSH
6015: CALL_OW 248
6019: PUSH
6020: LD_VAR 0 4
6024: PPUSH
6025: CALL_OW 256
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: LIST
6037: LIST
6038: PUSH
6039: EMPTY
6040: LIST
6041: ADD
6042: ST_TO_ADDR
// end ;
6043: GO 5496
6045: POP
6046: POP
// SaveVariable ( buildingsToSave , ident ) ;
6047: LD_VAR 0 5
6051: PPUSH
6052: LD_VAR 0 2
6056: PPUSH
6057: CALL_OW 39
// end ;
6061: LD_VAR 0 3
6065: RET
// export function CreateBelkovTeam ; var i , unit , restRandSolds , tmp ; begin
6066: LD_INT 0
6068: PPUSH
6069: PPUSH
6070: PPUSH
6071: PPUSH
6072: PPUSH
// belkovTeam = [ ] ;
6073: LD_ADDR_EXP 73
6077: PUSH
6078: EMPTY
6079: ST_TO_ADDR
// if belkovReturn then
6080: LD_EXP 6
6084: IFFALSE 6102
// belkovTeam = belkovTeam ^ Belkov ;
6086: LD_ADDR_EXP 73
6090: PUSH
6091: LD_EXP 73
6095: PUSH
6096: LD_EXP 64
6100: ADD
6101: ST_TO_ADDR
// belkovTeam = belkovTeam ^ Belkov2 ;
6102: LD_ADDR_EXP 73
6106: PUSH
6107: LD_EXP 73
6111: PUSH
6112: LD_EXP 68
6116: ADD
6117: ST_TO_ADDR
// for unit in other_survivors do
6118: LD_ADDR_VAR 0 3
6122: PUSH
6123: LD_EXP 66
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6170
// if IsOK ( unit ) and belkovTeam < 5 then
6131: LD_VAR 0 3
6135: PPUSH
6136: CALL_OW 302
6140: PUSH
6141: LD_EXP 73
6145: PUSH
6146: LD_INT 5
6148: LESS
6149: AND
6150: IFFALSE 6168
// belkovTeam = belkovTeam ^ unit ;
6152: LD_ADDR_EXP 73
6156: PUSH
6157: LD_EXP 73
6161: PUSH
6162: LD_VAR 0 3
6166: ADD
6167: ST_TO_ADDR
6168: GO 6128
6170: POP
6171: POP
// if belkovTeam < 5 then
6172: LD_EXP 73
6176: PUSH
6177: LD_INT 5
6179: LESS
6180: IFFALSE 6306
// begin restRandSolds = 5 - belkovTeam ;
6182: LD_ADDR_VAR 0 4
6186: PUSH
6187: LD_INT 5
6189: PUSH
6190: LD_EXP 73
6194: MINUS
6195: ST_TO_ADDR
// for i := 1 to restRandSolds do
6196: LD_ADDR_VAR 0 2
6200: PUSH
6201: DOUBLE
6202: LD_INT 1
6204: DEC
6205: ST_TO_ADDR
6206: LD_VAR 0 4
6210: PUSH
6211: FOR_TO
6212: IFFALSE 6304
// for unit in UnitFilter ( otherKirovUnits , [ [ f_class , class_soldier ] ] ) diff Kurin do
6214: LD_ADDR_VAR 0 3
6218: PUSH
6219: LD_EXP 69
6223: PPUSH
6224: LD_INT 25
6226: PUSH
6227: LD_INT 1
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: PUSH
6234: EMPTY
6235: LIST
6236: PPUSH
6237: CALL_OW 72
6241: PUSH
6242: LD_EXP 67
6246: DIFF
6247: PUSH
6248: FOR_IN
6249: IFFALSE 6300
// if not unit in belkovTeam then
6251: LD_VAR 0 3
6255: PUSH
6256: LD_EXP 73
6260: IN
6261: NOT
6262: IFFALSE 6298
// begin belkovTeam = belkovTeam ^ unit ;
6264: LD_ADDR_EXP 73
6268: PUSH
6269: LD_EXP 73
6273: PUSH
6274: LD_VAR 0 3
6278: ADD
6279: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits diff unit ;
6280: LD_ADDR_EXP 69
6284: PUSH
6285: LD_EXP 69
6289: PUSH
6290: LD_VAR 0 3
6294: DIFF
6295: ST_TO_ADDR
// break ;
6296: GO 6300
// end ;
6298: GO 6248
6300: POP
6301: POP
6302: GO 6211
6304: POP
6305: POP
// end ; tmp = belkovTeam diff Belkov ;
6306: LD_ADDR_VAR 0 5
6310: PUSH
6311: LD_EXP 73
6315: PUSH
6316: LD_EXP 64
6320: DIFF
6321: ST_TO_ADDR
// if tmp < 4 then
6322: LD_VAR 0 5
6326: PUSH
6327: LD_INT 4
6329: LESS
6330: IFFALSE 6414
// begin for i := 1 to 4 - tmp do
6332: LD_ADDR_VAR 0 2
6336: PUSH
6337: DOUBLE
6338: LD_INT 1
6340: DEC
6341: ST_TO_ADDR
6342: LD_INT 4
6344: PUSH
6345: LD_VAR 0 5
6349: MINUS
6350: PUSH
6351: FOR_TO
6352: IFFALSE 6412
// begin PrepareSoldier ( false , rand ( 1 , 2 ) ) ;
6354: LD_INT 0
6356: PPUSH
6357: LD_INT 1
6359: PPUSH
6360: LD_INT 2
6362: PPUSH
6363: CALL_OW 12
6367: PPUSH
6368: CALL_OW 381
// unit = CreateHuman ;
6372: LD_ADDR_VAR 0 3
6376: PUSH
6377: CALL_OW 44
6381: ST_TO_ADDR
// belkovTeam = belkovTeam ^ unit ;
6382: LD_ADDR_EXP 73
6386: PUSH
6387: LD_EXP 73
6391: PUSH
6392: LD_VAR 0 3
6396: ADD
6397: ST_TO_ADDR
// PlaceHumanInUnit ( unit , ru2_arm2 ) ;
6398: LD_VAR 0 3
6402: PPUSH
6403: LD_INT 209
6405: PPUSH
6406: CALL_OW 52
// end ;
6410: GO 6351
6412: POP
6413: POP
// end ; if TestCharacters ( 01_Kirilenkova ) then
6414: LD_STRING 01_Kirilenkova
6416: PPUSH
6417: CALL_OW 28
6421: IFFALSE 6441
// belkovTeam = belkovTeam ^ Kirilenkova else
6423: LD_ADDR_EXP 73
6427: PUSH
6428: LD_EXP 73
6432: PUSH
6433: LD_EXP 65
6437: ADD
6438: ST_TO_ADDR
6439: GO 6517
// begin belkovTeam = belkovTeam ^ UnitFilter ( otherKirovUnits , [ [ f_class , class_scientistic ] ] ) [ 1 ] ;
6441: LD_ADDR_EXP 73
6445: PUSH
6446: LD_EXP 73
6450: PUSH
6451: LD_EXP 69
6455: PPUSH
6456: LD_INT 25
6458: PUSH
6459: LD_INT 4
6461: PUSH
6462: EMPTY
6463: LIST
6464: LIST
6465: PUSH
6466: EMPTY
6467: LIST
6468: PPUSH
6469: CALL_OW 72
6473: PUSH
6474: LD_INT 1
6476: ARRAY
6477: ADD
6478: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits diff UnitFilter ( otherKirovUnits , [ [ f_class , class_scientistic ] ] ) [ 1 ] ;
6479: LD_ADDR_EXP 69
6483: PUSH
6484: LD_EXP 69
6488: PUSH
6489: LD_EXP 69
6493: PPUSH
6494: LD_INT 25
6496: PUSH
6497: LD_INT 4
6499: PUSH
6500: EMPTY
6501: LIST
6502: LIST
6503: PUSH
6504: EMPTY
6505: LIST
6506: PPUSH
6507: CALL_OW 72
6511: PUSH
6512: LD_INT 1
6514: ARRAY
6515: DIFF
6516: ST_TO_ADDR
// end ; end ;
6517: LD_VAR 0 1
6521: RET
// export function PlatonovSendSupport ; var soldsOk ; begin
6522: LD_INT 0
6524: PPUSH
6525: PPUSH
// if not Kuklajs or not IsOK ( Kuklajs ) then
6526: LD_EXP 78
6530: NOT
6531: PUSH
6532: LD_EXP 78
6536: PPUSH
6537: CALL_OW 302
6541: NOT
6542: OR
6543: IFFALSE 6646
// begin soldsOk = UnitFilter ( platSoldiers , [ f_ok ] ) diff Benko ;
6545: LD_ADDR_VAR 0 2
6549: PUSH
6550: LD_EXP 77
6554: PPUSH
6555: LD_INT 50
6557: PUSH
6558: EMPTY
6559: LIST
6560: PPUSH
6561: CALL_OW 72
6565: PUSH
6566: LD_EXP 79
6570: DIFF
6571: ST_TO_ADDR
// if soldsOK then
6572: LD_VAR 0 2
6576: IFFALSE 6646
// begin ComExitBuilding ( soldsOK [ 1 ] ) ;
6578: LD_VAR 0 2
6582: PUSH
6583: LD_INT 1
6585: ARRAY
6586: PPUSH
6587: CALL_OW 122
// AddComMoveXY ( soldsOK [ 1 ] , 112 , 96 ) ;
6591: LD_VAR 0 2
6595: PUSH
6596: LD_INT 1
6598: ARRAY
6599: PPUSH
6600: LD_INT 112
6602: PPUSH
6603: LD_INT 96
6605: PPUSH
6606: CALL_OW 171
// SetSide ( soldsOK [ 1 ] , 3 ) ;
6610: LD_VAR 0 2
6614: PUSH
6615: LD_INT 1
6617: ARRAY
6618: PPUSH
6619: LD_INT 3
6621: PPUSH
6622: CALL_OW 235
// platSoldiers = platSoldiers diff soldsOK [ 1 ] ;
6626: LD_ADDR_EXP 77
6630: PUSH
6631: LD_EXP 77
6635: PUSH
6636: LD_VAR 0 2
6640: PUSH
6641: LD_INT 1
6643: ARRAY
6644: DIFF
6645: ST_TO_ADDR
// end ; end ; if not Benko or not IsOK ( Benko ) then
6646: LD_EXP 79
6650: NOT
6651: PUSH
6652: LD_EXP 79
6656: PPUSH
6657: CALL_OW 302
6661: NOT
6662: OR
6663: IFFALSE 6766
// begin soldsOk = UnitFilter ( platSoldiers , [ f_ok ] ) diff Kuklajs ;
6665: LD_ADDR_VAR 0 2
6669: PUSH
6670: LD_EXP 77
6674: PPUSH
6675: LD_INT 50
6677: PUSH
6678: EMPTY
6679: LIST
6680: PPUSH
6681: CALL_OW 72
6685: PUSH
6686: LD_EXP 78
6690: DIFF
6691: ST_TO_ADDR
// if soldsOK then
6692: LD_VAR 0 2
6696: IFFALSE 6766
// begin ComExitBuilding ( soldsOK [ 1 ] ) ;
6698: LD_VAR 0 2
6702: PUSH
6703: LD_INT 1
6705: ARRAY
6706: PPUSH
6707: CALL_OW 122
// AddComMoveXY ( soldsOK [ 1 ] , 112 , 96 ) ;
6711: LD_VAR 0 2
6715: PUSH
6716: LD_INT 1
6718: ARRAY
6719: PPUSH
6720: LD_INT 112
6722: PPUSH
6723: LD_INT 96
6725: PPUSH
6726: CALL_OW 171
// SetSide ( soldsOK [ 1 ] , 3 ) ;
6730: LD_VAR 0 2
6734: PUSH
6735: LD_INT 1
6737: ARRAY
6738: PPUSH
6739: LD_INT 3
6741: PPUSH
6742: CALL_OW 235
// platSoldiers = platSoldiers diff soldsOK [ 1 ] ;
6746: LD_ADDR_EXP 77
6750: PUSH
6751: LD_EXP 77
6755: PUSH
6756: LD_VAR 0 2
6760: PUSH
6761: LD_INT 1
6763: ARRAY
6764: DIFF
6765: ST_TO_ADDR
// end ; end ; ComExitBuilding ( [ Kuklajs , Benko ] ) ;
6766: LD_EXP 78
6770: PUSH
6771: LD_EXP 79
6775: PUSH
6776: EMPTY
6777: LIST
6778: LIST
6779: PPUSH
6780: CALL_OW 122
// AddComMoveXY ( [ Kuklajs , Benko ] , 112 , 96 ) ;
6784: LD_EXP 78
6788: PUSH
6789: LD_EXP 79
6793: PUSH
6794: EMPTY
6795: LIST
6796: LIST
6797: PPUSH
6798: LD_INT 112
6800: PPUSH
6801: LD_INT 96
6803: PPUSH
6804: CALL_OW 171
// SetSide ( [ Kuklajs , Benko ] , 3 ) ;
6808: LD_EXP 78
6812: PUSH
6813: LD_EXP 79
6817: PUSH
6818: EMPTY
6819: LIST
6820: LIST
6821: PPUSH
6822: LD_INT 3
6824: PPUSH
6825: CALL_OW 235
// end ; end_of_file
6829: LD_VAR 0 1
6833: RET
// export function MissionIntro ; var yourSolds , nearUnit ; var i ; begin
6834: LD_INT 0
6836: PPUSH
6837: PPUSH
6838: PPUSH
6839: PPUSH
// CenterNowOnUnits ( Burlak ) ;
6840: LD_EXP 62
6844: PPUSH
6845: CALL_OW 87
// ComMoveXY ( Burlak , 163 , 108 ) ;
6849: LD_EXP 62
6853: PPUSH
6854: LD_INT 163
6856: PPUSH
6857: LD_INT 108
6859: PPUSH
6860: CALL_OW 111
// AddComTurnUnit ( Burlak , Kurin ) ;
6864: LD_EXP 62
6868: PPUSH
6869: LD_EXP 67
6873: PPUSH
6874: CALL_OW 179
// yourSolds = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff Burlak ;
6878: LD_ADDR_VAR 0 2
6882: PUSH
6883: LD_INT 22
6885: PUSH
6886: LD_INT 3
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: PUSH
6893: LD_INT 21
6895: PUSH
6896: LD_INT 1
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: PUSH
6903: EMPTY
6904: LIST
6905: LIST
6906: PPUSH
6907: CALL_OW 69
6911: PUSH
6912: LD_EXP 62
6916: DIFF
6917: ST_TO_ADDR
// for i := 1 to meetWithKurinPositions do
6918: LD_ADDR_VAR 0 4
6922: PUSH
6923: DOUBLE
6924: LD_INT 1
6926: DEC
6927: ST_TO_ADDR
6928: LD_EXP 52
6932: PUSH
6933: FOR_TO
6934: IFFALSE 7052
// begin nearUnit = NearestUnitToXY ( yourSolds , meetWithKurinPositions [ i ] [ 1 ] , meetWithKurinPositions [ i ] [ 2 ] ) ;
6936: LD_ADDR_VAR 0 3
6940: PUSH
6941: LD_VAR 0 2
6945: PPUSH
6946: LD_EXP 52
6950: PUSH
6951: LD_VAR 0 4
6955: ARRAY
6956: PUSH
6957: LD_INT 1
6959: ARRAY
6960: PPUSH
6961: LD_EXP 52
6965: PUSH
6966: LD_VAR 0 4
6970: ARRAY
6971: PUSH
6972: LD_INT 2
6974: ARRAY
6975: PPUSH
6976: CALL_OW 73
6980: ST_TO_ADDR
// ComMoveXY ( nearUnit , meetWithKurinPositions [ i ] [ 1 ] , meetWithKurinPositions [ i ] [ 2 ] ) ;
6981: LD_VAR 0 3
6985: PPUSH
6986: LD_EXP 52
6990: PUSH
6991: LD_VAR 0 4
6995: ARRAY
6996: PUSH
6997: LD_INT 1
6999: ARRAY
7000: PPUSH
7001: LD_EXP 52
7005: PUSH
7006: LD_VAR 0 4
7010: ARRAY
7011: PUSH
7012: LD_INT 2
7014: ARRAY
7015: PPUSH
7016: CALL_OW 111
// AddComTurnUnit ( nearUnit , Kurin ) ;
7020: LD_VAR 0 3
7024: PPUSH
7025: LD_EXP 67
7029: PPUSH
7030: CALL_OW 179
// yourSolds = yourSolds diff nearUnit ;
7034: LD_ADDR_VAR 0 2
7038: PUSH
7039: LD_VAR 0 2
7043: PUSH
7044: LD_VAR 0 3
7048: DIFF
7049: ST_TO_ADDR
// end ;
7050: GO 6933
7052: POP
7053: POP
// repeat CenterNowOnUnits ( Burlak ) ;
7054: LD_EXP 62
7058: PPUSH
7059: CALL_OW 87
// wait ( 0 0$1 ) ;
7063: LD_INT 35
7065: PPUSH
7066: CALL_OW 67
// until GetDistUnits ( Burlak , Kurin ) < 4 ;
7070: LD_EXP 62
7074: PPUSH
7075: LD_EXP 67
7079: PPUSH
7080: CALL_OW 296
7084: PUSH
7085: LD_INT 4
7087: LESS
7088: IFFALSE 7054
// CenterNowOnUnits ( [ Burlak , Kurin ] ) ;
7090: LD_EXP 62
7094: PUSH
7095: LD_EXP 67
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 87
// ComTurnUnit ( Kurin , Burlak ) ;
7108: LD_EXP 67
7112: PPUSH
7113: LD_EXP 62
7117: PPUSH
7118: CALL_OW 119
// Say ( Kurin , D1-Kur-1 ) ;
7122: LD_EXP 67
7126: PPUSH
7127: LD_STRING D1-Kur-1
7129: PPUSH
7130: CALL_OW 88
// Say ( Burlak , D1-Bur-1 ) ;
7134: LD_EXP 62
7138: PPUSH
7139: LD_STRING D1-Bur-1
7141: PPUSH
7142: CALL_OW 88
// Say ( Kurin , D1-Kur-2 ) ;
7146: LD_EXP 67
7150: PPUSH
7151: LD_STRING D1-Kur-2
7153: PPUSH
7154: CALL_OW 88
// Say ( Burlak , D1-Bur-2 ) ;
7158: LD_EXP 62
7162: PPUSH
7163: LD_STRING D1-Bur-2
7165: PPUSH
7166: CALL_OW 88
// Say ( Kurin , D1-Kur-3 ) ;
7170: LD_EXP 67
7174: PPUSH
7175: LD_STRING D1-Kur-3
7177: PPUSH
7178: CALL_OW 88
// if IsOK ( Gnyevko ) then
7182: LD_EXP 63
7186: PPUSH
7187: CALL_OW 302
7191: IFFALSE 7205
// Say ( Kurin , D1-Kur-3a ) ;
7193: LD_EXP 67
7197: PPUSH
7198: LD_STRING D1-Kur-3a
7200: PPUSH
7201: CALL_OW 88
// InGameOff ;
7205: CALL_OW 9
// SetSide ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko ] , 6 ) ;
7209: LD_INT 22
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 21
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: PPUSH
7233: CALL_OW 69
7237: PUSH
7238: LD_EXP 62
7242: PUSH
7243: LD_EXP 63
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: DIFF
7252: PPUSH
7253: LD_INT 6
7255: PPUSH
7256: CALL_OW 235
// SetSide ( Kovalyuk , 3 ) ;
7260: LD_EXP 70
7264: PPUSH
7265: LD_INT 3
7267: PPUSH
7268: CALL_OW 235
// ComFree ( FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Kurin ) ;
7272: LD_INT 9
7274: PPUSH
7275: LD_INT 22
7277: PUSH
7278: LD_INT 6
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PUSH
7285: LD_INT 21
7287: PUSH
7288: LD_INT 1
7290: PUSH
7291: EMPTY
7292: LIST
7293: LIST
7294: PUSH
7295: EMPTY
7296: LIST
7297: LIST
7298: PPUSH
7299: CALL_OW 70
7303: PUSH
7304: LD_EXP 67
7308: DIFF
7309: PPUSH
7310: CALL_OW 139
// ComEnterUnit ( other_survivors , ru2_arm1 ) ;
7314: LD_EXP 66
7318: PPUSH
7319: LD_INT 95
7321: PPUSH
7322: CALL_OW 120
// ComEnterUnit ( Belkov , ru2_arm1 ) ;
7326: LD_EXP 64
7330: PPUSH
7331: LD_INT 95
7333: PPUSH
7334: CALL_OW 120
// if IsPlaced ( Kirilenkova ) then
7338: LD_EXP 65
7342: PPUSH
7343: CALL_OW 305
7347: IFFALSE 7361
// ComEnterUnit ( Kirilenkova , ru_lab ) ;
7349: LD_EXP 65
7353: PPUSH
7354: LD_INT 83
7356: PPUSH
7357: CALL_OW 120
// if not TestCharacters ( 01_Gnyevko ) then
7361: LD_STRING 01_Gnyevko
7363: PPUSH
7364: CALL_OW 28
7368: NOT
7369: IFFALSE 7383
// SetSide ( randomMech , 3 ) ;
7371: LD_EXP 71
7375: PPUSH
7376: LD_INT 3
7378: PPUSH
7379: CALL_OW 235
// ChangeMissionObjectives ( M1 ) ;
7383: LD_STRING M1
7385: PPUSH
7386: CALL_OW 337
// HideArea ( 3 , AllMapArea ) ;
7390: LD_INT 3
7392: PPUSH
7393: LD_INT 6
7395: PPUSH
7396: CALL_OW 333
// ShowArea ( 3 , VisibleMapPartArea ) ;
7400: LD_INT 3
7402: PPUSH
7403: LD_INT 7
7405: PPUSH
7406: CALL_OW 334
// HideArea ( 6 , AllMapArea ) ;
7410: LD_INT 6
7412: PPUSH
7413: LD_INT 6
7415: PPUSH
7416: CALL_OW 333
// ShowArea ( 6 , VisibleMapPartArea ) ;
7420: LD_INT 6
7422: PPUSH
7423: LD_INT 7
7425: PPUSH
7426: CALL_OW 334
// SaveForQuickRestart ;
7430: CALL_OW 22
// ComEnterUnit ( other_survivors , ru2_arm1 ) ;
7434: LD_EXP 66
7438: PPUSH
7439: LD_INT 95
7441: PPUSH
7442: CALL_OW 120
// ComEnterUnit ( Belkov , ru2_arm1 ) ;
7446: LD_EXP 64
7450: PPUSH
7451: LD_INT 95
7453: PPUSH
7454: CALL_OW 120
// if IsPlaced ( Kirilenkova ) then
7458: LD_EXP 65
7462: PPUSH
7463: CALL_OW 305
7467: IFFALSE 7481
// ComEnterUnit ( Kirilenkova , ru_lab ) ;
7469: LD_EXP 65
7473: PPUSH
7474: LD_INT 83
7476: PPUSH
7477: CALL_OW 120
// end ;
7481: LD_VAR 0 1
7485: RET
// every 1 trigger not canExploreMap and FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 do var unit ;
7486: LD_EXP 20
7490: NOT
7491: PUSH
7492: LD_INT 20
7494: PPUSH
7495: LD_INT 22
7497: PUSH
7498: LD_INT 3
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PUSH
7505: LD_INT 2
7507: PUSH
7508: LD_INT 21
7510: PUSH
7511: LD_INT 1
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: PUSH
7518: LD_INT 21
7520: PUSH
7521: LD_INT 2
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: LIST
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PPUSH
7537: CALL_OW 70
7541: PUSH
7542: LD_INT 0
7544: GREATER
7545: AND
7546: IFFALSE 7920
7548: GO 7550
7550: DISABLE
7551: LD_INT 0
7553: PPUSH
// begin enable ;
7554: ENABLE
// for unit in FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
7555: LD_ADDR_VAR 0 1
7559: PUSH
7560: LD_INT 20
7562: PPUSH
7563: LD_INT 22
7565: PUSH
7566: LD_INT 3
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: PUSH
7573: LD_INT 2
7575: PUSH
7576: LD_INT 21
7578: PUSH
7579: LD_INT 1
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: PUSH
7586: LD_INT 21
7588: PUSH
7589: LD_INT 2
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: PPUSH
7605: CALL_OW 70
7609: PUSH
7610: FOR_IN
7611: IFFALSE 7897
// begin ComMoveXY ( unit , GetX ( unit ) , GetY ( unit ) + 5 ) ;
7613: LD_VAR 0 1
7617: PPUSH
7618: LD_VAR 0 1
7622: PPUSH
7623: CALL_OW 250
7627: PPUSH
7628: LD_VAR 0 1
7632: PPUSH
7633: CALL_OW 251
7637: PUSH
7638: LD_INT 5
7640: PLUS
7641: PPUSH
7642: CALL_OW 111
// if not meetPlatonov and not dialogLoopBlocker then
7646: LD_EXP 7
7650: NOT
7651: PUSH
7652: LD_EXP 33
7656: NOT
7657: AND
7658: IFFALSE 7721
// begin if unit <> Burlak and IsOk ( Kovalyuk ) then
7660: LD_VAR 0 1
7664: PUSH
7665: LD_EXP 62
7669: NONEQUAL
7670: PUSH
7671: LD_EXP 70
7675: PPUSH
7676: CALL_OW 302
7680: AND
7681: IFFALSE 7695
// Say ( Kovalyuk , D1b-Kov-1 ) ;
7683: LD_EXP 70
7687: PPUSH
7688: LD_STRING D1b-Kov-1
7690: PPUSH
7691: CALL_OW 88
// if unit = Burlak then
7695: LD_VAR 0 1
7699: PUSH
7700: LD_EXP 62
7704: EQUAL
7705: IFFALSE 7719
// Say ( Burlak , D1b-Bur-1 ) ;
7707: LD_EXP 62
7711: PPUSH
7712: LD_STRING D1b-Bur-1
7714: PPUSH
7715: CALL_OW 88
// end else
7719: GO 7740
// if not dialogLoopBlocker then
7721: LD_EXP 33
7725: NOT
7726: IFFALSE 7740
// Say ( Platonov , D8-Pla-1 ) ;
7728: LD_EXP 76
7732: PPUSH
7733: LD_STRING D8-Pla-1
7735: PPUSH
7736: CALL_OW 88
// if not dialogLoopBlocker then
7740: LD_EXP 33
7744: NOT
7745: IFFALSE 7755
// dialogLoopBlocker = true ;
7747: LD_ADDR_EXP 33
7751: PUSH
7752: LD_INT 1
7754: ST_TO_ADDR
// repeat ComMoveXY ( FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) , GetX ( unit ) , GetY ( unit ) + 5 ) ;
7755: LD_INT 20
7757: PPUSH
7758: LD_INT 22
7760: PUSH
7761: LD_INT 3
7763: PUSH
7764: EMPTY
7765: LIST
7766: LIST
7767: PUSH
7768: LD_INT 2
7770: PUSH
7771: LD_INT 21
7773: PUSH
7774: LD_INT 1
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: PUSH
7781: LD_INT 21
7783: PUSH
7784: LD_INT 2
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PPUSH
7800: CALL_OW 70
7804: PPUSH
7805: LD_VAR 0 1
7809: PPUSH
7810: CALL_OW 250
7814: PPUSH
7815: LD_VAR 0 1
7819: PPUSH
7820: CALL_OW 251
7824: PUSH
7825: LD_INT 5
7827: PLUS
7828: PPUSH
7829: CALL_OW 111
// wait ( 0 0$1 ) ;
7833: LD_INT 35
7835: PPUSH
7836: CALL_OW 67
// until FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) = 0 ;
7840: LD_INT 20
7842: PPUSH
7843: LD_INT 22
7845: PUSH
7846: LD_INT 3
7848: PUSH
7849: EMPTY
7850: LIST
7851: LIST
7852: PUSH
7853: LD_INT 2
7855: PUSH
7856: LD_INT 21
7858: PUSH
7859: LD_INT 1
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 21
7868: PUSH
7869: LD_INT 2
7871: PUSH
7872: EMPTY
7873: LIST
7874: LIST
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: LIST
7880: PUSH
7881: EMPTY
7882: LIST
7883: LIST
7884: PPUSH
7885: CALL_OW 70
7889: PUSH
7890: LD_INT 0
7892: EQUAL
7893: IFFALSE 7755
// end ;
7895: GO 7610
7897: POP
7898: POP
// if dialogLoopBlocker then
7899: LD_EXP 33
7903: IFFALSE 7920
// begin wait ( 0 0$5 ) ;
7905: LD_INT 175
7907: PPUSH
7908: CALL_OW 67
// dialogLoopBlocker = false ;
7912: LD_ADDR_EXP 33
7916: PUSH
7917: LD_INT 0
7919: ST_TO_ADDR
// end ; end ;
7920: PPOPN 1
7922: END
// every 1 trigger not canExitBase and FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 do var unit ;
7923: LD_EXP 19
7927: NOT
7928: PUSH
7929: LD_INT 8
7931: PPUSH
7932: LD_INT 22
7934: PUSH
7935: LD_INT 3
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 2
7944: PUSH
7945: LD_INT 21
7947: PUSH
7948: LD_INT 1
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: LD_INT 21
7957: PUSH
7958: LD_INT 2
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: LIST
7969: PUSH
7970: EMPTY
7971: LIST
7972: LIST
7973: PPUSH
7974: CALL_OW 71
7978: PUSH
7979: LD_INT 0
7981: GREATER
7982: AND
7983: IFFALSE 8118
7985: GO 7987
7987: DISABLE
7988: LD_INT 0
7990: PPUSH
// begin enable ;
7991: ENABLE
// for unit in FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
7992: LD_ADDR_VAR 0 1
7996: PUSH
7997: LD_INT 8
7999: PPUSH
8000: LD_INT 22
8002: PUSH
8003: LD_INT 3
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PUSH
8010: LD_INT 2
8012: PUSH
8013: LD_INT 21
8015: PUSH
8016: LD_INT 1
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: PUSH
8023: LD_INT 21
8025: PUSH
8026: LD_INT 2
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: EMPTY
8034: LIST
8035: LIST
8036: LIST
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PPUSH
8042: CALL_OW 71
8046: PUSH
8047: FOR_IN
8048: IFFALSE 8101
// begin ComMoveXY ( unit , 114 , 98 ) ;
8050: LD_VAR 0 1
8054: PPUSH
8055: LD_INT 114
8057: PPUSH
8058: LD_INT 98
8060: PPUSH
8061: CALL_OW 111
// if dialogLoopBlocker then
8065: LD_EXP 33
8069: IFFALSE 8075
// exit ;
8071: POP
8072: POP
8073: GO 8118
// dialogLoopBlocker = true ;
8075: LD_ADDR_EXP 33
8079: PUSH
8080: LD_INT 1
8082: ST_TO_ADDR
// Say ( Platonov , D8-Pla-1 ) ;
8083: LD_EXP 76
8087: PPUSH
8088: LD_STRING D8-Pla-1
8090: PPUSH
8091: CALL_OW 88
// exit ;
8095: POP
8096: POP
8097: GO 8118
// end ;
8099: GO 8047
8101: POP
8102: POP
// wait ( 0 0$5 ) ;
8103: LD_INT 175
8105: PPUSH
8106: CALL_OW 67
// dialogLoopBlocker = false ;
8110: LD_ADDR_EXP 33
8114: PUSH
8115: LD_INT 0
8117: ST_TO_ADDR
// end ;
8118: PPOPN 1
8120: END
// every 1 1$30 trigger not meetPlatonov and FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 0 do
8121: LD_EXP 7
8125: NOT
8126: PUSH
8127: LD_INT 9
8129: PPUSH
8130: LD_INT 22
8132: PUSH
8133: LD_INT 3
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: PUSH
8140: LD_INT 21
8142: PUSH
8143: LD_INT 1
8145: PUSH
8146: EMPTY
8147: LIST
8148: LIST
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PPUSH
8154: CALL_OW 70
8158: PUSH
8159: LD_INT 0
8161: GREATER
8162: AND
8163: IFFALSE 8180
8165: GO 8167
8167: DISABLE
// Say ( Kurin , D1a-Kur-1 ) ;
8168: LD_EXP 67
8172: PPUSH
8173: LD_STRING D1a-Kur-1
8175: PPUSH
8176: CALL_OW 88
8180: END
// every 0 0$1 trigger not meetPlatonov and IsOK ( Burlak ) and FilterUnitsInArea ( MeetBeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 0 do var i , unit , yourUnits , randomMaleSoldiers , nearRandom ;
8181: LD_EXP 7
8185: NOT
8186: PUSH
8187: LD_EXP 62
8191: PPUSH
8192: CALL_OW 302
8196: AND
8197: PUSH
8198: LD_INT 29
8200: PPUSH
8201: LD_INT 22
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 21
8213: PUSH
8214: LD_INT 1
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 70
8229: PUSH
8230: LD_INT 0
8232: GREATER
8233: AND
8234: IFFALSE 8861
8236: GO 8238
8238: DISABLE
8239: LD_INT 0
8241: PPUSH
8242: PPUSH
8243: PPUSH
8244: PPUSH
8245: PPUSH
// begin enable ;
8246: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
8247: LD_ADDR_VAR 0 2
8251: PUSH
8252: LD_INT 22
8254: PUSH
8255: LD_INT 3
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: PUSH
8262: LD_INT 21
8264: PUSH
8265: LD_INT 1
8267: PUSH
8268: EMPTY
8269: LIST
8270: LIST
8271: PUSH
8272: EMPTY
8273: LIST
8274: LIST
8275: PPUSH
8276: CALL_OW 69
8280: PUSH
8281: FOR_IN
8282: IFFALSE 8859
// if See ( 6 , unit ) then
8284: LD_INT 6
8286: PPUSH
8287: LD_VAR 0 2
8291: PPUSH
8292: CALL_OW 292
8296: IFFALSE 8857
// begin meetPlatonov = true ;
8298: LD_ADDR_EXP 7
8302: PUSH
8303: LD_INT 1
8305: ST_TO_ADDR
// InGameOn ;
8306: CALL_OW 8
// DialogueOn ;
8310: CALL_OW 6
// randomMaleSoldiers = UnitFilter ( platSoldiers , [ f_sex , sex_male ] ) ;
8314: LD_ADDR_VAR 0 4
8318: PUSH
8319: LD_EXP 77
8323: PPUSH
8324: LD_INT 26
8326: PUSH
8327: LD_INT 1
8329: PUSH
8330: EMPTY
8331: LIST
8332: LIST
8333: PPUSH
8334: CALL_OW 72
8338: ST_TO_ADDR
// randomMaleSoldiers = randomMaleSoldiers ^ FilterUnitsInArea ( BeriaBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_not , [ f_empty ] ] ] ) ;
8339: LD_ADDR_VAR 0 4
8343: PUSH
8344: LD_VAR 0 4
8348: PUSH
8349: LD_INT 8
8351: PPUSH
8352: LD_INT 22
8354: PUSH
8355: LD_INT 6
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: PUSH
8362: LD_INT 21
8364: PUSH
8365: LD_INT 3
8367: PUSH
8368: EMPTY
8369: LIST
8370: LIST
8371: PUSH
8372: LD_INT 30
8374: PUSH
8375: LD_INT 31
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 3
8384: PUSH
8385: LD_INT 58
8387: PUSH
8388: EMPTY
8389: LIST
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: PPUSH
8401: CALL_OW 70
8405: ADD
8406: ST_TO_ADDR
// nearRandom = NearestUnitToUnit ( randomMaleSoldiers , unit ) ;
8407: LD_ADDR_VAR 0 5
8411: PUSH
8412: LD_VAR 0 4
8416: PPUSH
8417: LD_VAR 0 2
8421: PPUSH
8422: CALL_OW 74
8426: ST_TO_ADDR
// if GetType ( nearRandom ) = unit_building then
8427: LD_VAR 0 5
8431: PPUSH
8432: CALL_OW 247
8436: PUSH
8437: LD_INT 3
8439: EQUAL
8440: IFFALSE 8461
// nearRandom = UnitsInside ( nearRandom ) [ 1 ] ;
8442: LD_ADDR_VAR 0 5
8446: PUSH
8447: LD_VAR 0 5
8451: PPUSH
8452: CALL_OW 313
8456: PUSH
8457: LD_INT 1
8459: ARRAY
8460: ST_TO_ADDR
// DialogRandom ( nearRandom , D2-RSol1-1 ,  , false ) ;
8461: LD_VAR 0 5
8465: PPUSH
8466: LD_STRING D2-RSol1-1
8468: PPUSH
8469: LD_STRING 
8471: PPUSH
8472: LD_INT 0
8474: PPUSH
8475: CALL 4093 0 4
// Say ( Burlak , D2-Bur-1 ) ;
8479: LD_EXP 62
8483: PPUSH
8484: LD_STRING D2-Bur-1
8486: PPUSH
8487: CALL_OW 88
// Say ( nearRandom , D2-RSol1-2 ) ;
8491: LD_VAR 0 5
8495: PPUSH
8496: LD_STRING D2-RSol1-2
8498: PPUSH
8499: CALL_OW 88
// DialogueOff ;
8503: CALL_OW 7
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
8507: LD_ADDR_VAR 0 3
8511: PUSH
8512: LD_INT 22
8514: PUSH
8515: LD_INT 3
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PUSH
8522: LD_INT 21
8524: PUSH
8525: LD_INT 1
8527: PUSH
8528: EMPTY
8529: LIST
8530: LIST
8531: PUSH
8532: LD_INT 50
8534: PUSH
8535: EMPTY
8536: LIST
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: ST_TO_ADDR
// for i := 1 to yourUnits do
8548: LD_ADDR_VAR 0 1
8552: PUSH
8553: DOUBLE
8554: LD_INT 1
8556: DEC
8557: ST_TO_ADDR
8558: LD_VAR 0 3
8562: PUSH
8563: FOR_TO
8564: IFFALSE 8633
// begin ComMoveXY ( yourUnits [ i ] , meetWithPlatonovPositions [ i ] [ 1 ] , meetWithPlatonovPositions [ i ] [ 2 ] ) ;
8566: LD_VAR 0 3
8570: PUSH
8571: LD_VAR 0 1
8575: ARRAY
8576: PPUSH
8577: LD_EXP 53
8581: PUSH
8582: LD_VAR 0 1
8586: ARRAY
8587: PUSH
8588: LD_INT 1
8590: ARRAY
8591: PPUSH
8592: LD_EXP 53
8596: PUSH
8597: LD_VAR 0 1
8601: ARRAY
8602: PUSH
8603: LD_INT 2
8605: ARRAY
8606: PPUSH
8607: CALL_OW 111
// AddComTurnUnit ( yourUnits [ i ] , Platonov ) ;
8611: LD_VAR 0 3
8615: PUSH
8616: LD_VAR 0 1
8620: ARRAY
8621: PPUSH
8622: LD_EXP 76
8626: PPUSH
8627: CALL_OW 179
// end ;
8631: GO 8563
8633: POP
8634: POP
// repeat CenterNowOnUnits ( Burlak ) ;
8635: LD_EXP 62
8639: PPUSH
8640: CALL_OW 87
// wait ( 0 0$1 ) ;
8644: LD_INT 35
8646: PPUSH
8647: CALL_OW 67
// until GetDistUnits ( Burlak , Platonov ) < 4 ;
8651: LD_EXP 62
8655: PPUSH
8656: LD_EXP 76
8660: PPUSH
8661: CALL_OW 296
8665: PUSH
8666: LD_INT 4
8668: LESS
8669: IFFALSE 8635
// ComTurnUnit ( Platonov , Burlak ) ;
8671: LD_EXP 76
8675: PPUSH
8676: LD_EXP 62
8680: PPUSH
8681: CALL_OW 119
// Say ( Platonov , D2-Pla-2 ) ;
8685: LD_EXP 76
8689: PPUSH
8690: LD_STRING D2-Pla-2
8692: PPUSH
8693: CALL_OW 88
// Say ( Burlak , D2-Bur-2 ) ;
8697: LD_EXP 62
8701: PPUSH
8702: LD_STRING D2-Bur-2
8704: PPUSH
8705: CALL_OW 88
// Say ( Platonov , D2-Pla-3 ) ;
8709: LD_EXP 76
8713: PPUSH
8714: LD_STRING D2-Pla-3
8716: PPUSH
8717: CALL_OW 88
// Say ( Burlak , D2-Bur-3 ) ;
8721: LD_EXP 62
8725: PPUSH
8726: LD_STRING D2-Bur-3
8728: PPUSH
8729: CALL_OW 88
// Say ( Platonov , D2-Pla-4 ) ;
8733: LD_EXP 76
8737: PPUSH
8738: LD_STRING D2-Pla-4
8740: PPUSH
8741: CALL_OW 88
// Say ( Burlak , D2-Bur-4 ) ;
8745: LD_EXP 62
8749: PPUSH
8750: LD_STRING D2-Bur-4
8752: PPUSH
8753: CALL_OW 88
// Say ( Platonov , D2-Pla-5 ) ;
8757: LD_EXP 76
8761: PPUSH
8762: LD_STRING D2-Pla-5
8764: PPUSH
8765: CALL_OW 88
// Question1 ( [ 1 , 2 , 3 , 4 ] ) ;
8769: LD_INT 1
8771: PUSH
8772: LD_INT 2
8774: PUSH
8775: LD_INT 3
8777: PUSH
8778: LD_INT 4
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: PPUSH
8787: CALL 4426 0 1
// Say ( Platonov , D3-Pla-1 ) ;
8791: LD_EXP 76
8795: PPUSH
8796: LD_STRING D3-Pla-1
8798: PPUSH
8799: CALL_OW 88
// Say ( Burlak , D3-Bur-1 ) ;
8803: LD_EXP 62
8807: PPUSH
8808: LD_STRING D3-Bur-1
8810: PPUSH
8811: CALL_OW 88
// InGameOff ;
8815: CALL_OW 9
// ChangeMissionObjectives ( M2a ) ;
8819: LD_STRING M2a
8821: PPUSH
8822: CALL_OW 337
// ComFree ( Platonov ) ;
8826: LD_EXP 76
8830: PPUSH
8831: CALL_OW 139
// SetSide ( beria , 3 ) ;
8835: LD_INT 106
8837: PPUSH
8838: LD_INT 3
8840: PPUSH
8841: CALL_OW 235
// canExitBase = false ;
8845: LD_ADDR_EXP 19
8849: PUSH
8850: LD_INT 0
8852: ST_TO_ADDR
// exit ;
8853: POP
8854: POP
8855: GO 8861
// end ;
8857: GO 8281
8859: POP
8860: POP
// end ;
8861: PPOPN 5
8863: END
// export function Dial_LabConstructed ; begin
8864: LD_INT 0
8866: PPUSH
// labConstructed = true ;
8867: LD_ADDR_EXP 8
8871: PUSH
8872: LD_INT 1
8874: ST_TO_ADDR
// DialogueOn ;
8875: CALL_OW 6
// Say ( Burlak , D5a-Bur-1 ) ;
8879: LD_EXP 62
8883: PPUSH
8884: LD_STRING D5a-Bur-1
8886: PPUSH
8887: CALL_OW 88
// if workshopConstructed then
8891: LD_EXP 9
8895: IFFALSE 8911
// Say ( Platonov , D5a-Pla-1 ) else
8897: LD_EXP 76
8901: PPUSH
8902: LD_STRING D5a-Pla-1
8904: PPUSH
8905: CALL_OW 88
8909: GO 8923
// Say ( Platonov , D5a-Pla-1a ) ;
8911: LD_EXP 76
8915: PPUSH
8916: LD_STRING D5a-Pla-1a
8918: PPUSH
8919: CALL_OW 88
// DialogueOff ;
8923: CALL_OW 7
// ChangeMissionObjectives ( M2b ) ;
8927: LD_STRING M2b
8929: PPUSH
8930: CALL_OW 337
// end ;
8934: LD_VAR 0 1
8938: RET
// export function Dial_WorkshopConstructed ; begin
8939: LD_INT 0
8941: PPUSH
// workshopConstructed = true ;
8942: LD_ADDR_EXP 9
8946: PUSH
8947: LD_INT 1
8949: ST_TO_ADDR
// DialogueOn ;
8950: CALL_OW 6
// Say ( Burlak , D5b-Bur-1 ) ;
8954: LD_EXP 62
8958: PPUSH
8959: LD_STRING D5b-Bur-1
8961: PPUSH
8962: CALL_OW 88
// if labConstructed then
8966: LD_EXP 8
8970: IFFALSE 8986
// Say ( Platonov , D5b-Pla-1 ) else
8972: LD_EXP 76
8976: PPUSH
8977: LD_STRING D5b-Pla-1
8979: PPUSH
8980: CALL_OW 88
8984: GO 8998
// Say ( Platonov , D5b-Pla-1a ) ;
8986: LD_EXP 76
8990: PPUSH
8991: LD_STRING D5b-Pla-1a
8993: PPUSH
8994: CALL_OW 88
// DialogueOff ;
8998: CALL_OW 7
// ChangeMissionObjectives ( M2c ) ;
9002: LD_STRING M2c
9004: PPUSH
9005: CALL_OW 337
// end ;
9009: LD_VAR 0 1
9013: RET
// export function Dial_StopConstructAgainSameBuilding ( building ) ; begin
9014: LD_INT 0
9016: PPUSH
// wait ( 0 0$1 ) ;
9017: LD_INT 35
9019: PPUSH
9020: CALL_OW 67
// CenterNowOnUnits ( building ) ;
9024: LD_VAR 0 1
9028: PPUSH
9029: CALL_OW 87
// ComStop ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
9033: LD_INT 22
9035: PUSH
9036: LD_INT 3
9038: PUSH
9039: EMPTY
9040: LIST
9041: LIST
9042: PUSH
9043: LD_INT 21
9045: PUSH
9046: LD_INT 1
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: PUSH
9053: EMPTY
9054: LIST
9055: LIST
9056: PPUSH
9057: CALL_OW 69
9061: PPUSH
9062: CALL_OW 141
// DialogueOn ;
9066: CALL_OW 6
// Say ( Platonov , D6-Pla-1 ) ;
9070: LD_EXP 76
9074: PPUSH
9075: LD_STRING D6-Pla-1
9077: PPUSH
9078: CALL_OW 88
// Say ( Burlak , D6-Bur-1 ) ;
9082: LD_EXP 62
9086: PPUSH
9087: LD_STRING D6-Bur-1
9089: PPUSH
9090: CALL_OW 88
// DialogueOff ;
9094: CALL_OW 7
// case GetBType ( building ) of b_lab :
9098: LD_VAR 0 1
9102: PPUSH
9103: CALL_OW 266
9107: PUSH
9108: LD_INT 6
9110: DOUBLE
9111: EQUAL
9112: IFTRUE 9116
9114: GO 9156
9116: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + labCratesRefund ) ; b_workshop :
9117: LD_INT 106
9119: PPUSH
9120: CALL_OW 274
9124: PPUSH
9125: LD_INT 1
9127: PPUSH
9128: LD_INT 106
9130: PPUSH
9131: CALL_OW 274
9135: PPUSH
9136: LD_INT 1
9138: PPUSH
9139: CALL_OW 275
9143: PUSH
9144: LD_EXP 54
9148: PLUS
9149: PPUSH
9150: CALL_OW 277
9154: GO 9349
9156: LD_INT 2
9158: DOUBLE
9159: EQUAL
9160: IFTRUE 9164
9162: GO 9204
9164: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + workshopCratesRefund ) ; b_oil_power :
9165: LD_INT 106
9167: PPUSH
9168: CALL_OW 274
9172: PPUSH
9173: LD_INT 1
9175: PPUSH
9176: LD_INT 106
9178: PPUSH
9179: CALL_OW 274
9183: PPUSH
9184: LD_INT 1
9186: PPUSH
9187: CALL_OW 275
9191: PUSH
9192: LD_EXP 55
9196: PLUS
9197: PPUSH
9198: CALL_OW 277
9202: GO 9349
9204: LD_INT 26
9206: DOUBLE
9207: EQUAL
9208: IFTRUE 9212
9210: GO 9252
9212: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + oilPowerCratesRefund ) ; b_armoury :
9213: LD_INT 106
9215: PPUSH
9216: CALL_OW 274
9220: PPUSH
9221: LD_INT 1
9223: PPUSH
9224: LD_INT 106
9226: PPUSH
9227: CALL_OW 274
9231: PPUSH
9232: LD_INT 1
9234: PPUSH
9235: CALL_OW 275
9239: PUSH
9240: LD_EXP 56
9244: PLUS
9245: PPUSH
9246: CALL_OW 277
9250: GO 9349
9252: LD_INT 4
9254: DOUBLE
9255: EQUAL
9256: IFTRUE 9260
9258: GO 9300
9260: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + armouryCratesRefund ) ; b_breastwork :
9261: LD_INT 106
9263: PPUSH
9264: CALL_OW 274
9268: PPUSH
9269: LD_INT 1
9271: PPUSH
9272: LD_INT 106
9274: PPUSH
9275: CALL_OW 274
9279: PPUSH
9280: LD_INT 1
9282: PPUSH
9283: CALL_OW 275
9287: PUSH
9288: LD_EXP 57
9292: PLUS
9293: PPUSH
9294: CALL_OW 277
9298: GO 9349
9300: LD_INT 31
9302: DOUBLE
9303: EQUAL
9304: IFTRUE 9308
9306: GO 9348
9308: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + bunkerCratesRefund ) ; end ;
9309: LD_INT 106
9311: PPUSH
9312: CALL_OW 274
9316: PPUSH
9317: LD_INT 1
9319: PPUSH
9320: LD_INT 106
9322: PPUSH
9323: CALL_OW 274
9327: PPUSH
9328: LD_INT 1
9330: PPUSH
9331: CALL_OW 275
9335: PUSH
9336: LD_EXP 58
9340: PLUS
9341: PPUSH
9342: CALL_OW 277
9346: GO 9349
9348: POP
// RemoveUnit ( building ) ;
9349: LD_VAR 0 1
9353: PPUSH
9354: CALL_OW 64
// end ;
9358: LD_VAR 0 2
9362: RET
// every 0 0$2 trigger workshopConstructed and labConstructed do
9363: LD_EXP 9
9367: PUSH
9368: LD_EXP 8
9372: AND
9373: IFFALSE 9482
9375: GO 9377
9377: DISABLE
// begin DialogueOn ;
9378: CALL_OW 6
// if engineResearched then
9382: LD_EXP 10
9386: IFFALSE 9414
// begin Say ( Burlak , D7b-Bur-1 ) ;
9388: LD_EXP 62
9392: PPUSH
9393: LD_STRING D7b-Bur-1
9395: PPUSH
9396: CALL_OW 88
// Say ( Platonov , D7b-Pla-1 ) ;
9400: LD_EXP 76
9404: PPUSH
9405: LD_STRING D7b-Pla-1
9407: PPUSH
9408: CALL_OW 88
// end else
9412: GO 9438
// begin Say ( Burlak , D7a-Bur-1 ) ;
9414: LD_EXP 62
9418: PPUSH
9419: LD_STRING D7a-Bur-1
9421: PPUSH
9422: CALL_OW 88
// Say ( Platonov , D7a-Pla-1 ) ;
9426: LD_EXP 76
9430: PPUSH
9431: LD_STRING D7a-Pla-1
9433: PPUSH
9434: CALL_OW 88
// end ; DialogueOff ;
9438: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9442: LD_STRING M2
9444: PPUSH
9445: CALL_OW 337
// CreateCratesXYR ( 3 , GetX ( Platonov ) , GetY ( Platonov ) , 5 , true ) ;
9449: LD_INT 3
9451: PPUSH
9452: LD_EXP 76
9456: PPUSH
9457: CALL_OW 250
9461: PPUSH
9462: LD_EXP 76
9466: PPUSH
9467: CALL_OW 251
9471: PPUSH
9472: LD_INT 5
9474: PPUSH
9475: LD_INT 1
9477: PPUSH
9478: CALL_OW 56
// end ;
9482: END
// export function Dial_NewCrates ( x , y ) ; begin
9483: LD_INT 0
9485: PPUSH
// wait ( 0 0$18 ) ;
9486: LD_INT 630
9488: PPUSH
9489: CALL_OW 67
// if not spawnCrates then
9493: LD_EXP 21
9497: NOT
9498: IFFALSE 9502
// exit ;
9500: GO 9533
// ComMoveXY ( Platonov , x , y ) ;
9502: LD_EXP 76
9506: PPUSH
9507: LD_VAR 0 1
9511: PPUSH
9512: LD_VAR 0 2
9516: PPUSH
9517: CALL_OW 111
// Say ( Platonov , D4-Pla-1 ) ;
9521: LD_EXP 76
9525: PPUSH
9526: LD_STRING D4-Pla-1
9528: PPUSH
9529: CALL_OW 88
// end ;
9533: LD_VAR 0 3
9537: RET
// export function Dial_FirstVehConstructed ( factory ) ; begin
9538: LD_INT 0
9540: PPUSH
// firstVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
9541: LD_ADDR_EXP 13
9545: PUSH
9546: LD_INT 22
9548: PUSH
9549: LD_INT 3
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: PUSH
9556: LD_INT 21
9558: PUSH
9559: LD_INT 2
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: PUSH
9566: EMPTY
9567: LIST
9568: LIST
9569: PPUSH
9570: CALL_OW 69
9574: PUSH
9575: LD_INT 1
9577: ARRAY
9578: ST_TO_ADDR
// constructedFirstVehicle = true ;
9579: LD_ADDR_EXP 12
9583: PUSH
9584: LD_INT 1
9586: ST_TO_ADDR
// InGameOn ;
9587: CALL_OW 8
// CenterNowOnUnits ( factory ) ;
9591: LD_VAR 0 1
9595: PPUSH
9596: CALL_OW 87
// wait ( 0 0$3 ) ;
9600: LD_INT 105
9602: PPUSH
9603: CALL_OW 67
// Say ( Burlak , D9-Bur-1 ) ;
9607: LD_EXP 62
9611: PPUSH
9612: LD_STRING D9-Bur-1
9614: PPUSH
9615: CALL_OW 88
// ComMoveXY ( Platonov , GetX ( firstVeh ) , GetY ( firstVeh ) ) ;
9619: LD_EXP 76
9623: PPUSH
9624: LD_EXP 13
9628: PPUSH
9629: CALL_OW 250
9633: PPUSH
9634: LD_EXP 13
9638: PPUSH
9639: CALL_OW 251
9643: PPUSH
9644: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
9648: LD_INT 35
9650: PPUSH
9651: CALL_OW 67
// until GetDistUnits ( Platonov , firstVeh ) < 4 ;
9655: LD_EXP 76
9659: PPUSH
9660: LD_EXP 13
9664: PPUSH
9665: CALL_OW 296
9669: PUSH
9670: LD_INT 4
9672: LESS
9673: IFFALSE 9648
// ComTurnUnit ( Platonov , firstVeh ) ;
9675: LD_EXP 76
9679: PPUSH
9680: LD_EXP 13
9684: PPUSH
9685: CALL_OW 119
// Say ( Platonov , D9-Pla-1 ) ;
9689: LD_EXP 76
9693: PPUSH
9694: LD_STRING D9-Pla-1
9696: PPUSH
9697: CALL_OW 88
// InGameOff ;
9701: CALL_OW 9
// ChangeMissionObjectives ( M3 ) ;
9705: LD_STRING M3
9707: PPUSH
9708: CALL_OW 337
// canExitBase = true ;
9712: LD_ADDR_EXP 19
9716: PUSH
9717: LD_INT 1
9719: ST_TO_ADDR
// ComMoveXY ( Platonov , 112 , 97 ) ;
9720: LD_EXP 76
9724: PPUSH
9725: LD_INT 112
9727: PPUSH
9728: LD_INT 97
9730: PPUSH
9731: CALL_OW 111
// end ;
9735: LD_VAR 0 2
9739: RET
// every 0 0$1 trigger IsInArea ( firstVeh , KirovBaseArea ) and not vehicleForKurin do var i , eng , mech ;
9740: LD_EXP 13
9744: PPUSH
9745: LD_INT 9
9747: PPUSH
9748: CALL_OW 308
9752: PUSH
9753: LD_EXP 14
9757: NOT
9758: AND
9759: IFFALSE 10613
9761: GO 9763
9763: DISABLE
9764: LD_INT 0
9766: PPUSH
9767: PPUSH
9768: PPUSH
// begin vehicleForKurin = true ;
9769: LD_ADDR_EXP 14
9773: PUSH
9774: LD_INT 1
9776: ST_TO_ADDR
// eng = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) [ 1 ] ;
9777: LD_ADDR_VAR 0 2
9781: PUSH
9782: LD_EXP 69
9786: PPUSH
9787: LD_INT 25
9789: PUSH
9790: LD_INT 2
9792: PUSH
9793: EMPTY
9794: LIST
9795: LIST
9796: PPUSH
9797: CALL_OW 72
9801: PUSH
9802: LD_INT 1
9804: ARRAY
9805: ST_TO_ADDR
// mech = UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) [ 1 ] ;
9806: LD_ADDR_VAR 0 3
9810: PUSH
9811: LD_EXP 69
9815: PPUSH
9816: LD_INT 25
9818: PUSH
9819: LD_INT 3
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: PPUSH
9826: CALL_OW 72
9830: PUSH
9831: LD_INT 1
9833: ARRAY
9834: ST_TO_ADDR
// InGameOn ;
9835: CALL_OW 8
// CenterNowOnUnits ( Kurin ) ;
9839: LD_EXP 67
9843: PPUSH
9844: CALL_OW 87
// ComMoveXY ( firstVeh , GetX ( Kurin ) , GetY ( Kurin ) ) ;
9848: LD_EXP 13
9852: PPUSH
9853: LD_EXP 67
9857: PPUSH
9858: CALL_OW 250
9862: PPUSH
9863: LD_EXP 67
9867: PPUSH
9868: CALL_OW 251
9872: PPUSH
9873: CALL_OW 111
// Say ( Kurin , D10-Kur-1 ) ;
9877: LD_EXP 67
9881: PPUSH
9882: LD_STRING D10-Kur-1
9884: PPUSH
9885: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
9889: LD_INT 35
9891: PPUSH
9892: CALL_OW 67
// ComMoveXY ( firstVeh , GetX ( Kurin ) , GetY ( Kurin ) ) ;
9896: LD_EXP 13
9900: PPUSH
9901: LD_EXP 67
9905: PPUSH
9906: CALL_OW 250
9910: PPUSH
9911: LD_EXP 67
9915: PPUSH
9916: CALL_OW 251
9920: PPUSH
9921: CALL_OW 111
// until GetDistUnits ( firstVeh , Kurin ) < 9 ;
9925: LD_EXP 13
9929: PPUSH
9930: LD_EXP 67
9934: PPUSH
9935: CALL_OW 296
9939: PUSH
9940: LD_INT 9
9942: LESS
9943: IFFALSE 9889
// ComExitVehicle ( UnitsInside ( firstVeh ) ) ;
9945: LD_EXP 13
9949: PPUSH
9950: CALL_OW 313
9954: PPUSH
9955: CALL_OW 121
// wait ( 0 0$1 ) ;
9959: LD_INT 35
9961: PPUSH
9962: CALL_OW 67
// if GetLives ( firstVeh ) < 1000 then
9966: LD_EXP 13
9970: PPUSH
9971: CALL_OW 256
9975: PUSH
9976: LD_INT 1000
9978: LESS
9979: IFFALSE 10011
// begin ComExitBuilding ( mech ) ;
9981: LD_VAR 0 3
9985: PPUSH
9986: CALL_OW 122
// wait ( 0 0$1 ) ;
9990: LD_INT 35
9992: PPUSH
9993: CALL_OW 67
// AddComRepairVehicle ( mech , firstVeh ) ;
9997: LD_VAR 0 3
10001: PPUSH
10002: LD_EXP 13
10006: PPUSH
10007: CALL_OW 189
// end ; if GetFuel ( firstVeh ) < 90 then
10011: LD_EXP 13
10015: PPUSH
10016: CALL_OW 261
10020: PUSH
10021: LD_INT 90
10023: LESS
10024: IFFALSE 10059
// begin ComExitBuilding ( eng ) ;
10026: LD_VAR 0 2
10030: PPUSH
10031: CALL_OW 122
// wait ( 0 0$1 ) ;
10035: LD_INT 35
10037: PPUSH
10038: CALL_OW 67
// ExtAddComRefuel ( eng , kirov , firstVeh ) ;
10042: LD_VAR 0 2
10046: PPUSH
10047: LD_INT 71
10049: PPUSH
10050: LD_EXP 13
10054: PPUSH
10055: CALL 4664 0 3
// end ; repeat wait ( 0 0$1 ) ;
10059: LD_INT 35
10061: PPUSH
10062: CALL_OW 67
// until GetLives ( firstVeh ) = 1000 and GetFuel ( firstVeh ) > 90 ;
10066: LD_EXP 13
10070: PPUSH
10071: CALL_OW 256
10075: PUSH
10076: LD_INT 1000
10078: EQUAL
10079: PUSH
10080: LD_EXP 13
10084: PPUSH
10085: CALL_OW 261
10089: PUSH
10090: LD_INT 90
10092: GREATER
10093: AND
10094: IFFALSE 10059
// if UnitsInside ( firstVeh ) then
10096: LD_EXP 13
10100: PPUSH
10101: CALL_OW 313
10105: IFFALSE 10125
// ComExitVehicle ( UnitsInside ( firstVeh ) [ 1 ] ) ;
10107: LD_EXP 13
10111: PPUSH
10112: CALL_OW 313
10116: PUSH
10117: LD_INT 1
10119: ARRAY
10120: PPUSH
10121: CALL_OW 121
// ComEnterUnit ( eng , kirov ) ;
10125: LD_VAR 0 2
10129: PPUSH
10130: LD_INT 71
10132: PPUSH
10133: CALL_OW 120
// SetSide ( firstVeh , 6 ) ;
10137: LD_EXP 13
10141: PPUSH
10142: LD_INT 6
10144: PPUSH
10145: CALL_OW 235
// if belkovReturn then
10149: LD_EXP 6
10153: IFFALSE 10239
// begin if IsInUnit ( Belkov ) then
10155: LD_EXP 64
10159: PPUSH
10160: CALL_OW 310
10164: IFFALSE 10175
// ComExitBuilding ( Belkov ) ;
10166: LD_EXP 64
10170: PPUSH
10171: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
10175: LD_INT 35
10177: PPUSH
10178: CALL_OW 67
// AddComEnterUnit ( Belkov , firstVeh ) ;
10182: LD_EXP 64
10186: PPUSH
10187: LD_EXP 13
10191: PPUSH
10192: CALL_OW 180
// until IsInUnit ( Belkov ) = firstVeh ;
10196: LD_EXP 64
10200: PPUSH
10201: CALL_OW 310
10205: PUSH
10206: LD_EXP 13
10210: EQUAL
10211: IFFALSE 10175
// Say ( Belkov , D10-Bel-1 ) ;
10213: LD_EXP 64
10217: PPUSH
10218: LD_STRING D10-Bel-1
10220: PPUSH
10221: CALL_OW 88
// Say ( Kurin , D10-Kur-2 ) ;
10225: LD_EXP 67
10229: PPUSH
10230: LD_STRING D10-Kur-2
10232: PPUSH
10233: CALL_OW 88
// end else
10237: GO 10365
// begin if IsInUnit ( Belkov2 ) then
10239: LD_EXP 68
10243: PPUSH
10244: CALL_OW 310
10248: IFFALSE 10259
// ComExitBuilding ( Belkov2 ) ;
10250: LD_EXP 68
10254: PPUSH
10255: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
10259: LD_INT 35
10261: PPUSH
10262: CALL_OW 67
// AddComEnterUnit ( Belkov2 , firstVeh ) ;
10266: LD_EXP 68
10270: PPUSH
10271: LD_EXP 13
10275: PPUSH
10276: CALL_OW 180
// until IsInUnit ( Belkov2 ) = firstVeh ;
10280: LD_EXP 68
10284: PPUSH
10285: CALL_OW 310
10289: PUSH
10290: LD_EXP 13
10294: EQUAL
10295: IFFALSE 10259
// meetBelkovBrother = true ;
10297: LD_ADDR_EXP 4
10301: PUSH
10302: LD_INT 1
10304: ST_TO_ADDR
// Say ( Belkov2 , D10-Bel-1 ) ;
10305: LD_EXP 68
10309: PPUSH
10310: LD_STRING D10-Bel-1
10312: PPUSH
10313: CALL_OW 88
// Say ( Burlak , D10-Bur-1 ) ;
10317: LD_EXP 62
10321: PPUSH
10322: LD_STRING D10-Bur-1
10324: PPUSH
10325: CALL_OW 88
// Say ( Belkov2 , D10-Bel-2 ) ;
10329: LD_EXP 68
10333: PPUSH
10334: LD_STRING D10-Bel-2
10336: PPUSH
10337: CALL_OW 88
// Say ( Burlak , D10-Bur-2 ) ;
10341: LD_EXP 62
10345: PPUSH
10346: LD_STRING D10-Bur-2
10348: PPUSH
10349: CALL_OW 88
// Say ( Kurin , D10-Kur-2a ) ;
10353: LD_EXP 67
10357: PPUSH
10358: LD_STRING D10-Kur-2a
10360: PPUSH
10361: CALL_OW 88
// end ; removedBelkovUntisSaved = [ ] ;
10365: LD_ADDR_EXP 74
10369: PUSH
10370: EMPTY
10371: ST_TO_ADDR
// removedBelkovVehicleSaved = [ ] ;
10372: LD_ADDR_EXP 75
10376: PUSH
10377: EMPTY
10378: ST_TO_ADDR
// canRemoveBelkovUnits = true ;
10379: LD_ADDR_EXP 22
10383: PUSH
10384: LD_INT 1
10386: ST_TO_ADDR
// CreateBelkovTeam ;
10387: CALL 6066 0 0
// ComExitBuilding ( belkovTeam ) ;
10391: LD_EXP 73
10395: PPUSH
10396: CALL_OW 122
// wait ( 0 0$1 ) ;
10400: LD_INT 35
10402: PPUSH
10403: CALL_OW 67
// kirovVehicle = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
10407: LD_ADDR_EXP 72
10411: PUSH
10412: LD_INT 22
10414: PUSH
10415: LD_INT 6
10417: PUSH
10418: EMPTY
10419: LIST
10420: LIST
10421: PUSH
10422: LD_INT 21
10424: PUSH
10425: LD_INT 2
10427: PUSH
10428: EMPTY
10429: LIST
10430: LIST
10431: PUSH
10432: EMPTY
10433: LIST
10434: LIST
10435: PPUSH
10436: CALL_OW 69
10440: PUSH
10441: LD_INT 1
10443: ARRAY
10444: ST_TO_ADDR
// belkovTeam = belkovTeam ^ kirovVehicle ;
10445: LD_ADDR_EXP 73
10449: PUSH
10450: LD_EXP 73
10454: PUSH
10455: LD_EXP 72
10459: ADD
10460: ST_TO_ADDR
// ComMoveXY ( belkovTeam , 147 , 102 ) ;
10461: LD_EXP 73
10465: PPUSH
10466: LD_INT 147
10468: PPUSH
10469: LD_INT 102
10471: PPUSH
10472: CALL_OW 111
// AddComMoveXY ( belkovTeam , 133 , 94 ) ;
10476: LD_EXP 73
10480: PPUSH
10481: LD_INT 133
10483: PPUSH
10484: LD_INT 94
10486: PPUSH
10487: CALL_OW 171
// AddComMoveXY ( belkovTeam , 123 , 74 ) ;
10491: LD_EXP 73
10495: PPUSH
10496: LD_INT 123
10498: PPUSH
10499: LD_INT 74
10501: PPUSH
10502: CALL_OW 171
// AddComMoveXY ( belkovTeam , 111 , 48 ) ;
10506: LD_EXP 73
10510: PPUSH
10511: LD_INT 111
10513: PPUSH
10514: LD_INT 48
10516: PPUSH
10517: CALL_OW 171
// AddComMoveXY ( belkovTeam , 122 , 43 ) ;
10521: LD_EXP 73
10525: PPUSH
10526: LD_INT 122
10528: PPUSH
10529: LD_INT 43
10531: PPUSH
10532: CALL_OW 171
// AddComMoveXY ( belkovTeam , 129 , 32 ) ;
10536: LD_EXP 73
10540: PPUSH
10541: LD_INT 129
10543: PPUSH
10544: LD_INT 32
10546: PPUSH
10547: CALL_OW 171
// AddComMoveXY ( belkovTeam , 132 , 22 ) ;
10551: LD_EXP 73
10555: PPUSH
10556: LD_INT 132
10558: PPUSH
10559: LD_INT 22
10561: PPUSH
10562: CALL_OW 171
// wait ( 0 0$8 ) ;
10566: LD_INT 280
10568: PPUSH
10569: CALL_OW 67
// CenterNowOnUnits ( Kurin ) ;
10573: LD_EXP 67
10577: PPUSH
10578: CALL_OW 87
// Say ( Kurin , D10-Kur-2b ) ;
10582: LD_EXP 67
10586: PPUSH
10587: LD_STRING D10-Kur-2b
10589: PPUSH
10590: CALL_OW 88
// InGameOff ;
10594: CALL_OW 9
// ChangeMissionObjectives ( M4 ) ;
10598: LD_STRING M4
10600: PPUSH
10601: CALL_OW 337
// backToBeria1 = true ;
10605: LD_ADDR_EXP 15
10609: PUSH
10610: LD_INT 1
10612: ST_TO_ADDR
// end ;
10613: PPOPN 3
10615: END
// every 0 0$1 trigger FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) and vehicleForKurin do
10616: LD_INT 9
10618: PPUSH
10619: LD_INT 22
10621: PUSH
10622: LD_INT 3
10624: PUSH
10625: EMPTY
10626: LIST
10627: LIST
10628: PUSH
10629: LD_INT 21
10631: PUSH
10632: LD_INT 2
10634: PUSH
10635: EMPTY
10636: LIST
10637: LIST
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PPUSH
10643: CALL_OW 70
10647: PUSH
10648: LD_EXP 14
10652: AND
10653: IFFALSE 10670
10655: GO 10657
10657: DISABLE
// Say ( Kurin , D1a-Kur-1a ) ;
10658: LD_EXP 67
10662: PPUSH
10663: LD_STRING D1a-Kur-1a
10665: PPUSH
10666: CALL_OW 88
10670: END
// every 1 trigger canRemoveBelkovUnits do var unit , driver ;
10671: LD_EXP 22
10675: IFFALSE 11078
10677: GO 10679
10679: DISABLE
10680: LD_INT 0
10682: PPUSH
10683: PPUSH
// begin enable ;
10684: ENABLE
// if FilterUnitsInArea ( BelkovExitArea , [ f_side , 6 ] ) = 0 then
10685: LD_INT 10
10687: PPUSH
10688: LD_INT 22
10690: PUSH
10691: LD_INT 6
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: PPUSH
10698: CALL_OW 70
10702: PUSH
10703: LD_INT 0
10705: EQUAL
10706: IFFALSE 10710
// exit ;
10708: GO 11078
// for unit in FilterUnitsInArea ( BelkovExitArea , [ f_side , 6 ] ) do
10710: LD_ADDR_VAR 0 1
10714: PUSH
10715: LD_INT 10
10717: PPUSH
10718: LD_INT 22
10720: PUSH
10721: LD_INT 6
10723: PUSH
10724: EMPTY
10725: LIST
10726: LIST
10727: PPUSH
10728: CALL_OW 70
10732: PUSH
10733: FOR_IN
10734: IFFALSE 11064
// begin if GetType ( unit ) = unit_human and ( not unit = Belkov and not unit = Belkov2 and not unit = Kirilenkova ) then
10736: LD_VAR 0 1
10740: PPUSH
10741: CALL_OW 247
10745: PUSH
10746: LD_INT 1
10748: EQUAL
10749: PUSH
10750: LD_VAR 0 1
10754: PUSH
10755: LD_EXP 64
10759: EQUAL
10760: NOT
10761: PUSH
10762: LD_VAR 0 1
10766: PUSH
10767: LD_EXP 68
10771: EQUAL
10772: NOT
10773: AND
10774: PUSH
10775: LD_VAR 0 1
10779: PUSH
10780: LD_EXP 65
10784: EQUAL
10785: NOT
10786: AND
10787: AND
10788: IFFALSE 10829
// begin removedBelkovUntis = removedBelkovUntis + 1 ;
10790: LD_ADDR_EXP 23
10794: PUSH
10795: LD_EXP 23
10799: PUSH
10800: LD_INT 1
10802: PLUS
10803: ST_TO_ADDR
// removedBelkovUntisSaved = removedBelkovUntisSaved ^ unit ;
10804: LD_ADDR_EXP 74
10808: PUSH
10809: LD_EXP 74
10813: PUSH
10814: LD_VAR 0 1
10818: ADD
10819: ST_TO_ADDR
// RemoveUnit ( unit ) ;
10820: LD_VAR 0 1
10824: PPUSH
10825: CALL_OW 64
// end ; if unit = Kirilenkova then
10829: LD_VAR 0 1
10833: PUSH
10834: LD_EXP 65
10838: EQUAL
10839: IFFALSE 10862
// begin SaveCharacters ( Kirilenkova , 02_TmpKirilenkova ) ;
10841: LD_EXP 65
10845: PPUSH
10846: LD_STRING 02_TmpKirilenkova
10848: PPUSH
10849: CALL_OW 38
// RemoveUnit ( unit ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: CALL_OW 64
// end ; if unit = Belkov2 then
10862: LD_VAR 0 1
10866: PUSH
10867: LD_EXP 68
10871: EQUAL
10872: IFFALSE 10895
// begin SaveCharacters ( Belkov2 , 02_TmpBelkov2 ) ;
10874: LD_EXP 68
10878: PPUSH
10879: LD_STRING 02_TmpBelkov2
10881: PPUSH
10882: CALL_OW 38
// RemoveUnit ( unit ) ;
10886: LD_VAR 0 1
10890: PPUSH
10891: CALL_OW 64
// end ; if GetType ( unit ) = unit_vehicle then
10895: LD_VAR 0 1
10899: PPUSH
10900: CALL_OW 247
10904: PUSH
10905: LD_INT 2
10907: EQUAL
10908: IFFALSE 11062
// begin driver = UnitsInside ( unit ) ;
10910: LD_ADDR_VAR 0 2
10914: PUSH
10915: LD_VAR 0 1
10919: PPUSH
10920: CALL_OW 313
10924: ST_TO_ADDR
// if driver [ 1 ] = Belkov then
10925: LD_VAR 0 2
10929: PUSH
10930: LD_INT 1
10932: ARRAY
10933: PUSH
10934: LD_EXP 64
10938: EQUAL
10939: IFFALSE 10964
// begin SaveCharacters ( Belkov , 02_TmpBelkov ) ;
10941: LD_EXP 64
10945: PPUSH
10946: LD_STRING 02_TmpBelkov
10948: PPUSH
10949: CALL_OW 38
// RemoveUnit ( unit ) ;
10953: LD_VAR 0 1
10957: PPUSH
10958: CALL_OW 64
// end else
10962: GO 10985
// begin SaveCharacters ( Belkov2 , 02_TmpBelkov2 ) ;
10964: LD_EXP 68
10968: PPUSH
10969: LD_STRING 02_TmpBelkov2
10971: PPUSH
10972: CALL_OW 38
// RemoveUnit ( unit ) ;
10976: LD_VAR 0 1
10980: PPUSH
10981: CALL_OW 64
// end ; removedBelkovVehicleSaved = removedBelkovVehicleSaved ^ [ GetChassis ( unit ) , GetEngine ( unit ) , GetControl ( unit ) , GetWeapon ( unit ) , GetFuel ( unit ) ] ;
10985: LD_ADDR_EXP 75
10989: PUSH
10990: LD_EXP 75
10994: PUSH
10995: LD_VAR 0 1
10999: PPUSH
11000: CALL_OW 265
11004: PUSH
11005: LD_VAR 0 1
11009: PPUSH
11010: CALL_OW 262
11014: PUSH
11015: LD_VAR 0 1
11019: PPUSH
11020: CALL_OW 263
11024: PUSH
11025: LD_VAR 0 1
11029: PPUSH
11030: CALL_OW 264
11034: PUSH
11035: LD_VAR 0 1
11039: PPUSH
11040: CALL_OW 261
11044: PUSH
11045: EMPTY
11046: LIST
11047: LIST
11048: LIST
11049: LIST
11050: LIST
11051: ADD
11052: ST_TO_ADDR
// RemoveUnit ( unit ) ;
11053: LD_VAR 0 1
11057: PPUSH
11058: CALL_OW 64
// end ; end ;
11062: GO 10733
11064: POP
11065: POP
// SaveCharacters ( removedBelkovUntisSaved , 02_TmpBelkovTeam ) ;
11066: LD_EXP 74
11070: PPUSH
11071: LD_STRING 02_TmpBelkovTeam
11073: PPUSH
11074: CALL_OW 38
// end ;
11078: PPOPN 2
11080: END
// every 0 0$1 trigger FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and backToBeria1 do var engs ;
11081: LD_INT 8
11083: PPUSH
11084: LD_INT 22
11086: PUSH
11087: LD_INT 3
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 21
11096: PUSH
11097: LD_INT 1
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PPUSH
11108: CALL_OW 71
11112: PUSH
11113: LD_INT 0
11115: EQUAL
11116: PUSH
11117: LD_EXP 15
11121: AND
11122: IFFALSE 11329
11124: GO 11126
11126: DISABLE
11127: LD_INT 0
11129: PPUSH
// begin engs = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) ;
11130: LD_ADDR_VAR 0 1
11134: PUSH
11135: LD_EXP 69
11139: PPUSH
11140: LD_INT 25
11142: PUSH
11143: LD_INT 2
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: PPUSH
11150: CALL_OW 72
11154: ST_TO_ADDR
// backToBeria1 = false ;
11155: LD_ADDR_EXP 15
11159: PUSH
11160: LD_INT 0
11162: ST_TO_ADDR
// canExitBase = false ;
11163: LD_ADDR_EXP 19
11167: PUSH
11168: LD_INT 0
11170: ST_TO_ADDR
// Say ( Platonov , D11-Pla-1 ) ;
11171: LD_EXP 76
11175: PPUSH
11176: LD_STRING D11-Pla-1
11178: PPUSH
11179: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 1 then
11183: LD_INT 22
11185: PUSH
11186: LD_INT 3
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PUSH
11193: LD_INT 21
11195: PUSH
11196: LD_INT 1
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: EMPTY
11204: LIST
11205: LIST
11206: PPUSH
11207: CALL_OW 69
11211: PUSH
11212: LD_INT 1
11214: GREATER
11215: IFFALSE 11231
// Say ( Burlak , D11-Bur-1a ) else
11217: LD_EXP 62
11221: PPUSH
11222: LD_STRING D11-Bur-1a
11224: PPUSH
11225: CALL_OW 88
11229: GO 11243
// Say ( Burlak , D11-Bur-1 ) ;
11231: LD_EXP 62
11235: PPUSH
11236: LD_STRING D11-Bur-1
11238: PPUSH
11239: CALL_OW 88
// ChangeMissionObjectives ( M5 ) ;
11243: LD_STRING M5
11245: PPUSH
11246: CALL_OW 337
// CreateCratesArea ( rand ( 1 , 5 ) , CratesArea , true ) ;
11250: LD_INT 1
11252: PPUSH
11253: LD_INT 5
11255: PPUSH
11256: CALL_OW 12
11260: PPUSH
11261: LD_INT 26
11263: PPUSH
11264: LD_INT 1
11266: PPUSH
11267: CALL_OW 55
// construcMoreVehicles = true ;
11271: LD_ADDR_EXP 17
11275: PUSH
11276: LD_INT 1
11278: ST_TO_ADDR
// spawnCrates = true ;
11279: LD_ADDR_EXP 21
11283: PUSH
11284: LD_INT 1
11286: ST_TO_ADDR
// AddComExitBuilding ( engs ) ;
11287: LD_VAR 0 1
11291: PPUSH
11292: CALL_OW 182
// AddComBuild ( engs , b_workshop , 159 , 112 , 0 ) ;
11296: LD_VAR 0 1
11300: PPUSH
11301: LD_INT 2
11303: PPUSH
11304: LD_INT 159
11306: PPUSH
11307: LD_INT 112
11309: PPUSH
11310: LD_INT 0
11312: PPUSH
11313: CALL_OW 205
// AddComEnterUnit ( engs , kirov ) ;
11317: LD_VAR 0 1
11321: PPUSH
11322: LD_INT 71
11324: PPUSH
11325: CALL_OW 180
// end ;
11329: PPOPN 1
11331: END
// every 0 0$1 trigger constructedVehiclesCounter >= FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do var tmpBelkov , nearRuUnit ;
11332: LD_EXP 18
11336: PUSH
11337: LD_INT 22
11339: PUSH
11340: LD_INT 3
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: PUSH
11347: LD_INT 21
11349: PUSH
11350: LD_INT 1
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: PUSH
11357: EMPTY
11358: LIST
11359: LIST
11360: PPUSH
11361: CALL_OW 69
11365: GREATEREQUAL
11366: IFFALSE 12494
11368: GO 11370
11370: DISABLE
11371: LD_INT 0
11373: PPUSH
11374: PPUSH
// begin canRemoveBelkovUnits = false ;
11375: LD_ADDR_EXP 22
11379: PUSH
11380: LD_INT 0
11382: ST_TO_ADDR
// spawnCrates = false ;
11383: LD_ADDR_EXP 21
11387: PUSH
11388: LD_INT 0
11390: ST_TO_ADDR
// ComStop ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ) ;
11391: LD_INT 22
11393: PUSH
11394: LD_INT 3
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: PUSH
11401: LD_INT 2
11403: PUSH
11404: LD_INT 21
11406: PUSH
11407: LD_INT 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 21
11416: PUSH
11417: LD_INT 2
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: LIST
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PPUSH
11433: CALL_OW 69
11437: PPUSH
11438: CALL_OW 141
// InGameOn ;
11442: CALL_OW 8
// CenterOnUnits ( Platonov ) ;
11446: LD_EXP 76
11450: PPUSH
11451: CALL_OW 85
// DialogueOn ;
11455: CALL_OW 6
// Say ( Burlak , D12-Bur-1 ) ;
11459: LD_EXP 62
11463: PPUSH
11464: LD_STRING D12-Bur-1
11466: PPUSH
11467: CALL_OW 88
// Say ( Platonov , D12-Pla-1 ) ;
11471: LD_EXP 76
11475: PPUSH
11476: LD_STRING D12-Pla-1
11478: PPUSH
11479: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
11483: LD_EXP 62
11487: PPUSH
11488: LD_STRING D12-Bur-2
11490: PPUSH
11491: CALL_OW 88
// Say ( Platonov , D12-Pla-2 ) ;
11495: LD_EXP 76
11499: PPUSH
11500: LD_STRING D12-Pla-2
11502: PPUSH
11503: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11507: LD_EXP 62
11511: PPUSH
11512: LD_STRING D12-Bur-3
11514: PPUSH
11515: CALL_OW 88
// Say ( Platonov , D12-Pla-3 ) ;
11519: LD_EXP 76
11523: PPUSH
11524: LD_STRING D12-Pla-3
11526: PPUSH
11527: CALL_OW 88
// DialogueOff ;
11531: CALL_OW 7
// SetAttitude ( 6 , 1 , att_friend , true ) ;
11535: LD_INT 6
11537: PPUSH
11538: LD_INT 1
11540: PPUSH
11541: LD_INT 1
11543: PPUSH
11544: LD_INT 1
11546: PPUSH
11547: CALL_OW 80
// PrepareAmerican ;
11551: CALL 2879 0 0
// PrepareBelkovReturnTeam ;
11555: CALL 1132 0 0
// if IsOK ( Belkov ) then
11559: LD_EXP 64
11563: PPUSH
11564: CALL_OW 302
11568: IFFALSE 11582
// tmpBelkov = Belkov else
11570: LD_ADDR_VAR 0 1
11574: PUSH
11575: LD_EXP 64
11579: ST_TO_ADDR
11580: GO 11592
// tmpBelkov = Belkov2 ;
11582: LD_ADDR_VAR 0 1
11586: PUSH
11587: LD_EXP 68
11591: ST_TO_ADDR
// CenterNowOnUnits ( kirovVehicle ) ;
11592: LD_EXP 72
11596: PPUSH
11597: CALL_OW 87
// SayRadio ( trapCommander , D13-Sol1-1 ) ;
11601: LD_EXP 80
11605: PPUSH
11606: LD_STRING D13-Sol1-1
11608: PPUSH
11609: CALL_OW 94
// SayRadio ( tmpBelkov , D13-Bel-1 ) ;
11613: LD_VAR 0 1
11617: PPUSH
11618: LD_STRING D13-Bel-1
11620: PPUSH
11621: CALL_OW 94
// SayRadio ( Kurin , D13-Kur-1 ) ;
11625: LD_EXP 67
11629: PPUSH
11630: LD_STRING D13-Kur-1
11632: PPUSH
11633: CALL_OW 94
// SayRadio ( tmpBelkov , D13-Bel-2 ) ;
11637: LD_VAR 0 1
11641: PPUSH
11642: LD_STRING D13-Bel-2
11644: PPUSH
11645: CALL_OW 94
// ComMoveXY ( belkovTeam , 121 , 29 ) ;
11649: LD_EXP 73
11653: PPUSH
11654: LD_INT 121
11656: PPUSH
11657: LD_INT 29
11659: PPUSH
11660: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11664: LD_INT 35
11666: PPUSH
11667: CALL_OW 67
// CenterNowOnUnits ( kirovVehicle ) ;
11671: LD_EXP 72
11675: PPUSH
11676: CALL_OW 87
// nearRuUnit = NearestUnitToUnit ( UnitFilter ( belkovTeam , [ [ f_type , unit_human ] , [ f_outside ] ] ) , kirovVehicle ) ;
11680: LD_ADDR_VAR 0 2
11684: PUSH
11685: LD_EXP 73
11689: PPUSH
11690: LD_INT 21
11692: PUSH
11693: LD_INT 1
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: PUSH
11700: LD_INT 56
11702: PUSH
11703: EMPTY
11704: LIST
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PPUSH
11710: CALL_OW 72
11714: PPUSH
11715: LD_EXP 72
11719: PPUSH
11720: CALL_OW 74
11724: ST_TO_ADDR
// if GetDistUnits ( kirovVehicle , nearRuUnit ) < 5 then
11725: LD_EXP 72
11729: PPUSH
11730: LD_VAR 0 2
11734: PPUSH
11735: CALL_OW 296
11739: PUSH
11740: LD_INT 5
11742: LESS
11743: IFFALSE 11756
// ComStop ( kirovVehicle ) else
11745: LD_EXP 72
11749: PPUSH
11750: CALL_OW 141
11754: GO 11771
// ComMoveXY ( belkovTeam , 121 , 29 ) ;
11756: LD_EXP 73
11760: PPUSH
11761: LD_INT 121
11763: PPUSH
11764: LD_INT 29
11766: PPUSH
11767: CALL_OW 111
// until GetDistUnits ( NearestUnitToUnit ( belkovTeam , trapCommander ) , trapCommander ) < 5 ;
11771: LD_EXP 73
11775: PPUSH
11776: LD_EXP 80
11780: PPUSH
11781: CALL_OW 74
11785: PPUSH
11786: LD_EXP 80
11790: PPUSH
11791: CALL_OW 296
11795: PUSH
11796: LD_INT 5
11798: LESS
11799: IFFALSE 11664
// CenterNowOnUnits ( [ kirovVehicle , trapCommander ] ) ;
11801: LD_EXP 72
11805: PUSH
11806: LD_EXP 80
11810: PUSH
11811: EMPTY
11812: LIST
11813: LIST
11814: PPUSH
11815: CALL_OW 87
// ComWalk ( trapTeam ) ;
11819: LD_EXP 81
11823: PPUSH
11824: CALL_OW 138
// AddComTurnUnit ( trapTeam , kirovVehicle ) ;
11828: LD_EXP 81
11832: PPUSH
11833: LD_EXP 72
11837: PPUSH
11838: CALL_OW 179
// ComStop ( belkovTeam ) ;
11842: LD_EXP 73
11846: PPUSH
11847: CALL_OW 141
// AddComTurnUnit ( belkovTeam , trapCommander ) ;
11851: LD_EXP 73
11855: PPUSH
11856: LD_EXP 80
11860: PPUSH
11861: CALL_OW 179
// AddComMoveXY ( FilterUnitsInArea ( TrapNorthGroupArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) , 111 , 13 ) ;
11865: LD_INT 25
11867: PPUSH
11868: LD_INT 22
11870: PUSH
11871: LD_INT 1
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: PUSH
11878: LD_INT 21
11880: PUSH
11881: LD_INT 1
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: PPUSH
11892: CALL_OW 70
11896: PPUSH
11897: LD_INT 111
11899: PPUSH
11900: LD_INT 13
11902: PPUSH
11903: CALL_OW 171
// music_class = music_combat ;
11907: LD_ADDR_OWVAR 72
11911: PUSH
11912: LD_INT 1
11914: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11915: LD_INT 35
11917: PPUSH
11918: CALL_OW 67
// DialogueOn ;
11922: CALL_OW 6
// Say ( trapCommander , D14-Sol1-1 ) ;
11926: LD_EXP 80
11930: PPUSH
11931: LD_STRING D14-Sol1-1
11933: PPUSH
11934: CALL_OW 88
// Say ( tmpBelkov , D14-Bel-1 ) ;
11938: LD_VAR 0 1
11942: PPUSH
11943: LD_STRING D14-Bel-1
11945: PPUSH
11946: CALL_OW 88
// DialogueOff ;
11950: CALL_OW 7
// immortalBelkovTeam = true ;
11954: LD_ADDR_EXP 24
11958: PUSH
11959: LD_INT 1
11961: ST_TO_ADDR
// SetAttitude ( 6 , 1 , att_enemy , true ) ;
11962: LD_INT 6
11964: PPUSH
11965: LD_INT 1
11967: PPUSH
11968: LD_INT 2
11970: PPUSH
11971: LD_INT 1
11973: PPUSH
11974: CALL_OW 80
// ComMoveXY ( belkovTeam , 107 , 5 ) ;
11978: LD_EXP 73
11982: PPUSH
11983: LD_INT 107
11985: PPUSH
11986: LD_INT 5
11988: PPUSH
11989: CALL_OW 111
// ComMoveXY ( kirovVehicle , 107 , 5 ) ;
11993: LD_EXP 72
11997: PPUSH
11998: LD_INT 107
12000: PPUSH
12001: LD_INT 5
12003: PPUSH
12004: CALL_OW 111
// wait ( 0 0$2 ) ;
12008: LD_INT 70
12010: PPUSH
12011: CALL_OW 67
// ComMoveXY ( belkovTeam , 101 , 19 ) ;
12015: LD_EXP 73
12019: PPUSH
12020: LD_INT 101
12022: PPUSH
12023: LD_INT 19
12025: PPUSH
12026: CALL_OW 111
// ComMoveXY ( kirovVehicle , 101 , 19 ) ;
12030: LD_EXP 72
12034: PPUSH
12035: LD_INT 101
12037: PPUSH
12038: LD_INT 19
12040: PPUSH
12041: CALL_OW 111
// wait ( 0 0$2 ) ;
12045: LD_INT 70
12047: PPUSH
12048: CALL_OW 67
// immortalVehLive = 400 ;
12052: LD_ADDR_EXP 25
12056: PUSH
12057: LD_INT 400
12059: ST_TO_ADDR
// SetLives ( kirovVehicle , 500 ) ;
12060: LD_EXP 72
12064: PPUSH
12065: LD_INT 500
12067: PPUSH
12068: CALL_OW 234
// wait ( 0 0$3 ) ;
12072: LD_INT 105
12074: PPUSH
12075: CALL_OW 67
// ComExitVehicle ( tmpBelkov ) ;
12079: LD_VAR 0 1
12083: PPUSH
12084: CALL_OW 121
// wait ( 0 0$1 ) ;
12088: LD_INT 35
12090: PPUSH
12091: CALL_OW 67
// ComEnterUnit ( trapCommander , kirovVehicle ) ;
12095: LD_EXP 80
12099: PPUSH
12100: LD_EXP 72
12104: PPUSH
12105: CALL_OW 120
// AddComHold ( trapTeam ) ;
12109: LD_EXP 81
12113: PPUSH
12114: CALL_OW 200
// ComMoveXY ( belkovTeam , 88 , 18 ) ;
12118: LD_EXP 73
12122: PPUSH
12123: LD_INT 88
12125: PPUSH
12126: LD_INT 18
12128: PPUSH
12129: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
12133: LD_INT 35
12135: PPUSH
12136: CALL_OW 67
// CenterNowOnUnits ( tmpBelkov ) ;
12140: LD_VAR 0 1
12144: PPUSH
12145: CALL_OW 87
// until IsInArea ( tmpBelkov , BelkovRetreatArea ) ;
12149: LD_VAR 0 1
12153: PPUSH
12154: LD_INT 15
12156: PPUSH
12157: CALL_OW 308
12161: IFFALSE 12133
// amVeh = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
12163: LD_ADDR_EXP 88
12167: PUSH
12168: LD_INT 22
12170: PUSH
12171: LD_INT 1
12173: PUSH
12174: EMPTY
12175: LIST
12176: LIST
12177: PUSH
12178: LD_INT 21
12180: PUSH
12181: LD_INT 2
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PPUSH
12192: CALL_OW 69
12196: PUSH
12197: LD_INT 1
12199: ARRAY
12200: ST_TO_ADDR
// ComMoveXY ( FilterUnitsInArea ( NearHillArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) , 113 , 29 ) ;
12201: LD_INT 28
12203: PPUSH
12204: LD_INT 22
12206: PUSH
12207: LD_INT 1
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: PUSH
12214: LD_INT 21
12216: PUSH
12217: LD_INT 1
12219: PUSH
12220: EMPTY
12221: LIST
12222: LIST
12223: PUSH
12224: EMPTY
12225: LIST
12226: LIST
12227: PPUSH
12228: CALL_OW 70
12232: PPUSH
12233: LD_INT 113
12235: PPUSH
12236: LD_INT 29
12238: PPUSH
12239: CALL_OW 111
// ComMoveXY ( amVeh , 118 , 25 ) ;
12243: LD_EXP 88
12247: PPUSH
12248: LD_INT 118
12250: PPUSH
12251: LD_INT 25
12253: PPUSH
12254: CALL_OW 111
// SayRadio ( tmpBelkov , D14-Bel-1a ) ;
12258: LD_VAR 0 1
12262: PPUSH
12263: LD_STRING D14-Bel-1a
12265: PPUSH
12266: CALL_OW 94
// SayRadio ( Kurin , D14-Kur-1 ) ;
12270: LD_EXP 67
12274: PPUSH
12275: LD_STRING D14-Kur-1
12277: PPUSH
12278: CALL_OW 94
// SayRadio ( tmpBelkov , D14-Bel-2 ) ;
12282: LD_VAR 0 1
12286: PPUSH
12287: LD_STRING D14-Bel-2
12289: PPUSH
12290: CALL_OW 94
// SayRadio ( Kurin , D14-Kur-2 ) ;
12294: LD_EXP 67
12298: PPUSH
12299: LD_STRING D14-Kur-2
12301: PPUSH
12302: CALL_OW 94
// CenterOnUnits ( Platonov ) ;
12306: LD_EXP 76
12310: PPUSH
12311: CALL_OW 85
// wait ( 0 0$2 ) ;
12315: LD_INT 70
12317: PPUSH
12318: CALL_OW 67
// Say ( Burlak , D14a-Bur-1 ) ;
12322: LD_EXP 62
12326: PPUSH
12327: LD_STRING D14a-Bur-1
12329: PPUSH
12330: CALL_OW 88
// Say ( Platonov , D14a-Pla-1 ) ;
12334: LD_EXP 76
12338: PPUSH
12339: LD_STRING D14a-Pla-1
12341: PPUSH
12342: CALL_OW 88
// Say ( Burlak , D14a-Bur-2 ) ;
12346: LD_EXP 62
12350: PPUSH
12351: LD_STRING D14a-Bur-2
12353: PPUSH
12354: CALL_OW 88
// Say ( Platonov , D14a-Pla-2 ) ;
12358: LD_EXP 76
12362: PPUSH
12363: LD_STRING D14a-Pla-2
12365: PPUSH
12366: CALL_OW 88
// Say ( Burlak , D14a-Bur-3 ) ;
12370: LD_EXP 62
12374: PPUSH
12375: LD_STRING D14a-Bur-3
12377: PPUSH
12378: CALL_OW 88
// Say ( Platonov , D14a-Pla-3 ) ;
12382: LD_EXP 76
12386: PPUSH
12387: LD_STRING D14a-Pla-3
12389: PPUSH
12390: CALL_OW 88
// Say ( Burlak , D14a-Bur-4 ) ;
12394: LD_EXP 62
12398: PPUSH
12399: LD_STRING D14a-Bur-4
12401: PPUSH
12402: CALL_OW 88
// Say ( Platonov , D14a-Pla-4 ) ;
12406: LD_EXP 76
12410: PPUSH
12411: LD_STRING D14a-Pla-4
12413: PPUSH
12414: CALL_OW 88
// InGameOff ;
12418: CALL_OW 9
// immortalBelkovTeam = false ;
12422: LD_ADDR_EXP 24
12426: PUSH
12427: LD_INT 0
12429: ST_TO_ADDR
// activateAMAI = true ;
12430: LD_ADDR_EXP 27
12434: PUSH
12435: LD_INT 1
12437: ST_TO_ADDR
// canExitBase = true ;
12438: LD_ADDR_EXP 19
12442: PUSH
12443: LD_INT 1
12445: ST_TO_ADDR
// canExploreMap = true ;
12446: LD_ADDR_EXP 20
12450: PUSH
12451: LD_INT 1
12453: ST_TO_ADDR
// construcMoreVehicles = false ;
12454: LD_ADDR_EXP 17
12458: PUSH
12459: LD_INT 0
12461: ST_TO_ADDR
// activateBelkovAI = true ;
12462: LD_ADDR_EXP 28
12466: PUSH
12467: LD_INT 1
12469: ST_TO_ADDR
// ChangeMissionObjectives ( M6 ) ;
12470: LD_STRING M6
12472: PPUSH
12473: CALL_OW 337
// music_class = 0 ;
12477: LD_ADDR_OWVAR 72
12481: PUSH
12482: LD_INT 0
12484: ST_TO_ADDR
// ComFree ( trapTeam ) ;
12485: LD_EXP 81
12489: PPUSH
12490: CALL_OW 139
// end ;
12494: PPOPN 2
12496: END
// every 0 0$1 trigger GetDistUnitXY ( amVeh , 118 , 25 ) < 6 do
12497: LD_EXP 88
12501: PPUSH
12502: LD_INT 118
12504: PPUSH
12505: LD_INT 25
12507: PPUSH
12508: CALL_OW 297
12512: PUSH
12513: LD_INT 6
12515: LESS
12516: IFFALSE 12611
12518: GO 12520
12520: DISABLE
// begin ComExitVehicle ( trapCommander ) ;
12521: LD_EXP 80
12525: PPUSH
12526: CALL_OW 121
// uc_side = 1 ;
12530: LD_ADDR_OWVAR 20
12534: PUSH
12535: LD_INT 1
12537: ST_TO_ADDR
// uc_nation = 1 ;
12538: LD_ADDR_OWVAR 21
12542: PUSH
12543: LD_INT 1
12545: ST_TO_ADDR
// PrepareMechanic ( 0 , enemySkillLevel ) ;
12546: LD_INT 0
12548: PPUSH
12549: LD_EXP 59
12553: PPUSH
12554: CALL_OW 383
// amMech = CreateHuman ;
12558: LD_ADDR_EXP 89
12562: PUSH
12563: CALL_OW 44
12567: ST_TO_ADDR
// PlaceUnitArea ( amMech , AmMechSpawnArea , false ) ;
12568: LD_EXP 89
12572: PPUSH
12573: LD_INT 27
12575: PPUSH
12576: LD_INT 0
12578: PPUSH
12579: CALL_OW 49
// ComRepairVehicle ( amMech , amVeh ) ;
12583: LD_EXP 89
12587: PPUSH
12588: LD_EXP 88
12592: PPUSH
12593: CALL_OW 129
// AddComEnterUnit ( amMech , amVeh ) ;
12597: LD_EXP 89
12601: PPUSH
12602: LD_EXP 88
12606: PPUSH
12607: CALL_OW 180
// end ;
12611: END
// every 0 0$1 trigger IsOK ( amMech ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) do var nearUnit ;
12612: LD_EXP 89
12616: PPUSH
12617: CALL_OW 302
12621: PUSH
12622: LD_INT 22
12624: PUSH
12625: LD_INT 1
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 21
12634: PUSH
12635: LD_INT 2
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: LD_INT 50
12644: PUSH
12645: EMPTY
12646: LIST
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: LIST
12652: PPUSH
12653: CALL_OW 69
12657: AND
12658: IFFALSE 12911
12660: GO 12662
12662: DISABLE
12663: LD_INT 0
12665: PPUSH
// begin enable ;
12666: ENABLE
// nearUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) , amMech ) ;
12667: LD_ADDR_VAR 0 1
12671: PUSH
12672: LD_INT 22
12674: PUSH
12675: LD_INT 3
12677: PUSH
12678: EMPTY
12679: LIST
12680: LIST
12681: PUSH
12682: LD_INT 2
12684: PUSH
12685: LD_INT 21
12687: PUSH
12688: LD_INT 1
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: PUSH
12695: LD_INT 21
12697: PUSH
12698: LD_INT 2
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: PUSH
12705: EMPTY
12706: LIST
12707: LIST
12708: LIST
12709: PUSH
12710: EMPTY
12711: LIST
12712: LIST
12713: PPUSH
12714: CALL_OW 69
12718: PPUSH
12719: LD_EXP 89
12723: PPUSH
12724: CALL_OW 74
12728: ST_TO_ADDR
// if GetDistUnits ( nearUnit , amMech ) < 13 then
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_EXP 89
12738: PPUSH
12739: CALL_OW 296
12743: PUSH
12744: LD_INT 13
12746: LESS
12747: IFFALSE 12800
// ComEnterUnit ( amMech , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) [ 1 ] ) else
12749: LD_EXP 89
12753: PPUSH
12754: LD_INT 22
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: LD_INT 21
12766: PUSH
12767: LD_INT 2
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PUSH
12774: LD_INT 50
12776: PUSH
12777: EMPTY
12778: LIST
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: PPUSH
12785: CALL_OW 69
12789: PUSH
12790: LD_INT 1
12792: ARRAY
12793: PPUSH
12794: CALL_OW 120
12798: GO 12911
// begin if GetLives ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) [ 1 ] ) = 1000 and not IsInUnit ( amMech ) then
12800: LD_INT 22
12802: PUSH
12803: LD_INT 1
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 21
12812: PUSH
12813: LD_INT 2
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PUSH
12820: LD_INT 50
12822: PUSH
12823: EMPTY
12824: LIST
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: LIST
12830: PPUSH
12831: CALL_OW 69
12835: PUSH
12836: LD_INT 1
12838: ARRAY
12839: PPUSH
12840: CALL_OW 256
12844: PUSH
12845: LD_INT 1000
12847: EQUAL
12848: PUSH
12849: LD_EXP 89
12853: PPUSH
12854: CALL_OW 310
12858: NOT
12859: AND
12860: IFFALSE 12911
// ComEnterUnit ( amMech , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) [ 1 ] ) ;
12862: LD_EXP 89
12866: PPUSH
12867: LD_INT 22
12869: PUSH
12870: LD_INT 1
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: PUSH
12877: LD_INT 21
12879: PUSH
12880: LD_INT 2
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: PUSH
12887: LD_INT 50
12889: PUSH
12890: EMPTY
12891: LIST
12892: PUSH
12893: EMPTY
12894: LIST
12895: LIST
12896: LIST
12897: PPUSH
12898: CALL_OW 69
12902: PUSH
12903: LD_INT 1
12905: ARRAY
12906: PPUSH
12907: CALL_OW 120
// end ; end ;
12911: PPOPN 1
12913: END
// every 0 0$1 trigger immortalBelkovTeam do
12914: LD_EXP 24
12918: IFFALSE 13005
12920: GO 12922
12922: DISABLE
// begin enable ;
12923: ENABLE
// SetLives ( UnitFilter ( belkovTeam , [ f_type , unit_human ] ) , 1000 ) ;
12924: LD_EXP 73
12928: PPUSH
12929: LD_INT 21
12931: PUSH
12932: LD_INT 1
12934: PUSH
12935: EMPTY
12936: LIST
12937: LIST
12938: PPUSH
12939: CALL_OW 72
12943: PPUSH
12944: LD_INT 1000
12946: PPUSH
12947: CALL_OW 234
// if UnitFilter ( belkovTeam , [ f_type , unit_vehicle ] ) then
12951: LD_EXP 73
12955: PPUSH
12956: LD_INT 21
12958: PUSH
12959: LD_INT 2
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PPUSH
12966: CALL_OW 72
12970: IFFALSE 13005
// SetLives ( UnitFilter ( belkovTeam , [ f_type , unit_vehicle ] ) [ 1 ] , immortalVehLive ) ;
12972: LD_EXP 73
12976: PPUSH
12977: LD_INT 21
12979: PUSH
12980: LD_INT 2
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PPUSH
12987: CALL_OW 72
12991: PUSH
12992: LD_INT 1
12994: ARRAY
12995: PPUSH
12996: LD_EXP 25
13000: PPUSH
13001: CALL_OW 234
// end ;
13005: END
// every 0 0$1 trigger canExploreMap and not belkovSaved and belkovAttackTime > 0 0$00 do
13006: LD_EXP 20
13010: PUSH
13011: LD_EXP 37
13015: NOT
13016: AND
13017: PUSH
13018: LD_EXP 61
13022: PUSH
13023: LD_INT 0
13025: GREATER
13026: AND
13027: IFFALSE 13047
13029: GO 13031
13031: DISABLE
// begin enable ;
13032: ENABLE
// belkovAttackTime = belkovAttackTime - 0 0$01 ;
13033: LD_ADDR_EXP 61
13037: PUSH
13038: LD_EXP 61
13042: PUSH
13043: LD_INT 35
13045: MINUS
13046: ST_TO_ADDR
// end ;
13047: END
// every 0 0$15 trigger canExploreMap do var i , tmp ;
13048: LD_EXP 20
13052: IFFALSE 13136
13054: GO 13056
13056: DISABLE
13057: LD_INT 0
13059: PPUSH
13060: PPUSH
// begin tmp = trapTeam ;
13061: LD_ADDR_VAR 0 2
13065: PUSH
13066: LD_EXP 81
13070: ST_TO_ADDR
// tmp = tmp diff trapCommander ;
13071: LD_ADDR_VAR 0 2
13075: PUSH
13076: LD_VAR 0 2
13080: PUSH
13081: LD_EXP 80
13085: DIFF
13086: ST_TO_ADDR
// for i := 1 to rand ( 2 , 3 ) do
13087: LD_ADDR_VAR 0 1
13091: PUSH
13092: DOUBLE
13093: LD_INT 1
13095: DEC
13096: ST_TO_ADDR
13097: LD_INT 2
13099: PPUSH
13100: LD_INT 3
13102: PPUSH
13103: CALL_OW 12
13107: PUSH
13108: FOR_TO
13109: IFFALSE 13134
// ComAgressiveMove ( tmp [ i ] , 87 , 18 ) ;
13111: LD_VAR 0 2
13115: PUSH
13116: LD_VAR 0 1
13120: ARRAY
13121: PPUSH
13122: LD_INT 87
13124: PPUSH
13125: LD_INT 18
13127: PPUSH
13128: CALL_OW 114
13132: GO 13108
13134: POP
13135: POP
// end ;
13136: PPOPN 2
13138: END
// every 0 0$1 trigger belkovAttackTime < 0 0$02 and trapTeam do
13139: LD_EXP 61
13143: PUSH
13144: LD_INT 70
13146: LESS
13147: PUSH
13148: LD_EXP 81
13152: AND
13153: IFFALSE 13182
13155: GO 13157
13157: DISABLE
// begin enable ;
13158: ENABLE
// activateBelkovAI = false ;
13159: LD_ADDR_EXP 28
13163: PUSH
13164: LD_INT 0
13166: ST_TO_ADDR
// ComAgressiveMove ( belkovTeam , 120 , 28 ) ;
13167: LD_EXP 73
13171: PPUSH
13172: LD_INT 120
13174: PPUSH
13175: LD_INT 28
13177: PPUSH
13178: CALL_OW 114
// end ;
13182: END
// every 0 0$1 trigger ( not sawLeftBunker or not sawRightBunker ) and canExploreMap do var bunker ;
13183: LD_EXP 29
13187: NOT
13188: PUSH
13189: LD_EXP 30
13193: NOT
13194: OR
13195: PUSH
13196: LD_EXP 20
13200: AND
13201: IFFALSE 13663
13203: GO 13205
13205: DISABLE
13206: LD_INT 0
13208: PPUSH
// begin enable ;
13209: ENABLE
// for bunker in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] ] ) do
13210: LD_ADDR_VAR 0 1
13214: PUSH
13215: LD_INT 22
13217: PUSH
13218: LD_INT 1
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: LD_INT 21
13227: PUSH
13228: LD_INT 3
13230: PUSH
13231: EMPTY
13232: LIST
13233: LIST
13234: PUSH
13235: LD_INT 30
13237: PUSH
13238: LD_INT 31
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: PUSH
13245: EMPTY
13246: LIST
13247: LIST
13248: LIST
13249: PPUSH
13250: CALL_OW 69
13254: PUSH
13255: FOR_IN
13256: IFFALSE 13661
// begin if See ( 3 , bunker ) then
13258: LD_INT 3
13260: PPUSH
13261: LD_VAR 0 1
13265: PPUSH
13266: CALL_OW 292
13270: IFFALSE 13659
// begin if bunker in leftBunkers and not sawLeftBunker and not FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) then
13272: LD_VAR 0 1
13276: PUSH
13277: LD_EXP 82
13281: IN
13282: PUSH
13283: LD_EXP 29
13287: NOT
13288: AND
13289: PUSH
13290: LD_INT 18
13292: PPUSH
13293: LD_INT 22
13295: PUSH
13296: LD_INT 3
13298: PUSH
13299: EMPTY
13300: LIST
13301: LIST
13302: PUSH
13303: EMPTY
13304: LIST
13305: PPUSH
13306: CALL_OW 70
13310: NOT
13311: AND
13312: IFFALSE 13505
// begin sawLeftBunker = true ;
13314: LD_ADDR_EXP 29
13318: PUSH
13319: LD_INT 1
13321: ST_TO_ADDR
// CenterOnUnits ( bunker ) ;
13322: LD_VAR 0 1
13326: PPUSH
13327: CALL_OW 85
// DialogueOn ;
13331: CALL_OW 6
// Say ( Burlak , D15-Bur-1 ) ;
13335: LD_EXP 62
13339: PPUSH
13340: LD_STRING D15-Bur-1
13342: PPUSH
13343: CALL_OW 88
// if IsOK ( Gnyevko ) or IsOK ( Kovalyuk ) then
13347: LD_EXP 63
13351: PPUSH
13352: CALL_OW 302
13356: PUSH
13357: LD_EXP 70
13361: PPUSH
13362: CALL_OW 302
13366: OR
13367: IFFALSE 13462
// begin if IsOK ( Gnyevko ) then
13369: LD_EXP 63
13373: PPUSH
13374: CALL_OW 302
13378: IFFALSE 13392
// Say ( Gnyevko , D15-Gny-1 ) ;
13380: LD_EXP 63
13384: PPUSH
13385: LD_STRING D15-Gny-1
13387: PPUSH
13388: CALL_OW 88
// if IsOK ( Kovalyuk ) then
13392: LD_EXP 70
13396: PPUSH
13397: CALL_OW 302
13401: IFFALSE 13415
// Say ( Kovalyuk , D15-Kov-1 ) ;
13403: LD_EXP 70
13407: PPUSH
13408: LD_STRING D15-Kov-1
13410: PPUSH
13411: CALL_OW 88
// Say ( Burlak , D15-Bur-2 ) ;
13415: LD_EXP 62
13419: PPUSH
13420: LD_STRING D15-Bur-2
13422: PPUSH
13423: CALL_OW 88
// if IsOK ( Kovalyuk ) then
13427: LD_EXP 70
13431: PPUSH
13432: CALL_OW 302
13436: IFFALSE 13450
// Say ( Kovalyuk , D15-Kov-2 ) ;
13438: LD_EXP 70
13442: PPUSH
13443: LD_STRING D15-Kov-2
13445: PPUSH
13446: CALL_OW 88
// Say ( Burlak , D15-Bur-3 ) ;
13450: LD_EXP 62
13454: PPUSH
13455: LD_STRING D15-Bur-3
13457: PPUSH
13458: CALL_OW 88
// end ; DialogueOff ;
13462: CALL_OW 7
// if raportForPlatonov = 2 then
13466: LD_EXP 39
13470: PUSH
13471: LD_INT 2
13473: EQUAL
13474: IFFALSE 13486
// raportForPlatonov = 1 else
13476: LD_ADDR_EXP 39
13480: PUSH
13481: LD_INT 1
13483: ST_TO_ADDR
13484: GO 13494
// raportForPlatonov = 3 ;
13486: LD_ADDR_EXP 39
13490: PUSH
13491: LD_INT 3
13493: ST_TO_ADDR
// ChangeMissionObjectives ( M7 ) ;
13494: LD_STRING M7
13496: PPUSH
13497: CALL_OW 337
// exit ;
13501: POP
13502: POP
13503: GO 13663
// end ; if bunker in rightBunkers and not sawRightBunker then
13505: LD_VAR 0 1
13509: PUSH
13510: LD_EXP 83
13514: IN
13515: PUSH
13516: LD_EXP 30
13520: NOT
13521: AND
13522: IFFALSE 13659
// begin sawRightBunker = true ;
13524: LD_ADDR_EXP 30
13528: PUSH
13529: LD_INT 1
13531: ST_TO_ADDR
// CenterOnUnits ( bunker ) ;
13532: LD_VAR 0 1
13536: PPUSH
13537: CALL_OW 85
// DialogueOn ;
13541: CALL_OW 6
// if IsOK ( Kovalyuk ) then
13545: LD_EXP 70
13549: PPUSH
13550: CALL_OW 302
13554: IFFALSE 13623
// begin if sawLeftBunker then
13556: LD_EXP 29
13560: IFFALSE 13576
// Say ( Kovalyuk , D16-Kov-1a ) else
13562: LD_EXP 70
13566: PPUSH
13567: LD_STRING D16-Kov-1a
13569: PPUSH
13570: CALL_OW 88
13574: GO 13588
// Say ( Kovalyuk , D16-Kov-1 ) ;
13576: LD_EXP 70
13580: PPUSH
13581: LD_STRING D16-Kov-1
13583: PPUSH
13584: CALL_OW 88
// Say ( Burlak , D16-Bur-1 ) ;
13588: LD_EXP 62
13592: PPUSH
13593: LD_STRING D16-Bur-1
13595: PPUSH
13596: CALL_OW 88
// if IsOK ( Gnyevko ) then
13600: LD_EXP 63
13604: PPUSH
13605: CALL_OW 302
13609: IFFALSE 13623
// Say ( Gnyevko , D16-Gny-1 ) ;
13611: LD_EXP 63
13615: PPUSH
13616: LD_STRING D16-Gny-1
13618: PPUSH
13619: CALL_OW 88
// end ; DialogueOff ;
13623: CALL_OW 7
// if raportForPlatonov = 3 then
13627: LD_EXP 39
13631: PUSH
13632: LD_INT 3
13634: EQUAL
13635: IFFALSE 13647
// raportForPlatonov = 1 else
13637: LD_ADDR_EXP 39
13641: PUSH
13642: LD_INT 1
13644: ST_TO_ADDR
13645: GO 13655
// raportForPlatonov = 2 ;
13647: LD_ADDR_EXP 39
13651: PUSH
13652: LD_INT 2
13654: ST_TO_ADDR
// exit ;
13655: POP
13656: POP
13657: GO 13663
// end ; end ; end ;
13659: GO 13255
13661: POP
13662: POP
// end ;
13663: PPOPN 1
13665: END
// every 0 0$2 trigger not dialogAttackRightBunkers and rightBunkers and canExploreMap and ( IsOK ( Kovalyuk ) or IsOK ( Gnyevko ) ) do var unit ;
13666: LD_EXP 32
13670: NOT
13671: PUSH
13672: LD_EXP 83
13676: AND
13677: PUSH
13678: LD_EXP 20
13682: AND
13683: PUSH
13684: LD_EXP 70
13688: PPUSH
13689: CALL_OW 302
13693: PUSH
13694: LD_EXP 63
13698: PPUSH
13699: CALL_OW 302
13703: OR
13704: AND
13705: IFFALSE 13893
13707: GO 13709
13709: DISABLE
13710: LD_INT 0
13712: PPUSH
// begin enable ;
13713: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
13714: LD_ADDR_VAR 0 1
13718: PUSH
13719: LD_INT 22
13721: PUSH
13722: LD_INT 3
13724: PUSH
13725: EMPTY
13726: LIST
13727: LIST
13728: PUSH
13729: LD_INT 2
13731: PUSH
13732: LD_INT 21
13734: PUSH
13735: LD_INT 1
13737: PUSH
13738: EMPTY
13739: LIST
13740: LIST
13741: PUSH
13742: LD_INT 21
13744: PUSH
13745: LD_INT 2
13747: PUSH
13748: EMPTY
13749: LIST
13750: LIST
13751: PUSH
13752: EMPTY
13753: LIST
13754: LIST
13755: LIST
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: PPUSH
13761: CALL_OW 69
13765: PUSH
13766: FOR_IN
13767: IFFALSE 13891
// begin if Attacks ( unit ) = rightBunkers [ 1 ] or Attacks ( unit ) = rightBunkers [ 2 ] then
13769: LD_VAR 0 1
13773: PPUSH
13774: CALL_OW 320
13778: PUSH
13779: LD_EXP 83
13783: PUSH
13784: LD_INT 1
13786: ARRAY
13787: EQUAL
13788: PUSH
13789: LD_VAR 0 1
13793: PPUSH
13794: CALL_OW 320
13798: PUSH
13799: LD_EXP 83
13803: PUSH
13804: LD_INT 2
13806: ARRAY
13807: EQUAL
13808: OR
13809: IFFALSE 13889
// begin dialogAttackRightBunkers = true ;
13811: LD_ADDR_EXP 32
13815: PUSH
13816: LD_INT 1
13818: ST_TO_ADDR
// DialogueOn ;
13819: CALL_OW 6
// if IsOK ( Gnyevko ) then
13823: LD_EXP 63
13827: PPUSH
13828: CALL_OW 302
13832: IFFALSE 13846
// Say ( Gnyevko , D16A-Gny-1 ) ;
13834: LD_EXP 63
13838: PPUSH
13839: LD_STRING D16A-Gny-1
13841: PPUSH
13842: CALL_OW 88
// if IsOK ( Kovalyuk ) then
13846: LD_EXP 70
13850: PPUSH
13851: CALL_OW 302
13855: IFFALSE 13869
// Say ( Kovalyuk , D16A-Kov-1 ) ;
13857: LD_EXP 70
13861: PPUSH
13862: LD_STRING D16A-Kov-1
13864: PPUSH
13865: CALL_OW 88
// Say ( Burlak , D16A-Bur-1 ) ;
13869: LD_EXP 62
13873: PPUSH
13874: LD_STRING D16A-Bur-1
13876: PPUSH
13877: CALL_OW 88
// DialogueOff ;
13881: CALL_OW 7
// exit ;
13885: POP
13886: POP
13887: GO 13893
// end ; end ;
13889: GO 13766
13891: POP
13892: POP
// end ;
13893: PPOPN 1
13895: END
// every 0 0$3 trigger FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) and not sawLeftBunker do var decsToChoose ;
13896: LD_INT 18
13898: PPUSH
13899: LD_INT 22
13901: PUSH
13902: LD_INT 3
13904: PUSH
13905: EMPTY
13906: LIST
13907: LIST
13908: PUSH
13909: EMPTY
13910: LIST
13911: PPUSH
13912: CALL_OW 70
13916: PUSH
13917: LD_EXP 29
13921: NOT
13922: AND
13923: IFFALSE 14306
13925: GO 13927
13927: DISABLE
13928: LD_INT 0
13930: PPUSH
// begin sawLeftBunker = true ;
13931: LD_ADDR_EXP 29
13935: PUSH
13936: LD_INT 1
13938: ST_TO_ADDR
// if playerGetSupport then
13939: LD_EXP 34
13943: IFFALSE 13962
// decsToChoose = [ 1 , 3 ] else
13945: LD_ADDR_VAR 0 1
13949: PUSH
13950: LD_INT 1
13952: PUSH
13953: LD_INT 3
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: ST_TO_ADDR
13960: GO 13981
// decsToChoose = [ 1 , 2 , 3 ] ;
13962: LD_ADDR_VAR 0 1
13966: PUSH
13967: LD_INT 1
13969: PUSH
13970: LD_INT 2
13972: PUSH
13973: LD_INT 3
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: LIST
13980: ST_TO_ADDR
// case SelectiveQuery ( QAttackBw , decsToChoose ) of 1 :
13981: LD_STRING QAttackBw
13983: PPUSH
13984: LD_VAR 0 1
13988: PPUSH
13989: CALL_OW 98
13993: PUSH
13994: LD_INT 1
13996: DOUBLE
13997: EQUAL
13998: IFTRUE 14002
14000: GO 14095
14002: POP
// begin DialogueOn ;
14003: CALL_OW 6
// Say ( Burlak , D17-Bur-1 ) ;
14007: LD_EXP 62
14011: PPUSH
14012: LD_STRING D17-Bur-1
14014: PPUSH
14015: CALL_OW 88
// SayRadio ( Platonov , D17-Pla-1 ) ;
14019: LD_EXP 76
14023: PPUSH
14024: LD_STRING D17-Pla-1
14026: PPUSH
14027: CALL_OW 94
// Say ( Burlak , D17-Bur-2 ) ;
14031: LD_EXP 62
14035: PPUSH
14036: LD_STRING D17-Bur-2
14038: PPUSH
14039: CALL_OW 88
// SayRadio ( Platonov , D17-Pla-2 ) ;
14043: LD_EXP 76
14047: PPUSH
14048: LD_STRING D17-Pla-2
14050: PPUSH
14051: CALL_OW 94
// DialogueOff ;
14055: CALL_OW 7
// if not ( initiative in [ 2 , 3 ] ) then
14059: LD_EXP 42
14063: PUSH
14064: LD_INT 2
14066: PUSH
14067: LD_INT 3
14069: PUSH
14070: EMPTY
14071: LIST
14072: LIST
14073: IN
14074: NOT
14075: IFFALSE 14093
// begin initiative = 1 ;
14077: LD_ADDR_EXP 42
14081: PUSH
14082: LD_INT 1
14084: ST_TO_ADDR
// platonovOpinion = 2 ;
14085: LD_ADDR_EXP 5
14089: PUSH
14090: LD_INT 2
14092: ST_TO_ADDR
// end ; end ; 2 :
14093: GO 14236
14095: LD_INT 2
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14208
14103: POP
// begin DialogueOn ;
14104: CALL_OW 6
// Say ( Burlak , D18-Bur-1 ) ;
14108: LD_EXP 62
14112: PPUSH
14113: LD_STRING D18-Bur-1
14115: PPUSH
14116: CALL_OW 88
// SayRadio ( Platonov , D18-Pla-1 ) ;
14120: LD_EXP 76
14124: PPUSH
14125: LD_STRING D18-Pla-1
14127: PPUSH
14128: CALL_OW 94
// Say ( Burlak , D18-Bur-2 ) ;
14132: LD_EXP 62
14136: PPUSH
14137: LD_STRING D18-Bur-2
14139: PPUSH
14140: CALL_OW 88
// SayRadio ( Platonov , D18-Pla-2 ) ;
14144: LD_EXP 76
14148: PPUSH
14149: LD_STRING D18-Pla-2
14151: PPUSH
14152: CALL_OW 94
// DialogueOff ;
14156: CALL_OW 7
// playerGetSupport = true ;
14160: LD_ADDR_EXP 34
14164: PUSH
14165: LD_INT 1
14167: ST_TO_ADDR
// medalForGetSupport = false ;
14168: LD_ADDR_EXP 40
14172: PUSH
14173: LD_INT 0
14175: ST_TO_ADDR
// PlatonovSendSupport ;
14176: CALL 6522 0 0
// if initiative <> 3 then
14180: LD_EXP 42
14184: PUSH
14185: LD_INT 3
14187: NONEQUAL
14188: IFFALSE 14206
// begin initiative = 1 ;
14190: LD_ADDR_EXP 42
14194: PUSH
14195: LD_INT 1
14197: ST_TO_ADDR
// platonovOpinion = 2 ;
14198: LD_ADDR_EXP 5
14202: PUSH
14203: LD_INT 2
14205: ST_TO_ADDR
// end ; end ; 3 :
14206: GO 14236
14208: LD_INT 3
14210: DOUBLE
14211: EQUAL
14212: IFTRUE 14216
14214: GO 14235
14216: POP
// begin initiative = 3 ;
14217: LD_ADDR_EXP 42
14221: PUSH
14222: LD_INT 3
14224: ST_TO_ADDR
// platonovOpinion = 0 ;
14225: LD_ADDR_EXP 5
14229: PUSH
14230: LD_INT 0
14232: ST_TO_ADDR
// end ; end ;
14233: GO 14236
14235: POP
// if IsOK ( Gnyevko ) then
14236: LD_EXP 63
14240: PPUSH
14241: CALL_OW 302
14245: IFFALSE 14271
// begin Say ( Gnyevko , D19-Gny-1 ) ;
14247: LD_EXP 63
14251: PPUSH
14252: LD_STRING D19-Gny-1
14254: PPUSH
14255: CALL_OW 88
// Say ( Burlak , D19-Bur-1 ) ;
14259: LD_EXP 62
14263: PPUSH
14264: LD_STRING D19-Bur-1
14266: PPUSH
14267: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
14271: LD_EXP 70
14275: PPUSH
14276: CALL_OW 302
14280: IFFALSE 14306
// begin Say ( Kovalyuk , D19-Kov-1 ) ;
14282: LD_EXP 70
14286: PPUSH
14287: LD_STRING D19-Kov-1
14289: PPUSH
14290: CALL_OW 88
// Say ( Burlak , D19-Bur-2 ) ;
14294: LD_EXP 62
14298: PPUSH
14299: LD_STRING D19-Bur-2
14301: PPUSH
14302: CALL_OW 88
// end ; end ;
14306: PPOPN 1
14308: END
// every 0 0$2 trigger not dialogAttackLeftBunkers and leftBunkers and canExploreMap and FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) = 0 and ( IsOK ( Kovalyuk ) or IsOK ( Gnyevko ) ) do var unit ;
14309: LD_EXP 31
14313: NOT
14314: PUSH
14315: LD_EXP 82
14319: AND
14320: PUSH
14321: LD_EXP 20
14325: AND
14326: PUSH
14327: LD_INT 18
14329: PPUSH
14330: LD_INT 22
14332: PUSH
14333: LD_INT 3
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: PUSH
14340: EMPTY
14341: LIST
14342: PPUSH
14343: CALL_OW 70
14347: PUSH
14348: LD_INT 0
14350: EQUAL
14351: AND
14352: PUSH
14353: LD_EXP 70
14357: PPUSH
14358: CALL_OW 302
14362: PUSH
14363: LD_EXP 63
14367: PPUSH
14368: CALL_OW 302
14372: OR
14373: AND
14374: IFFALSE 14562
14376: GO 14378
14378: DISABLE
14379: LD_INT 0
14381: PPUSH
// begin enable ;
14382: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
14383: LD_ADDR_VAR 0 1
14387: PUSH
14388: LD_INT 22
14390: PUSH
14391: LD_INT 3
14393: PUSH
14394: EMPTY
14395: LIST
14396: LIST
14397: PUSH
14398: LD_INT 2
14400: PUSH
14401: LD_INT 21
14403: PUSH
14404: LD_INT 1
14406: PUSH
14407: EMPTY
14408: LIST
14409: LIST
14410: PUSH
14411: LD_INT 21
14413: PUSH
14414: LD_INT 2
14416: PUSH
14417: EMPTY
14418: LIST
14419: LIST
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: LIST
14425: PUSH
14426: EMPTY
14427: LIST
14428: LIST
14429: PPUSH
14430: CALL_OW 69
14434: PUSH
14435: FOR_IN
14436: IFFALSE 14560
// begin if Attacks ( unit ) = leftBunkers [ 1 ] or Attacks ( unit ) = leftBunkers [ 2 ] then
14438: LD_VAR 0 1
14442: PPUSH
14443: CALL_OW 320
14447: PUSH
14448: LD_EXP 82
14452: PUSH
14453: LD_INT 1
14455: ARRAY
14456: EQUAL
14457: PUSH
14458: LD_VAR 0 1
14462: PPUSH
14463: CALL_OW 320
14467: PUSH
14468: LD_EXP 82
14472: PUSH
14473: LD_INT 2
14475: ARRAY
14476: EQUAL
14477: OR
14478: IFFALSE 14558
// begin dialogAttackLeftBunkers = true ;
14480: LD_ADDR_EXP 31
14484: PUSH
14485: LD_INT 1
14487: ST_TO_ADDR
// DialogueOn ;
14488: CALL_OW 6
// if IsOK ( Gnyevko ) then
14492: LD_EXP 63
14496: PPUSH
14497: CALL_OW 302
14501: IFFALSE 14515
// Say ( Gnyevko , D19A-Gny-1 ) ;
14503: LD_EXP 63
14507: PPUSH
14508: LD_STRING D19A-Gny-1
14510: PPUSH
14511: CALL_OW 88
// if IsOK ( Kovalyuk ) then
14515: LD_EXP 70
14519: PPUSH
14520: CALL_OW 302
14524: IFFALSE 14538
// Say ( Kovalyuk , D19A-Kov-1 ) ;
14526: LD_EXP 70
14530: PPUSH
14531: LD_STRING D19A-Kov-1
14533: PPUSH
14534: CALL_OW 88
// Say ( Burlak , D16A-Bur-1 ) ;
14538: LD_EXP 62
14542: PPUSH
14543: LD_STRING D16A-Bur-1
14545: PPUSH
14546: CALL_OW 88
// DialogueOff ;
14550: CALL_OW 7
// exit ;
14554: POP
14555: POP
14556: GO 14562
// end ; end ;
14558: GO 14435
14560: POP
14561: POP
// end ;
14562: PPOPN 1
14564: END
// every 0 0$1 trigger ( not leftBunkers or FilterUnitsInArea ( LeftHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_ok ] ] ) = 0 ) and canExploreMap do
14565: LD_EXP 82
14569: NOT
14570: PUSH
14571: LD_INT 17
14573: PPUSH
14574: LD_INT 22
14576: PUSH
14577: LD_INT 1
14579: PUSH
14580: EMPTY
14581: LIST
14582: LIST
14583: PUSH
14584: LD_INT 21
14586: PUSH
14587: LD_INT 3
14589: PUSH
14590: EMPTY
14591: LIST
14592: LIST
14593: PUSH
14594: LD_INT 30
14596: PUSH
14597: LD_INT 31
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: PUSH
14604: LD_INT 50
14606: PUSH
14607: EMPTY
14608: LIST
14609: PUSH
14610: EMPTY
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: PPUSH
14616: CALL_OW 70
14620: PUSH
14621: LD_INT 0
14623: EQUAL
14624: OR
14625: PUSH
14626: LD_EXP 20
14630: AND
14631: IFFALSE 14682
14633: GO 14635
14635: DISABLE
// begin leftBunkers = [ ] ;
14636: LD_ADDR_EXP 82
14640: PUSH
14641: EMPTY
14642: ST_TO_ADDR
// DialogueOn ;
14643: CALL_OW 6
// Say ( Burlak , D20-Bur-1 ) ;
14647: LD_EXP 62
14651: PPUSH
14652: LD_STRING D20-Bur-1
14654: PPUSH
14655: CALL_OW 88
// Say ( Platonov , D20-Pla-1 ) ;
14659: LD_EXP 76
14663: PPUSH
14664: LD_STRING D20-Pla-1
14666: PPUSH
14667: CALL_OW 88
// DialogueOff ;
14671: CALL_OW 7
// ChangeMissionObjectives ( M8 ) ;
14675: LD_STRING M8
14677: PPUSH
14678: CALL_OW 337
// end ;
14682: END
// every 0 0$1 trigger ( not rightBunkers or FilterUnitsInArea ( rightHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_ok ] ] ) = 0 ) and canExploreMap do
14683: LD_EXP 83
14687: NOT
14688: PUSH
14689: LD_INT 16
14691: PPUSH
14692: LD_INT 22
14694: PUSH
14695: LD_INT 1
14697: PUSH
14698: EMPTY
14699: LIST
14700: LIST
14701: PUSH
14702: LD_INT 21
14704: PUSH
14705: LD_INT 3
14707: PUSH
14708: EMPTY
14709: LIST
14710: LIST
14711: PUSH
14712: LD_INT 30
14714: PUSH
14715: LD_INT 31
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: PUSH
14722: LD_INT 50
14724: PUSH
14725: EMPTY
14726: LIST
14727: PUSH
14728: EMPTY
14729: LIST
14730: LIST
14731: LIST
14732: LIST
14733: PPUSH
14734: CALL_OW 70
14738: PUSH
14739: LD_INT 0
14741: EQUAL
14742: OR
14743: PUSH
14744: LD_EXP 20
14748: AND
14749: IFFALSE 14793
14751: GO 14753
14753: DISABLE
// begin rightBunkers = [ ] ;
14754: LD_ADDR_EXP 83
14758: PUSH
14759: EMPTY
14760: ST_TO_ADDR
// DialogueOn ;
14761: CALL_OW 6
// Say ( Burlak , D20a-Bur-1 ) ;
14765: LD_EXP 62
14769: PPUSH
14770: LD_STRING D20a-Bur-1
14772: PPUSH
14773: CALL_OW 88
// Say ( Platonov , D20a-Pla-1 ) ;
14777: LD_EXP 76
14781: PPUSH
14782: LD_STRING D20a-Pla-1
14784: PPUSH
14785: CALL_OW 88
// DialogueOff ;
14789: CALL_OW 7
// end ;
14793: END
// every 0 0$1 trigger not saveBelkovDecision and belkovTeam do var yourUnit , trapUnit , decsToChoose ;
14794: LD_EXP 35
14798: NOT
14799: PUSH
14800: LD_EXP 73
14804: AND
14805: IFFALSE 15300
14807: GO 14809
14809: DISABLE
14810: LD_INT 0
14812: PPUSH
14813: PPUSH
14814: PPUSH
// begin enable ;
14815: ENABLE
// for yourUnit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
14816: LD_ADDR_VAR 0 1
14820: PUSH
14821: LD_INT 22
14823: PUSH
14824: LD_INT 3
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PUSH
14831: LD_INT 2
14833: PUSH
14834: LD_INT 21
14836: PUSH
14837: LD_INT 1
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: PUSH
14844: LD_INT 21
14846: PUSH
14847: LD_INT 2
14849: PUSH
14850: EMPTY
14851: LIST
14852: LIST
14853: PUSH
14854: EMPTY
14855: LIST
14856: LIST
14857: LIST
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: PPUSH
14863: CALL_OW 69
14867: PUSH
14868: FOR_IN
14869: IFFALSE 15298
// for trapUnit in trapTeam do
14871: LD_ADDR_VAR 0 2
14875: PUSH
14876: LD_EXP 81
14880: PUSH
14881: FOR_IN
14882: IFFALSE 15294
// if GetDistUnits ( yourUnit , trapUnit ) < 16 then
14884: LD_VAR 0 1
14888: PPUSH
14889: LD_VAR 0 2
14893: PPUSH
14894: CALL_OW 296
14898: PUSH
14899: LD_INT 16
14901: LESS
14902: IFFALSE 15292
// begin saveBelkovDecision = true ;
14904: LD_ADDR_EXP 35
14908: PUSH
14909: LD_INT 1
14911: ST_TO_ADDR
// if playerGetSupport then
14912: LD_EXP 34
14916: IFFALSE 14935
// decsToChoose = [ 1 , 3 ] else
14918: LD_ADDR_VAR 0 3
14922: PUSH
14923: LD_INT 1
14925: PUSH
14926: LD_INT 3
14928: PUSH
14929: EMPTY
14930: LIST
14931: LIST
14932: ST_TO_ADDR
14933: GO 14954
// decsToChoose = [ 1 , 2 , 3 ] ;
14935: LD_ADDR_VAR 0 3
14939: PUSH
14940: LD_INT 1
14942: PUSH
14943: LD_INT 2
14945: PUSH
14946: LD_INT 3
14948: PUSH
14949: EMPTY
14950: LIST
14951: LIST
14952: LIST
14953: ST_TO_ADDR
// case SelectiveQuery ( QAttackAm , decsToChoose ) of 1 :
14954: LD_STRING QAttackAm
14956: PPUSH
14957: LD_VAR 0 3
14961: PPUSH
14962: CALL_OW 98
14966: PUSH
14967: LD_INT 1
14969: DOUBLE
14970: EQUAL
14971: IFTRUE 14975
14973: GO 15044
14975: POP
// begin DialogueOn ;
14976: CALL_OW 6
// Say ( Burlak , D21-Bur-1 ) ;
14980: LD_EXP 62
14984: PPUSH
14985: LD_STRING D21-Bur-1
14987: PPUSH
14988: CALL_OW 88
// SayRadio ( Platonov , D21-Pla-1 ) ;
14992: LD_EXP 76
14996: PPUSH
14997: LD_STRING D21-Pla-1
14999: PPUSH
15000: CALL_OW 94
// DialogueOff ;
15004: CALL_OW 7
// if not ( initiative in [ 2 , 3 ] ) then
15008: LD_EXP 42
15012: PUSH
15013: LD_INT 2
15015: PUSH
15016: LD_INT 3
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: IN
15023: NOT
15024: IFFALSE 15042
// begin initiative = 1 ;
15026: LD_ADDR_EXP 42
15030: PUSH
15031: LD_INT 1
15033: ST_TO_ADDR
// platonovOpinion = 2 ;
15034: LD_ADDR_EXP 5
15038: PUSH
15039: LD_INT 2
15041: ST_TO_ADDR
// end ; end ; 2 :
15042: GO 15236
15044: LD_INT 2
15046: DOUBLE
15047: EQUAL
15048: IFTRUE 15052
15050: GO 15208
15052: POP
// begin DialogueOn ;
15053: CALL_OW 6
// Say ( Burlak , D22-Bur-1 ) ;
15057: LD_EXP 62
15061: PPUSH
15062: LD_STRING D22-Bur-1
15064: PPUSH
15065: CALL_OW 88
// if playerGetSupport and ( leftBunkers = 0 or rightBunkers = 0 ) then
15069: LD_EXP 34
15073: PUSH
15074: LD_EXP 82
15078: PUSH
15079: LD_INT 0
15081: EQUAL
15082: PUSH
15083: LD_EXP 83
15087: PUSH
15088: LD_INT 0
15090: EQUAL
15091: OR
15092: AND
15093: IFFALSE 15107
// Say ( Platonov , D22-Pla-1b ) ;
15095: LD_EXP 76
15099: PPUSH
15100: LD_STRING D22-Pla-1b
15102: PPUSH
15103: CALL_OW 88
// if playerGetSupport and ( leftBunkers or rightBunkers ) then
15107: LD_EXP 34
15111: PUSH
15112: LD_EXP 82
15116: PUSH
15117: LD_EXP 83
15121: OR
15122: AND
15123: IFFALSE 15137
// Say ( Platonov , D22-Pla-1a ) ;
15125: LD_EXP 76
15129: PPUSH
15130: LD_STRING D22-Pla-1a
15132: PPUSH
15133: CALL_OW 88
// if not playerGetSupport then
15137: LD_EXP 34
15141: NOT
15142: IFFALSE 15176
// begin Say ( Platonov , D22-Pla-1 ) ;
15144: LD_EXP 76
15148: PPUSH
15149: LD_STRING D22-Pla-1
15151: PPUSH
15152: CALL_OW 88
// playerGetSupport = true ;
15156: LD_ADDR_EXP 34
15160: PUSH
15161: LD_INT 1
15163: ST_TO_ADDR
// medalForGetSupport = false ;
15164: LD_ADDR_EXP 40
15168: PUSH
15169: LD_INT 0
15171: ST_TO_ADDR
// PlatonovSendSupport ;
15172: CALL 6522 0 0
// end ; DialogueOff ;
15176: CALL_OW 7
// if initiative <> 3 then
15180: LD_EXP 42
15184: PUSH
15185: LD_INT 3
15187: NONEQUAL
15188: IFFALSE 15206
// begin initiative = 2 ;
15190: LD_ADDR_EXP 42
15194: PUSH
15195: LD_INT 2
15197: ST_TO_ADDR
// platonovOpinion = 1 ;
15198: LD_ADDR_EXP 5
15202: PUSH
15203: LD_INT 1
15205: ST_TO_ADDR
// end ; end ; 3 :
15206: GO 15236
15208: LD_INT 3
15210: DOUBLE
15211: EQUAL
15212: IFTRUE 15216
15214: GO 15235
15216: POP
// begin initiative = 3 ;
15217: LD_ADDR_EXP 42
15221: PUSH
15222: LD_INT 3
15224: ST_TO_ADDR
// platonovOpinion = 0 ;
15225: LD_ADDR_EXP 5
15229: PUSH
15230: LD_INT 0
15232: ST_TO_ADDR
// end ; end ;
15233: GO 15236
15235: POP
// if IsOK ( Gnyevko ) then
15236: LD_EXP 63
15240: PPUSH
15241: CALL_OW 302
15245: IFFALSE 15271
// begin Say ( Gnyevko , D23-Gny-1 ) ;
15247: LD_EXP 63
15251: PPUSH
15252: LD_STRING D23-Gny-1
15254: PPUSH
15255: CALL_OW 88
// Say ( Burlak , D23-Bur-1 ) ;
15259: LD_EXP 62
15263: PPUSH
15264: LD_STRING D23-Bur-1
15266: PPUSH
15267: CALL_OW 88
// end ; saveBelkovObjective = true ;
15271: LD_ADDR_EXP 36
15275: PUSH
15276: LD_INT 1
15278: ST_TO_ADDR
// ChangeMissionObjectives ( M9 ) ;
15279: LD_STRING M9
15281: PPUSH
15282: CALL_OW 337
// exit ;
15286: POP
15287: POP
15288: POP
15289: POP
15290: GO 15300
// end ;
15292: GO 14881
15294: POP
15295: POP
15296: GO 14868
15298: POP
15299: POP
// end ;
15300: PPOPN 3
15302: END
// every 0 0$1 trigger canExploreMap and not trapTeam and not belkovSaved do
15303: LD_EXP 20
15307: PUSH
15308: LD_EXP 81
15312: NOT
15313: AND
15314: PUSH
15315: LD_EXP 37
15319: NOT
15320: AND
15321: IFFALSE 15361
15323: GO 15325
15325: DISABLE
// begin belkovSaved = true ;
15326: LD_ADDR_EXP 37
15330: PUSH
15331: LD_INT 1
15333: ST_TO_ADDR
// activateBelkovAI = false ;
15334: LD_ADDR_EXP 28
15338: PUSH
15339: LD_INT 0
15341: ST_TO_ADDR
// SetSide ( belkovTeam , 3 ) ;
15342: LD_EXP 73
15346: PPUSH
15347: LD_INT 3
15349: PPUSH
15350: CALL_OW 235
// ChangeMissionObjectives ( M9a ) ;
15354: LD_STRING M9a
15356: PPUSH
15357: CALL_OW 337
// end ;
15361: END
// every 0 0$1 trigger saveBelkovDecision and ( IsDead ( Belkov ) or IsDead ( Belkov2 ) and ( GetSide ( Belkov ) = 6 or GetSide ( Belkov2 ) = 6 ) ) do
15362: LD_EXP 35
15366: PUSH
15367: LD_EXP 64
15371: PPUSH
15372: CALL_OW 301
15376: PUSH
15377: LD_EXP 68
15381: PPUSH
15382: CALL_OW 301
15386: PUSH
15387: LD_EXP 64
15391: PPUSH
15392: CALL_OW 255
15396: PUSH
15397: LD_INT 6
15399: EQUAL
15400: PUSH
15401: LD_EXP 68
15405: PPUSH
15406: CALL_OW 255
15410: PUSH
15411: LD_INT 6
15413: EQUAL
15414: OR
15415: AND
15416: OR
15417: AND
15418: IFFALSE 15438
15420: GO 15422
15422: DISABLE
// begin ChangeMissionObjectives ( M9a ) ;
15423: LD_STRING M9a
15425: PPUSH
15426: CALL_OW 337
// saveBelkovObjective = false ;
15430: LD_ADDR_EXP 36
15434: PUSH
15435: LD_INT 0
15437: ST_TO_ADDR
// end ;
15438: END
// every 0 0$5 trigger belkovSaved and ( ( GetDistUnits ( Burlak , Belkov ) < 14 and belkovReturn ) or ( GetDistUnits ( Burlak , Belkov2 ) < 14 and not belkovReturn ) ) do
15439: LD_EXP 37
15443: PUSH
15444: LD_EXP 62
15448: PPUSH
15449: LD_EXP 64
15453: PPUSH
15454: CALL_OW 296
15458: PUSH
15459: LD_INT 14
15461: LESS
15462: PUSH
15463: LD_EXP 6
15467: AND
15468: PUSH
15469: LD_EXP 62
15473: PPUSH
15474: LD_EXP 68
15478: PPUSH
15479: CALL_OW 296
15483: PUSH
15484: LD_INT 14
15486: LESS
15487: PUSH
15488: LD_EXP 6
15492: NOT
15493: AND
15494: OR
15495: AND
15496: IFFALSE 15792
15498: GO 15500
15500: DISABLE
// begin InGameOn ;
15501: CALL_OW 8
// if IsOk ( Belkov ) and belkovReturn then
15505: LD_EXP 64
15509: PPUSH
15510: CALL_OW 302
15514: PUSH
15515: LD_EXP 6
15519: AND
15520: IFFALSE 15616
// begin CenterNowOnUnits ( [ Burlak , Belkov ] ) ;
15522: LD_EXP 62
15526: PUSH
15527: LD_EXP 64
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: PPUSH
15536: CALL_OW 87
// ComTurnUnit ( Burlak , Belkov ) ;
15540: LD_EXP 62
15544: PPUSH
15545: LD_EXP 64
15549: PPUSH
15550: CALL_OW 119
// ComTurnUnit ( Belkov , Burlak ) ;
15554: LD_EXP 64
15558: PPUSH
15559: LD_EXP 62
15563: PPUSH
15564: CALL_OW 119
// Say ( Belkov , D24-Bel-1 ) ;
15568: LD_EXP 64
15572: PPUSH
15573: LD_STRING D24-Bel-1
15575: PPUSH
15576: CALL_OW 88
// Say ( Burlak , D24-Bur-1 ) ;
15580: LD_EXP 62
15584: PPUSH
15585: LD_STRING D24-Bur-1
15587: PPUSH
15588: CALL_OW 88
// Say ( Belkov , D24-Bel-2 ) ;
15592: LD_EXP 64
15596: PPUSH
15597: LD_STRING D24-Bel-2
15599: PPUSH
15600: CALL_OW 88
// Say ( Burlak , D24-Bur-2 ) ;
15604: LD_EXP 62
15608: PPUSH
15609: LD_STRING D24-Bur-2
15611: PPUSH
15612: CALL_OW 88
// end ; if IsOk ( Belkov2 ) and not belkovReturn then
15616: LD_EXP 68
15620: PPUSH
15621: CALL_OW 302
15625: PUSH
15626: LD_EXP 6
15630: NOT
15631: AND
15632: IFFALSE 15740
// begin CenterNowOnUnits ( [ Burlak , Belkov2 ] ) ;
15634: LD_EXP 62
15638: PUSH
15639: LD_EXP 68
15643: PUSH
15644: EMPTY
15645: LIST
15646: LIST
15647: PPUSH
15648: CALL_OW 87
// ComTurnUnit ( Burlak , Belkov2 ) ;
15652: LD_EXP 62
15656: PPUSH
15657: LD_EXP 68
15661: PPUSH
15662: CALL_OW 119
// ComTurnUnit ( Belkov2 , Burlak ) ;
15666: LD_EXP 68
15670: PPUSH
15671: LD_EXP 62
15675: PPUSH
15676: CALL_OW 119
// Say ( Belkov2 , D24-Bel-1 ) ;
15680: LD_EXP 68
15684: PPUSH
15685: LD_STRING D24-Bel-1
15687: PPUSH
15688: CALL_OW 88
// Say ( Burlak , D24-Bur-1 ) ;
15692: LD_EXP 62
15696: PPUSH
15697: LD_STRING D24-Bur-1
15699: PPUSH
15700: CALL_OW 88
// Say ( Burlak , D24-Bur-1a ) ;
15704: LD_EXP 62
15708: PPUSH
15709: LD_STRING D24-Bur-1a
15711: PPUSH
15712: CALL_OW 88
// Say ( Belkov2 , D24-Bel-2 ) ;
15716: LD_EXP 68
15720: PPUSH
15721: LD_STRING D24-Bel-2
15723: PPUSH
15724: CALL_OW 88
// Say ( Burlak , D24-Bur-2 ) ;
15728: LD_EXP 62
15732: PPUSH
15733: LD_STRING D24-Bur-2
15735: PPUSH
15736: CALL_OW 88
// end ; if captureBelkovVehicle then
15740: LD_EXP 38
15744: IFFALSE 15758
// Say ( Burlak , D24-Bur-2a ) ;
15746: LD_EXP 62
15750: PPUSH
15751: LD_STRING D24-Bur-2a
15753: PPUSH
15754: CALL_OW 88
// SayRadio ( Platonov , D24-Pla-2 ) ;
15758: LD_EXP 76
15762: PPUSH
15763: LD_STRING D24-Pla-2
15765: PPUSH
15766: CALL_OW 94
// if leftBunkers then
15770: LD_EXP 82
15774: IFFALSE 15788
// SayRadio ( Platonov , D24-Pla-2a ) ;
15776: LD_EXP 76
15780: PPUSH
15781: LD_STRING D24-Pla-2a
15783: PPUSH
15784: CALL_OW 94
// InGameOff ;
15788: CALL_OW 9
// end ;
15792: END
// every 0 0$1 trigger FilterUnitsInArea ( TrackDialogArea , [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) and ( IsOk ( Kovalyuk ) or IsOK ( Gnyevko ) ) do
15793: LD_INT 22
15795: PPUSH
15796: LD_INT 22
15798: PUSH
15799: LD_INT 3
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PUSH
15806: LD_INT 21
15808: PUSH
15809: LD_INT 2
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PUSH
15816: EMPTY
15817: LIST
15818: LIST
15819: PPUSH
15820: CALL_OW 70
15824: PUSH
15825: LD_EXP 70
15829: PPUSH
15830: CALL_OW 302
15834: PUSH
15835: LD_EXP 63
15839: PPUSH
15840: CALL_OW 302
15844: OR
15845: AND
15846: IFFALSE 15929
15848: GO 15850
15850: DISABLE
// begin DialogueOn ;
15851: CALL_OW 6
// Say ( Burlak , D26-Bur-1 ) ;
15855: LD_EXP 62
15859: PPUSH
15860: LD_STRING D26-Bur-1
15862: PPUSH
15863: CALL_OW 88
// if IsOk ( Kovalyuk ) then
15867: LD_EXP 70
15871: PPUSH
15872: CALL_OW 302
15876: IFFALSE 15890
// Say ( Kovalyuk , D26-Kov-1 ) ;
15878: LD_EXP 70
15882: PPUSH
15883: LD_STRING D26-Kov-1
15885: PPUSH
15886: CALL_OW 88
// if IsOk ( Gnyevko ) then
15890: LD_EXP 63
15894: PPUSH
15895: CALL_OW 302
15899: IFFALSE 15913
// Say ( Gnyevko , D26-Gny-1 ) ;
15901: LD_EXP 63
15905: PPUSH
15906: LD_STRING D26-Gny-1
15908: PPUSH
15909: CALL_OW 88
// Say ( Burlak , D26-Bur-2 ) ;
15913: LD_EXP 62
15917: PPUSH
15918: LD_STRING D26-Bur-2
15920: PPUSH
15921: CALL_OW 88
// DialogueOff ;
15925: CALL_OW 7
// end ;
15929: END
// every 0 0$1 trigger canExploreMap and ( not IsInArea ( Burlak , BeriaBaseArea ) and not IsInArea ( IsInUnit ( IsInUnit ( Burlak ) ) , BeriaBaseArea ) ) and raportForPlatonov = - 1 do
15930: LD_EXP 20
15934: PUSH
15935: LD_EXP 62
15939: PPUSH
15940: LD_INT 8
15942: PPUSH
15943: CALL_OW 308
15947: NOT
15948: PUSH
15949: LD_EXP 62
15953: PPUSH
15954: CALL_OW 310
15958: PPUSH
15959: CALL_OW 310
15963: PPUSH
15964: LD_INT 8
15966: PPUSH
15967: CALL_OW 308
15971: NOT
15972: AND
15973: AND
15974: PUSH
15975: LD_EXP 39
15979: PUSH
15980: LD_INT 1
15982: NEG
15983: EQUAL
15984: AND
15985: IFFALSE 15999
15987: GO 15989
15989: DISABLE
// begin enable ;
15990: ENABLE
// raportForPlatonov = 0 ;
15991: LD_ADDR_EXP 39
15995: PUSH
15996: LD_INT 0
15998: ST_TO_ADDR
// end ;
15999: END
// every 0 0$1 trigger canExploreMap and raportForPlatonov >= 0 and not backToBeria2 and ( IsInArea ( Burlak , BeriaBaseArea ) or IsInArea ( IsInUnit ( IsInUnit ( Burlak ) ) , BeriaBaseArea ) and not backToBeria2 ) do
16000: LD_EXP 20
16004: PUSH
16005: LD_EXP 39
16009: PUSH
16010: LD_INT 0
16012: GREATEREQUAL
16013: AND
16014: PUSH
16015: LD_EXP 16
16019: NOT
16020: AND
16021: PUSH
16022: LD_EXP 62
16026: PPUSH
16027: LD_INT 8
16029: PPUSH
16030: CALL_OW 308
16034: PUSH
16035: LD_EXP 62
16039: PPUSH
16040: CALL_OW 310
16044: PPUSH
16045: CALL_OW 310
16049: PPUSH
16050: LD_INT 8
16052: PPUSH
16053: CALL_OW 308
16057: PUSH
16058: LD_EXP 16
16062: NOT
16063: AND
16064: OR
16065: AND
16066: IFFALSE 16357
16068: GO 16070
16070: DISABLE
// begin enable ;
16071: ENABLE
// DialogueOn ;
16072: CALL_OW 6
// case raportForPlatonov of 0 :
16076: LD_EXP 39
16080: PUSH
16081: LD_INT 0
16083: DOUBLE
16084: EQUAL
16085: IFTRUE 16089
16087: GO 16116
16089: POP
// begin Say ( Platonov , D25a-Pla-1 ) ;
16090: LD_EXP 76
16094: PPUSH
16095: LD_STRING D25a-Pla-1
16097: PPUSH
16098: CALL_OW 88
// Say ( Burlak , D25a-Bur-1 ) ;
16102: LD_EXP 62
16106: PPUSH
16107: LD_STRING D25a-Bur-1
16109: PPUSH
16110: CALL_OW 88
// end ; 1 :
16114: GO 16332
16116: LD_INT 1
16118: DOUBLE
16119: EQUAL
16120: IFTRUE 16124
16122: GO 16187
16124: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
16125: LD_EXP 76
16129: PPUSH
16130: LD_STRING D25-Pla-1
16132: PPUSH
16133: CALL_OW 88
// Say ( Burlak , D25-Bur-1 ) ;
16137: LD_EXP 62
16141: PPUSH
16142: LD_STRING D25-Bur-1
16144: PPUSH
16145: CALL_OW 88
// Say ( Burlak , D25b-Bur-1 ) ;
16149: LD_EXP 62
16153: PPUSH
16154: LD_STRING D25b-Bur-1
16156: PPUSH
16157: CALL_OW 88
// Say ( Platonov , D25b-Pla-1 ) ;
16161: LD_EXP 76
16165: PPUSH
16166: LD_STRING D25b-Pla-1
16168: PPUSH
16169: CALL_OW 88
// playerGetSupport = true ;
16173: LD_ADDR_EXP 34
16177: PUSH
16178: LD_INT 1
16180: ST_TO_ADDR
// PlatonovSendSupport ;
16181: CALL 6522 0 0
// end ; 2 :
16185: GO 16332
16187: LD_INT 2
16189: DOUBLE
16190: EQUAL
16191: IFTRUE 16195
16193: GO 16241
16195: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
16196: LD_EXP 76
16200: PPUSH
16201: LD_STRING D25-Pla-1
16203: PPUSH
16204: CALL_OW 88
// Say ( Burlak , D25-Bur-1a ) ;
16208: LD_EXP 62
16212: PPUSH
16213: LD_STRING D25-Bur-1a
16215: PPUSH
16216: CALL_OW 88
// if not sawLeftBunker then
16220: LD_EXP 29
16224: NOT
16225: IFFALSE 16239
// Say ( Platonov , D25c-Pla-1 ) ;
16227: LD_EXP 76
16231: PPUSH
16232: LD_STRING D25c-Pla-1
16234: PPUSH
16235: CALL_OW 88
// end ; 3 :
16239: GO 16332
16241: LD_INT 3
16243: DOUBLE
16244: EQUAL
16245: IFTRUE 16249
16247: GO 16331
16249: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
16250: LD_EXP 76
16254: PPUSH
16255: LD_STRING D25-Pla-1
16257: PPUSH
16258: CALL_OW 88
// Say ( Burlak , D25a-Bur-1b ) ;
16262: LD_EXP 62
16266: PPUSH
16267: LD_STRING D25a-Bur-1b
16269: PPUSH
16270: CALL_OW 88
// Say ( Burlak , D25b-Bur-1 ) ;
16274: LD_EXP 62
16278: PPUSH
16279: LD_STRING D25b-Bur-1
16281: PPUSH
16282: CALL_OW 88
// Say ( Platonov , D25b-Pla-1 ) ;
16286: LD_EXP 76
16290: PPUSH
16291: LD_STRING D25b-Pla-1
16293: PPUSH
16294: CALL_OW 88
// playerGetSupport = true ;
16298: LD_ADDR_EXP 34
16302: PUSH
16303: LD_INT 1
16305: ST_TO_ADDR
// PlatonovSendSupport ;
16306: CALL 6522 0 0
// if not sawRightBunker then
16310: LD_EXP 30
16314: NOT
16315: IFFALSE 16329
// Say ( Platonov , D25c-Pla-1 ) ;
16317: LD_EXP 76
16321: PPUSH
16322: LD_STRING D25c-Pla-1
16324: PPUSH
16325: CALL_OW 88
// end ; end ;
16329: GO 16332
16331: POP
// raportForPlatonov = - 1 ;
16332: LD_ADDR_EXP 39
16336: PUSH
16337: LD_INT 1
16339: NEG
16340: ST_TO_ADDR
// Say ( Platonov , D25c-Pla-1a ) ;
16341: LD_EXP 76
16345: PPUSH
16346: LD_STRING D25c-Pla-1a
16348: PPUSH
16349: CALL_OW 88
// DialogueOff ;
16353: CALL_OW 7
// end ;
16357: END
// every 0 0$1 trigger FilterUnitsInArea ( NorthArea , [ [ f_side , 3 ] ] ) > 0 do
16358: LD_INT 19
16360: PPUSH
16361: LD_INT 22
16363: PUSH
16364: LD_INT 3
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: PUSH
16371: EMPTY
16372: LIST
16373: PPUSH
16374: CALL_OW 70
16378: PUSH
16379: LD_INT 0
16381: GREATER
16382: IFFALSE 16402
16384: GO 16386
16386: DISABLE
// begin northMapExplored = true ;
16387: LD_ADDR_EXP 41
16391: PUSH
16392: LD_INT 1
16394: ST_TO_ADDR
// ChangeMissionObjectives ( M10 ) ;
16395: LD_STRING M10
16397: PPUSH
16398: CALL_OW 337
// end ;
16402: END
// every 0 0$1 trigger not leftBunkers and northMapExplored and ( belkovSaved or not saveBelkovObjective ) do
16403: LD_EXP 82
16407: NOT
16408: PUSH
16409: LD_EXP 41
16413: AND
16414: PUSH
16415: LD_EXP 37
16419: PUSH
16420: LD_EXP 36
16424: NOT
16425: OR
16426: AND
16427: IFFALSE 16447
16429: GO 16431
16431: DISABLE
// begin backToBeria2 = true ;
16432: LD_ADDR_EXP 16
16436: PUSH
16437: LD_INT 1
16439: ST_TO_ADDR
// ChangeMissionObjectives ( M10a ) ;
16440: LD_STRING M10a
16442: PPUSH
16443: CALL_OW 337
// end ;
16447: END
// every 0 0$1 do
16448: GO 16450
16450: DISABLE
// begin enable ;
16451: ENABLE
// SetLives ( [ Kurin , Platonov ] , 1000 ) ;
16452: LD_EXP 67
16456: PUSH
16457: LD_EXP 76
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PPUSH
16466: LD_INT 1000
16468: PPUSH
16469: CALL_OW 234
// end ; end_of_file
16473: END
// export function PrepareNature ; var i , un ; begin
16474: LD_INT 0
16476: PPUSH
16477: PPUSH
16478: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
16479: LD_ADDR_VAR 0 2
16483: PUSH
16484: DOUBLE
16485: LD_INT 1
16487: DEC
16488: ST_TO_ADDR
16489: LD_EXP 45
16493: PUSH
16494: LD_INT 1
16496: ARRAY
16497: PUSH
16498: FOR_TO
16499: IFFALSE 16609
// begin uc_side = 0 ;
16501: LD_ADDR_OWVAR 20
16505: PUSH
16506: LD_INT 0
16508: ST_TO_ADDR
// uc_nation = nation_nature ;
16509: LD_ADDR_OWVAR 21
16513: PUSH
16514: LD_INT 0
16516: ST_TO_ADDR
// hc_class = class_apeman ;
16517: LD_ADDR_OWVAR 28
16521: PUSH
16522: LD_INT 12
16524: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16525: LD_ADDR_OWVAR 31
16529: PUSH
16530: LD_EXP 46
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PUSH
16539: LD_EXP 46
16543: PUSH
16544: LD_INT 2
16546: ARRAY
16547: PUSH
16548: LD_EXP 46
16552: PUSH
16553: LD_INT 3
16555: ARRAY
16556: PUSH
16557: LD_EXP 46
16561: PUSH
16562: LD_INT 4
16564: ARRAY
16565: PUSH
16566: EMPTY
16567: LIST
16568: LIST
16569: LIST
16570: LIST
16571: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16572: LD_ADDR_OWVAR 35
16576: PUSH
16577: LD_EXP 47
16581: ST_TO_ADDR
// un = CreateHuman ;
16582: LD_ADDR_VAR 0 3
16586: PUSH
16587: CALL_OW 44
16591: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16592: LD_VAR 0 3
16596: PPUSH
16597: LD_INT 21
16599: PPUSH
16600: LD_INT 0
16602: PPUSH
16603: CALL_OW 49
// end ;
16607: GO 16498
16609: POP
16610: POP
// for i := 1 to animalsAmount [ 2 ] do
16611: LD_ADDR_VAR 0 2
16615: PUSH
16616: DOUBLE
16617: LD_INT 1
16619: DEC
16620: ST_TO_ADDR
16621: LD_EXP 45
16625: PUSH
16626: LD_INT 2
16628: ARRAY
16629: PUSH
16630: FOR_TO
16631: IFFALSE 16741
// begin uc_side = 0 ;
16633: LD_ADDR_OWVAR 20
16637: PUSH
16638: LD_INT 0
16640: ST_TO_ADDR
// uc_nation = nation_nature ;
16641: LD_ADDR_OWVAR 21
16645: PUSH
16646: LD_INT 0
16648: ST_TO_ADDR
// hc_class = class_phororhacos ;
16649: LD_ADDR_OWVAR 28
16653: PUSH
16654: LD_INT 18
16656: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16657: LD_ADDR_OWVAR 31
16661: PUSH
16662: LD_EXP 46
16666: PUSH
16667: LD_INT 1
16669: ARRAY
16670: PUSH
16671: LD_EXP 46
16675: PUSH
16676: LD_INT 2
16678: ARRAY
16679: PUSH
16680: LD_EXP 46
16684: PUSH
16685: LD_INT 3
16687: ARRAY
16688: PUSH
16689: LD_EXP 46
16693: PUSH
16694: LD_INT 4
16696: ARRAY
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16704: LD_ADDR_OWVAR 35
16708: PUSH
16709: LD_EXP 47
16713: ST_TO_ADDR
// un = CreateHuman ;
16714: LD_ADDR_VAR 0 3
16718: PUSH
16719: CALL_OW 44
16723: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16724: LD_VAR 0 3
16728: PPUSH
16729: LD_INT 21
16731: PPUSH
16732: LD_INT 0
16734: PPUSH
16735: CALL_OW 49
// end ;
16739: GO 16630
16741: POP
16742: POP
// for i := 1 to animalsAmount [ 3 ] do
16743: LD_ADDR_VAR 0 2
16747: PUSH
16748: DOUBLE
16749: LD_INT 1
16751: DEC
16752: ST_TO_ADDR
16753: LD_EXP 45
16757: PUSH
16758: LD_INT 3
16760: ARRAY
16761: PUSH
16762: FOR_TO
16763: IFFALSE 16873
// begin uc_side = 0 ;
16765: LD_ADDR_OWVAR 20
16769: PUSH
16770: LD_INT 0
16772: ST_TO_ADDR
// uc_nation = nation_nature ;
16773: LD_ADDR_OWVAR 21
16777: PUSH
16778: LD_INT 0
16780: ST_TO_ADDR
// hc_class = class_tiger ;
16781: LD_ADDR_OWVAR 28
16785: PUSH
16786: LD_INT 14
16788: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16789: LD_ADDR_OWVAR 31
16793: PUSH
16794: LD_EXP 46
16798: PUSH
16799: LD_INT 1
16801: ARRAY
16802: PUSH
16803: LD_EXP 46
16807: PUSH
16808: LD_INT 2
16810: ARRAY
16811: PUSH
16812: LD_EXP 46
16816: PUSH
16817: LD_INT 3
16819: ARRAY
16820: PUSH
16821: LD_EXP 46
16825: PUSH
16826: LD_INT 4
16828: ARRAY
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: LIST
16834: LIST
16835: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16836: LD_ADDR_OWVAR 35
16840: PUSH
16841: LD_EXP 47
16845: ST_TO_ADDR
// un = CreateHuman ;
16846: LD_ADDR_VAR 0 3
16850: PUSH
16851: CALL_OW 44
16855: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16856: LD_VAR 0 3
16860: PPUSH
16861: LD_INT 21
16863: PPUSH
16864: LD_INT 0
16866: PPUSH
16867: CALL_OW 49
// end ;
16871: GO 16762
16873: POP
16874: POP
// for i := 1 to animalsAmount [ 4 ] do
16875: LD_ADDR_VAR 0 2
16879: PUSH
16880: DOUBLE
16881: LD_INT 1
16883: DEC
16884: ST_TO_ADDR
16885: LD_EXP 45
16889: PUSH
16890: LD_INT 4
16892: ARRAY
16893: PUSH
16894: FOR_TO
16895: IFFALSE 17005
// begin uc_side = 0 ;
16897: LD_ADDR_OWVAR 20
16901: PUSH
16902: LD_INT 0
16904: ST_TO_ADDR
// uc_nation = nation_nature ;
16905: LD_ADDR_OWVAR 21
16909: PUSH
16910: LD_INT 0
16912: ST_TO_ADDR
// hc_class = 21 ;
16913: LD_ADDR_OWVAR 28
16917: PUSH
16918: LD_INT 21
16920: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16921: LD_ADDR_OWVAR 31
16925: PUSH
16926: LD_EXP 46
16930: PUSH
16931: LD_INT 1
16933: ARRAY
16934: PUSH
16935: LD_EXP 46
16939: PUSH
16940: LD_INT 2
16942: ARRAY
16943: PUSH
16944: LD_EXP 46
16948: PUSH
16949: LD_INT 3
16951: ARRAY
16952: PUSH
16953: LD_EXP 46
16957: PUSH
16958: LD_INT 4
16960: ARRAY
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: LIST
16966: LIST
16967: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16968: LD_ADDR_OWVAR 35
16972: PUSH
16973: LD_EXP 47
16977: ST_TO_ADDR
// un = CreateHuman ;
16978: LD_ADDR_VAR 0 3
16982: PUSH
16983: CALL_OW 44
16987: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16988: LD_VAR 0 3
16992: PPUSH
16993: LD_INT 21
16995: PPUSH
16996: LD_INT 0
16998: PPUSH
16999: CALL_OW 49
// end ;
17003: GO 16894
17005: POP
17006: POP
// end ; end_of_file
17007: LD_VAR 0 1
17011: RET
// every 0 0$1 trigger spawnCrates do var i , unit , carryCratesEngs , playerEngs , spawnNextCrates ;
17012: LD_EXP 21
17016: IFFALSE 17245
17018: GO 17020
17020: DISABLE
17021: LD_INT 0
17023: PPUSH
17024: PPUSH
17025: PPUSH
17026: PPUSH
17027: PPUSH
// begin repeat playerEngs = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_class , class_engineer ] ] ) ;
17028: LD_ADDR_VAR 0 4
17032: PUSH
17033: LD_INT 22
17035: PUSH
17036: LD_INT 3
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PUSH
17043: LD_INT 21
17045: PUSH
17046: LD_INT 1
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: PUSH
17053: LD_INT 25
17055: PUSH
17056: LD_INT 2
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: PUSH
17063: EMPTY
17064: LIST
17065: LIST
17066: LIST
17067: PPUSH
17068: CALL_OW 69
17072: ST_TO_ADDR
// wait ( 0 0$20 ) ;
17073: LD_INT 700
17075: PPUSH
17076: CALL_OW 67
// carryCratesEngs = 0 ;
17080: LD_ADDR_VAR 0 3
17084: PUSH
17085: LD_INT 0
17087: ST_TO_ADDR
// for unit in playerEngs do
17088: LD_ADDR_VAR 0 2
17092: PUSH
17093: LD_VAR 0 4
17097: PUSH
17098: FOR_IN
17099: IFFALSE 17127
// carryCratesEngs = carryCratesEngs + GetCargo ( unit , mat_cans ) ;
17101: LD_ADDR_VAR 0 3
17105: PUSH
17106: LD_VAR 0 3
17110: PUSH
17111: LD_VAR 0 2
17115: PPUSH
17116: LD_INT 1
17118: PPUSH
17119: CALL_OW 289
17123: PLUS
17124: ST_TO_ADDR
17125: GO 17098
17127: POP
17128: POP
// if GetResourceType ( GetBase ( beria ) , mat_cans ) < 50 and ( GetResourceArea ( beriaBaseArea , mat_cans ) * 10 ) + GetResourceType ( GetBase ( beria ) , mat_cans ) + carryCratesEngs < 50 then
17129: LD_INT 106
17131: PPUSH
17132: CALL_OW 274
17136: PPUSH
17137: LD_INT 1
17139: PPUSH
17140: CALL_OW 275
17144: PUSH
17145: LD_INT 50
17147: LESS
17148: PUSH
17149: LD_INT 8
17151: PPUSH
17152: LD_INT 1
17154: PPUSH
17155: CALL_OW 287
17159: PUSH
17160: LD_INT 10
17162: MUL
17163: PUSH
17164: LD_INT 106
17166: PPUSH
17167: CALL_OW 274
17171: PPUSH
17172: LD_INT 1
17174: PPUSH
17175: CALL_OW 275
17179: PLUS
17180: PUSH
17181: LD_VAR 0 3
17185: PLUS
17186: PUSH
17187: LD_INT 50
17189: LESS
17190: AND
17191: IFFALSE 17203
// spawnNextCrates = true else
17193: LD_ADDR_VAR 0 5
17197: PUSH
17198: LD_INT 1
17200: ST_TO_ADDR
17201: GO 17211
// spawnNextCrates = false ;
17203: LD_ADDR_VAR 0 5
17207: PUSH
17208: LD_INT 0
17210: ST_TO_ADDR
// if spawnNextCrates then
17211: LD_VAR 0 5
17215: IFFALSE 17238
// CreateCratesArea ( rand ( 1 , 5 ) , CratesArea , true ) ;
17217: LD_INT 1
17219: PPUSH
17220: LD_INT 5
17222: PPUSH
17223: CALL_OW 12
17227: PPUSH
17228: LD_INT 26
17230: PPUSH
17231: LD_INT 1
17233: PPUSH
17234: CALL_OW 55
// until not spawnCrates ;
17238: LD_EXP 21
17242: NOT
17243: IFFALSE 17028
// end ; end_of_file
17245: PPOPN 5
17247: END
// on BuildingStarted ( building , builder ) do begin if GetBType ( building ) = b_lab and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) > 1 and not canBuildSameBuilding then
17248: LD_VAR 0 1
17252: PPUSH
17253: CALL_OW 266
17257: PUSH
17258: LD_INT 6
17260: EQUAL
17261: PUSH
17262: LD_INT 22
17264: PUSH
17265: LD_INT 3
17267: PUSH
17268: EMPTY
17269: LIST
17270: LIST
17271: PUSH
17272: LD_INT 30
17274: PUSH
17275: LD_INT 6
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: PUSH
17282: EMPTY
17283: LIST
17284: LIST
17285: PPUSH
17286: CALL_OW 69
17290: PUSH
17291: LD_INT 1
17293: GREATER
17294: AND
17295: PUSH
17296: LD_EXP 11
17300: NOT
17301: AND
17302: IFFALSE 17313
// Dial_StopConstructAgainSameBuilding ( building ) ;
17304: LD_VAR 0 1
17308: PPUSH
17309: CALL 9014 0 1
// if GetBType ( building ) = b_workshop and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_workshop ] ] ) > 1 and not canBuildSameBuilding then
17313: LD_VAR 0 1
17317: PPUSH
17318: CALL_OW 266
17322: PUSH
17323: LD_INT 2
17325: EQUAL
17326: PUSH
17327: LD_INT 22
17329: PUSH
17330: LD_INT 3
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: PUSH
17337: LD_INT 30
17339: PUSH
17340: LD_INT 2
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: PUSH
17347: EMPTY
17348: LIST
17349: LIST
17350: PPUSH
17351: CALL_OW 69
17355: PUSH
17356: LD_INT 1
17358: GREATER
17359: AND
17360: PUSH
17361: LD_EXP 11
17365: NOT
17366: AND
17367: IFFALSE 17378
// Dial_StopConstructAgainSameBuilding ( building ) ;
17369: LD_VAR 0 1
17373: PPUSH
17374: CALL 9014 0 1
// if GetSide ( building ) = 3 and GetBType ( building ) in [ b_oil_power , b_armoury , b_breastwork ] and IsInArea ( building , BeriaBaseArea ) then
17378: LD_VAR 0 1
17382: PPUSH
17383: CALL_OW 255
17387: PUSH
17388: LD_INT 3
17390: EQUAL
17391: PUSH
17392: LD_VAR 0 1
17396: PPUSH
17397: CALL_OW 266
17401: PUSH
17402: LD_INT 26
17404: PUSH
17405: LD_INT 4
17407: PUSH
17408: LD_INT 31
17410: PUSH
17411: EMPTY
17412: LIST
17413: LIST
17414: LIST
17415: IN
17416: AND
17417: PUSH
17418: LD_VAR 0 1
17422: PPUSH
17423: LD_INT 8
17425: PPUSH
17426: CALL_OW 308
17430: AND
17431: IFFALSE 17442
// Dial_StopConstructAgainSameBuilding ( building ) ;
17433: LD_VAR 0 1
17437: PPUSH
17438: CALL 9014 0 1
// end ;
17442: PPOPN 2
17444: END
// on BuildingComplete ( building ) do var sold , platSold ;
17445: LD_INT 0
17447: PPUSH
17448: PPUSH
// begin if GetSide ( building ) = 3 and GetBType ( building ) = b_lab and not labConstructed then
17449: LD_VAR 0 1
17453: PPUSH
17454: CALL_OW 255
17458: PUSH
17459: LD_INT 3
17461: EQUAL
17462: PUSH
17463: LD_VAR 0 1
17467: PPUSH
17468: CALL_OW 266
17472: PUSH
17473: LD_INT 6
17475: EQUAL
17476: AND
17477: PUSH
17478: LD_EXP 8
17482: NOT
17483: AND
17484: IFFALSE 17490
// Dial_LabConstructed ;
17486: CALL 8864 0 0
// if GetSide ( building ) = 3 and GetBType ( building ) = b_workshop and not workshopConstructed then
17490: LD_VAR 0 1
17494: PPUSH
17495: CALL_OW 255
17499: PUSH
17500: LD_INT 3
17502: EQUAL
17503: PUSH
17504: LD_VAR 0 1
17508: PPUSH
17509: CALL_OW 266
17513: PUSH
17514: LD_INT 2
17516: EQUAL
17517: AND
17518: PUSH
17519: LD_EXP 9
17523: NOT
17524: AND
17525: IFFALSE 17531
// Dial_WorkshopConstructed ;
17527: CALL 8939 0 0
// if GetSide ( building ) = 6 then
17531: LD_VAR 0 1
17535: PPUSH
17536: CALL_OW 255
17540: PUSH
17541: LD_INT 6
17543: EQUAL
17544: IFFALSE 17755
// begin if GetBType ( building ) = b_breastwork and IsInArea ( building , KirovBaseArea ) then
17546: LD_VAR 0 1
17550: PPUSH
17551: CALL_OW 266
17555: PUSH
17556: LD_INT 31
17558: EQUAL
17559: PUSH
17560: LD_VAR 0 1
17564: PPUSH
17565: LD_INT 9
17567: PPUSH
17568: CALL_OW 308
17572: AND
17573: IFFALSE 17624
// begin if UnitsInside ( ru2_arm2 ) then
17575: LD_INT 209
17577: PPUSH
17578: CALL_OW 313
17582: IFFALSE 17624
// begin sold = UnitsInside ( ru2_arm2 ) [ 1 ] ;
17584: LD_ADDR_VAR 0 2
17588: PUSH
17589: LD_INT 209
17591: PPUSH
17592: CALL_OW 313
17596: PUSH
17597: LD_INT 1
17599: ARRAY
17600: ST_TO_ADDR
// ComExitBuilding ( sold ) ;
17601: LD_VAR 0 2
17605: PPUSH
17606: CALL_OW 122
// AddComEnterUnit ( sold , building ) ;
17610: LD_VAR 0 2
17614: PPUSH
17615: LD_VAR 0 1
17619: PPUSH
17620: CALL_OW 180
// end ; end ; if GetBType ( building ) = b_breastwork and IsInArea ( building , BeriaBaseArea ) then
17624: LD_VAR 0 1
17628: PPUSH
17629: CALL_OW 266
17633: PUSH
17634: LD_INT 31
17636: EQUAL
17637: PUSH
17638: LD_VAR 0 1
17642: PPUSH
17643: LD_INT 8
17645: PPUSH
17646: CALL_OW 308
17650: AND
17651: IFFALSE 17687
// begin sold = NearestUnitToUnit ( platSoldiers , building ) ;
17653: LD_ADDR_VAR 0 2
17657: PUSH
17658: LD_EXP 77
17662: PPUSH
17663: LD_VAR 0 1
17667: PPUSH
17668: CALL_OW 74
17672: ST_TO_ADDR
// ComEnterUnit ( sold , building ) ;
17673: LD_VAR 0 2
17677: PPUSH
17678: LD_VAR 0 1
17682: PPUSH
17683: CALL_OW 120
// end ; if GetBType ( building ) = b_workshop then
17687: LD_VAR 0 1
17691: PPUSH
17692: CALL_OW 266
17696: PUSH
17697: LD_INT 2
17699: EQUAL
17700: IFFALSE 17755
// begin ComExitBuilding ( UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) ) ;
17702: LD_EXP 69
17706: PPUSH
17707: LD_INT 25
17709: PUSH
17710: LD_INT 3
17712: PUSH
17713: EMPTY
17714: LIST
17715: LIST
17716: PPUSH
17717: CALL_OW 72
17721: PPUSH
17722: CALL_OW 122
// AddComEnterUnit ( UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) , building ) ;
17726: LD_EXP 69
17730: PPUSH
17731: LD_INT 25
17733: PUSH
17734: LD_INT 3
17736: PUSH
17737: EMPTY
17738: LIST
17739: LIST
17740: PPUSH
17741: CALL_OW 72
17745: PPUSH
17746: LD_VAR 0 1
17750: PPUSH
17751: CALL_OW 180
// end ; end ; end ;
17755: PPOPN 3
17757: END
// on ResearchComplete ( tech , building ) do begin if tech = tech_oilEng and GetSide ( building ) = 3 then
17758: LD_VAR 0 1
17762: PUSH
17763: LD_INT 47
17765: EQUAL
17766: PUSH
17767: LD_VAR 0 2
17771: PPUSH
17772: CALL_OW 255
17776: PUSH
17777: LD_INT 3
17779: EQUAL
17780: AND
17781: IFFALSE 17791
// engineResearched = true ;
17783: LD_ADDR_EXP 10
17787: PUSH
17788: LD_INT 1
17790: ST_TO_ADDR
// if tech = tech_Tech1 then
17791: LD_VAR 0 1
17795: PUSH
17796: LD_INT 48
17798: EQUAL
17799: IFFALSE 17821
// begin wait ( 0 0$5 ) ;
17801: LD_INT 175
17803: PPUSH
17804: CALL_OW 67
// SetSpecResearch ( ru_lab , 1500 , false ) ;
17808: LD_INT 83
17810: PPUSH
17811: LD_INT 1500
17813: PPUSH
17814: LD_INT 0
17816: PPUSH
17817: CALL_OW 486
// end ; end ;
17821: PPOPN 2
17823: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( factory ) = your_side and IsOK ( factory ) and not constructedFirstVehicle and not construcMoreVehicles then
17824: LD_VAR 0 2
17828: PPUSH
17829: CALL_OW 255
17833: PUSH
17834: LD_OWVAR 2
17838: EQUAL
17839: PUSH
17840: LD_VAR 0 2
17844: PPUSH
17845: CALL_OW 302
17849: AND
17850: PUSH
17851: LD_EXP 12
17855: NOT
17856: AND
17857: PUSH
17858: LD_EXP 17
17862: NOT
17863: AND
17864: IFFALSE 17875
// Dial_FirstVehConstructed ( factory ) ;
17866: LD_VAR 0 2
17870: PPUSH
17871: CALL 9538 0 1
// if GetSide ( factory ) = your_side and not vehicleForKurin and not IsOK ( firstVeh ) then
17875: LD_VAR 0 2
17879: PPUSH
17880: CALL_OW 255
17884: PUSH
17885: LD_OWVAR 2
17889: EQUAL
17890: PUSH
17891: LD_EXP 14
17895: NOT
17896: AND
17897: PUSH
17898: LD_EXP 13
17902: PPUSH
17903: CALL_OW 302
17907: NOT
17908: AND
17909: IFFALSE 17921
// firstVeh = vehicle ;
17911: LD_ADDR_EXP 13
17915: PUSH
17916: LD_VAR 0 1
17920: ST_TO_ADDR
// if GetSide ( factory ) = your_side and IsOK ( factory ) and construcMoreVehicles then
17921: LD_VAR 0 2
17925: PPUSH
17926: CALL_OW 255
17930: PUSH
17931: LD_OWVAR 2
17935: EQUAL
17936: PUSH
17937: LD_VAR 0 2
17941: PPUSH
17942: CALL_OW 302
17946: AND
17947: PUSH
17948: LD_EXP 17
17952: AND
17953: IFFALSE 17969
// constructedVehiclesCounter = constructedVehiclesCounter + 1 ;
17955: LD_ADDR_EXP 18
17959: PUSH
17960: LD_EXP 18
17964: PUSH
17965: LD_INT 1
17967: PLUS
17968: ST_TO_ADDR
// if GetSide ( factory ) = your_side and GetNation ( factory ) = nation_russian then
17969: LD_VAR 0 2
17973: PPUSH
17974: CALL_OW 255
17978: PUSH
17979: LD_OWVAR 2
17983: EQUAL
17984: PUSH
17985: LD_VAR 0 2
17989: PPUSH
17990: CALL_OW 248
17994: PUSH
17995: LD_INT 3
17997: EQUAL
17998: AND
17999: IFFALSE 18015
// achievement_ConstructVehicles = achievement_ConstructVehicles + 1 ;
18001: LD_ADDR_EXP 44
18005: PUSH
18006: LD_EXP 44
18010: PUSH
18011: LD_INT 1
18013: PLUS
18014: ST_TO_ADDR
// end ;
18015: PPOPN 2
18017: END
// on CrateSpawn ( unit , x , y , amount , mode ) do begin if not canExitBase and mode = true then
18018: LD_EXP 19
18022: NOT
18023: PUSH
18024: LD_VAR 0 5
18028: PUSH
18029: LD_INT 1
18031: EQUAL
18032: AND
18033: IFFALSE 18049
// Dial_NewCrates ( x , y ) ;
18035: LD_VAR 0 2
18039: PPUSH
18040: LD_VAR 0 3
18044: PPUSH
18045: CALL 9483 0 2
// end ;
18049: PPOPN 5
18051: END
// on Command ( com ) do var i , j , temp , order , destiny ;
18052: LD_INT 0
18054: PPUSH
18055: PPUSH
18056: PPUSH
18057: PPUSH
18058: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
18059: LD_ADDR_VAR 0 2
18063: PUSH
18064: LD_INT 22
18066: PUSH
18067: LD_INT 3
18069: PUSH
18070: EMPTY
18071: LIST
18072: LIST
18073: PUSH
18074: LD_INT 21
18076: PUSH
18077: LD_INT 1
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: PUSH
18084: EMPTY
18085: LIST
18086: LIST
18087: PPUSH
18088: CALL_OW 69
18092: PUSH
18093: FOR_IN
18094: IFFALSE 18287
// if GetTaskList ( i ) > 0 then
18096: LD_VAR 0 2
18100: PPUSH
18101: CALL_OW 437
18105: PUSH
18106: LD_INT 0
18108: GREATER
18109: IFFALSE 18285
// for j = 1 to GetTaskList ( i ) do
18111: LD_ADDR_VAR 0 3
18115: PUSH
18116: DOUBLE
18117: LD_INT 1
18119: DEC
18120: ST_TO_ADDR
18121: LD_VAR 0 2
18125: PPUSH
18126: CALL_OW 437
18130: PUSH
18131: FOR_TO
18132: IFFALSE 18283
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
18134: LD_ADDR_VAR 0 4
18138: PUSH
18139: LD_VAR 0 2
18143: PPUSH
18144: CALL_OW 437
18148: PUSH
18149: LD_VAR 0 3
18153: ARRAY
18154: PUSH
18155: LD_INT 4
18157: ARRAY
18158: ST_TO_ADDR
// if temp = kirov or ( GetSide ( temp ) = 6 and GetTaskList ( i ) [ j ] [ 1 ] = e and GetType ( temp ) = unit_vehicle ) then
18159: LD_VAR 0 4
18163: PUSH
18164: LD_INT 71
18166: EQUAL
18167: PUSH
18168: LD_VAR 0 4
18172: PPUSH
18173: CALL_OW 255
18177: PUSH
18178: LD_INT 6
18180: EQUAL
18181: PUSH
18182: LD_VAR 0 2
18186: PPUSH
18187: CALL_OW 437
18191: PUSH
18192: LD_VAR 0 3
18196: ARRAY
18197: PUSH
18198: LD_INT 1
18200: ARRAY
18201: PUSH
18202: LD_STRING e
18204: EQUAL
18205: AND
18206: PUSH
18207: LD_VAR 0 4
18211: PPUSH
18212: CALL_OW 247
18216: PUSH
18217: LD_INT 2
18219: EQUAL
18220: AND
18221: OR
18222: IFFALSE 18235
// SetTaskList ( i , [ ] ) ;
18224: LD_VAR 0 2
18228: PPUSH
18229: EMPTY
18230: PPUSH
18231: CALL_OW 446
// if temp = beria and GetTaskList ( i ) [ j ] [ 1 ] = Y then
18235: LD_VAR 0 4
18239: PUSH
18240: LD_INT 106
18242: EQUAL
18243: PUSH
18244: LD_VAR 0 2
18248: PPUSH
18249: CALL_OW 437
18253: PUSH
18254: LD_VAR 0 3
18258: ARRAY
18259: PUSH
18260: LD_INT 1
18262: ARRAY
18263: PUSH
18264: LD_STRING Y
18266: EQUAL
18267: AND
18268: IFFALSE 18281
// SetTaskList ( i , [ ] ) ;
18270: LD_VAR 0 2
18274: PPUSH
18275: EMPTY
18276: PPUSH
18277: CALL_OW 446
// end ;
18281: GO 18131
18283: POP
18284: POP
18285: GO 18093
18287: POP
18288: POP
// end ;
18289: PPOPN 6
18291: END
// on UnitDestroyed ( unit ) do begin if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
18292: LD_VAR 0 1
18296: PPUSH
18297: CALL_OW 255
18301: PUSH
18302: LD_INT 1
18304: EQUAL
18305: PUSH
18306: LD_VAR 0 1
18310: PPUSH
18311: CALL_OW 247
18315: PUSH
18316: LD_INT 1
18318: EQUAL
18319: AND
18320: IFFALSE 18378
// begin if unit in amLeftEngs then
18322: LD_VAR 0 1
18326: PUSH
18327: LD_EXP 86
18331: IN
18332: IFFALSE 18350
// amLeftEngs = amLeftEngs diff unit ;
18334: LD_ADDR_EXP 86
18338: PUSH
18339: LD_EXP 86
18343: PUSH
18344: LD_VAR 0 1
18348: DIFF
18349: ST_TO_ADDR
// if unit in amRightEngs then
18350: LD_VAR 0 1
18354: PUSH
18355: LD_EXP 87
18359: IN
18360: IFFALSE 18378
// amRightEngs = amRightEngs diff unit ;
18362: LD_ADDR_EXP 87
18366: PUSH
18367: LD_EXP 87
18371: PUSH
18372: LD_VAR 0 1
18376: DIFF
18377: ST_TO_ADDR
// end ; if GetSide ( unit ) = 6 and GetType ( unit ) = unit_human then
18378: LD_VAR 0 1
18382: PPUSH
18383: CALL_OW 255
18387: PUSH
18388: LD_INT 6
18390: EQUAL
18391: PUSH
18392: LD_VAR 0 1
18396: PPUSH
18397: CALL_OW 247
18401: PUSH
18402: LD_INT 1
18404: EQUAL
18405: AND
18406: IFFALSE 18436
// if unit in belkovTeam then
18408: LD_VAR 0 1
18412: PUSH
18413: LD_EXP 73
18417: IN
18418: IFFALSE 18436
// belkovTeam = belkovTeam diff unit ;
18420: LD_ADDR_EXP 73
18424: PUSH
18425: LD_EXP 73
18429: PUSH
18430: LD_VAR 0 1
18434: DIFF
18435: ST_TO_ADDR
// if GetSide ( unit ) = 3 and GetType ( unit ) = unit_human then
18436: LD_VAR 0 1
18440: PPUSH
18441: CALL_OW 255
18445: PUSH
18446: LD_INT 3
18448: EQUAL
18449: PUSH
18450: LD_VAR 0 1
18454: PPUSH
18455: CALL_OW 247
18459: PUSH
18460: LD_INT 1
18462: EQUAL
18463: AND
18464: IFFALSE 18480
// lostComradesCounter = lostComradesCounter + 1 ;
18466: LD_ADDR_EXP 43
18470: PUSH
18471: LD_EXP 43
18475: PUSH
18476: LD_INT 1
18478: PLUS
18479: ST_TO_ADDR
// if unit = Burlak then
18480: LD_VAR 0 1
18484: PUSH
18485: LD_EXP 62
18489: EQUAL
18490: IFFALSE 18496
// BurlakIsDead ;
18492: CALL 19793 0 0
// if unit in platSoldiers then
18496: LD_VAR 0 1
18500: PUSH
18501: LD_EXP 77
18505: IN
18506: IFFALSE 18524
// platSoldiers = platSoldiers diff unit ;
18508: LD_ADDR_EXP 77
18512: PUSH
18513: LD_EXP 77
18517: PUSH
18518: LD_VAR 0 1
18522: DIFF
18523: ST_TO_ADDR
// end ;
18524: PPOPN 1
18526: END
// on UnitGoesToRed ( unit ) do begin if GetSide ( unit ) = 1 and GetType ( unit ) = unit_building then
18527: LD_VAR 0 1
18531: PPUSH
18532: CALL_OW 255
18536: PUSH
18537: LD_INT 1
18539: EQUAL
18540: PUSH
18541: LD_VAR 0 1
18545: PPUSH
18546: CALL_OW 247
18550: PUSH
18551: LD_INT 3
18553: EQUAL
18554: AND
18555: IFFALSE 18613
// begin if unit in leftBunkers then
18557: LD_VAR 0 1
18561: PUSH
18562: LD_EXP 82
18566: IN
18567: IFFALSE 18585
// leftBunkers = leftBunkers diff unit ;
18569: LD_ADDR_EXP 82
18573: PUSH
18574: LD_EXP 82
18578: PUSH
18579: LD_VAR 0 1
18583: DIFF
18584: ST_TO_ADDR
// if unit in rightBunkers then
18585: LD_VAR 0 1
18589: PUSH
18590: LD_EXP 83
18594: IN
18595: IFFALSE 18613
// rightBunkers = rightBunkers diff unit ;
18597: LD_ADDR_EXP 83
18601: PUSH
18602: LD_EXP 83
18606: PUSH
18607: LD_VAR 0 1
18611: DIFF
18612: ST_TO_ADDR
// end ; if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
18613: LD_VAR 0 1
18617: PPUSH
18618: CALL_OW 255
18622: PUSH
18623: LD_INT 1
18625: EQUAL
18626: PUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: CALL_OW 247
18636: PUSH
18637: LD_INT 1
18639: EQUAL
18640: AND
18641: IFFALSE 18671
// if unit in trapTeam then
18643: LD_VAR 0 1
18647: PUSH
18648: LD_EXP 81
18652: IN
18653: IFFALSE 18671
// trapTeam = trapTeam diff unit ;
18655: LD_ADDR_EXP 81
18659: PUSH
18660: LD_EXP 81
18664: PUSH
18665: LD_VAR 0 1
18669: DIFF
18670: ST_TO_ADDR
// end ;
18671: PPOPN 1
18673: END
// on VehicleCaptured ( new_vehicle , old_vehicle , original_side , human ) do begin if original_side = 1 then
18674: LD_VAR 0 3
18678: PUSH
18679: LD_INT 1
18681: EQUAL
18682: IFFALSE 18692
// captureBelkovVehicle = true ;
18684: LD_ADDR_EXP 38
18688: PUSH
18689: LD_INT 1
18691: ST_TO_ADDR
// if original_side = 6 then
18692: LD_VAR 0 3
18696: PUSH
18697: LD_INT 6
18699: EQUAL
18700: IFFALSE 18744
// begin ComMoveXY ( [ new_vehicle , old_vehicle ] , 118 , 25 ) ;
18702: LD_VAR 0 1
18706: PUSH
18707: LD_VAR 0 2
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: PPUSH
18716: LD_INT 118
18718: PPUSH
18719: LD_INT 25
18721: PPUSH
18722: CALL_OW 111
// ComFree ( [ new_vehicle , old_vehicle ] ) ;
18726: LD_VAR 0 1
18730: PUSH
18731: LD_VAR 0 2
18735: PUSH
18736: EMPTY
18737: LIST
18738: LIST
18739: PPUSH
18740: CALL_OW 139
// end ; end ;
18744: PPOPN 4
18746: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
18747: LD_VAR 0 1
18751: PUSH
18752: LD_INT 3
18754: EQUAL
18755: PUSH
18756: LD_VAR 0 2
18760: PUSH
18761: LD_INT 6
18763: EQUAL
18764: AND
18765: IFFALSE 18771
// AttackComrades ;
18767: CALL 19808 0 0
// end ;
18771: PPOPN 2
18773: END
// on BuildingCaptured ( building , side , human ) do begin if side = 6 then
18774: LD_VAR 0 2
18778: PUSH
18779: LD_INT 6
18781: EQUAL
18782: IFFALSE 18796
// SetSide ( building , 3 ) ;
18784: LD_VAR 0 1
18788: PPUSH
18789: LD_INT 3
18791: PPUSH
18792: CALL_OW 235
// end ; end_of_file
18796: PPOPN 3
18798: END
// every 0 0$5 trigger backToBeria2 and FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
18799: LD_EXP 16
18803: PUSH
18804: LD_INT 8
18806: PPUSH
18807: LD_INT 22
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 21
18819: PUSH
18820: LD_INT 1
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: PPUSH
18831: CALL_OW 71
18835: PUSH
18836: LD_INT 0
18838: EQUAL
18839: AND
18840: IFFALSE 18941
18842: GO 18844
18844: DISABLE
// begin enable ;
18845: ENABLE
// if not saveBelkovObjective and ( IsOk ( Belkov ) or IsOk ( Belkov2 ) ) then
18846: LD_EXP 36
18850: NOT
18851: PUSH
18852: LD_EXP 64
18856: PPUSH
18857: CALL_OW 302
18861: PUSH
18862: LD_EXP 68
18866: PPUSH
18867: CALL_OW 302
18871: OR
18872: AND
18873: IFFALSE 18920
// begin case Query ( QContMission ) of 1 :
18875: LD_STRING QContMission
18877: PPUSH
18878: CALL_OW 97
18882: PUSH
18883: LD_INT 1
18885: DOUBLE
18886: EQUAL
18887: IFTRUE 18891
18889: GO 18898
18891: POP
// begin FinishMission ;
18892: CALL 18942 0 0
// end ; 2 :
18896: GO 18918
18898: LD_INT 2
18900: DOUBLE
18901: EQUAL
18902: IFTRUE 18906
18904: GO 18917
18906: POP
// begin saveBelkovObjective = true ;
18907: LD_ADDR_EXP 36
18911: PUSH
18912: LD_INT 1
18914: ST_TO_ADDR
// end ; end ;
18915: GO 18918
18917: POP
// end else
18918: GO 18931
// if not belkovSaved then
18920: LD_EXP 37
18924: NOT
18925: IFFALSE 18931
// FinishMission ;
18927: CALL 18942 0 0
// if belkovSaved then
18931: LD_EXP 37
18935: IFFALSE 18941
// FinishMission ;
18937: CALL 18942 0 0
// end ;
18941: END
// function FinishMission ; begin
18942: LD_INT 0
18944: PPUSH
// SetRewards ;
18945: CALL 18966 0 0
// SavePlayerCharacters ;
18949: CALL 19256 0 0
// SaveGlobalVariables ;
18953: CALL 19473 0 0
// YouWin ;
18957: CALL_OW 103
// end ;
18961: LD_VAR 0 1
18965: RET
// function SetRewards ; begin
18966: LD_INT 0
18968: PPUSH
// case initiative of 1 :
18969: LD_EXP 42
18973: PUSH
18974: LD_INT 1
18976: DOUBLE
18977: EQUAL
18978: IFTRUE 18982
18980: GO 18995
18982: POP
// AddMedal ( Initiative , 1 ) ; 2 :
18983: LD_STRING Initiative
18985: PPUSH
18986: LD_INT 1
18988: PPUSH
18989: CALL_OW 101
18993: GO 19040
18995: LD_INT 2
18997: DOUBLE
18998: EQUAL
18999: IFTRUE 19003
19001: GO 19017
19003: POP
// AddMedal ( Initiative , - 2 ) ; 3 :
19004: LD_STRING Initiative
19006: PPUSH
19007: LD_INT 2
19009: NEG
19010: PPUSH
19011: CALL_OW 101
19015: GO 19040
19017: LD_INT 3
19019: DOUBLE
19020: EQUAL
19021: IFTRUE 19025
19023: GO 19039
19025: POP
// AddMedal ( Initiative , - 1 ) ; end ;
19026: LD_STRING Initiative
19028: PPUSH
19029: LD_INT 1
19031: NEG
19032: PPUSH
19033: CALL_OW 101
19037: GO 19040
19039: POP
// if belkovSaved and ( IsOK ( Belkov ) or IsOK ( Belkov2 ) ) then
19040: LD_EXP 37
19044: PUSH
19045: LD_EXP 64
19049: PPUSH
19050: CALL_OW 302
19054: PUSH
19055: LD_EXP 68
19059: PPUSH
19060: CALL_OW 302
19064: OR
19065: AND
19066: IFFALSE 19078
// AddMedal ( Belkov , 1 ) ;
19068: LD_STRING Belkov
19070: PPUSH
19071: LD_INT 1
19073: PPUSH
19074: CALL_OW 101
// if not belkovSaved and not saveBelkovObjective then
19078: LD_EXP 37
19082: NOT
19083: PUSH
19084: LD_EXP 36
19088: NOT
19089: AND
19090: IFFALSE 19103
// AddMedal ( Belkov , - 1 ) ;
19092: LD_STRING Belkov
19094: PPUSH
19095: LD_INT 1
19097: NEG
19098: PPUSH
19099: CALL_OW 101
// if not belkovSaved and saveBelkovObjective then
19103: LD_EXP 37
19107: NOT
19108: PUSH
19109: LD_EXP 36
19113: AND
19114: IFFALSE 19127
// AddMedal ( Belkov , - 2 ) ;
19116: LD_STRING Belkov
19118: PPUSH
19119: LD_INT 2
19121: NEG
19122: PPUSH
19123: CALL_OW 101
// if belkovSaved and ( belkovReturn and IsDead ( Belkov ) ) or ( not belkovReturn and IsDead ( Belkov2 ) ) then
19127: LD_EXP 37
19131: PUSH
19132: LD_EXP 6
19136: PUSH
19137: LD_EXP 64
19141: PPUSH
19142: CALL_OW 301
19146: AND
19147: AND
19148: PUSH
19149: LD_EXP 6
19153: NOT
19154: PUSH
19155: LD_EXP 68
19159: PPUSH
19160: CALL_OW 301
19164: AND
19165: OR
19166: IFFALSE 19179
// AddMedal ( Belkov , - 2 ) ;
19168: LD_STRING Belkov
19170: PPUSH
19171: LD_INT 2
19173: NEG
19174: PPUSH
19175: CALL_OW 101
// if lostComradesCounter = 0 then
19179: LD_EXP 43
19183: PUSH
19184: LD_INT 0
19186: EQUAL
19187: IFFALSE 19201
// AddMedal ( NoLosses , 1 ) else
19189: LD_STRING NoLosses
19191: PPUSH
19192: LD_INT 1
19194: PPUSH
19195: CALL_OW 101
19199: GO 19211
// AddMedal ( NoLosses , 0 ) ;
19201: LD_STRING NoLosses
19203: PPUSH
19204: LD_INT 0
19206: PPUSH
19207: CALL_OW 101
// GiveMedals ( Main ) ;
19211: LD_STRING Main
19213: PPUSH
19214: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
19218: LD_INT 22
19220: PUSH
19221: LD_INT 3
19223: PUSH
19224: EMPTY
19225: LIST
19226: LIST
19227: PUSH
19228: LD_INT 21
19230: PUSH
19231: LD_INT 1
19233: PUSH
19234: EMPTY
19235: LIST
19236: LIST
19237: PUSH
19238: EMPTY
19239: LIST
19240: LIST
19241: PPUSH
19242: CALL_OW 69
19246: PPUSH
19247: CALL_OW 43
// end ;
19251: LD_VAR 0 1
19255: RET
// function SavePlayerCharacters ; var othersYour ; begin
19256: LD_INT 0
19258: PPUSH
19259: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
19260: LD_EXP 62
19264: PPUSH
19265: LD_STRING Burlak
19267: PPUSH
19268: LD_INT 3
19270: PPUSH
19271: CALL 4272 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
19275: LD_EXP 63
19279: PPUSH
19280: LD_STRING Gnyevko
19282: PPUSH
19283: LD_INT 3
19285: PPUSH
19286: CALL 4272 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
19290: LD_EXP 70
19294: PPUSH
19295: LD_STRING Kovalyuk
19297: PPUSH
19298: LD_INT 3
19300: PPUSH
19301: CALL 4272 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
19305: LD_EXP 64
19309: PPUSH
19310: LD_STRING Belkov
19312: PPUSH
19313: LD_INT 3
19315: PPUSH
19316: CALL 4272 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
19320: LD_EXP 68
19324: PPUSH
19325: LD_STRING Belkov2
19327: PPUSH
19328: LD_INT 3
19330: PPUSH
19331: CALL 4272 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
19335: LD_EXP 65
19339: PPUSH
19340: LD_STRING Kirilenkova
19342: PPUSH
19343: LD_INT 3
19345: PPUSH
19346: CALL 4272 0 3
// othersYour = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko , Belkov , Belkov2 , Kovalyuk , Kirilenkova ] ;
19350: LD_ADDR_VAR 0 2
19354: PUSH
19355: LD_INT 22
19357: PUSH
19358: LD_INT 3
19360: PUSH
19361: EMPTY
19362: LIST
19363: LIST
19364: PUSH
19365: LD_INT 21
19367: PUSH
19368: LD_INT 1
19370: PUSH
19371: EMPTY
19372: LIST
19373: LIST
19374: PUSH
19375: EMPTY
19376: LIST
19377: LIST
19378: PPUSH
19379: CALL_OW 69
19383: PUSH
19384: LD_EXP 62
19388: PUSH
19389: LD_EXP 63
19393: PUSH
19394: LD_EXP 64
19398: PUSH
19399: LD_EXP 68
19403: PUSH
19404: LD_EXP 70
19408: PUSH
19409: LD_EXP 65
19413: PUSH
19414: EMPTY
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: LIST
19420: LIST
19421: DIFF
19422: ST_TO_ADDR
// ExtSaveCharacters ( othersYour , other_survivors , 3 ) ;
19423: LD_VAR 0 2
19427: PPUSH
19428: LD_STRING other_survivors
19430: PPUSH
19431: LD_INT 3
19433: PPUSH
19434: CALL 4328 0 3
// ExtSaveCharacters ( platSoldiers , other_beria , 6 ) ;
19438: LD_EXP 77
19442: PPUSH
19443: LD_STRING other_beria
19445: PPUSH
19446: LD_INT 6
19448: PPUSH
19449: CALL 4328 0 3
// ExtSaveCharacters ( otherKirovUnits , other_kirov , 6 ) ;
19453: LD_EXP 69
19457: PPUSH
19458: LD_STRING other_kirov
19460: PPUSH
19461: LD_INT 6
19463: PPUSH
19464: CALL 4328 0 3
// end ;
19468: LD_VAR 0 1
19472: RET
// function SaveGlobalVariables ; var vehicles ; begin
19473: LD_INT 0
19475: PPUSH
19476: PPUSH
// vehicles = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
19477: LD_ADDR_VAR 0 2
19481: PUSH
19482: LD_INT 22
19484: PUSH
19485: LD_INT 3
19487: PUSH
19488: EMPTY
19489: LIST
19490: LIST
19491: PUSH
19492: LD_INT 21
19494: PUSH
19495: LD_INT 2
19497: PUSH
19498: EMPTY
19499: LIST
19500: LIST
19501: PUSH
19502: LD_INT 50
19504: PUSH
19505: EMPTY
19506: LIST
19507: PUSH
19508: EMPTY
19509: LIST
19510: LIST
19511: LIST
19512: PPUSH
19513: CALL_OW 69
19517: ST_TO_ADDR
// if vehicles then
19518: LD_VAR 0 2
19522: IFFALSE 19536
// SaveVehicles ( vehicles , 02_Vehicles_1 ) ;
19524: LD_VAR 0 2
19528: PPUSH
19529: LD_STRING 02_Vehicles_1
19531: PPUSH
19532: CALL 5322 0 2
// SaveBase ( FilterUnitsInArea ( BeriaBaseArea , [ [ f_type , unit_building ] ] ) , 02_BeriaBase_2 ) ;
19536: LD_INT 8
19538: PPUSH
19539: LD_INT 21
19541: PUSH
19542: LD_INT 3
19544: PUSH
19545: EMPTY
19546: LIST
19547: LIST
19548: PUSH
19549: EMPTY
19550: LIST
19551: PPUSH
19552: CALL_OW 70
19556: PPUSH
19557: LD_STRING 02_BeriaBase_2
19559: PPUSH
19560: CALL 5465 0 2
// SaveBase ( FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) , 02_KirovBase_3 ) ;
19564: LD_INT 9
19566: PPUSH
19567: LD_INT 22
19569: PUSH
19570: LD_INT 6
19572: PUSH
19573: EMPTY
19574: LIST
19575: LIST
19576: PUSH
19577: LD_INT 21
19579: PUSH
19580: LD_INT 3
19582: PUSH
19583: EMPTY
19584: LIST
19585: LIST
19586: PUSH
19587: EMPTY
19588: LIST
19589: LIST
19590: PPUSH
19591: CALL_OW 70
19595: PPUSH
19596: LD_STRING 02_KirovBase_3
19598: PPUSH
19599: CALL 5465 0 2
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_ok ] , [ f_not , [ f_inarea , BeriaBaseArea ] ] ] ) , 02_OtherBuildings_4 ) ;
19603: LD_INT 22
19605: PUSH
19606: LD_INT 3
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: PUSH
19613: LD_INT 21
19615: PUSH
19616: LD_INT 3
19618: PUSH
19619: EMPTY
19620: LIST
19621: LIST
19622: PUSH
19623: LD_INT 50
19625: PUSH
19626: EMPTY
19627: LIST
19628: PUSH
19629: LD_INT 3
19631: PUSH
19632: LD_INT 95
19634: PUSH
19635: LD_INT 8
19637: PUSH
19638: EMPTY
19639: LIST
19640: LIST
19641: PUSH
19642: EMPTY
19643: LIST
19644: LIST
19645: PUSH
19646: EMPTY
19647: LIST
19648: LIST
19649: LIST
19650: LIST
19651: PPUSH
19652: CALL_OW 69
19656: PPUSH
19657: LD_STRING 02_OtherBuildings_4
19659: PPUSH
19660: CALL 5465 0 2
// SaveBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_ok ] , [ f_nation , nation_american ] ] ) , 02_AmericanBuildings_5 ) ;
19664: LD_INT 22
19666: PUSH
19667: LD_INT 1
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: PUSH
19674: LD_INT 21
19676: PUSH
19677: LD_INT 3
19679: PUSH
19680: EMPTY
19681: LIST
19682: LIST
19683: PUSH
19684: LD_INT 50
19686: PUSH
19687: EMPTY
19688: LIST
19689: PUSH
19690: LD_INT 23
19692: PUSH
19693: LD_INT 1
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PUSH
19700: EMPTY
19701: LIST
19702: LIST
19703: LIST
19704: LIST
19705: PPUSH
19706: CALL_OW 69
19710: PPUSH
19711: LD_STRING 02_AmericanBuildings_5
19713: PPUSH
19714: CALL 5465 0 2
// SaveVariable ( meetBelkovBrother , 02_MeetBelkovBrother_6 ) ;
19718: LD_EXP 4
19722: PPUSH
19723: LD_STRING 02_MeetBelkovBrother_6
19725: PPUSH
19726: CALL_OW 39
// SaveVariable ( GetResourceType ( GetBase ( beria ) , mat_cans ) , 02_BeriaResourceCrates_7 ) ;
19730: LD_INT 106
19732: PPUSH
19733: CALL_OW 274
19737: PPUSH
19738: LD_INT 1
19740: PPUSH
19741: CALL_OW 275
19745: PPUSH
19746: LD_STRING 02_BeriaResourceCrates_7
19748: PPUSH
19749: CALL_OW 39
// SaveVariable ( GetResourceType ( GetBase ( beria ) , mat_oil ) , 02_BeriaResourceOil_8 ) ;
19753: LD_INT 106
19755: PPUSH
19756: CALL_OW 274
19760: PPUSH
19761: LD_INT 2
19763: PPUSH
19764: CALL_OW 275
19768: PPUSH
19769: LD_STRING 02_BeriaResourceOil_8
19771: PPUSH
19772: CALL_OW 39
// SaveVariable ( platonovOpinion , 02_PlatonovOpinion_9 ) ;
19776: LD_EXP 5
19780: PPUSH
19781: LD_STRING 02_PlatonovOpinion_9
19783: PPUSH
19784: CALL_OW 39
// end ; end_of_file
19788: LD_VAR 0 1
19792: RET
// export function BurlakIsDead ; begin
19793: LD_INT 0
19795: PPUSH
// YouLost ( Burlak ) ;
19796: LD_STRING Burlak
19798: PPUSH
19799: CALL_OW 104
// end ;
19803: LD_VAR 0 1
19807: RET
// export function AttackComrades ; begin
19808: LD_INT 0
19810: PPUSH
// YouLost ( SelfAttack ) ;
19811: LD_STRING SelfAttack
19813: PPUSH
19814: CALL_OW 104
// end ; end_of_file
19818: LD_VAR 0 1
19822: RET
// every 0 0$1 do var engs ;
19823: GO 19825
19825: DISABLE
19826: LD_INT 0
19828: PPUSH
// begin engs = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) ;
19829: LD_ADDR_VAR 0 1
19833: PUSH
19834: LD_EXP 69
19838: PPUSH
19839: LD_INT 25
19841: PUSH
19842: LD_INT 2
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: PPUSH
19849: CALL_OW 72
19853: ST_TO_ADDR
// ComExitBuilding ( engs ) ;
19854: LD_VAR 0 1
19858: PPUSH
19859: CALL_OW 122
// wait ( 0 0$1 ) ;
19863: LD_INT 35
19865: PPUSH
19866: CALL_OW 67
// AddComBuild ( engs , b_breastwork , 146 , 107 , 1 ) ;
19870: LD_VAR 0 1
19874: PPUSH
19875: LD_INT 31
19877: PPUSH
19878: LD_INT 146
19880: PPUSH
19881: LD_INT 107
19883: PPUSH
19884: LD_INT 1
19886: PPUSH
19887: CALL_OW 205
// AddComBuild ( engs , b_breastwork , 176 , 123 , 5 ) ;
19891: LD_VAR 0 1
19895: PPUSH
19896: LD_INT 31
19898: PPUSH
19899: LD_INT 176
19901: PPUSH
19902: LD_INT 123
19904: PPUSH
19905: LD_INT 5
19907: PPUSH
19908: CALL_OW 205
// AddComBuild ( engs , b_breastwork , 170 , 102 , 4 ) ;
19912: LD_VAR 0 1
19916: PPUSH
19917: LD_INT 31
19919: PPUSH
19920: LD_INT 170
19922: PPUSH
19923: LD_INT 102
19925: PPUSH
19926: LD_INT 4
19928: PPUSH
19929: CALL_OW 205
// AddComBuild ( engs , b_breastwork , 173 , 105 , 4 ) ;
19933: LD_VAR 0 1
19937: PPUSH
19938: LD_INT 31
19940: PPUSH
19941: LD_INT 173
19943: PPUSH
19944: LD_INT 105
19946: PPUSH
19947: LD_INT 4
19949: PPUSH
19950: CALL_OW 205
// AddComEnterUnit ( engs , kirov ) ;
19954: LD_VAR 0 1
19958: PPUSH
19959: LD_INT 71
19961: PPUSH
19962: CALL_OW 180
// end ;
19966: PPOPN 1
19968: END
// every 0 0$1 trigger activateAMAI do
19969: LD_EXP 27
19973: IFFALSE 19997
19975: GO 19977
19977: DISABLE
// begin enable ;
19978: ENABLE
// RepairDamageLeftBunkers ;
19979: CALL 19998 0 0
// if Difficulty = 3 then
19983: LD_OWVAR 67
19987: PUSH
19988: LD_INT 3
19990: EQUAL
19991: IFFALSE 19997
// RepairDamageRightBunkers ;
19993: CALL 20206 0 0
// end ;
19997: END
// function RepairDamageLeftBunkers ; var eng , bunker ; begin
19998: LD_INT 0
20000: PPUSH
20001: PPUSH
20002: PPUSH
// if not amLeftEngs or FilterUnitsInArea ( LeftHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 then
20003: LD_EXP 86
20007: NOT
20008: PUSH
20009: LD_INT 17
20011: PPUSH
20012: LD_INT 22
20014: PUSH
20015: LD_INT 1
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: PUSH
20022: LD_INT 21
20024: PUSH
20025: LD_INT 3
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: LD_INT 30
20034: PUSH
20035: LD_INT 31
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: LD_INT 3
20044: PUSH
20045: LD_INT 24
20047: PUSH
20048: LD_INT 1000
20050: PUSH
20051: EMPTY
20052: LIST
20053: LIST
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: PUSH
20059: EMPTY
20060: LIST
20061: LIST
20062: LIST
20063: LIST
20064: PPUSH
20065: CALL_OW 70
20069: PUSH
20070: LD_INT 0
20072: EQUAL
20073: OR
20074: IFFALSE 20078
// exit ;
20076: GO 20201
// ComExitBuilding ( UnitFilter ( amLeftEngs , [ f_not , [ f_hastask ] ] ) ) ;
20078: LD_EXP 86
20082: PPUSH
20083: LD_INT 3
20085: PUSH
20086: LD_INT 60
20088: PUSH
20089: EMPTY
20090: LIST
20091: PUSH
20092: EMPTY
20093: LIST
20094: LIST
20095: PPUSH
20096: CALL_OW 72
20100: PPUSH
20101: CALL_OW 122
// for bunker in leftBunkers do
20105: LD_ADDR_VAR 0 3
20109: PUSH
20110: LD_EXP 82
20114: PUSH
20115: FOR_IN
20116: IFFALSE 20167
// if GetLives ( bunker ) < 1000 then
20118: LD_VAR 0 3
20122: PPUSH
20123: CALL_OW 256
20127: PUSH
20128: LD_INT 1000
20130: LESS
20131: IFFALSE 20165
// AddComRepairBuilding ( UnitFilter ( amLeftEngs , [ f_not , [ f_hastask ] ] ) , bunker ) ;
20133: LD_EXP 86
20137: PPUSH
20138: LD_INT 3
20140: PUSH
20141: LD_INT 60
20143: PUSH
20144: EMPTY
20145: LIST
20146: PUSH
20147: EMPTY
20148: LIST
20149: LIST
20150: PPUSH
20151: CALL_OW 72
20155: PPUSH
20156: LD_VAR 0 3
20160: PPUSH
20161: CALL_OW 190
20165: GO 20115
20167: POP
20168: POP
// AddComEnterUnit ( UnitFilter ( amLeftEngs , [ f_not , [ f_hastask ] ] ) , amLeftDepot ) ;
20169: LD_EXP 86
20173: PPUSH
20174: LD_INT 3
20176: PUSH
20177: LD_INT 60
20179: PUSH
20180: EMPTY
20181: LIST
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: PPUSH
20187: CALL_OW 72
20191: PPUSH
20192: LD_EXP 84
20196: PPUSH
20197: CALL_OW 180
// end ;
20201: LD_VAR 0 1
20205: RET
// function RepairDamageRightBunkers ; var eng , bunker ; begin
20206: LD_INT 0
20208: PPUSH
20209: PPUSH
20210: PPUSH
// if not amRightEngs or FilterUnitsInArea ( RightHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 then
20211: LD_EXP 87
20215: NOT
20216: PUSH
20217: LD_INT 16
20219: PPUSH
20220: LD_INT 22
20222: PUSH
20223: LD_INT 1
20225: PUSH
20226: EMPTY
20227: LIST
20228: LIST
20229: PUSH
20230: LD_INT 21
20232: PUSH
20233: LD_INT 3
20235: PUSH
20236: EMPTY
20237: LIST
20238: LIST
20239: PUSH
20240: LD_INT 30
20242: PUSH
20243: LD_INT 31
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: PUSH
20250: LD_INT 3
20252: PUSH
20253: LD_INT 24
20255: PUSH
20256: LD_INT 1000
20258: PUSH
20259: EMPTY
20260: LIST
20261: LIST
20262: PUSH
20263: EMPTY
20264: LIST
20265: LIST
20266: PUSH
20267: EMPTY
20268: LIST
20269: LIST
20270: LIST
20271: LIST
20272: PPUSH
20273: CALL_OW 70
20277: PUSH
20278: LD_INT 0
20280: EQUAL
20281: OR
20282: IFFALSE 20286
// exit ;
20284: GO 20409
// ComExitBuilding ( UnitFilter ( amRightEngs , [ f_not , [ f_hastask ] ] ) ) ;
20286: LD_EXP 87
20290: PPUSH
20291: LD_INT 3
20293: PUSH
20294: LD_INT 60
20296: PUSH
20297: EMPTY
20298: LIST
20299: PUSH
20300: EMPTY
20301: LIST
20302: LIST
20303: PPUSH
20304: CALL_OW 72
20308: PPUSH
20309: CALL_OW 122
// for bunker in rightBunkers do
20313: LD_ADDR_VAR 0 3
20317: PUSH
20318: LD_EXP 83
20322: PUSH
20323: FOR_IN
20324: IFFALSE 20375
// if GetLives ( bunker ) < 1000 then
20326: LD_VAR 0 3
20330: PPUSH
20331: CALL_OW 256
20335: PUSH
20336: LD_INT 1000
20338: LESS
20339: IFFALSE 20373
// AddComRepairBuilding ( UnitFilter ( amRightEngs , [ f_not , [ f_hastask ] ] ) , bunker ) ;
20341: LD_EXP 87
20345: PPUSH
20346: LD_INT 3
20348: PUSH
20349: LD_INT 60
20351: PUSH
20352: EMPTY
20353: LIST
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: PPUSH
20359: CALL_OW 72
20363: PPUSH
20364: LD_VAR 0 3
20368: PPUSH
20369: CALL_OW 190
20373: GO 20323
20375: POP
20376: POP
// AddComEnterUnit ( UnitFilter ( amRightEngs , [ f_not , [ f_hastask ] ] ) , amRightDepot ) ;
20377: LD_EXP 87
20381: PPUSH
20382: LD_INT 3
20384: PUSH
20385: LD_INT 60
20387: PUSH
20388: EMPTY
20389: LIST
20390: PUSH
20391: EMPTY
20392: LIST
20393: LIST
20394: PPUSH
20395: CALL_OW 72
20399: PPUSH
20400: LD_EXP 85
20404: PPUSH
20405: CALL_OW 180
// end ;
20409: LD_VAR 0 1
20413: RET
// every 0 0$1 trigger activateBelkovAI and belkovTeam do var unit , med , damaged ;
20414: LD_EXP 28
20418: PUSH
20419: LD_EXP 73
20423: AND
20424: IFFALSE 20561
20426: GO 20428
20428: DISABLE
20429: LD_INT 0
20431: PPUSH
20432: PPUSH
20433: PPUSH
// begin enable ;
20434: ENABLE
// med = UnitFilter ( belkovTeam , [ f_class , class_scientistic ] ) ;
20435: LD_ADDR_VAR 0 2
20439: PUSH
20440: LD_EXP 73
20444: PPUSH
20445: LD_INT 25
20447: PUSH
20448: LD_INT 4
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: PPUSH
20455: CALL_OW 72
20459: ST_TO_ADDR
// damaged = UnitFilter ( belkovTeam , [ f_not , [ f_lives , 650 ] ] ) ;
20460: LD_ADDR_VAR 0 3
20464: PUSH
20465: LD_EXP 73
20469: PPUSH
20470: LD_INT 3
20472: PUSH
20473: LD_INT 24
20475: PUSH
20476: LD_INT 650
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: PUSH
20483: EMPTY
20484: LIST
20485: LIST
20486: PPUSH
20487: CALL_OW 72
20491: ST_TO_ADDR
// if not damaged and med then
20492: LD_VAR 0 3
20496: NOT
20497: PUSH
20498: LD_VAR 0 2
20502: AND
20503: IFFALSE 20522
// ComMoveXY ( med , 83 , 17 ) else
20505: LD_VAR 0 2
20509: PPUSH
20510: LD_INT 83
20512: PPUSH
20513: LD_INT 17
20515: PPUSH
20516: CALL_OW 111
20520: GO 20561
// if med then
20522: LD_VAR 0 2
20526: IFFALSE 20561
// begin ComMoveXY ( damaged , 83 , 17 ) ;
20528: LD_VAR 0 3
20532: PPUSH
20533: LD_INT 83
20535: PPUSH
20536: LD_INT 17
20538: PPUSH
20539: CALL_OW 111
// ComHeal ( med , damaged [ 1 ] ) ;
20543: LD_VAR 0 2
20547: PPUSH
20548: LD_VAR 0 3
20552: PUSH
20553: LD_INT 1
20555: ARRAY
20556: PPUSH
20557: CALL_OW 128
// end ; end ; end_of_file
20561: PPOPN 3
20563: END
// every 1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_american ] , [ f_btype , b_depot ] ] ) = 2 do
20564: LD_INT 22
20566: PUSH
20567: LD_INT 3
20569: PUSH
20570: EMPTY
20571: LIST
20572: LIST
20573: PUSH
20574: LD_INT 23
20576: PUSH
20577: LD_INT 1
20579: PUSH
20580: EMPTY
20581: LIST
20582: LIST
20583: PUSH
20584: LD_INT 30
20586: PUSH
20587: LD_INT 0
20589: PUSH
20590: EMPTY
20591: LIST
20592: LIST
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: LIST
20598: PPUSH
20599: CALL_OW 69
20603: PUSH
20604: LD_INT 2
20606: EQUAL
20607: IFFALSE 20619
20609: GO 20611
20611: DISABLE
// SetAchievement ( ACH_DEPOT ) ;
20612: LD_STRING ACH_DEPOT
20614: PPUSH
20615: CALL_OW 543
20619: END
// every 1 trigger achievement_ConstructVehicles = 5 do
20620: LD_EXP 44
20624: PUSH
20625: LD_INT 5
20627: EQUAL
20628: IFFALSE 20640
20630: GO 20632
20632: DISABLE
// SetAchievement ( ACH_WORKSHOP ) ;
20633: LD_STRING ACH_WORKSHOP
20635: PPUSH
20636: CALL_OW 543
20640: END
// every 1 trigger captureBelkovVehicle do
20641: LD_EXP 38
20645: IFFALSE 20657
20647: GO 20649
20649: DISABLE
// SetAchievement ( ACH_RETAKE ) ; end_of_file
20650: LD_STRING ACH_RETAKE
20652: PPUSH
20653: CALL_OW 543
20657: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
20658: LD_VAR 0 2
20662: PUSH
20663: LD_INT 100
20665: EQUAL
20666: IFFALSE 21615
// begin if not StreamModeActive then
20668: LD_EXP 90
20672: NOT
20673: IFFALSE 20683
// StreamModeActive := true ;
20675: LD_ADDR_EXP 90
20679: PUSH
20680: LD_INT 1
20682: ST_TO_ADDR
// if p3 = 0 then
20683: LD_VAR 0 3
20687: PUSH
20688: LD_INT 0
20690: EQUAL
20691: IFFALSE 20697
// InitStreamMode ;
20693: CALL 21848 0 0
// if p3 = 1 then
20697: LD_VAR 0 3
20701: PUSH
20702: LD_INT 1
20704: EQUAL
20705: IFFALSE 20715
// sRocket := true ;
20707: LD_ADDR_EXP 95
20711: PUSH
20712: LD_INT 1
20714: ST_TO_ADDR
// if p3 = 2 then
20715: LD_VAR 0 3
20719: PUSH
20720: LD_INT 2
20722: EQUAL
20723: IFFALSE 20733
// sSpeed := true ;
20725: LD_ADDR_EXP 94
20729: PUSH
20730: LD_INT 1
20732: ST_TO_ADDR
// if p3 = 3 then
20733: LD_VAR 0 3
20737: PUSH
20738: LD_INT 3
20740: EQUAL
20741: IFFALSE 20751
// sEngine := true ;
20743: LD_ADDR_EXP 96
20747: PUSH
20748: LD_INT 1
20750: ST_TO_ADDR
// if p3 = 4 then
20751: LD_VAR 0 3
20755: PUSH
20756: LD_INT 4
20758: EQUAL
20759: IFFALSE 20769
// sSpec := true ;
20761: LD_ADDR_EXP 93
20765: PUSH
20766: LD_INT 1
20768: ST_TO_ADDR
// if p3 = 5 then
20769: LD_VAR 0 3
20773: PUSH
20774: LD_INT 5
20776: EQUAL
20777: IFFALSE 20787
// sLevel := true ;
20779: LD_ADDR_EXP 97
20783: PUSH
20784: LD_INT 1
20786: ST_TO_ADDR
// if p3 = 6 then
20787: LD_VAR 0 3
20791: PUSH
20792: LD_INT 6
20794: EQUAL
20795: IFFALSE 20805
// sArmoury := true ;
20797: LD_ADDR_EXP 98
20801: PUSH
20802: LD_INT 1
20804: ST_TO_ADDR
// if p3 = 7 then
20805: LD_VAR 0 3
20809: PUSH
20810: LD_INT 7
20812: EQUAL
20813: IFFALSE 20823
// sRadar := true ;
20815: LD_ADDR_EXP 99
20819: PUSH
20820: LD_INT 1
20822: ST_TO_ADDR
// if p3 = 8 then
20823: LD_VAR 0 3
20827: PUSH
20828: LD_INT 8
20830: EQUAL
20831: IFFALSE 20841
// sBunker := true ;
20833: LD_ADDR_EXP 100
20837: PUSH
20838: LD_INT 1
20840: ST_TO_ADDR
// if p3 = 9 then
20841: LD_VAR 0 3
20845: PUSH
20846: LD_INT 9
20848: EQUAL
20849: IFFALSE 20859
// sHack := true ;
20851: LD_ADDR_EXP 101
20855: PUSH
20856: LD_INT 1
20858: ST_TO_ADDR
// if p3 = 10 then
20859: LD_VAR 0 3
20863: PUSH
20864: LD_INT 10
20866: EQUAL
20867: IFFALSE 20877
// sFire := true ;
20869: LD_ADDR_EXP 102
20873: PUSH
20874: LD_INT 1
20876: ST_TO_ADDR
// if p3 = 11 then
20877: LD_VAR 0 3
20881: PUSH
20882: LD_INT 11
20884: EQUAL
20885: IFFALSE 20895
// sRefresh := true ;
20887: LD_ADDR_EXP 103
20891: PUSH
20892: LD_INT 1
20894: ST_TO_ADDR
// if p3 = 12 then
20895: LD_VAR 0 3
20899: PUSH
20900: LD_INT 12
20902: EQUAL
20903: IFFALSE 20913
// sExp := true ;
20905: LD_ADDR_EXP 104
20909: PUSH
20910: LD_INT 1
20912: ST_TO_ADDR
// if p3 = 13 then
20913: LD_VAR 0 3
20917: PUSH
20918: LD_INT 13
20920: EQUAL
20921: IFFALSE 20931
// sDepot := true ;
20923: LD_ADDR_EXP 105
20927: PUSH
20928: LD_INT 1
20930: ST_TO_ADDR
// if p3 = 14 then
20931: LD_VAR 0 3
20935: PUSH
20936: LD_INT 14
20938: EQUAL
20939: IFFALSE 20949
// sFlag := true ;
20941: LD_ADDR_EXP 106
20945: PUSH
20946: LD_INT 1
20948: ST_TO_ADDR
// if p3 = 15 then
20949: LD_VAR 0 3
20953: PUSH
20954: LD_INT 15
20956: EQUAL
20957: IFFALSE 20967
// sKamikadze := true ;
20959: LD_ADDR_EXP 114
20963: PUSH
20964: LD_INT 1
20966: ST_TO_ADDR
// if p3 = 16 then
20967: LD_VAR 0 3
20971: PUSH
20972: LD_INT 16
20974: EQUAL
20975: IFFALSE 20985
// sTroll := true ;
20977: LD_ADDR_EXP 115
20981: PUSH
20982: LD_INT 1
20984: ST_TO_ADDR
// if p3 = 17 then
20985: LD_VAR 0 3
20989: PUSH
20990: LD_INT 17
20992: EQUAL
20993: IFFALSE 21003
// sSlow := true ;
20995: LD_ADDR_EXP 116
20999: PUSH
21000: LD_INT 1
21002: ST_TO_ADDR
// if p3 = 18 then
21003: LD_VAR 0 3
21007: PUSH
21008: LD_INT 18
21010: EQUAL
21011: IFFALSE 21021
// sLack := true ;
21013: LD_ADDR_EXP 117
21017: PUSH
21018: LD_INT 1
21020: ST_TO_ADDR
// if p3 = 19 then
21021: LD_VAR 0 3
21025: PUSH
21026: LD_INT 19
21028: EQUAL
21029: IFFALSE 21039
// sTank := true ;
21031: LD_ADDR_EXP 119
21035: PUSH
21036: LD_INT 1
21038: ST_TO_ADDR
// if p3 = 20 then
21039: LD_VAR 0 3
21043: PUSH
21044: LD_INT 20
21046: EQUAL
21047: IFFALSE 21057
// sRemote := true ;
21049: LD_ADDR_EXP 120
21053: PUSH
21054: LD_INT 1
21056: ST_TO_ADDR
// if p3 = 21 then
21057: LD_VAR 0 3
21061: PUSH
21062: LD_INT 21
21064: EQUAL
21065: IFFALSE 21075
// sPowell := true ;
21067: LD_ADDR_EXP 121
21071: PUSH
21072: LD_INT 1
21074: ST_TO_ADDR
// if p3 = 22 then
21075: LD_VAR 0 3
21079: PUSH
21080: LD_INT 22
21082: EQUAL
21083: IFFALSE 21093
// sTeleport := true ;
21085: LD_ADDR_EXP 124
21089: PUSH
21090: LD_INT 1
21092: ST_TO_ADDR
// if p3 = 23 then
21093: LD_VAR 0 3
21097: PUSH
21098: LD_INT 23
21100: EQUAL
21101: IFFALSE 21111
// sOilTower := true ;
21103: LD_ADDR_EXP 126
21107: PUSH
21108: LD_INT 1
21110: ST_TO_ADDR
// if p3 = 24 then
21111: LD_VAR 0 3
21115: PUSH
21116: LD_INT 24
21118: EQUAL
21119: IFFALSE 21129
// sShovel := true ;
21121: LD_ADDR_EXP 127
21125: PUSH
21126: LD_INT 1
21128: ST_TO_ADDR
// if p3 = 25 then
21129: LD_VAR 0 3
21133: PUSH
21134: LD_INT 25
21136: EQUAL
21137: IFFALSE 21147
// sSheik := true ;
21139: LD_ADDR_EXP 128
21143: PUSH
21144: LD_INT 1
21146: ST_TO_ADDR
// if p3 = 26 then
21147: LD_VAR 0 3
21151: PUSH
21152: LD_INT 26
21154: EQUAL
21155: IFFALSE 21165
// sEarthquake := true ;
21157: LD_ADDR_EXP 130
21161: PUSH
21162: LD_INT 1
21164: ST_TO_ADDR
// if p3 = 27 then
21165: LD_VAR 0 3
21169: PUSH
21170: LD_INT 27
21172: EQUAL
21173: IFFALSE 21183
// sAI := true ;
21175: LD_ADDR_EXP 131
21179: PUSH
21180: LD_INT 1
21182: ST_TO_ADDR
// if p3 = 28 then
21183: LD_VAR 0 3
21187: PUSH
21188: LD_INT 28
21190: EQUAL
21191: IFFALSE 21201
// sCargo := true ;
21193: LD_ADDR_EXP 134
21197: PUSH
21198: LD_INT 1
21200: ST_TO_ADDR
// if p3 = 29 then
21201: LD_VAR 0 3
21205: PUSH
21206: LD_INT 29
21208: EQUAL
21209: IFFALSE 21219
// sDLaser := true ;
21211: LD_ADDR_EXP 135
21215: PUSH
21216: LD_INT 1
21218: ST_TO_ADDR
// if p3 = 30 then
21219: LD_VAR 0 3
21223: PUSH
21224: LD_INT 30
21226: EQUAL
21227: IFFALSE 21237
// sExchange := true ;
21229: LD_ADDR_EXP 136
21233: PUSH
21234: LD_INT 1
21236: ST_TO_ADDR
// if p3 = 31 then
21237: LD_VAR 0 3
21241: PUSH
21242: LD_INT 31
21244: EQUAL
21245: IFFALSE 21255
// sFac := true ;
21247: LD_ADDR_EXP 137
21251: PUSH
21252: LD_INT 1
21254: ST_TO_ADDR
// if p3 = 32 then
21255: LD_VAR 0 3
21259: PUSH
21260: LD_INT 32
21262: EQUAL
21263: IFFALSE 21273
// sPower := true ;
21265: LD_ADDR_EXP 138
21269: PUSH
21270: LD_INT 1
21272: ST_TO_ADDR
// if p3 = 33 then
21273: LD_VAR 0 3
21277: PUSH
21278: LD_INT 33
21280: EQUAL
21281: IFFALSE 21291
// sRandom := true ;
21283: LD_ADDR_EXP 139
21287: PUSH
21288: LD_INT 1
21290: ST_TO_ADDR
// if p3 = 34 then
21291: LD_VAR 0 3
21295: PUSH
21296: LD_INT 34
21298: EQUAL
21299: IFFALSE 21309
// sShield := true ;
21301: LD_ADDR_EXP 140
21305: PUSH
21306: LD_INT 1
21308: ST_TO_ADDR
// if p3 = 35 then
21309: LD_VAR 0 3
21313: PUSH
21314: LD_INT 35
21316: EQUAL
21317: IFFALSE 21327
// sTime := true ;
21319: LD_ADDR_EXP 141
21323: PUSH
21324: LD_INT 1
21326: ST_TO_ADDR
// if p3 = 36 then
21327: LD_VAR 0 3
21331: PUSH
21332: LD_INT 36
21334: EQUAL
21335: IFFALSE 21345
// sTools := true ;
21337: LD_ADDR_EXP 142
21341: PUSH
21342: LD_INT 1
21344: ST_TO_ADDR
// if p3 = 101 then
21345: LD_VAR 0 3
21349: PUSH
21350: LD_INT 101
21352: EQUAL
21353: IFFALSE 21363
// sSold := true ;
21355: LD_ADDR_EXP 107
21359: PUSH
21360: LD_INT 1
21362: ST_TO_ADDR
// if p3 = 102 then
21363: LD_VAR 0 3
21367: PUSH
21368: LD_INT 102
21370: EQUAL
21371: IFFALSE 21381
// sDiff := true ;
21373: LD_ADDR_EXP 108
21377: PUSH
21378: LD_INT 1
21380: ST_TO_ADDR
// if p3 = 103 then
21381: LD_VAR 0 3
21385: PUSH
21386: LD_INT 103
21388: EQUAL
21389: IFFALSE 21399
// sFog := true ;
21391: LD_ADDR_EXP 111
21395: PUSH
21396: LD_INT 1
21398: ST_TO_ADDR
// if p3 = 104 then
21399: LD_VAR 0 3
21403: PUSH
21404: LD_INT 104
21406: EQUAL
21407: IFFALSE 21417
// sReset := true ;
21409: LD_ADDR_EXP 112
21413: PUSH
21414: LD_INT 1
21416: ST_TO_ADDR
// if p3 = 105 then
21417: LD_VAR 0 3
21421: PUSH
21422: LD_INT 105
21424: EQUAL
21425: IFFALSE 21435
// sSun := true ;
21427: LD_ADDR_EXP 113
21431: PUSH
21432: LD_INT 1
21434: ST_TO_ADDR
// if p3 = 106 then
21435: LD_VAR 0 3
21439: PUSH
21440: LD_INT 106
21442: EQUAL
21443: IFFALSE 21453
// sTiger := true ;
21445: LD_ADDR_EXP 109
21449: PUSH
21450: LD_INT 1
21452: ST_TO_ADDR
// if p3 = 107 then
21453: LD_VAR 0 3
21457: PUSH
21458: LD_INT 107
21460: EQUAL
21461: IFFALSE 21471
// sBomb := true ;
21463: LD_ADDR_EXP 110
21467: PUSH
21468: LD_INT 1
21470: ST_TO_ADDR
// if p3 = 108 then
21471: LD_VAR 0 3
21475: PUSH
21476: LD_INT 108
21478: EQUAL
21479: IFFALSE 21489
// sWound := true ;
21481: LD_ADDR_EXP 118
21485: PUSH
21486: LD_INT 1
21488: ST_TO_ADDR
// if p3 = 109 then
21489: LD_VAR 0 3
21493: PUSH
21494: LD_INT 109
21496: EQUAL
21497: IFFALSE 21507
// sBetray := true ;
21499: LD_ADDR_EXP 122
21503: PUSH
21504: LD_INT 1
21506: ST_TO_ADDR
// if p3 = 110 then
21507: LD_VAR 0 3
21511: PUSH
21512: LD_INT 110
21514: EQUAL
21515: IFFALSE 21525
// sContamin := true ;
21517: LD_ADDR_EXP 123
21521: PUSH
21522: LD_INT 1
21524: ST_TO_ADDR
// if p3 = 111 then
21525: LD_VAR 0 3
21529: PUSH
21530: LD_INT 111
21532: EQUAL
21533: IFFALSE 21543
// sOil := true ;
21535: LD_ADDR_EXP 125
21539: PUSH
21540: LD_INT 1
21542: ST_TO_ADDR
// if p3 = 112 then
21543: LD_VAR 0 3
21547: PUSH
21548: LD_INT 112
21550: EQUAL
21551: IFFALSE 21561
// sStu := true ;
21553: LD_ADDR_EXP 129
21557: PUSH
21558: LD_INT 1
21560: ST_TO_ADDR
// if p3 = 113 then
21561: LD_VAR 0 3
21565: PUSH
21566: LD_INT 113
21568: EQUAL
21569: IFFALSE 21579
// sBazooka := true ;
21571: LD_ADDR_EXP 132
21575: PUSH
21576: LD_INT 1
21578: ST_TO_ADDR
// if p3 = 114 then
21579: LD_VAR 0 3
21583: PUSH
21584: LD_INT 114
21586: EQUAL
21587: IFFALSE 21597
// sMortar := true ;
21589: LD_ADDR_EXP 133
21593: PUSH
21594: LD_INT 1
21596: ST_TO_ADDR
// if p3 = 115 then
21597: LD_VAR 0 3
21601: PUSH
21602: LD_INT 115
21604: EQUAL
21605: IFFALSE 21615
// sRanger := true ;
21607: LD_ADDR_EXP 143
21611: PUSH
21612: LD_INT 1
21614: ST_TO_ADDR
// end ; if p2 = 101 then
21615: LD_VAR 0 2
21619: PUSH
21620: LD_INT 101
21622: EQUAL
21623: IFFALSE 21826
// begin case p3 of 1 :
21625: LD_VAR 0 3
21629: PUSH
21630: LD_INT 1
21632: DOUBLE
21633: EQUAL
21634: IFTRUE 21638
21636: GO 21645
21638: POP
// hHackUnlimitedResources ; 2 :
21639: CALL 31920 0 0
21643: GO 21826
21645: LD_INT 2
21647: DOUBLE
21648: EQUAL
21649: IFTRUE 21653
21651: GO 21660
21653: POP
// hHackSetLevel10 ; 3 :
21654: CALL 32053 0 0
21658: GO 21826
21660: LD_INT 3
21662: DOUBLE
21663: EQUAL
21664: IFTRUE 21668
21666: GO 21675
21668: POP
// hHackSetLevel10YourUnits ; 4 :
21669: CALL 32138 0 0
21673: GO 21826
21675: LD_INT 4
21677: DOUBLE
21678: EQUAL
21679: IFTRUE 21683
21681: GO 21705
21683: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
21684: LD_VAR 0 4
21688: PPUSH
21689: LD_VAR 0 5
21693: PPUSH
21694: LD_VAR 0 6
21698: PPUSH
21699: CALL 32228 0 3
21703: GO 21826
21705: LD_INT 5
21707: DOUBLE
21708: EQUAL
21709: IFTRUE 21713
21711: GO 21720
21713: POP
// hHackSpawnVehicle ; 6 :
21714: CALL 32289 0 0
21718: GO 21826
21720: LD_INT 6
21722: DOUBLE
21723: EQUAL
21724: IFTRUE 21728
21726: GO 21735
21728: POP
// hHackInvincible ; 7 :
21729: CALL 32835 0 0
21733: GO 21826
21735: LD_INT 7
21737: DOUBLE
21738: EQUAL
21739: IFTRUE 21743
21741: GO 21750
21743: POP
// hHackInvisible ; 8 :
21744: CALL 32946 0 0
21748: GO 21826
21750: LD_INT 8
21752: DOUBLE
21753: EQUAL
21754: IFTRUE 21758
21756: GO 21765
21758: POP
// hHackChangeYourSide ; 9 :
21759: CALL 33003 0 0
21763: GO 21826
21765: LD_INT 9
21767: DOUBLE
21768: EQUAL
21769: IFTRUE 21773
21771: GO 21780
21773: POP
// hHackChangeUnitSide ; 10 :
21774: CALL 33045 0 0
21778: GO 21826
21780: LD_INT 10
21782: DOUBLE
21783: EQUAL
21784: IFTRUE 21788
21786: GO 21795
21788: POP
// hHackFog ; 11 :
21789: CALL 33146 0 0
21793: GO 21826
21795: LD_INT 11
21797: DOUBLE
21798: EQUAL
21799: IFTRUE 21803
21801: GO 21810
21803: POP
// hHackApeman ; 12 :
21804: CALL 33161 0 0
21808: GO 21826
21810: LD_INT 12
21812: DOUBLE
21813: EQUAL
21814: IFTRUE 21818
21816: GO 21825
21818: POP
// hHackBoom ; end ;
21819: CALL 33246 0 0
21823: GO 21826
21825: POP
// end ; end ;
21826: PPOPN 6
21828: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
21829: GO 21831
21831: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
21832: LD_STRING initStreamRollete();
21834: PPUSH
21835: CALL_OW 559
// InitStreamMode ;
21839: CALL 21848 0 0
// DefineStreamItems ( ) ;
21843: CALL 22288 0 0
// end ;
21847: END
// function InitStreamMode ; begin
21848: LD_INT 0
21850: PPUSH
// streamModeActive := false ;
21851: LD_ADDR_EXP 90
21855: PUSH
21856: LD_INT 0
21858: ST_TO_ADDR
// normalCounter := 36 ;
21859: LD_ADDR_EXP 91
21863: PUSH
21864: LD_INT 36
21866: ST_TO_ADDR
// hardcoreCounter := 16 ;
21867: LD_ADDR_EXP 92
21871: PUSH
21872: LD_INT 16
21874: ST_TO_ADDR
// sRocket := false ;
21875: LD_ADDR_EXP 95
21879: PUSH
21880: LD_INT 0
21882: ST_TO_ADDR
// sSpeed := false ;
21883: LD_ADDR_EXP 94
21887: PUSH
21888: LD_INT 0
21890: ST_TO_ADDR
// sEngine := false ;
21891: LD_ADDR_EXP 96
21895: PUSH
21896: LD_INT 0
21898: ST_TO_ADDR
// sSpec := false ;
21899: LD_ADDR_EXP 93
21903: PUSH
21904: LD_INT 0
21906: ST_TO_ADDR
// sLevel := false ;
21907: LD_ADDR_EXP 97
21911: PUSH
21912: LD_INT 0
21914: ST_TO_ADDR
// sArmoury := false ;
21915: LD_ADDR_EXP 98
21919: PUSH
21920: LD_INT 0
21922: ST_TO_ADDR
// sRadar := false ;
21923: LD_ADDR_EXP 99
21927: PUSH
21928: LD_INT 0
21930: ST_TO_ADDR
// sBunker := false ;
21931: LD_ADDR_EXP 100
21935: PUSH
21936: LD_INT 0
21938: ST_TO_ADDR
// sHack := false ;
21939: LD_ADDR_EXP 101
21943: PUSH
21944: LD_INT 0
21946: ST_TO_ADDR
// sFire := false ;
21947: LD_ADDR_EXP 102
21951: PUSH
21952: LD_INT 0
21954: ST_TO_ADDR
// sRefresh := false ;
21955: LD_ADDR_EXP 103
21959: PUSH
21960: LD_INT 0
21962: ST_TO_ADDR
// sExp := false ;
21963: LD_ADDR_EXP 104
21967: PUSH
21968: LD_INT 0
21970: ST_TO_ADDR
// sDepot := false ;
21971: LD_ADDR_EXP 105
21975: PUSH
21976: LD_INT 0
21978: ST_TO_ADDR
// sFlag := false ;
21979: LD_ADDR_EXP 106
21983: PUSH
21984: LD_INT 0
21986: ST_TO_ADDR
// sKamikadze := false ;
21987: LD_ADDR_EXP 114
21991: PUSH
21992: LD_INT 0
21994: ST_TO_ADDR
// sTroll := false ;
21995: LD_ADDR_EXP 115
21999: PUSH
22000: LD_INT 0
22002: ST_TO_ADDR
// sSlow := false ;
22003: LD_ADDR_EXP 116
22007: PUSH
22008: LD_INT 0
22010: ST_TO_ADDR
// sLack := false ;
22011: LD_ADDR_EXP 117
22015: PUSH
22016: LD_INT 0
22018: ST_TO_ADDR
// sTank := false ;
22019: LD_ADDR_EXP 119
22023: PUSH
22024: LD_INT 0
22026: ST_TO_ADDR
// sRemote := false ;
22027: LD_ADDR_EXP 120
22031: PUSH
22032: LD_INT 0
22034: ST_TO_ADDR
// sPowell := false ;
22035: LD_ADDR_EXP 121
22039: PUSH
22040: LD_INT 0
22042: ST_TO_ADDR
// sTeleport := false ;
22043: LD_ADDR_EXP 124
22047: PUSH
22048: LD_INT 0
22050: ST_TO_ADDR
// sOilTower := false ;
22051: LD_ADDR_EXP 126
22055: PUSH
22056: LD_INT 0
22058: ST_TO_ADDR
// sShovel := false ;
22059: LD_ADDR_EXP 127
22063: PUSH
22064: LD_INT 0
22066: ST_TO_ADDR
// sSheik := false ;
22067: LD_ADDR_EXP 128
22071: PUSH
22072: LD_INT 0
22074: ST_TO_ADDR
// sEarthquake := false ;
22075: LD_ADDR_EXP 130
22079: PUSH
22080: LD_INT 0
22082: ST_TO_ADDR
// sAI := false ;
22083: LD_ADDR_EXP 131
22087: PUSH
22088: LD_INT 0
22090: ST_TO_ADDR
// sCargo := false ;
22091: LD_ADDR_EXP 134
22095: PUSH
22096: LD_INT 0
22098: ST_TO_ADDR
// sDLaser := false ;
22099: LD_ADDR_EXP 135
22103: PUSH
22104: LD_INT 0
22106: ST_TO_ADDR
// sExchange := false ;
22107: LD_ADDR_EXP 136
22111: PUSH
22112: LD_INT 0
22114: ST_TO_ADDR
// sFac := false ;
22115: LD_ADDR_EXP 137
22119: PUSH
22120: LD_INT 0
22122: ST_TO_ADDR
// sPower := false ;
22123: LD_ADDR_EXP 138
22127: PUSH
22128: LD_INT 0
22130: ST_TO_ADDR
// sRandom := false ;
22131: LD_ADDR_EXP 139
22135: PUSH
22136: LD_INT 0
22138: ST_TO_ADDR
// sShield := false ;
22139: LD_ADDR_EXP 140
22143: PUSH
22144: LD_INT 0
22146: ST_TO_ADDR
// sTime := false ;
22147: LD_ADDR_EXP 141
22151: PUSH
22152: LD_INT 0
22154: ST_TO_ADDR
// sTools := false ;
22155: LD_ADDR_EXP 142
22159: PUSH
22160: LD_INT 0
22162: ST_TO_ADDR
// sSold := false ;
22163: LD_ADDR_EXP 107
22167: PUSH
22168: LD_INT 0
22170: ST_TO_ADDR
// sDiff := false ;
22171: LD_ADDR_EXP 108
22175: PUSH
22176: LD_INT 0
22178: ST_TO_ADDR
// sFog := false ;
22179: LD_ADDR_EXP 111
22183: PUSH
22184: LD_INT 0
22186: ST_TO_ADDR
// sReset := false ;
22187: LD_ADDR_EXP 112
22191: PUSH
22192: LD_INT 0
22194: ST_TO_ADDR
// sSun := false ;
22195: LD_ADDR_EXP 113
22199: PUSH
22200: LD_INT 0
22202: ST_TO_ADDR
// sTiger := false ;
22203: LD_ADDR_EXP 109
22207: PUSH
22208: LD_INT 0
22210: ST_TO_ADDR
// sBomb := false ;
22211: LD_ADDR_EXP 110
22215: PUSH
22216: LD_INT 0
22218: ST_TO_ADDR
// sWound := false ;
22219: LD_ADDR_EXP 118
22223: PUSH
22224: LD_INT 0
22226: ST_TO_ADDR
// sBetray := false ;
22227: LD_ADDR_EXP 122
22231: PUSH
22232: LD_INT 0
22234: ST_TO_ADDR
// sContamin := false ;
22235: LD_ADDR_EXP 123
22239: PUSH
22240: LD_INT 0
22242: ST_TO_ADDR
// sOil := false ;
22243: LD_ADDR_EXP 125
22247: PUSH
22248: LD_INT 0
22250: ST_TO_ADDR
// sStu := false ;
22251: LD_ADDR_EXP 129
22255: PUSH
22256: LD_INT 0
22258: ST_TO_ADDR
// sBazooka := false ;
22259: LD_ADDR_EXP 132
22263: PUSH
22264: LD_INT 0
22266: ST_TO_ADDR
// sMortar := false ;
22267: LD_ADDR_EXP 133
22271: PUSH
22272: LD_INT 0
22274: ST_TO_ADDR
// sRanger := false ;
22275: LD_ADDR_EXP 143
22279: PUSH
22280: LD_INT 0
22282: ST_TO_ADDR
// end ;
22283: LD_VAR 0 1
22287: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
22288: LD_INT 0
22290: PPUSH
22291: PPUSH
22292: PPUSH
22293: PPUSH
22294: PPUSH
// result := [ ] ;
22295: LD_ADDR_VAR 0 1
22299: PUSH
22300: EMPTY
22301: ST_TO_ADDR
// if campaign_id = 1 then
22302: LD_OWVAR 69
22306: PUSH
22307: LD_INT 1
22309: EQUAL
22310: IFFALSE 25248
// begin case mission_number of 1 :
22312: LD_OWVAR 70
22316: PUSH
22317: LD_INT 1
22319: DOUBLE
22320: EQUAL
22321: IFTRUE 22325
22323: GO 22389
22325: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
22326: LD_ADDR_VAR 0 1
22330: PUSH
22331: LD_INT 2
22333: PUSH
22334: LD_INT 4
22336: PUSH
22337: LD_INT 11
22339: PUSH
22340: LD_INT 12
22342: PUSH
22343: LD_INT 15
22345: PUSH
22346: LD_INT 16
22348: PUSH
22349: LD_INT 22
22351: PUSH
22352: LD_INT 23
22354: PUSH
22355: LD_INT 26
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: LIST
22365: LIST
22366: LIST
22367: LIST
22368: PUSH
22369: LD_INT 101
22371: PUSH
22372: LD_INT 102
22374: PUSH
22375: LD_INT 106
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: LIST
22382: PUSH
22383: EMPTY
22384: LIST
22385: LIST
22386: ST_TO_ADDR
22387: GO 25246
22389: LD_INT 2
22391: DOUBLE
22392: EQUAL
22393: IFTRUE 22397
22395: GO 22469
22397: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
22398: LD_ADDR_VAR 0 1
22402: PUSH
22403: LD_INT 2
22405: PUSH
22406: LD_INT 4
22408: PUSH
22409: LD_INT 11
22411: PUSH
22412: LD_INT 12
22414: PUSH
22415: LD_INT 15
22417: PUSH
22418: LD_INT 16
22420: PUSH
22421: LD_INT 22
22423: PUSH
22424: LD_INT 23
22426: PUSH
22427: LD_INT 26
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: LIST
22437: LIST
22438: LIST
22439: LIST
22440: PUSH
22441: LD_INT 101
22443: PUSH
22444: LD_INT 102
22446: PUSH
22447: LD_INT 105
22449: PUSH
22450: LD_INT 106
22452: PUSH
22453: LD_INT 108
22455: PUSH
22456: EMPTY
22457: LIST
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: PUSH
22463: EMPTY
22464: LIST
22465: LIST
22466: ST_TO_ADDR
22467: GO 25246
22469: LD_INT 3
22471: DOUBLE
22472: EQUAL
22473: IFTRUE 22477
22475: GO 22553
22477: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
22478: LD_ADDR_VAR 0 1
22482: PUSH
22483: LD_INT 2
22485: PUSH
22486: LD_INT 4
22488: PUSH
22489: LD_INT 5
22491: PUSH
22492: LD_INT 11
22494: PUSH
22495: LD_INT 12
22497: PUSH
22498: LD_INT 15
22500: PUSH
22501: LD_INT 16
22503: PUSH
22504: LD_INT 22
22506: PUSH
22507: LD_INT 26
22509: PUSH
22510: LD_INT 36
22512: PUSH
22513: EMPTY
22514: LIST
22515: LIST
22516: LIST
22517: LIST
22518: LIST
22519: LIST
22520: LIST
22521: LIST
22522: LIST
22523: LIST
22524: PUSH
22525: LD_INT 101
22527: PUSH
22528: LD_INT 102
22530: PUSH
22531: LD_INT 105
22533: PUSH
22534: LD_INT 106
22536: PUSH
22537: LD_INT 108
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: LIST
22544: LIST
22545: LIST
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: ST_TO_ADDR
22551: GO 25246
22553: LD_INT 4
22555: DOUBLE
22556: EQUAL
22557: IFTRUE 22561
22559: GO 22645
22561: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
22562: LD_ADDR_VAR 0 1
22566: PUSH
22567: LD_INT 2
22569: PUSH
22570: LD_INT 4
22572: PUSH
22573: LD_INT 5
22575: PUSH
22576: LD_INT 8
22578: PUSH
22579: LD_INT 11
22581: PUSH
22582: LD_INT 12
22584: PUSH
22585: LD_INT 15
22587: PUSH
22588: LD_INT 16
22590: PUSH
22591: LD_INT 22
22593: PUSH
22594: LD_INT 23
22596: PUSH
22597: LD_INT 26
22599: PUSH
22600: LD_INT 36
22602: PUSH
22603: EMPTY
22604: LIST
22605: LIST
22606: LIST
22607: LIST
22608: LIST
22609: LIST
22610: LIST
22611: LIST
22612: LIST
22613: LIST
22614: LIST
22615: LIST
22616: PUSH
22617: LD_INT 101
22619: PUSH
22620: LD_INT 102
22622: PUSH
22623: LD_INT 105
22625: PUSH
22626: LD_INT 106
22628: PUSH
22629: LD_INT 108
22631: PUSH
22632: EMPTY
22633: LIST
22634: LIST
22635: LIST
22636: LIST
22637: LIST
22638: PUSH
22639: EMPTY
22640: LIST
22641: LIST
22642: ST_TO_ADDR
22643: GO 25246
22645: LD_INT 5
22647: DOUBLE
22648: EQUAL
22649: IFTRUE 22653
22651: GO 22753
22653: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
22654: LD_ADDR_VAR 0 1
22658: PUSH
22659: LD_INT 2
22661: PUSH
22662: LD_INT 4
22664: PUSH
22665: LD_INT 5
22667: PUSH
22668: LD_INT 6
22670: PUSH
22671: LD_INT 8
22673: PUSH
22674: LD_INT 11
22676: PUSH
22677: LD_INT 12
22679: PUSH
22680: LD_INT 15
22682: PUSH
22683: LD_INT 16
22685: PUSH
22686: LD_INT 22
22688: PUSH
22689: LD_INT 23
22691: PUSH
22692: LD_INT 25
22694: PUSH
22695: LD_INT 26
22697: PUSH
22698: LD_INT 36
22700: PUSH
22701: EMPTY
22702: LIST
22703: LIST
22704: LIST
22705: LIST
22706: LIST
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: LIST
22712: LIST
22713: LIST
22714: LIST
22715: LIST
22716: PUSH
22717: LD_INT 101
22719: PUSH
22720: LD_INT 102
22722: PUSH
22723: LD_INT 105
22725: PUSH
22726: LD_INT 106
22728: PUSH
22729: LD_INT 108
22731: PUSH
22732: LD_INT 109
22734: PUSH
22735: LD_INT 112
22737: PUSH
22738: EMPTY
22739: LIST
22740: LIST
22741: LIST
22742: LIST
22743: LIST
22744: LIST
22745: LIST
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: ST_TO_ADDR
22751: GO 25246
22753: LD_INT 6
22755: DOUBLE
22756: EQUAL
22757: IFTRUE 22761
22759: GO 22881
22761: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
22762: LD_ADDR_VAR 0 1
22766: PUSH
22767: LD_INT 2
22769: PUSH
22770: LD_INT 4
22772: PUSH
22773: LD_INT 5
22775: PUSH
22776: LD_INT 6
22778: PUSH
22779: LD_INT 8
22781: PUSH
22782: LD_INT 11
22784: PUSH
22785: LD_INT 12
22787: PUSH
22788: LD_INT 15
22790: PUSH
22791: LD_INT 16
22793: PUSH
22794: LD_INT 20
22796: PUSH
22797: LD_INT 21
22799: PUSH
22800: LD_INT 22
22802: PUSH
22803: LD_INT 23
22805: PUSH
22806: LD_INT 25
22808: PUSH
22809: LD_INT 26
22811: PUSH
22812: LD_INT 30
22814: PUSH
22815: LD_INT 31
22817: PUSH
22818: LD_INT 32
22820: PUSH
22821: LD_INT 36
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: LIST
22828: LIST
22829: LIST
22830: LIST
22831: LIST
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: LIST
22841: LIST
22842: LIST
22843: LIST
22844: PUSH
22845: LD_INT 101
22847: PUSH
22848: LD_INT 102
22850: PUSH
22851: LD_INT 105
22853: PUSH
22854: LD_INT 106
22856: PUSH
22857: LD_INT 108
22859: PUSH
22860: LD_INT 109
22862: PUSH
22863: LD_INT 112
22865: PUSH
22866: EMPTY
22867: LIST
22868: LIST
22869: LIST
22870: LIST
22871: LIST
22872: LIST
22873: LIST
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: ST_TO_ADDR
22879: GO 25246
22881: LD_INT 7
22883: DOUBLE
22884: EQUAL
22885: IFTRUE 22889
22887: GO 22989
22889: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
22890: LD_ADDR_VAR 0 1
22894: PUSH
22895: LD_INT 2
22897: PUSH
22898: LD_INT 4
22900: PUSH
22901: LD_INT 5
22903: PUSH
22904: LD_INT 7
22906: PUSH
22907: LD_INT 11
22909: PUSH
22910: LD_INT 12
22912: PUSH
22913: LD_INT 15
22915: PUSH
22916: LD_INT 16
22918: PUSH
22919: LD_INT 20
22921: PUSH
22922: LD_INT 21
22924: PUSH
22925: LD_INT 22
22927: PUSH
22928: LD_INT 23
22930: PUSH
22931: LD_INT 25
22933: PUSH
22934: LD_INT 26
22936: PUSH
22937: EMPTY
22938: LIST
22939: LIST
22940: LIST
22941: LIST
22942: LIST
22943: LIST
22944: LIST
22945: LIST
22946: LIST
22947: LIST
22948: LIST
22949: LIST
22950: LIST
22951: LIST
22952: PUSH
22953: LD_INT 101
22955: PUSH
22956: LD_INT 102
22958: PUSH
22959: LD_INT 103
22961: PUSH
22962: LD_INT 105
22964: PUSH
22965: LD_INT 106
22967: PUSH
22968: LD_INT 108
22970: PUSH
22971: LD_INT 112
22973: PUSH
22974: EMPTY
22975: LIST
22976: LIST
22977: LIST
22978: LIST
22979: LIST
22980: LIST
22981: LIST
22982: PUSH
22983: EMPTY
22984: LIST
22985: LIST
22986: ST_TO_ADDR
22987: GO 25246
22989: LD_INT 8
22991: DOUBLE
22992: EQUAL
22993: IFTRUE 22997
22995: GO 23125
22997: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
22998: LD_ADDR_VAR 0 1
23002: PUSH
23003: LD_INT 2
23005: PUSH
23006: LD_INT 4
23008: PUSH
23009: LD_INT 5
23011: PUSH
23012: LD_INT 6
23014: PUSH
23015: LD_INT 7
23017: PUSH
23018: LD_INT 8
23020: PUSH
23021: LD_INT 11
23023: PUSH
23024: LD_INT 12
23026: PUSH
23027: LD_INT 15
23029: PUSH
23030: LD_INT 16
23032: PUSH
23033: LD_INT 20
23035: PUSH
23036: LD_INT 21
23038: PUSH
23039: LD_INT 22
23041: PUSH
23042: LD_INT 23
23044: PUSH
23045: LD_INT 25
23047: PUSH
23048: LD_INT 26
23050: PUSH
23051: LD_INT 30
23053: PUSH
23054: LD_INT 31
23056: PUSH
23057: LD_INT 32
23059: PUSH
23060: LD_INT 36
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: LIST
23067: LIST
23068: LIST
23069: LIST
23070: LIST
23071: LIST
23072: LIST
23073: LIST
23074: LIST
23075: LIST
23076: LIST
23077: LIST
23078: LIST
23079: LIST
23080: LIST
23081: LIST
23082: LIST
23083: LIST
23084: PUSH
23085: LD_INT 101
23087: PUSH
23088: LD_INT 102
23090: PUSH
23091: LD_INT 103
23093: PUSH
23094: LD_INT 105
23096: PUSH
23097: LD_INT 106
23099: PUSH
23100: LD_INT 108
23102: PUSH
23103: LD_INT 109
23105: PUSH
23106: LD_INT 112
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: LIST
23113: LIST
23114: LIST
23115: LIST
23116: LIST
23117: LIST
23118: PUSH
23119: EMPTY
23120: LIST
23121: LIST
23122: ST_TO_ADDR
23123: GO 25246
23125: LD_INT 9
23127: DOUBLE
23128: EQUAL
23129: IFTRUE 23133
23131: GO 23269
23133: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
23134: LD_ADDR_VAR 0 1
23138: PUSH
23139: LD_INT 2
23141: PUSH
23142: LD_INT 4
23144: PUSH
23145: LD_INT 5
23147: PUSH
23148: LD_INT 6
23150: PUSH
23151: LD_INT 7
23153: PUSH
23154: LD_INT 8
23156: PUSH
23157: LD_INT 11
23159: PUSH
23160: LD_INT 12
23162: PUSH
23163: LD_INT 15
23165: PUSH
23166: LD_INT 16
23168: PUSH
23169: LD_INT 20
23171: PUSH
23172: LD_INT 21
23174: PUSH
23175: LD_INT 22
23177: PUSH
23178: LD_INT 23
23180: PUSH
23181: LD_INT 25
23183: PUSH
23184: LD_INT 26
23186: PUSH
23187: LD_INT 28
23189: PUSH
23190: LD_INT 30
23192: PUSH
23193: LD_INT 31
23195: PUSH
23196: LD_INT 32
23198: PUSH
23199: LD_INT 36
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: LIST
23206: LIST
23207: LIST
23208: LIST
23209: LIST
23210: LIST
23211: LIST
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: LIST
23217: LIST
23218: LIST
23219: LIST
23220: LIST
23221: LIST
23222: LIST
23223: LIST
23224: PUSH
23225: LD_INT 101
23227: PUSH
23228: LD_INT 102
23230: PUSH
23231: LD_INT 103
23233: PUSH
23234: LD_INT 105
23236: PUSH
23237: LD_INT 106
23239: PUSH
23240: LD_INT 108
23242: PUSH
23243: LD_INT 109
23245: PUSH
23246: LD_INT 112
23248: PUSH
23249: LD_INT 114
23251: PUSH
23252: EMPTY
23253: LIST
23254: LIST
23255: LIST
23256: LIST
23257: LIST
23258: LIST
23259: LIST
23260: LIST
23261: LIST
23262: PUSH
23263: EMPTY
23264: LIST
23265: LIST
23266: ST_TO_ADDR
23267: GO 25246
23269: LD_INT 10
23271: DOUBLE
23272: EQUAL
23273: IFTRUE 23277
23275: GO 23461
23277: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
23278: LD_ADDR_VAR 0 1
23282: PUSH
23283: LD_INT 2
23285: PUSH
23286: LD_INT 4
23288: PUSH
23289: LD_INT 5
23291: PUSH
23292: LD_INT 6
23294: PUSH
23295: LD_INT 7
23297: PUSH
23298: LD_INT 8
23300: PUSH
23301: LD_INT 9
23303: PUSH
23304: LD_INT 10
23306: PUSH
23307: LD_INT 11
23309: PUSH
23310: LD_INT 12
23312: PUSH
23313: LD_INT 13
23315: PUSH
23316: LD_INT 14
23318: PUSH
23319: LD_INT 15
23321: PUSH
23322: LD_INT 16
23324: PUSH
23325: LD_INT 17
23327: PUSH
23328: LD_INT 18
23330: PUSH
23331: LD_INT 19
23333: PUSH
23334: LD_INT 20
23336: PUSH
23337: LD_INT 21
23339: PUSH
23340: LD_INT 22
23342: PUSH
23343: LD_INT 23
23345: PUSH
23346: LD_INT 24
23348: PUSH
23349: LD_INT 25
23351: PUSH
23352: LD_INT 26
23354: PUSH
23355: LD_INT 28
23357: PUSH
23358: LD_INT 30
23360: PUSH
23361: LD_INT 31
23363: PUSH
23364: LD_INT 32
23366: PUSH
23367: LD_INT 36
23369: PUSH
23370: EMPTY
23371: LIST
23372: LIST
23373: LIST
23374: LIST
23375: LIST
23376: LIST
23377: LIST
23378: LIST
23379: LIST
23380: LIST
23381: LIST
23382: LIST
23383: LIST
23384: LIST
23385: LIST
23386: LIST
23387: LIST
23388: LIST
23389: LIST
23390: LIST
23391: LIST
23392: LIST
23393: LIST
23394: LIST
23395: LIST
23396: LIST
23397: LIST
23398: LIST
23399: LIST
23400: PUSH
23401: LD_INT 101
23403: PUSH
23404: LD_INT 102
23406: PUSH
23407: LD_INT 103
23409: PUSH
23410: LD_INT 104
23412: PUSH
23413: LD_INT 105
23415: PUSH
23416: LD_INT 106
23418: PUSH
23419: LD_INT 107
23421: PUSH
23422: LD_INT 108
23424: PUSH
23425: LD_INT 109
23427: PUSH
23428: LD_INT 110
23430: PUSH
23431: LD_INT 111
23433: PUSH
23434: LD_INT 112
23436: PUSH
23437: LD_INT 114
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: LIST
23444: LIST
23445: LIST
23446: LIST
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: LIST
23452: LIST
23453: LIST
23454: PUSH
23455: EMPTY
23456: LIST
23457: LIST
23458: ST_TO_ADDR
23459: GO 25246
23461: LD_INT 11
23463: DOUBLE
23464: EQUAL
23465: IFTRUE 23469
23467: GO 23661
23469: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
23470: LD_ADDR_VAR 0 1
23474: PUSH
23475: LD_INT 2
23477: PUSH
23478: LD_INT 3
23480: PUSH
23481: LD_INT 4
23483: PUSH
23484: LD_INT 5
23486: PUSH
23487: LD_INT 6
23489: PUSH
23490: LD_INT 7
23492: PUSH
23493: LD_INT 8
23495: PUSH
23496: LD_INT 9
23498: PUSH
23499: LD_INT 10
23501: PUSH
23502: LD_INT 11
23504: PUSH
23505: LD_INT 12
23507: PUSH
23508: LD_INT 13
23510: PUSH
23511: LD_INT 14
23513: PUSH
23514: LD_INT 15
23516: PUSH
23517: LD_INT 16
23519: PUSH
23520: LD_INT 17
23522: PUSH
23523: LD_INT 18
23525: PUSH
23526: LD_INT 19
23528: PUSH
23529: LD_INT 20
23531: PUSH
23532: LD_INT 21
23534: PUSH
23535: LD_INT 22
23537: PUSH
23538: LD_INT 23
23540: PUSH
23541: LD_INT 24
23543: PUSH
23544: LD_INT 25
23546: PUSH
23547: LD_INT 26
23549: PUSH
23550: LD_INT 28
23552: PUSH
23553: LD_INT 30
23555: PUSH
23556: LD_INT 31
23558: PUSH
23559: LD_INT 32
23561: PUSH
23562: LD_INT 34
23564: PUSH
23565: LD_INT 36
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: LIST
23575: LIST
23576: LIST
23577: LIST
23578: LIST
23579: LIST
23580: LIST
23581: LIST
23582: LIST
23583: LIST
23584: LIST
23585: LIST
23586: LIST
23587: LIST
23588: LIST
23589: LIST
23590: LIST
23591: LIST
23592: LIST
23593: LIST
23594: LIST
23595: LIST
23596: LIST
23597: LIST
23598: LIST
23599: LIST
23600: PUSH
23601: LD_INT 101
23603: PUSH
23604: LD_INT 102
23606: PUSH
23607: LD_INT 103
23609: PUSH
23610: LD_INT 104
23612: PUSH
23613: LD_INT 105
23615: PUSH
23616: LD_INT 106
23618: PUSH
23619: LD_INT 107
23621: PUSH
23622: LD_INT 108
23624: PUSH
23625: LD_INT 109
23627: PUSH
23628: LD_INT 110
23630: PUSH
23631: LD_INT 111
23633: PUSH
23634: LD_INT 112
23636: PUSH
23637: LD_INT 114
23639: PUSH
23640: EMPTY
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: LIST
23646: LIST
23647: LIST
23648: LIST
23649: LIST
23650: LIST
23651: LIST
23652: LIST
23653: LIST
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: ST_TO_ADDR
23659: GO 25246
23661: LD_INT 12
23663: DOUBLE
23664: EQUAL
23665: IFTRUE 23669
23667: GO 23877
23669: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
23670: LD_ADDR_VAR 0 1
23674: PUSH
23675: LD_INT 1
23677: PUSH
23678: LD_INT 2
23680: PUSH
23681: LD_INT 3
23683: PUSH
23684: LD_INT 4
23686: PUSH
23687: LD_INT 5
23689: PUSH
23690: LD_INT 6
23692: PUSH
23693: LD_INT 7
23695: PUSH
23696: LD_INT 8
23698: PUSH
23699: LD_INT 9
23701: PUSH
23702: LD_INT 10
23704: PUSH
23705: LD_INT 11
23707: PUSH
23708: LD_INT 12
23710: PUSH
23711: LD_INT 13
23713: PUSH
23714: LD_INT 14
23716: PUSH
23717: LD_INT 15
23719: PUSH
23720: LD_INT 16
23722: PUSH
23723: LD_INT 17
23725: PUSH
23726: LD_INT 18
23728: PUSH
23729: LD_INT 19
23731: PUSH
23732: LD_INT 20
23734: PUSH
23735: LD_INT 21
23737: PUSH
23738: LD_INT 22
23740: PUSH
23741: LD_INT 23
23743: PUSH
23744: LD_INT 24
23746: PUSH
23747: LD_INT 25
23749: PUSH
23750: LD_INT 26
23752: PUSH
23753: LD_INT 27
23755: PUSH
23756: LD_INT 28
23758: PUSH
23759: LD_INT 30
23761: PUSH
23762: LD_INT 31
23764: PUSH
23765: LD_INT 32
23767: PUSH
23768: LD_INT 33
23770: PUSH
23771: LD_INT 34
23773: PUSH
23774: LD_INT 36
23776: PUSH
23777: EMPTY
23778: LIST
23779: LIST
23780: LIST
23781: LIST
23782: LIST
23783: LIST
23784: LIST
23785: LIST
23786: LIST
23787: LIST
23788: LIST
23789: LIST
23790: LIST
23791: LIST
23792: LIST
23793: LIST
23794: LIST
23795: LIST
23796: LIST
23797: LIST
23798: LIST
23799: LIST
23800: LIST
23801: LIST
23802: LIST
23803: LIST
23804: LIST
23805: LIST
23806: LIST
23807: LIST
23808: LIST
23809: LIST
23810: LIST
23811: LIST
23812: PUSH
23813: LD_INT 101
23815: PUSH
23816: LD_INT 102
23818: PUSH
23819: LD_INT 103
23821: PUSH
23822: LD_INT 104
23824: PUSH
23825: LD_INT 105
23827: PUSH
23828: LD_INT 106
23830: PUSH
23831: LD_INT 107
23833: PUSH
23834: LD_INT 108
23836: PUSH
23837: LD_INT 109
23839: PUSH
23840: LD_INT 110
23842: PUSH
23843: LD_INT 111
23845: PUSH
23846: LD_INT 112
23848: PUSH
23849: LD_INT 113
23851: PUSH
23852: LD_INT 114
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: LIST
23859: LIST
23860: LIST
23861: LIST
23862: LIST
23863: LIST
23864: LIST
23865: LIST
23866: LIST
23867: LIST
23868: LIST
23869: LIST
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 25246
23877: LD_INT 13
23879: DOUBLE
23880: EQUAL
23881: IFTRUE 23885
23883: GO 24081
23885: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
23886: LD_ADDR_VAR 0 1
23890: PUSH
23891: LD_INT 1
23893: PUSH
23894: LD_INT 2
23896: PUSH
23897: LD_INT 3
23899: PUSH
23900: LD_INT 4
23902: PUSH
23903: LD_INT 5
23905: PUSH
23906: LD_INT 8
23908: PUSH
23909: LD_INT 9
23911: PUSH
23912: LD_INT 10
23914: PUSH
23915: LD_INT 11
23917: PUSH
23918: LD_INT 12
23920: PUSH
23921: LD_INT 14
23923: PUSH
23924: LD_INT 15
23926: PUSH
23927: LD_INT 16
23929: PUSH
23930: LD_INT 17
23932: PUSH
23933: LD_INT 18
23935: PUSH
23936: LD_INT 19
23938: PUSH
23939: LD_INT 20
23941: PUSH
23942: LD_INT 21
23944: PUSH
23945: LD_INT 22
23947: PUSH
23948: LD_INT 23
23950: PUSH
23951: LD_INT 24
23953: PUSH
23954: LD_INT 25
23956: PUSH
23957: LD_INT 26
23959: PUSH
23960: LD_INT 27
23962: PUSH
23963: LD_INT 28
23965: PUSH
23966: LD_INT 30
23968: PUSH
23969: LD_INT 31
23971: PUSH
23972: LD_INT 32
23974: PUSH
23975: LD_INT 33
23977: PUSH
23978: LD_INT 34
23980: PUSH
23981: LD_INT 36
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: LIST
23989: LIST
23990: LIST
23991: LIST
23992: LIST
23993: LIST
23994: LIST
23995: LIST
23996: LIST
23997: LIST
23998: LIST
23999: LIST
24000: LIST
24001: LIST
24002: LIST
24003: LIST
24004: LIST
24005: LIST
24006: LIST
24007: LIST
24008: LIST
24009: LIST
24010: LIST
24011: LIST
24012: LIST
24013: LIST
24014: LIST
24015: LIST
24016: PUSH
24017: LD_INT 101
24019: PUSH
24020: LD_INT 102
24022: PUSH
24023: LD_INT 103
24025: PUSH
24026: LD_INT 104
24028: PUSH
24029: LD_INT 105
24031: PUSH
24032: LD_INT 106
24034: PUSH
24035: LD_INT 107
24037: PUSH
24038: LD_INT 108
24040: PUSH
24041: LD_INT 109
24043: PUSH
24044: LD_INT 110
24046: PUSH
24047: LD_INT 111
24049: PUSH
24050: LD_INT 112
24052: PUSH
24053: LD_INT 113
24055: PUSH
24056: LD_INT 114
24058: PUSH
24059: EMPTY
24060: LIST
24061: LIST
24062: LIST
24063: LIST
24064: LIST
24065: LIST
24066: LIST
24067: LIST
24068: LIST
24069: LIST
24070: LIST
24071: LIST
24072: LIST
24073: LIST
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: ST_TO_ADDR
24079: GO 25246
24081: LD_INT 14
24083: DOUBLE
24084: EQUAL
24085: IFTRUE 24089
24087: GO 24301
24089: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
24090: LD_ADDR_VAR 0 1
24094: PUSH
24095: LD_INT 1
24097: PUSH
24098: LD_INT 2
24100: PUSH
24101: LD_INT 3
24103: PUSH
24104: LD_INT 4
24106: PUSH
24107: LD_INT 5
24109: PUSH
24110: LD_INT 6
24112: PUSH
24113: LD_INT 7
24115: PUSH
24116: LD_INT 8
24118: PUSH
24119: LD_INT 9
24121: PUSH
24122: LD_INT 10
24124: PUSH
24125: LD_INT 11
24127: PUSH
24128: LD_INT 12
24130: PUSH
24131: LD_INT 13
24133: PUSH
24134: LD_INT 14
24136: PUSH
24137: LD_INT 15
24139: PUSH
24140: LD_INT 16
24142: PUSH
24143: LD_INT 17
24145: PUSH
24146: LD_INT 18
24148: PUSH
24149: LD_INT 19
24151: PUSH
24152: LD_INT 20
24154: PUSH
24155: LD_INT 21
24157: PUSH
24158: LD_INT 22
24160: PUSH
24161: LD_INT 23
24163: PUSH
24164: LD_INT 24
24166: PUSH
24167: LD_INT 25
24169: PUSH
24170: LD_INT 26
24172: PUSH
24173: LD_INT 27
24175: PUSH
24176: LD_INT 28
24178: PUSH
24179: LD_INT 29
24181: PUSH
24182: LD_INT 30
24184: PUSH
24185: LD_INT 31
24187: PUSH
24188: LD_INT 32
24190: PUSH
24191: LD_INT 33
24193: PUSH
24194: LD_INT 34
24196: PUSH
24197: LD_INT 36
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: LIST
24207: LIST
24208: LIST
24209: LIST
24210: LIST
24211: LIST
24212: LIST
24213: LIST
24214: LIST
24215: LIST
24216: LIST
24217: LIST
24218: LIST
24219: LIST
24220: LIST
24221: LIST
24222: LIST
24223: LIST
24224: LIST
24225: LIST
24226: LIST
24227: LIST
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: LIST
24235: LIST
24236: PUSH
24237: LD_INT 101
24239: PUSH
24240: LD_INT 102
24242: PUSH
24243: LD_INT 103
24245: PUSH
24246: LD_INT 104
24248: PUSH
24249: LD_INT 105
24251: PUSH
24252: LD_INT 106
24254: PUSH
24255: LD_INT 107
24257: PUSH
24258: LD_INT 108
24260: PUSH
24261: LD_INT 109
24263: PUSH
24264: LD_INT 110
24266: PUSH
24267: LD_INT 111
24269: PUSH
24270: LD_INT 112
24272: PUSH
24273: LD_INT 113
24275: PUSH
24276: LD_INT 114
24278: PUSH
24279: EMPTY
24280: LIST
24281: LIST
24282: LIST
24283: LIST
24284: LIST
24285: LIST
24286: LIST
24287: LIST
24288: LIST
24289: LIST
24290: LIST
24291: LIST
24292: LIST
24293: LIST
24294: PUSH
24295: EMPTY
24296: LIST
24297: LIST
24298: ST_TO_ADDR
24299: GO 25246
24301: LD_INT 15
24303: DOUBLE
24304: EQUAL
24305: IFTRUE 24309
24307: GO 24521
24309: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
24310: LD_ADDR_VAR 0 1
24314: PUSH
24315: LD_INT 1
24317: PUSH
24318: LD_INT 2
24320: PUSH
24321: LD_INT 3
24323: PUSH
24324: LD_INT 4
24326: PUSH
24327: LD_INT 5
24329: PUSH
24330: LD_INT 6
24332: PUSH
24333: LD_INT 7
24335: PUSH
24336: LD_INT 8
24338: PUSH
24339: LD_INT 9
24341: PUSH
24342: LD_INT 10
24344: PUSH
24345: LD_INT 11
24347: PUSH
24348: LD_INT 12
24350: PUSH
24351: LD_INT 13
24353: PUSH
24354: LD_INT 14
24356: PUSH
24357: LD_INT 15
24359: PUSH
24360: LD_INT 16
24362: PUSH
24363: LD_INT 17
24365: PUSH
24366: LD_INT 18
24368: PUSH
24369: LD_INT 19
24371: PUSH
24372: LD_INT 20
24374: PUSH
24375: LD_INT 21
24377: PUSH
24378: LD_INT 22
24380: PUSH
24381: LD_INT 23
24383: PUSH
24384: LD_INT 24
24386: PUSH
24387: LD_INT 25
24389: PUSH
24390: LD_INT 26
24392: PUSH
24393: LD_INT 27
24395: PUSH
24396: LD_INT 28
24398: PUSH
24399: LD_INT 29
24401: PUSH
24402: LD_INT 30
24404: PUSH
24405: LD_INT 31
24407: PUSH
24408: LD_INT 32
24410: PUSH
24411: LD_INT 33
24413: PUSH
24414: LD_INT 34
24416: PUSH
24417: LD_INT 36
24419: PUSH
24420: EMPTY
24421: LIST
24422: LIST
24423: LIST
24424: LIST
24425: LIST
24426: LIST
24427: LIST
24428: LIST
24429: LIST
24430: LIST
24431: LIST
24432: LIST
24433: LIST
24434: LIST
24435: LIST
24436: LIST
24437: LIST
24438: LIST
24439: LIST
24440: LIST
24441: LIST
24442: LIST
24443: LIST
24444: LIST
24445: LIST
24446: LIST
24447: LIST
24448: LIST
24449: LIST
24450: LIST
24451: LIST
24452: LIST
24453: LIST
24454: LIST
24455: LIST
24456: PUSH
24457: LD_INT 101
24459: PUSH
24460: LD_INT 102
24462: PUSH
24463: LD_INT 103
24465: PUSH
24466: LD_INT 104
24468: PUSH
24469: LD_INT 105
24471: PUSH
24472: LD_INT 106
24474: PUSH
24475: LD_INT 107
24477: PUSH
24478: LD_INT 108
24480: PUSH
24481: LD_INT 109
24483: PUSH
24484: LD_INT 110
24486: PUSH
24487: LD_INT 111
24489: PUSH
24490: LD_INT 112
24492: PUSH
24493: LD_INT 113
24495: PUSH
24496: LD_INT 114
24498: PUSH
24499: EMPTY
24500: LIST
24501: LIST
24502: LIST
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: LIST
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: ST_TO_ADDR
24519: GO 25246
24521: LD_INT 16
24523: DOUBLE
24524: EQUAL
24525: IFTRUE 24529
24527: GO 24653
24529: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
24530: LD_ADDR_VAR 0 1
24534: PUSH
24535: LD_INT 2
24537: PUSH
24538: LD_INT 4
24540: PUSH
24541: LD_INT 5
24543: PUSH
24544: LD_INT 7
24546: PUSH
24547: LD_INT 11
24549: PUSH
24550: LD_INT 12
24552: PUSH
24553: LD_INT 15
24555: PUSH
24556: LD_INT 16
24558: PUSH
24559: LD_INT 20
24561: PUSH
24562: LD_INT 21
24564: PUSH
24565: LD_INT 22
24567: PUSH
24568: LD_INT 23
24570: PUSH
24571: LD_INT 25
24573: PUSH
24574: LD_INT 26
24576: PUSH
24577: LD_INT 30
24579: PUSH
24580: LD_INT 31
24582: PUSH
24583: LD_INT 32
24585: PUSH
24586: LD_INT 33
24588: PUSH
24589: LD_INT 34
24591: PUSH
24592: EMPTY
24593: LIST
24594: LIST
24595: LIST
24596: LIST
24597: LIST
24598: LIST
24599: LIST
24600: LIST
24601: LIST
24602: LIST
24603: LIST
24604: LIST
24605: LIST
24606: LIST
24607: LIST
24608: LIST
24609: LIST
24610: LIST
24611: LIST
24612: PUSH
24613: LD_INT 101
24615: PUSH
24616: LD_INT 102
24618: PUSH
24619: LD_INT 103
24621: PUSH
24622: LD_INT 106
24624: PUSH
24625: LD_INT 108
24627: PUSH
24628: LD_INT 112
24630: PUSH
24631: LD_INT 113
24633: PUSH
24634: LD_INT 114
24636: PUSH
24637: EMPTY
24638: LIST
24639: LIST
24640: LIST
24641: LIST
24642: LIST
24643: LIST
24644: LIST
24645: LIST
24646: PUSH
24647: EMPTY
24648: LIST
24649: LIST
24650: ST_TO_ADDR
24651: GO 25246
24653: LD_INT 17
24655: DOUBLE
24656: EQUAL
24657: IFTRUE 24661
24659: GO 24873
24661: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
24662: LD_ADDR_VAR 0 1
24666: PUSH
24667: LD_INT 1
24669: PUSH
24670: LD_INT 2
24672: PUSH
24673: LD_INT 3
24675: PUSH
24676: LD_INT 4
24678: PUSH
24679: LD_INT 5
24681: PUSH
24682: LD_INT 6
24684: PUSH
24685: LD_INT 7
24687: PUSH
24688: LD_INT 8
24690: PUSH
24691: LD_INT 9
24693: PUSH
24694: LD_INT 10
24696: PUSH
24697: LD_INT 11
24699: PUSH
24700: LD_INT 12
24702: PUSH
24703: LD_INT 13
24705: PUSH
24706: LD_INT 14
24708: PUSH
24709: LD_INT 15
24711: PUSH
24712: LD_INT 16
24714: PUSH
24715: LD_INT 17
24717: PUSH
24718: LD_INT 18
24720: PUSH
24721: LD_INT 19
24723: PUSH
24724: LD_INT 20
24726: PUSH
24727: LD_INT 21
24729: PUSH
24730: LD_INT 22
24732: PUSH
24733: LD_INT 23
24735: PUSH
24736: LD_INT 24
24738: PUSH
24739: LD_INT 25
24741: PUSH
24742: LD_INT 26
24744: PUSH
24745: LD_INT 27
24747: PUSH
24748: LD_INT 28
24750: PUSH
24751: LD_INT 29
24753: PUSH
24754: LD_INT 30
24756: PUSH
24757: LD_INT 31
24759: PUSH
24760: LD_INT 32
24762: PUSH
24763: LD_INT 33
24765: PUSH
24766: LD_INT 34
24768: PUSH
24769: LD_INT 36
24771: PUSH
24772: EMPTY
24773: LIST
24774: LIST
24775: LIST
24776: LIST
24777: LIST
24778: LIST
24779: LIST
24780: LIST
24781: LIST
24782: LIST
24783: LIST
24784: LIST
24785: LIST
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: LIST
24795: LIST
24796: LIST
24797: LIST
24798: LIST
24799: LIST
24800: LIST
24801: LIST
24802: LIST
24803: LIST
24804: LIST
24805: LIST
24806: LIST
24807: LIST
24808: PUSH
24809: LD_INT 101
24811: PUSH
24812: LD_INT 102
24814: PUSH
24815: LD_INT 103
24817: PUSH
24818: LD_INT 104
24820: PUSH
24821: LD_INT 105
24823: PUSH
24824: LD_INT 106
24826: PUSH
24827: LD_INT 107
24829: PUSH
24830: LD_INT 108
24832: PUSH
24833: LD_INT 109
24835: PUSH
24836: LD_INT 110
24838: PUSH
24839: LD_INT 111
24841: PUSH
24842: LD_INT 112
24844: PUSH
24845: LD_INT 113
24847: PUSH
24848: LD_INT 114
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: LIST
24862: LIST
24863: LIST
24864: LIST
24865: LIST
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: ST_TO_ADDR
24871: GO 25246
24873: LD_INT 18
24875: DOUBLE
24876: EQUAL
24877: IFTRUE 24881
24879: GO 25017
24881: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
24882: LD_ADDR_VAR 0 1
24886: PUSH
24887: LD_INT 2
24889: PUSH
24890: LD_INT 4
24892: PUSH
24893: LD_INT 5
24895: PUSH
24896: LD_INT 7
24898: PUSH
24899: LD_INT 11
24901: PUSH
24902: LD_INT 12
24904: PUSH
24905: LD_INT 15
24907: PUSH
24908: LD_INT 16
24910: PUSH
24911: LD_INT 20
24913: PUSH
24914: LD_INT 21
24916: PUSH
24917: LD_INT 22
24919: PUSH
24920: LD_INT 23
24922: PUSH
24923: LD_INT 25
24925: PUSH
24926: LD_INT 26
24928: PUSH
24929: LD_INT 30
24931: PUSH
24932: LD_INT 31
24934: PUSH
24935: LD_INT 32
24937: PUSH
24938: LD_INT 33
24940: PUSH
24941: LD_INT 34
24943: PUSH
24944: LD_INT 35
24946: PUSH
24947: LD_INT 36
24949: PUSH
24950: EMPTY
24951: LIST
24952: LIST
24953: LIST
24954: LIST
24955: LIST
24956: LIST
24957: LIST
24958: LIST
24959: LIST
24960: LIST
24961: LIST
24962: LIST
24963: LIST
24964: LIST
24965: LIST
24966: LIST
24967: LIST
24968: LIST
24969: LIST
24970: LIST
24971: LIST
24972: PUSH
24973: LD_INT 101
24975: PUSH
24976: LD_INT 102
24978: PUSH
24979: LD_INT 103
24981: PUSH
24982: LD_INT 106
24984: PUSH
24985: LD_INT 108
24987: PUSH
24988: LD_INT 112
24990: PUSH
24991: LD_INT 113
24993: PUSH
24994: LD_INT 114
24996: PUSH
24997: LD_INT 115
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: LIST
25004: LIST
25005: LIST
25006: LIST
25007: LIST
25008: LIST
25009: LIST
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: ST_TO_ADDR
25015: GO 25246
25017: LD_INT 19
25019: DOUBLE
25020: EQUAL
25021: IFTRUE 25025
25023: GO 25245
25025: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
25026: LD_ADDR_VAR 0 1
25030: PUSH
25031: LD_INT 1
25033: PUSH
25034: LD_INT 2
25036: PUSH
25037: LD_INT 3
25039: PUSH
25040: LD_INT 4
25042: PUSH
25043: LD_INT 5
25045: PUSH
25046: LD_INT 6
25048: PUSH
25049: LD_INT 7
25051: PUSH
25052: LD_INT 8
25054: PUSH
25055: LD_INT 9
25057: PUSH
25058: LD_INT 10
25060: PUSH
25061: LD_INT 11
25063: PUSH
25064: LD_INT 12
25066: PUSH
25067: LD_INT 13
25069: PUSH
25070: LD_INT 14
25072: PUSH
25073: LD_INT 15
25075: PUSH
25076: LD_INT 16
25078: PUSH
25079: LD_INT 17
25081: PUSH
25082: LD_INT 18
25084: PUSH
25085: LD_INT 19
25087: PUSH
25088: LD_INT 20
25090: PUSH
25091: LD_INT 21
25093: PUSH
25094: LD_INT 22
25096: PUSH
25097: LD_INT 23
25099: PUSH
25100: LD_INT 24
25102: PUSH
25103: LD_INT 25
25105: PUSH
25106: LD_INT 26
25108: PUSH
25109: LD_INT 27
25111: PUSH
25112: LD_INT 28
25114: PUSH
25115: LD_INT 29
25117: PUSH
25118: LD_INT 30
25120: PUSH
25121: LD_INT 31
25123: PUSH
25124: LD_INT 32
25126: PUSH
25127: LD_INT 33
25129: PUSH
25130: LD_INT 34
25132: PUSH
25133: LD_INT 35
25135: PUSH
25136: LD_INT 36
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: LIST
25143: LIST
25144: LIST
25145: LIST
25146: LIST
25147: LIST
25148: LIST
25149: LIST
25150: LIST
25151: LIST
25152: LIST
25153: LIST
25154: LIST
25155: LIST
25156: LIST
25157: LIST
25158: LIST
25159: LIST
25160: LIST
25161: LIST
25162: LIST
25163: LIST
25164: LIST
25165: LIST
25166: LIST
25167: LIST
25168: LIST
25169: LIST
25170: LIST
25171: LIST
25172: LIST
25173: LIST
25174: LIST
25175: LIST
25176: PUSH
25177: LD_INT 101
25179: PUSH
25180: LD_INT 102
25182: PUSH
25183: LD_INT 103
25185: PUSH
25186: LD_INT 104
25188: PUSH
25189: LD_INT 105
25191: PUSH
25192: LD_INT 106
25194: PUSH
25195: LD_INT 107
25197: PUSH
25198: LD_INT 108
25200: PUSH
25201: LD_INT 109
25203: PUSH
25204: LD_INT 110
25206: PUSH
25207: LD_INT 111
25209: PUSH
25210: LD_INT 112
25212: PUSH
25213: LD_INT 113
25215: PUSH
25216: LD_INT 114
25218: PUSH
25219: LD_INT 115
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: LIST
25226: LIST
25227: LIST
25228: LIST
25229: LIST
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: ST_TO_ADDR
25243: GO 25246
25245: POP
// end else
25246: GO 25465
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
25248: LD_ADDR_VAR 0 1
25252: PUSH
25253: LD_INT 1
25255: PUSH
25256: LD_INT 2
25258: PUSH
25259: LD_INT 3
25261: PUSH
25262: LD_INT 4
25264: PUSH
25265: LD_INT 5
25267: PUSH
25268: LD_INT 6
25270: PUSH
25271: LD_INT 7
25273: PUSH
25274: LD_INT 8
25276: PUSH
25277: LD_INT 9
25279: PUSH
25280: LD_INT 10
25282: PUSH
25283: LD_INT 11
25285: PUSH
25286: LD_INT 12
25288: PUSH
25289: LD_INT 13
25291: PUSH
25292: LD_INT 14
25294: PUSH
25295: LD_INT 15
25297: PUSH
25298: LD_INT 16
25300: PUSH
25301: LD_INT 17
25303: PUSH
25304: LD_INT 18
25306: PUSH
25307: LD_INT 19
25309: PUSH
25310: LD_INT 20
25312: PUSH
25313: LD_INT 21
25315: PUSH
25316: LD_INT 22
25318: PUSH
25319: LD_INT 23
25321: PUSH
25322: LD_INT 24
25324: PUSH
25325: LD_INT 25
25327: PUSH
25328: LD_INT 26
25330: PUSH
25331: LD_INT 27
25333: PUSH
25334: LD_INT 28
25336: PUSH
25337: LD_INT 29
25339: PUSH
25340: LD_INT 30
25342: PUSH
25343: LD_INT 31
25345: PUSH
25346: LD_INT 32
25348: PUSH
25349: LD_INT 33
25351: PUSH
25352: LD_INT 34
25354: PUSH
25355: LD_INT 35
25357: PUSH
25358: LD_INT 36
25360: PUSH
25361: EMPTY
25362: LIST
25363: LIST
25364: LIST
25365: LIST
25366: LIST
25367: LIST
25368: LIST
25369: LIST
25370: LIST
25371: LIST
25372: LIST
25373: LIST
25374: LIST
25375: LIST
25376: LIST
25377: LIST
25378: LIST
25379: LIST
25380: LIST
25381: LIST
25382: LIST
25383: LIST
25384: LIST
25385: LIST
25386: LIST
25387: LIST
25388: LIST
25389: LIST
25390: LIST
25391: LIST
25392: LIST
25393: LIST
25394: LIST
25395: LIST
25396: LIST
25397: LIST
25398: PUSH
25399: LD_INT 101
25401: PUSH
25402: LD_INT 102
25404: PUSH
25405: LD_INT 103
25407: PUSH
25408: LD_INT 104
25410: PUSH
25411: LD_INT 105
25413: PUSH
25414: LD_INT 106
25416: PUSH
25417: LD_INT 107
25419: PUSH
25420: LD_INT 108
25422: PUSH
25423: LD_INT 109
25425: PUSH
25426: LD_INT 110
25428: PUSH
25429: LD_INT 111
25431: PUSH
25432: LD_INT 112
25434: PUSH
25435: LD_INT 113
25437: PUSH
25438: LD_INT 114
25440: PUSH
25441: LD_INT 115
25443: PUSH
25444: EMPTY
25445: LIST
25446: LIST
25447: LIST
25448: LIST
25449: LIST
25450: LIST
25451: LIST
25452: LIST
25453: LIST
25454: LIST
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: LIST
25460: PUSH
25461: EMPTY
25462: LIST
25463: LIST
25464: ST_TO_ADDR
// if result then
25465: LD_VAR 0 1
25469: IFFALSE 25758
// begin normal :=  ;
25471: LD_ADDR_VAR 0 3
25475: PUSH
25476: LD_STRING 
25478: ST_TO_ADDR
// hardcore :=  ;
25479: LD_ADDR_VAR 0 4
25483: PUSH
25484: LD_STRING 
25486: ST_TO_ADDR
// for i = 1 to normalCounter do
25487: LD_ADDR_VAR 0 5
25491: PUSH
25492: DOUBLE
25493: LD_INT 1
25495: DEC
25496: ST_TO_ADDR
25497: LD_EXP 91
25501: PUSH
25502: FOR_TO
25503: IFFALSE 25604
// begin tmp := 0 ;
25505: LD_ADDR_VAR 0 2
25509: PUSH
25510: LD_STRING 0
25512: ST_TO_ADDR
// if result [ 1 ] then
25513: LD_VAR 0 1
25517: PUSH
25518: LD_INT 1
25520: ARRAY
25521: IFFALSE 25586
// if result [ 1 ] [ 1 ] = i then
25523: LD_VAR 0 1
25527: PUSH
25528: LD_INT 1
25530: ARRAY
25531: PUSH
25532: LD_INT 1
25534: ARRAY
25535: PUSH
25536: LD_VAR 0 5
25540: EQUAL
25541: IFFALSE 25586
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
25543: LD_ADDR_VAR 0 1
25547: PUSH
25548: LD_VAR 0 1
25552: PPUSH
25553: LD_INT 1
25555: PPUSH
25556: LD_VAR 0 1
25560: PUSH
25561: LD_INT 1
25563: ARRAY
25564: PPUSH
25565: LD_INT 1
25567: PPUSH
25568: CALL_OW 3
25572: PPUSH
25573: CALL_OW 1
25577: ST_TO_ADDR
// tmp := 1 ;
25578: LD_ADDR_VAR 0 2
25582: PUSH
25583: LD_STRING 1
25585: ST_TO_ADDR
// end ; normal := normal & tmp ;
25586: LD_ADDR_VAR 0 3
25590: PUSH
25591: LD_VAR 0 3
25595: PUSH
25596: LD_VAR 0 2
25600: STR
25601: ST_TO_ADDR
// end ;
25602: GO 25502
25604: POP
25605: POP
// for i = 1 to hardcoreCounter do
25606: LD_ADDR_VAR 0 5
25610: PUSH
25611: DOUBLE
25612: LD_INT 1
25614: DEC
25615: ST_TO_ADDR
25616: LD_EXP 92
25620: PUSH
25621: FOR_TO
25622: IFFALSE 25727
// begin tmp := 0 ;
25624: LD_ADDR_VAR 0 2
25628: PUSH
25629: LD_STRING 0
25631: ST_TO_ADDR
// if result [ 2 ] then
25632: LD_VAR 0 1
25636: PUSH
25637: LD_INT 2
25639: ARRAY
25640: IFFALSE 25709
// if result [ 2 ] [ 1 ] = 100 + i then
25642: LD_VAR 0 1
25646: PUSH
25647: LD_INT 2
25649: ARRAY
25650: PUSH
25651: LD_INT 1
25653: ARRAY
25654: PUSH
25655: LD_INT 100
25657: PUSH
25658: LD_VAR 0 5
25662: PLUS
25663: EQUAL
25664: IFFALSE 25709
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
25666: LD_ADDR_VAR 0 1
25670: PUSH
25671: LD_VAR 0 1
25675: PPUSH
25676: LD_INT 2
25678: PPUSH
25679: LD_VAR 0 1
25683: PUSH
25684: LD_INT 2
25686: ARRAY
25687: PPUSH
25688: LD_INT 1
25690: PPUSH
25691: CALL_OW 3
25695: PPUSH
25696: CALL_OW 1
25700: ST_TO_ADDR
// tmp := 1 ;
25701: LD_ADDR_VAR 0 2
25705: PUSH
25706: LD_STRING 1
25708: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
25709: LD_ADDR_VAR 0 4
25713: PUSH
25714: LD_VAR 0 4
25718: PUSH
25719: LD_VAR 0 2
25723: STR
25724: ST_TO_ADDR
// end ;
25725: GO 25621
25727: POP
25728: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
25729: LD_STRING getStreamItemsFromMission("
25731: PUSH
25732: LD_VAR 0 3
25736: STR
25737: PUSH
25738: LD_STRING ","
25740: STR
25741: PUSH
25742: LD_VAR 0 4
25746: STR
25747: PUSH
25748: LD_STRING ")
25750: STR
25751: PPUSH
25752: CALL_OW 559
// end else
25756: GO 25765
// ToLua ( getStreamItemsFromMission("","") ) ;
25758: LD_STRING getStreamItemsFromMission("","")
25760: PPUSH
25761: CALL_OW 559
// end ;
25765: LD_VAR 0 1
25769: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
25770: LD_EXP 90
25774: PUSH
25775: LD_EXP 95
25779: AND
25780: IFFALSE 25904
25782: GO 25784
25784: DISABLE
25785: LD_INT 0
25787: PPUSH
25788: PPUSH
// begin enable ;
25789: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
25790: LD_ADDR_VAR 0 2
25794: PUSH
25795: LD_INT 22
25797: PUSH
25798: LD_OWVAR 2
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: PUSH
25807: LD_INT 2
25809: PUSH
25810: LD_INT 34
25812: PUSH
25813: LD_INT 7
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 34
25822: PUSH
25823: LD_INT 45
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: LD_INT 34
25832: PUSH
25833: LD_INT 28
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 34
25842: PUSH
25843: LD_INT 47
25845: PUSH
25846: EMPTY
25847: LIST
25848: LIST
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: LIST
25854: LIST
25855: LIST
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PPUSH
25861: CALL_OW 69
25865: ST_TO_ADDR
// if not tmp then
25866: LD_VAR 0 2
25870: NOT
25871: IFFALSE 25875
// exit ;
25873: GO 25904
// for i in tmp do
25875: LD_ADDR_VAR 0 1
25879: PUSH
25880: LD_VAR 0 2
25884: PUSH
25885: FOR_IN
25886: IFFALSE 25902
// begin SetLives ( i , 0 ) ;
25888: LD_VAR 0 1
25892: PPUSH
25893: LD_INT 0
25895: PPUSH
25896: CALL_OW 234
// end ;
25900: GO 25885
25902: POP
25903: POP
// end ;
25904: PPOPN 2
25906: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
25907: LD_EXP 90
25911: PUSH
25912: LD_EXP 96
25916: AND
25917: IFFALSE 26001
25919: GO 25921
25921: DISABLE
25922: LD_INT 0
25924: PPUSH
25925: PPUSH
// begin enable ;
25926: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
25927: LD_ADDR_VAR 0 2
25931: PUSH
25932: LD_INT 22
25934: PUSH
25935: LD_OWVAR 2
25939: PUSH
25940: EMPTY
25941: LIST
25942: LIST
25943: PUSH
25944: LD_INT 32
25946: PUSH
25947: LD_INT 3
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: PUSH
25954: EMPTY
25955: LIST
25956: LIST
25957: PPUSH
25958: CALL_OW 69
25962: ST_TO_ADDR
// if not tmp then
25963: LD_VAR 0 2
25967: NOT
25968: IFFALSE 25972
// exit ;
25970: GO 26001
// for i in tmp do
25972: LD_ADDR_VAR 0 1
25976: PUSH
25977: LD_VAR 0 2
25981: PUSH
25982: FOR_IN
25983: IFFALSE 25999
// begin SetLives ( i , 0 ) ;
25985: LD_VAR 0 1
25989: PPUSH
25990: LD_INT 0
25992: PPUSH
25993: CALL_OW 234
// end ;
25997: GO 25982
25999: POP
26000: POP
// end ;
26001: PPOPN 2
26003: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
26004: LD_EXP 90
26008: PUSH
26009: LD_EXP 93
26013: AND
26014: IFFALSE 26107
26016: GO 26018
26018: DISABLE
26019: LD_INT 0
26021: PPUSH
// begin enable ;
26022: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
26023: LD_ADDR_VAR 0 1
26027: PUSH
26028: LD_INT 22
26030: PUSH
26031: LD_OWVAR 2
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: PUSH
26040: LD_INT 2
26042: PUSH
26043: LD_INT 25
26045: PUSH
26046: LD_INT 5
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: PUSH
26053: LD_INT 25
26055: PUSH
26056: LD_INT 9
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: LD_INT 25
26065: PUSH
26066: LD_INT 8
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PUSH
26073: EMPTY
26074: LIST
26075: LIST
26076: LIST
26077: LIST
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PPUSH
26083: CALL_OW 69
26087: PUSH
26088: FOR_IN
26089: IFFALSE 26105
// begin SetClass ( i , 1 ) ;
26091: LD_VAR 0 1
26095: PPUSH
26096: LD_INT 1
26098: PPUSH
26099: CALL_OW 336
// end ;
26103: GO 26088
26105: POP
26106: POP
// end ;
26107: PPOPN 1
26109: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
26110: LD_EXP 90
26114: PUSH
26115: LD_EXP 94
26119: AND
26120: PUSH
26121: LD_OWVAR 65
26125: PUSH
26126: LD_INT 7
26128: LESS
26129: AND
26130: IFFALSE 26144
26132: GO 26134
26134: DISABLE
// begin enable ;
26135: ENABLE
// game_speed := 7 ;
26136: LD_ADDR_OWVAR 65
26140: PUSH
26141: LD_INT 7
26143: ST_TO_ADDR
// end ;
26144: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
26145: LD_EXP 90
26149: PUSH
26150: LD_EXP 97
26154: AND
26155: IFFALSE 26357
26157: GO 26159
26159: DISABLE
26160: LD_INT 0
26162: PPUSH
26163: PPUSH
26164: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
26165: LD_ADDR_VAR 0 3
26169: PUSH
26170: LD_INT 81
26172: PUSH
26173: LD_OWVAR 2
26177: PUSH
26178: EMPTY
26179: LIST
26180: LIST
26181: PUSH
26182: LD_INT 21
26184: PUSH
26185: LD_INT 1
26187: PUSH
26188: EMPTY
26189: LIST
26190: LIST
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: PPUSH
26196: CALL_OW 69
26200: ST_TO_ADDR
// if not tmp then
26201: LD_VAR 0 3
26205: NOT
26206: IFFALSE 26210
// exit ;
26208: GO 26357
// if tmp > 5 then
26210: LD_VAR 0 3
26214: PUSH
26215: LD_INT 5
26217: GREATER
26218: IFFALSE 26230
// k := 5 else
26220: LD_ADDR_VAR 0 2
26224: PUSH
26225: LD_INT 5
26227: ST_TO_ADDR
26228: GO 26240
// k := tmp ;
26230: LD_ADDR_VAR 0 2
26234: PUSH
26235: LD_VAR 0 3
26239: ST_TO_ADDR
// for i := 1 to k do
26240: LD_ADDR_VAR 0 1
26244: PUSH
26245: DOUBLE
26246: LD_INT 1
26248: DEC
26249: ST_TO_ADDR
26250: LD_VAR 0 2
26254: PUSH
26255: FOR_TO
26256: IFFALSE 26355
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
26258: LD_VAR 0 3
26262: PUSH
26263: LD_VAR 0 1
26267: ARRAY
26268: PPUSH
26269: LD_VAR 0 1
26273: PUSH
26274: LD_INT 4
26276: MOD
26277: PUSH
26278: LD_INT 1
26280: PLUS
26281: PPUSH
26282: CALL_OW 259
26286: PUSH
26287: LD_INT 10
26289: LESS
26290: IFFALSE 26353
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
26292: LD_VAR 0 3
26296: PUSH
26297: LD_VAR 0 1
26301: ARRAY
26302: PPUSH
26303: LD_VAR 0 1
26307: PUSH
26308: LD_INT 4
26310: MOD
26311: PUSH
26312: LD_INT 1
26314: PLUS
26315: PPUSH
26316: LD_VAR 0 3
26320: PUSH
26321: LD_VAR 0 1
26325: ARRAY
26326: PPUSH
26327: LD_VAR 0 1
26331: PUSH
26332: LD_INT 4
26334: MOD
26335: PUSH
26336: LD_INT 1
26338: PLUS
26339: PPUSH
26340: CALL_OW 259
26344: PUSH
26345: LD_INT 1
26347: PLUS
26348: PPUSH
26349: CALL_OW 237
26353: GO 26255
26355: POP
26356: POP
// end ;
26357: PPOPN 3
26359: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
26360: LD_EXP 90
26364: PUSH
26365: LD_EXP 98
26369: AND
26370: IFFALSE 26390
26372: GO 26374
26374: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
26375: LD_INT 4
26377: PPUSH
26378: LD_OWVAR 2
26382: PPUSH
26383: LD_INT 0
26385: PPUSH
26386: CALL_OW 324
26390: END
// every 0 0$1 trigger StreamModeActive and sShovel do
26391: LD_EXP 90
26395: PUSH
26396: LD_EXP 127
26400: AND
26401: IFFALSE 26421
26403: GO 26405
26405: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
26406: LD_INT 19
26408: PPUSH
26409: LD_OWVAR 2
26413: PPUSH
26414: LD_INT 0
26416: PPUSH
26417: CALL_OW 324
26421: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
26422: LD_EXP 90
26426: PUSH
26427: LD_EXP 99
26431: AND
26432: IFFALSE 26534
26434: GO 26436
26436: DISABLE
26437: LD_INT 0
26439: PPUSH
26440: PPUSH
// begin enable ;
26441: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
26442: LD_ADDR_VAR 0 2
26446: PUSH
26447: LD_INT 22
26449: PUSH
26450: LD_OWVAR 2
26454: PUSH
26455: EMPTY
26456: LIST
26457: LIST
26458: PUSH
26459: LD_INT 2
26461: PUSH
26462: LD_INT 34
26464: PUSH
26465: LD_INT 11
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: LD_INT 34
26474: PUSH
26475: LD_INT 30
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: LIST
26486: PUSH
26487: EMPTY
26488: LIST
26489: LIST
26490: PPUSH
26491: CALL_OW 69
26495: ST_TO_ADDR
// if not tmp then
26496: LD_VAR 0 2
26500: NOT
26501: IFFALSE 26505
// exit ;
26503: GO 26534
// for i in tmp do
26505: LD_ADDR_VAR 0 1
26509: PUSH
26510: LD_VAR 0 2
26514: PUSH
26515: FOR_IN
26516: IFFALSE 26532
// begin SetLives ( i , 0 ) ;
26518: LD_VAR 0 1
26522: PPUSH
26523: LD_INT 0
26525: PPUSH
26526: CALL_OW 234
// end ;
26530: GO 26515
26532: POP
26533: POP
// end ;
26534: PPOPN 2
26536: END
// every 0 0$1 trigger StreamModeActive and sBunker do
26537: LD_EXP 90
26541: PUSH
26542: LD_EXP 100
26546: AND
26547: IFFALSE 26567
26549: GO 26551
26551: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
26552: LD_INT 32
26554: PPUSH
26555: LD_OWVAR 2
26559: PPUSH
26560: LD_INT 0
26562: PPUSH
26563: CALL_OW 324
26567: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
26568: LD_EXP 90
26572: PUSH
26573: LD_EXP 101
26577: AND
26578: IFFALSE 26759
26580: GO 26582
26582: DISABLE
26583: LD_INT 0
26585: PPUSH
26586: PPUSH
26587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
26588: LD_ADDR_VAR 0 2
26592: PUSH
26593: LD_INT 22
26595: PUSH
26596: LD_OWVAR 2
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 33
26607: PUSH
26608: LD_INT 3
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: PPUSH
26619: CALL_OW 69
26623: ST_TO_ADDR
// if not tmp then
26624: LD_VAR 0 2
26628: NOT
26629: IFFALSE 26633
// exit ;
26631: GO 26759
// side := 0 ;
26633: LD_ADDR_VAR 0 3
26637: PUSH
26638: LD_INT 0
26640: ST_TO_ADDR
// for i := 1 to 8 do
26641: LD_ADDR_VAR 0 1
26645: PUSH
26646: DOUBLE
26647: LD_INT 1
26649: DEC
26650: ST_TO_ADDR
26651: LD_INT 8
26653: PUSH
26654: FOR_TO
26655: IFFALSE 26703
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
26657: LD_OWVAR 2
26661: PUSH
26662: LD_VAR 0 1
26666: NONEQUAL
26667: PUSH
26668: LD_OWVAR 2
26672: PPUSH
26673: LD_VAR 0 1
26677: PPUSH
26678: CALL_OW 81
26682: PUSH
26683: LD_INT 2
26685: EQUAL
26686: AND
26687: IFFALSE 26701
// begin side := i ;
26689: LD_ADDR_VAR 0 3
26693: PUSH
26694: LD_VAR 0 1
26698: ST_TO_ADDR
// break ;
26699: GO 26703
// end ;
26701: GO 26654
26703: POP
26704: POP
// if not side then
26705: LD_VAR 0 3
26709: NOT
26710: IFFALSE 26714
// exit ;
26712: GO 26759
// for i := 1 to tmp do
26714: LD_ADDR_VAR 0 1
26718: PUSH
26719: DOUBLE
26720: LD_INT 1
26722: DEC
26723: ST_TO_ADDR
26724: LD_VAR 0 2
26728: PUSH
26729: FOR_TO
26730: IFFALSE 26757
// if Prob ( 60 ) then
26732: LD_INT 60
26734: PPUSH
26735: CALL_OW 13
26739: IFFALSE 26755
// SetSide ( i , side ) ;
26741: LD_VAR 0 1
26745: PPUSH
26746: LD_VAR 0 3
26750: PPUSH
26751: CALL_OW 235
26755: GO 26729
26757: POP
26758: POP
// end ;
26759: PPOPN 3
26761: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
26762: LD_EXP 90
26766: PUSH
26767: LD_EXP 103
26771: AND
26772: IFFALSE 26891
26774: GO 26776
26776: DISABLE
26777: LD_INT 0
26779: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
26780: LD_ADDR_VAR 0 1
26784: PUSH
26785: LD_INT 22
26787: PUSH
26788: LD_OWVAR 2
26792: PUSH
26793: EMPTY
26794: LIST
26795: LIST
26796: PUSH
26797: LD_INT 21
26799: PUSH
26800: LD_INT 1
26802: PUSH
26803: EMPTY
26804: LIST
26805: LIST
26806: PUSH
26807: LD_INT 3
26809: PUSH
26810: LD_INT 23
26812: PUSH
26813: LD_INT 0
26815: PUSH
26816: EMPTY
26817: LIST
26818: LIST
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: LIST
26828: PPUSH
26829: CALL_OW 69
26833: PUSH
26834: FOR_IN
26835: IFFALSE 26889
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
26837: LD_VAR 0 1
26841: PPUSH
26842: CALL_OW 257
26846: PUSH
26847: LD_INT 1
26849: PUSH
26850: LD_INT 2
26852: PUSH
26853: LD_INT 3
26855: PUSH
26856: LD_INT 4
26858: PUSH
26859: EMPTY
26860: LIST
26861: LIST
26862: LIST
26863: LIST
26864: IN
26865: IFFALSE 26887
// SetClass ( un , rand ( 1 , 4 ) ) ;
26867: LD_VAR 0 1
26871: PPUSH
26872: LD_INT 1
26874: PPUSH
26875: LD_INT 4
26877: PPUSH
26878: CALL_OW 12
26882: PPUSH
26883: CALL_OW 336
26887: GO 26834
26889: POP
26890: POP
// end ;
26891: PPOPN 1
26893: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
26894: LD_EXP 90
26898: PUSH
26899: LD_EXP 102
26903: AND
26904: IFFALSE 26983
26906: GO 26908
26908: DISABLE
26909: LD_INT 0
26911: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
26912: LD_ADDR_VAR 0 1
26916: PUSH
26917: LD_INT 22
26919: PUSH
26920: LD_OWVAR 2
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: PUSH
26929: LD_INT 21
26931: PUSH
26932: LD_INT 3
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: EMPTY
26940: LIST
26941: LIST
26942: PPUSH
26943: CALL_OW 69
26947: ST_TO_ADDR
// if not tmp then
26948: LD_VAR 0 1
26952: NOT
26953: IFFALSE 26957
// exit ;
26955: GO 26983
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
26957: LD_VAR 0 1
26961: PUSH
26962: LD_INT 1
26964: PPUSH
26965: LD_VAR 0 1
26969: PPUSH
26970: CALL_OW 12
26974: ARRAY
26975: PPUSH
26976: LD_INT 100
26978: PPUSH
26979: CALL_OW 234
// end ;
26983: PPOPN 1
26985: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
26986: LD_EXP 90
26990: PUSH
26991: LD_EXP 104
26995: AND
26996: IFFALSE 27094
26998: GO 27000
27000: DISABLE
27001: LD_INT 0
27003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27004: LD_ADDR_VAR 0 1
27008: PUSH
27009: LD_INT 22
27011: PUSH
27012: LD_OWVAR 2
27016: PUSH
27017: EMPTY
27018: LIST
27019: LIST
27020: PUSH
27021: LD_INT 21
27023: PUSH
27024: LD_INT 1
27026: PUSH
27027: EMPTY
27028: LIST
27029: LIST
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: PPUSH
27035: CALL_OW 69
27039: ST_TO_ADDR
// if not tmp then
27040: LD_VAR 0 1
27044: NOT
27045: IFFALSE 27049
// exit ;
27047: GO 27094
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
27049: LD_VAR 0 1
27053: PUSH
27054: LD_INT 1
27056: PPUSH
27057: LD_VAR 0 1
27061: PPUSH
27062: CALL_OW 12
27066: ARRAY
27067: PPUSH
27068: LD_INT 1
27070: PPUSH
27071: LD_INT 4
27073: PPUSH
27074: CALL_OW 12
27078: PPUSH
27079: LD_INT 3000
27081: PPUSH
27082: LD_INT 9000
27084: PPUSH
27085: CALL_OW 12
27089: PPUSH
27090: CALL_OW 492
// end ;
27094: PPOPN 1
27096: END
// every 0 0$1 trigger StreamModeActive and sDepot do
27097: LD_EXP 90
27101: PUSH
27102: LD_EXP 105
27106: AND
27107: IFFALSE 27127
27109: GO 27111
27111: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
27112: LD_INT 1
27114: PPUSH
27115: LD_OWVAR 2
27119: PPUSH
27120: LD_INT 0
27122: PPUSH
27123: CALL_OW 324
27127: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
27128: LD_EXP 90
27132: PUSH
27133: LD_EXP 106
27137: AND
27138: IFFALSE 27221
27140: GO 27142
27142: DISABLE
27143: LD_INT 0
27145: PPUSH
27146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
27147: LD_ADDR_VAR 0 2
27151: PUSH
27152: LD_INT 22
27154: PUSH
27155: LD_OWVAR 2
27159: PUSH
27160: EMPTY
27161: LIST
27162: LIST
27163: PUSH
27164: LD_INT 21
27166: PUSH
27167: LD_INT 3
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PPUSH
27178: CALL_OW 69
27182: ST_TO_ADDR
// if not tmp then
27183: LD_VAR 0 2
27187: NOT
27188: IFFALSE 27192
// exit ;
27190: GO 27221
// for i in tmp do
27192: LD_ADDR_VAR 0 1
27196: PUSH
27197: LD_VAR 0 2
27201: PUSH
27202: FOR_IN
27203: IFFALSE 27219
// SetBLevel ( i , 10 ) ;
27205: LD_VAR 0 1
27209: PPUSH
27210: LD_INT 10
27212: PPUSH
27213: CALL_OW 241
27217: GO 27202
27219: POP
27220: POP
// end ;
27221: PPOPN 2
27223: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
27224: LD_EXP 90
27228: PUSH
27229: LD_EXP 107
27233: AND
27234: IFFALSE 27345
27236: GO 27238
27238: DISABLE
27239: LD_INT 0
27241: PPUSH
27242: PPUSH
27243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27244: LD_ADDR_VAR 0 3
27248: PUSH
27249: LD_INT 22
27251: PUSH
27252: LD_OWVAR 2
27256: PUSH
27257: EMPTY
27258: LIST
27259: LIST
27260: PUSH
27261: LD_INT 25
27263: PUSH
27264: LD_INT 1
27266: PUSH
27267: EMPTY
27268: LIST
27269: LIST
27270: PUSH
27271: EMPTY
27272: LIST
27273: LIST
27274: PPUSH
27275: CALL_OW 69
27279: ST_TO_ADDR
// if not tmp then
27280: LD_VAR 0 3
27284: NOT
27285: IFFALSE 27289
// exit ;
27287: GO 27345
// un := tmp [ rand ( 1 , tmp ) ] ;
27289: LD_ADDR_VAR 0 2
27293: PUSH
27294: LD_VAR 0 3
27298: PUSH
27299: LD_INT 1
27301: PPUSH
27302: LD_VAR 0 3
27306: PPUSH
27307: CALL_OW 12
27311: ARRAY
27312: ST_TO_ADDR
// if Crawls ( un ) then
27313: LD_VAR 0 2
27317: PPUSH
27318: CALL_OW 318
27322: IFFALSE 27333
// ComWalk ( un ) ;
27324: LD_VAR 0 2
27328: PPUSH
27329: CALL_OW 138
// SetClass ( un , class_sniper ) ;
27333: LD_VAR 0 2
27337: PPUSH
27338: LD_INT 5
27340: PPUSH
27341: CALL_OW 336
// end ;
27345: PPOPN 3
27347: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
27348: LD_EXP 90
27352: PUSH
27353: LD_EXP 108
27357: AND
27358: PUSH
27359: LD_OWVAR 67
27363: PUSH
27364: LD_INT 3
27366: LESS
27367: AND
27368: IFFALSE 27387
27370: GO 27372
27372: DISABLE
// Difficulty := Difficulty + 1 ;
27373: LD_ADDR_OWVAR 67
27377: PUSH
27378: LD_OWVAR 67
27382: PUSH
27383: LD_INT 1
27385: PLUS
27386: ST_TO_ADDR
27387: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
27388: LD_EXP 90
27392: PUSH
27393: LD_EXP 109
27397: AND
27398: IFFALSE 27501
27400: GO 27402
27402: DISABLE
27403: LD_INT 0
27405: PPUSH
// begin for i := 1 to 5 do
27406: LD_ADDR_VAR 0 1
27410: PUSH
27411: DOUBLE
27412: LD_INT 1
27414: DEC
27415: ST_TO_ADDR
27416: LD_INT 5
27418: PUSH
27419: FOR_TO
27420: IFFALSE 27499
// begin uc_nation := nation_nature ;
27422: LD_ADDR_OWVAR 21
27426: PUSH
27427: LD_INT 0
27429: ST_TO_ADDR
// uc_side := 0 ;
27430: LD_ADDR_OWVAR 20
27434: PUSH
27435: LD_INT 0
27437: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
27438: LD_ADDR_OWVAR 29
27442: PUSH
27443: LD_INT 12
27445: PUSH
27446: LD_INT 12
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: ST_TO_ADDR
// hc_agressivity := 20 ;
27453: LD_ADDR_OWVAR 35
27457: PUSH
27458: LD_INT 20
27460: ST_TO_ADDR
// hc_class := class_tiger ;
27461: LD_ADDR_OWVAR 28
27465: PUSH
27466: LD_INT 14
27468: ST_TO_ADDR
// hc_gallery :=  ;
27469: LD_ADDR_OWVAR 33
27473: PUSH
27474: LD_STRING 
27476: ST_TO_ADDR
// hc_name :=  ;
27477: LD_ADDR_OWVAR 26
27481: PUSH
27482: LD_STRING 
27484: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
27485: CALL_OW 44
27489: PPUSH
27490: LD_INT 0
27492: PPUSH
27493: CALL_OW 51
// end ;
27497: GO 27419
27499: POP
27500: POP
// end ;
27501: PPOPN 1
27503: END
// every 0 0$1 trigger StreamModeActive and sBomb do
27504: LD_EXP 90
27508: PUSH
27509: LD_EXP 110
27513: AND
27514: IFFALSE 27523
27516: GO 27518
27518: DISABLE
// StreamSibBomb ;
27519: CALL 27524 0 0
27523: END
// export function StreamSibBomb ; var i , x , y ; begin
27524: LD_INT 0
27526: PPUSH
27527: PPUSH
27528: PPUSH
27529: PPUSH
// result := false ;
27530: LD_ADDR_VAR 0 1
27534: PUSH
27535: LD_INT 0
27537: ST_TO_ADDR
// for i := 1 to 16 do
27538: LD_ADDR_VAR 0 2
27542: PUSH
27543: DOUBLE
27544: LD_INT 1
27546: DEC
27547: ST_TO_ADDR
27548: LD_INT 16
27550: PUSH
27551: FOR_TO
27552: IFFALSE 27751
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
27554: LD_ADDR_VAR 0 3
27558: PUSH
27559: LD_INT 10
27561: PUSH
27562: LD_INT 20
27564: PUSH
27565: LD_INT 30
27567: PUSH
27568: LD_INT 40
27570: PUSH
27571: LD_INT 50
27573: PUSH
27574: LD_INT 60
27576: PUSH
27577: LD_INT 70
27579: PUSH
27580: LD_INT 80
27582: PUSH
27583: LD_INT 90
27585: PUSH
27586: LD_INT 100
27588: PUSH
27589: LD_INT 110
27591: PUSH
27592: LD_INT 120
27594: PUSH
27595: LD_INT 130
27597: PUSH
27598: LD_INT 140
27600: PUSH
27601: LD_INT 150
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: LIST
27608: LIST
27609: LIST
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: LIST
27615: LIST
27616: LIST
27617: LIST
27618: LIST
27619: LIST
27620: PUSH
27621: LD_INT 1
27623: PPUSH
27624: LD_INT 15
27626: PPUSH
27627: CALL_OW 12
27631: ARRAY
27632: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
27633: LD_ADDR_VAR 0 4
27637: PUSH
27638: LD_INT 10
27640: PUSH
27641: LD_INT 20
27643: PUSH
27644: LD_INT 30
27646: PUSH
27647: LD_INT 40
27649: PUSH
27650: LD_INT 50
27652: PUSH
27653: LD_INT 60
27655: PUSH
27656: LD_INT 70
27658: PUSH
27659: LD_INT 80
27661: PUSH
27662: LD_INT 90
27664: PUSH
27665: LD_INT 100
27667: PUSH
27668: LD_INT 110
27670: PUSH
27671: LD_INT 120
27673: PUSH
27674: LD_INT 130
27676: PUSH
27677: LD_INT 140
27679: PUSH
27680: LD_INT 150
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: LIST
27687: LIST
27688: LIST
27689: LIST
27690: LIST
27691: LIST
27692: LIST
27693: LIST
27694: LIST
27695: LIST
27696: LIST
27697: LIST
27698: LIST
27699: PUSH
27700: LD_INT 1
27702: PPUSH
27703: LD_INT 15
27705: PPUSH
27706: CALL_OW 12
27710: ARRAY
27711: ST_TO_ADDR
// if ValidHex ( x , y ) then
27712: LD_VAR 0 3
27716: PPUSH
27717: LD_VAR 0 4
27721: PPUSH
27722: CALL_OW 488
27726: IFFALSE 27749
// begin result := [ x , y ] ;
27728: LD_ADDR_VAR 0 1
27732: PUSH
27733: LD_VAR 0 3
27737: PUSH
27738: LD_VAR 0 4
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: ST_TO_ADDR
// break ;
27747: GO 27751
// end ; end ;
27749: GO 27551
27751: POP
27752: POP
// if result then
27753: LD_VAR 0 1
27757: IFFALSE 27817
// begin ToLua ( playSibBomb() ) ;
27759: LD_STRING playSibBomb()
27761: PPUSH
27762: CALL_OW 559
// wait ( 0 0$14 ) ;
27766: LD_INT 490
27768: PPUSH
27769: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
27773: LD_VAR 0 1
27777: PUSH
27778: LD_INT 1
27780: ARRAY
27781: PPUSH
27782: LD_VAR 0 1
27786: PUSH
27787: LD_INT 2
27789: ARRAY
27790: PPUSH
27791: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
27795: LD_VAR 0 1
27799: PUSH
27800: LD_INT 1
27802: ARRAY
27803: PPUSH
27804: LD_VAR 0 1
27808: PUSH
27809: LD_INT 2
27811: ARRAY
27812: PPUSH
27813: CALL_OW 429
// end ; end ;
27817: LD_VAR 0 1
27821: RET
// every 0 0$1 trigger StreamModeActive and sReset do
27822: LD_EXP 90
27826: PUSH
27827: LD_EXP 112
27831: AND
27832: IFFALSE 27844
27834: GO 27836
27836: DISABLE
// YouLost (  ) ;
27837: LD_STRING 
27839: PPUSH
27840: CALL_OW 104
27844: END
// every 0 0$1 trigger StreamModeActive and sFog do
27845: LD_EXP 90
27849: PUSH
27850: LD_EXP 111
27854: AND
27855: IFFALSE 27869
27857: GO 27859
27859: DISABLE
// FogOff ( your_side ) ;
27860: LD_OWVAR 2
27864: PPUSH
27865: CALL_OW 344
27869: END
// every 0 0$1 trigger StreamModeActive and sSun do
27870: LD_EXP 90
27874: PUSH
27875: LD_EXP 113
27879: AND
27880: IFFALSE 27908
27882: GO 27884
27884: DISABLE
// begin solar_recharge_percent := 0 ;
27885: LD_ADDR_OWVAR 79
27889: PUSH
27890: LD_INT 0
27892: ST_TO_ADDR
// wait ( 5 5$00 ) ;
27893: LD_INT 10500
27895: PPUSH
27896: CALL_OW 67
// solar_recharge_percent := 100 ;
27900: LD_ADDR_OWVAR 79
27904: PUSH
27905: LD_INT 100
27907: ST_TO_ADDR
// end ;
27908: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
27909: LD_EXP 90
27913: PUSH
27914: LD_EXP 114
27918: AND
27919: IFFALSE 28158
27921: GO 27923
27923: DISABLE
27924: LD_INT 0
27926: PPUSH
27927: PPUSH
27928: PPUSH
// begin tmp := [ ] ;
27929: LD_ADDR_VAR 0 3
27933: PUSH
27934: EMPTY
27935: ST_TO_ADDR
// for i := 1 to 6 do
27936: LD_ADDR_VAR 0 1
27940: PUSH
27941: DOUBLE
27942: LD_INT 1
27944: DEC
27945: ST_TO_ADDR
27946: LD_INT 6
27948: PUSH
27949: FOR_TO
27950: IFFALSE 28055
// begin uc_nation := nation_nature ;
27952: LD_ADDR_OWVAR 21
27956: PUSH
27957: LD_INT 0
27959: ST_TO_ADDR
// uc_side := 0 ;
27960: LD_ADDR_OWVAR 20
27964: PUSH
27965: LD_INT 0
27967: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
27968: LD_ADDR_OWVAR 29
27972: PUSH
27973: LD_INT 12
27975: PUSH
27976: LD_INT 12
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: ST_TO_ADDR
// hc_agressivity := 20 ;
27983: LD_ADDR_OWVAR 35
27987: PUSH
27988: LD_INT 20
27990: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
27991: LD_ADDR_OWVAR 28
27995: PUSH
27996: LD_INT 17
27998: ST_TO_ADDR
// hc_gallery :=  ;
27999: LD_ADDR_OWVAR 33
28003: PUSH
28004: LD_STRING 
28006: ST_TO_ADDR
// hc_name :=  ;
28007: LD_ADDR_OWVAR 26
28011: PUSH
28012: LD_STRING 
28014: ST_TO_ADDR
// un := CreateHuman ;
28015: LD_ADDR_VAR 0 2
28019: PUSH
28020: CALL_OW 44
28024: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
28025: LD_VAR 0 2
28029: PPUSH
28030: LD_INT 1
28032: PPUSH
28033: CALL_OW 51
// tmp := tmp ^ un ;
28037: LD_ADDR_VAR 0 3
28041: PUSH
28042: LD_VAR 0 3
28046: PUSH
28047: LD_VAR 0 2
28051: ADD
28052: ST_TO_ADDR
// end ;
28053: GO 27949
28055: POP
28056: POP
// repeat wait ( 0 0$1 ) ;
28057: LD_INT 35
28059: PPUSH
28060: CALL_OW 67
// for un in tmp do
28064: LD_ADDR_VAR 0 2
28068: PUSH
28069: LD_VAR 0 3
28073: PUSH
28074: FOR_IN
28075: IFFALSE 28149
// begin if IsDead ( un ) then
28077: LD_VAR 0 2
28081: PPUSH
28082: CALL_OW 301
28086: IFFALSE 28106
// begin tmp := tmp diff un ;
28088: LD_ADDR_VAR 0 3
28092: PUSH
28093: LD_VAR 0 3
28097: PUSH
28098: LD_VAR 0 2
28102: DIFF
28103: ST_TO_ADDR
// continue ;
28104: GO 28074
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
28106: LD_VAR 0 2
28110: PPUSH
28111: LD_INT 3
28113: PUSH
28114: LD_INT 22
28116: PUSH
28117: LD_INT 0
28119: PUSH
28120: EMPTY
28121: LIST
28122: LIST
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PPUSH
28128: CALL_OW 69
28132: PPUSH
28133: LD_VAR 0 2
28137: PPUSH
28138: CALL_OW 74
28142: PPUSH
28143: CALL_OW 115
// end ;
28147: GO 28074
28149: POP
28150: POP
// until not tmp ;
28151: LD_VAR 0 3
28155: NOT
28156: IFFALSE 28057
// end ;
28158: PPOPN 3
28160: END
// every 0 0$1 trigger StreamModeActive and sTroll do
28161: LD_EXP 90
28165: PUSH
28166: LD_EXP 115
28170: AND
28171: IFFALSE 28225
28173: GO 28175
28175: DISABLE
// begin ToLua ( displayTroll(); ) ;
28176: LD_STRING displayTroll();
28178: PPUSH
28179: CALL_OW 559
// wait ( 3 3$00 ) ;
28183: LD_INT 6300
28185: PPUSH
28186: CALL_OW 67
// ToLua ( hideTroll(); ) ;
28190: LD_STRING hideTroll();
28192: PPUSH
28193: CALL_OW 559
// wait ( 1 1$00 ) ;
28197: LD_INT 2100
28199: PPUSH
28200: CALL_OW 67
// ToLua ( displayTroll(); ) ;
28204: LD_STRING displayTroll();
28206: PPUSH
28207: CALL_OW 559
// wait ( 1 1$00 ) ;
28211: LD_INT 2100
28213: PPUSH
28214: CALL_OW 67
// ToLua ( hideTroll(); ) ;
28218: LD_STRING hideTroll();
28220: PPUSH
28221: CALL_OW 559
// end ;
28225: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
28226: LD_EXP 90
28230: PUSH
28231: LD_EXP 116
28235: AND
28236: IFFALSE 28299
28238: GO 28240
28240: DISABLE
28241: LD_INT 0
28243: PPUSH
// begin p := 0 ;
28244: LD_ADDR_VAR 0 1
28248: PUSH
28249: LD_INT 0
28251: ST_TO_ADDR
// repeat game_speed := 1 ;
28252: LD_ADDR_OWVAR 65
28256: PUSH
28257: LD_INT 1
28259: ST_TO_ADDR
// wait ( 0 0$1 ) ;
28260: LD_INT 35
28262: PPUSH
28263: CALL_OW 67
// p := p + 1 ;
28267: LD_ADDR_VAR 0 1
28271: PUSH
28272: LD_VAR 0 1
28276: PUSH
28277: LD_INT 1
28279: PLUS
28280: ST_TO_ADDR
// until p >= 60 ;
28281: LD_VAR 0 1
28285: PUSH
28286: LD_INT 60
28288: GREATEREQUAL
28289: IFFALSE 28252
// game_speed := 4 ;
28291: LD_ADDR_OWVAR 65
28295: PUSH
28296: LD_INT 4
28298: ST_TO_ADDR
// end ;
28299: PPOPN 1
28301: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
28302: LD_EXP 90
28306: PUSH
28307: LD_EXP 117
28311: AND
28312: IFFALSE 28458
28314: GO 28316
28316: DISABLE
28317: LD_INT 0
28319: PPUSH
28320: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28321: LD_ADDR_VAR 0 1
28325: PUSH
28326: LD_INT 22
28328: PUSH
28329: LD_OWVAR 2
28333: PUSH
28334: EMPTY
28335: LIST
28336: LIST
28337: PUSH
28338: LD_INT 2
28340: PUSH
28341: LD_INT 30
28343: PUSH
28344: LD_INT 0
28346: PUSH
28347: EMPTY
28348: LIST
28349: LIST
28350: PUSH
28351: LD_INT 30
28353: PUSH
28354: LD_INT 1
28356: PUSH
28357: EMPTY
28358: LIST
28359: LIST
28360: PUSH
28361: EMPTY
28362: LIST
28363: LIST
28364: LIST
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PPUSH
28370: CALL_OW 69
28374: ST_TO_ADDR
// if not depot then
28375: LD_VAR 0 1
28379: NOT
28380: IFFALSE 28384
// exit ;
28382: GO 28458
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
28384: LD_ADDR_VAR 0 2
28388: PUSH
28389: LD_VAR 0 1
28393: PUSH
28394: LD_INT 1
28396: PPUSH
28397: LD_VAR 0 1
28401: PPUSH
28402: CALL_OW 12
28406: ARRAY
28407: PPUSH
28408: CALL_OW 274
28412: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
28413: LD_VAR 0 2
28417: PPUSH
28418: LD_INT 1
28420: PPUSH
28421: LD_INT 0
28423: PPUSH
28424: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
28428: LD_VAR 0 2
28432: PPUSH
28433: LD_INT 2
28435: PPUSH
28436: LD_INT 0
28438: PPUSH
28439: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
28443: LD_VAR 0 2
28447: PPUSH
28448: LD_INT 3
28450: PPUSH
28451: LD_INT 0
28453: PPUSH
28454: CALL_OW 277
// end ;
28458: PPOPN 2
28460: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
28461: LD_EXP 90
28465: PUSH
28466: LD_EXP 118
28470: AND
28471: IFFALSE 28568
28473: GO 28475
28475: DISABLE
28476: LD_INT 0
28478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28479: LD_ADDR_VAR 0 1
28483: PUSH
28484: LD_INT 22
28486: PUSH
28487: LD_OWVAR 2
28491: PUSH
28492: EMPTY
28493: LIST
28494: LIST
28495: PUSH
28496: LD_INT 21
28498: PUSH
28499: LD_INT 1
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: PUSH
28506: LD_INT 3
28508: PUSH
28509: LD_INT 23
28511: PUSH
28512: LD_INT 0
28514: PUSH
28515: EMPTY
28516: LIST
28517: LIST
28518: PUSH
28519: EMPTY
28520: LIST
28521: LIST
28522: PUSH
28523: EMPTY
28524: LIST
28525: LIST
28526: LIST
28527: PPUSH
28528: CALL_OW 69
28532: ST_TO_ADDR
// if not tmp then
28533: LD_VAR 0 1
28537: NOT
28538: IFFALSE 28542
// exit ;
28540: GO 28568
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
28542: LD_VAR 0 1
28546: PUSH
28547: LD_INT 1
28549: PPUSH
28550: LD_VAR 0 1
28554: PPUSH
28555: CALL_OW 12
28559: ARRAY
28560: PPUSH
28561: LD_INT 200
28563: PPUSH
28564: CALL_OW 234
// end ;
28568: PPOPN 1
28570: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
28571: LD_EXP 90
28575: PUSH
28576: LD_EXP 119
28580: AND
28581: IFFALSE 28660
28583: GO 28585
28585: DISABLE
28586: LD_INT 0
28588: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
28589: LD_ADDR_VAR 0 1
28593: PUSH
28594: LD_INT 22
28596: PUSH
28597: LD_OWVAR 2
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 21
28608: PUSH
28609: LD_INT 2
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: PPUSH
28620: CALL_OW 69
28624: ST_TO_ADDR
// if not tmp then
28625: LD_VAR 0 1
28629: NOT
28630: IFFALSE 28634
// exit ;
28632: GO 28660
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
28634: LD_VAR 0 1
28638: PUSH
28639: LD_INT 1
28641: PPUSH
28642: LD_VAR 0 1
28646: PPUSH
28647: CALL_OW 12
28651: ARRAY
28652: PPUSH
28653: LD_INT 60
28655: PPUSH
28656: CALL_OW 234
// end ;
28660: PPOPN 1
28662: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
28663: LD_EXP 90
28667: PUSH
28668: LD_EXP 120
28672: AND
28673: IFFALSE 28772
28675: GO 28677
28677: DISABLE
28678: LD_INT 0
28680: PPUSH
28681: PPUSH
// begin enable ;
28682: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
28683: LD_ADDR_VAR 0 1
28687: PUSH
28688: LD_INT 22
28690: PUSH
28691: LD_OWVAR 2
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 61
28702: PUSH
28703: EMPTY
28704: LIST
28705: PUSH
28706: LD_INT 33
28708: PUSH
28709: LD_INT 2
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: LIST
28720: PPUSH
28721: CALL_OW 69
28725: ST_TO_ADDR
// if not tmp then
28726: LD_VAR 0 1
28730: NOT
28731: IFFALSE 28735
// exit ;
28733: GO 28772
// for i in tmp do
28735: LD_ADDR_VAR 0 2
28739: PUSH
28740: LD_VAR 0 1
28744: PUSH
28745: FOR_IN
28746: IFFALSE 28770
// if IsControledBy ( i ) then
28748: LD_VAR 0 2
28752: PPUSH
28753: CALL_OW 312
28757: IFFALSE 28768
// ComUnlink ( i ) ;
28759: LD_VAR 0 2
28763: PPUSH
28764: CALL_OW 136
28768: GO 28745
28770: POP
28771: POP
// end ;
28772: PPOPN 2
28774: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
28775: LD_EXP 90
28779: PUSH
28780: LD_EXP 121
28784: AND
28785: IFFALSE 28925
28787: GO 28789
28789: DISABLE
28790: LD_INT 0
28792: PPUSH
28793: PPUSH
// begin ToLua ( displayPowell(); ) ;
28794: LD_STRING displayPowell();
28796: PPUSH
28797: CALL_OW 559
// uc_side := 0 ;
28801: LD_ADDR_OWVAR 20
28805: PUSH
28806: LD_INT 0
28808: ST_TO_ADDR
// uc_nation := 2 ;
28809: LD_ADDR_OWVAR 21
28813: PUSH
28814: LD_INT 2
28816: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
28817: LD_ADDR_OWVAR 37
28821: PUSH
28822: LD_INT 14
28824: ST_TO_ADDR
// vc_engine := engine_siberite ;
28825: LD_ADDR_OWVAR 39
28829: PUSH
28830: LD_INT 3
28832: ST_TO_ADDR
// vc_control := control_apeman ;
28833: LD_ADDR_OWVAR 38
28837: PUSH
28838: LD_INT 5
28840: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
28841: LD_ADDR_OWVAR 40
28845: PUSH
28846: LD_INT 29
28848: ST_TO_ADDR
// un := CreateVehicle ;
28849: LD_ADDR_VAR 0 2
28853: PUSH
28854: CALL_OW 45
28858: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28859: LD_VAR 0 2
28863: PPUSH
28864: LD_INT 1
28866: PPUSH
28867: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
28871: LD_INT 35
28873: PPUSH
28874: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
28878: LD_VAR 0 2
28882: PPUSH
28883: LD_INT 22
28885: PUSH
28886: LD_OWVAR 2
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PPUSH
28895: CALL_OW 69
28899: PPUSH
28900: LD_VAR 0 2
28904: PPUSH
28905: CALL_OW 74
28909: PPUSH
28910: CALL_OW 115
// until IsDead ( un ) ;
28914: LD_VAR 0 2
28918: PPUSH
28919: CALL_OW 301
28923: IFFALSE 28871
// end ;
28925: PPOPN 2
28927: END
// every 0 0$1 trigger StreamModeActive and sStu do
28928: LD_EXP 90
28932: PUSH
28933: LD_EXP 129
28937: AND
28938: IFFALSE 28954
28940: GO 28942
28942: DISABLE
// begin ToLua ( displayStucuk(); ) ;
28943: LD_STRING displayStucuk();
28945: PPUSH
28946: CALL_OW 559
// ResetFog ;
28950: CALL_OW 335
// end ;
28954: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
28955: LD_EXP 90
28959: PUSH
28960: LD_EXP 122
28964: AND
28965: IFFALSE 29106
28967: GO 28969
28969: DISABLE
28970: LD_INT 0
28972: PPUSH
28973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
28974: LD_ADDR_VAR 0 2
28978: PUSH
28979: LD_INT 22
28981: PUSH
28982: LD_OWVAR 2
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 21
28993: PUSH
28994: LD_INT 1
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: PUSH
29001: EMPTY
29002: LIST
29003: LIST
29004: PPUSH
29005: CALL_OW 69
29009: ST_TO_ADDR
// if not tmp then
29010: LD_VAR 0 2
29014: NOT
29015: IFFALSE 29019
// exit ;
29017: GO 29106
// un := tmp [ rand ( 1 , tmp ) ] ;
29019: LD_ADDR_VAR 0 1
29023: PUSH
29024: LD_VAR 0 2
29028: PUSH
29029: LD_INT 1
29031: PPUSH
29032: LD_VAR 0 2
29036: PPUSH
29037: CALL_OW 12
29041: ARRAY
29042: ST_TO_ADDR
// SetSide ( un , 0 ) ;
29043: LD_VAR 0 1
29047: PPUSH
29048: LD_INT 0
29050: PPUSH
29051: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
29055: LD_VAR 0 1
29059: PPUSH
29060: LD_OWVAR 3
29064: PUSH
29065: LD_VAR 0 1
29069: DIFF
29070: PPUSH
29071: LD_VAR 0 1
29075: PPUSH
29076: CALL_OW 74
29080: PPUSH
29081: CALL_OW 115
// wait ( 0 0$20 ) ;
29085: LD_INT 700
29087: PPUSH
29088: CALL_OW 67
// SetSide ( un , your_side ) ;
29092: LD_VAR 0 1
29096: PPUSH
29097: LD_OWVAR 2
29101: PPUSH
29102: CALL_OW 235
// end ;
29106: PPOPN 2
29108: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
29109: LD_EXP 90
29113: PUSH
29114: LD_EXP 123
29118: AND
29119: IFFALSE 29225
29121: GO 29123
29123: DISABLE
29124: LD_INT 0
29126: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29127: LD_ADDR_VAR 0 1
29131: PUSH
29132: LD_INT 22
29134: PUSH
29135: LD_OWVAR 2
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PUSH
29144: LD_INT 2
29146: PUSH
29147: LD_INT 30
29149: PUSH
29150: LD_INT 0
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PUSH
29157: LD_INT 30
29159: PUSH
29160: LD_INT 1
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: LIST
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: PPUSH
29176: CALL_OW 69
29180: ST_TO_ADDR
// if not depot then
29181: LD_VAR 0 1
29185: NOT
29186: IFFALSE 29190
// exit ;
29188: GO 29225
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
29190: LD_VAR 0 1
29194: PUSH
29195: LD_INT 1
29197: ARRAY
29198: PPUSH
29199: CALL_OW 250
29203: PPUSH
29204: LD_VAR 0 1
29208: PUSH
29209: LD_INT 1
29211: ARRAY
29212: PPUSH
29213: CALL_OW 251
29217: PPUSH
29218: LD_INT 70
29220: PPUSH
29221: CALL_OW 495
// end ;
29225: PPOPN 1
29227: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
29228: LD_EXP 90
29232: PUSH
29233: LD_EXP 124
29237: AND
29238: IFFALSE 29449
29240: GO 29242
29242: DISABLE
29243: LD_INT 0
29245: PPUSH
29246: PPUSH
29247: PPUSH
29248: PPUSH
29249: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
29250: LD_ADDR_VAR 0 5
29254: PUSH
29255: LD_INT 22
29257: PUSH
29258: LD_OWVAR 2
29262: PUSH
29263: EMPTY
29264: LIST
29265: LIST
29266: PUSH
29267: LD_INT 21
29269: PUSH
29270: LD_INT 1
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PPUSH
29281: CALL_OW 69
29285: ST_TO_ADDR
// if not tmp then
29286: LD_VAR 0 5
29290: NOT
29291: IFFALSE 29295
// exit ;
29293: GO 29449
// for i in tmp do
29295: LD_ADDR_VAR 0 1
29299: PUSH
29300: LD_VAR 0 5
29304: PUSH
29305: FOR_IN
29306: IFFALSE 29447
// begin d := rand ( 0 , 5 ) ;
29308: LD_ADDR_VAR 0 4
29312: PUSH
29313: LD_INT 0
29315: PPUSH
29316: LD_INT 5
29318: PPUSH
29319: CALL_OW 12
29323: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
29324: LD_ADDR_VAR 0 2
29328: PUSH
29329: LD_VAR 0 1
29333: PPUSH
29334: CALL_OW 250
29338: PPUSH
29339: LD_VAR 0 4
29343: PPUSH
29344: LD_INT 3
29346: PPUSH
29347: LD_INT 12
29349: PPUSH
29350: CALL_OW 12
29354: PPUSH
29355: CALL_OW 272
29359: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
29360: LD_ADDR_VAR 0 3
29364: PUSH
29365: LD_VAR 0 1
29369: PPUSH
29370: CALL_OW 251
29374: PPUSH
29375: LD_VAR 0 4
29379: PPUSH
29380: LD_INT 3
29382: PPUSH
29383: LD_INT 12
29385: PPUSH
29386: CALL_OW 12
29390: PPUSH
29391: CALL_OW 273
29395: ST_TO_ADDR
// if ValidHex ( x , y ) then
29396: LD_VAR 0 2
29400: PPUSH
29401: LD_VAR 0 3
29405: PPUSH
29406: CALL_OW 488
29410: IFFALSE 29445
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
29412: LD_VAR 0 1
29416: PPUSH
29417: LD_VAR 0 2
29421: PPUSH
29422: LD_VAR 0 3
29426: PPUSH
29427: LD_INT 3
29429: PPUSH
29430: LD_INT 6
29432: PPUSH
29433: CALL_OW 12
29437: PPUSH
29438: LD_INT 1
29440: PPUSH
29441: CALL_OW 483
// end ;
29445: GO 29305
29447: POP
29448: POP
// end ;
29449: PPOPN 5
29451: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
29452: LD_EXP 90
29456: PUSH
29457: LD_EXP 125
29461: AND
29462: IFFALSE 29556
29464: GO 29466
29466: DISABLE
29467: LD_INT 0
29469: PPUSH
29470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
29471: LD_ADDR_VAR 0 2
29475: PUSH
29476: LD_INT 22
29478: PUSH
29479: LD_OWVAR 2
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: LD_INT 32
29490: PUSH
29491: LD_INT 1
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 21
29500: PUSH
29501: LD_INT 2
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: LIST
29512: PPUSH
29513: CALL_OW 69
29517: ST_TO_ADDR
// if not tmp then
29518: LD_VAR 0 2
29522: NOT
29523: IFFALSE 29527
// exit ;
29525: GO 29556
// for i in tmp do
29527: LD_ADDR_VAR 0 1
29531: PUSH
29532: LD_VAR 0 2
29536: PUSH
29537: FOR_IN
29538: IFFALSE 29554
// SetFuel ( i , 0 ) ;
29540: LD_VAR 0 1
29544: PPUSH
29545: LD_INT 0
29547: PPUSH
29548: CALL_OW 240
29552: GO 29537
29554: POP
29555: POP
// end ;
29556: PPOPN 2
29558: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
29559: LD_EXP 90
29563: PUSH
29564: LD_EXP 126
29568: AND
29569: IFFALSE 29635
29571: GO 29573
29573: DISABLE
29574: LD_INT 0
29576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
29577: LD_ADDR_VAR 0 1
29581: PUSH
29582: LD_INT 22
29584: PUSH
29585: LD_OWVAR 2
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PUSH
29594: LD_INT 30
29596: PUSH
29597: LD_INT 29
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: EMPTY
29605: LIST
29606: LIST
29607: PPUSH
29608: CALL_OW 69
29612: ST_TO_ADDR
// if not tmp then
29613: LD_VAR 0 1
29617: NOT
29618: IFFALSE 29622
// exit ;
29620: GO 29635
// DestroyUnit ( tmp [ 1 ] ) ;
29622: LD_VAR 0 1
29626: PUSH
29627: LD_INT 1
29629: ARRAY
29630: PPUSH
29631: CALL_OW 65
// end ;
29635: PPOPN 1
29637: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
29638: LD_EXP 90
29642: PUSH
29643: LD_EXP 128
29647: AND
29648: IFFALSE 29777
29650: GO 29652
29652: DISABLE
29653: LD_INT 0
29655: PPUSH
// begin uc_side := 0 ;
29656: LD_ADDR_OWVAR 20
29660: PUSH
29661: LD_INT 0
29663: ST_TO_ADDR
// uc_nation := nation_arabian ;
29664: LD_ADDR_OWVAR 21
29668: PUSH
29669: LD_INT 2
29671: ST_TO_ADDR
// hc_gallery :=  ;
29672: LD_ADDR_OWVAR 33
29676: PUSH
29677: LD_STRING 
29679: ST_TO_ADDR
// hc_name :=  ;
29680: LD_ADDR_OWVAR 26
29684: PUSH
29685: LD_STRING 
29687: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
29688: LD_INT 1
29690: PPUSH
29691: LD_INT 11
29693: PPUSH
29694: LD_INT 10
29696: PPUSH
29697: CALL_OW 380
// un := CreateHuman ;
29701: LD_ADDR_VAR 0 1
29705: PUSH
29706: CALL_OW 44
29710: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29711: LD_VAR 0 1
29715: PPUSH
29716: LD_INT 1
29718: PPUSH
29719: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
29723: LD_INT 35
29725: PPUSH
29726: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
29730: LD_VAR 0 1
29734: PPUSH
29735: LD_INT 22
29737: PUSH
29738: LD_OWVAR 2
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PPUSH
29747: CALL_OW 69
29751: PPUSH
29752: LD_VAR 0 1
29756: PPUSH
29757: CALL_OW 74
29761: PPUSH
29762: CALL_OW 115
// until IsDead ( un ) ;
29766: LD_VAR 0 1
29770: PPUSH
29771: CALL_OW 301
29775: IFFALSE 29723
// end ;
29777: PPOPN 1
29779: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
29780: LD_EXP 90
29784: PUSH
29785: LD_EXP 130
29789: AND
29790: IFFALSE 29802
29792: GO 29794
29794: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
29795: LD_STRING earthquake(getX(game), 0, 32)
29797: PPUSH
29798: CALL_OW 559
29802: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
29803: LD_EXP 90
29807: PUSH
29808: LD_EXP 131
29812: AND
29813: IFFALSE 29904
29815: GO 29817
29817: DISABLE
29818: LD_INT 0
29820: PPUSH
// begin enable ;
29821: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
29822: LD_ADDR_VAR 0 1
29826: PUSH
29827: LD_INT 22
29829: PUSH
29830: LD_OWVAR 2
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 21
29841: PUSH
29842: LD_INT 2
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 33
29851: PUSH
29852: LD_INT 3
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: LIST
29863: PPUSH
29864: CALL_OW 69
29868: ST_TO_ADDR
// if not tmp then
29869: LD_VAR 0 1
29873: NOT
29874: IFFALSE 29878
// exit ;
29876: GO 29904
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
29878: LD_VAR 0 1
29882: PUSH
29883: LD_INT 1
29885: PPUSH
29886: LD_VAR 0 1
29890: PPUSH
29891: CALL_OW 12
29895: ARRAY
29896: PPUSH
29897: LD_INT 1
29899: PPUSH
29900: CALL_OW 234
// end ;
29904: PPOPN 1
29906: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
29907: LD_EXP 90
29911: PUSH
29912: LD_EXP 132
29916: AND
29917: IFFALSE 30058
29919: GO 29921
29921: DISABLE
29922: LD_INT 0
29924: PPUSH
29925: PPUSH
29926: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
29927: LD_ADDR_VAR 0 3
29931: PUSH
29932: LD_INT 22
29934: PUSH
29935: LD_OWVAR 2
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: PUSH
29944: LD_INT 25
29946: PUSH
29947: LD_INT 1
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PPUSH
29958: CALL_OW 69
29962: ST_TO_ADDR
// if not tmp then
29963: LD_VAR 0 3
29967: NOT
29968: IFFALSE 29972
// exit ;
29970: GO 30058
// un := tmp [ rand ( 1 , tmp ) ] ;
29972: LD_ADDR_VAR 0 2
29976: PUSH
29977: LD_VAR 0 3
29981: PUSH
29982: LD_INT 1
29984: PPUSH
29985: LD_VAR 0 3
29989: PPUSH
29990: CALL_OW 12
29994: ARRAY
29995: ST_TO_ADDR
// if Crawls ( un ) then
29996: LD_VAR 0 2
30000: PPUSH
30001: CALL_OW 318
30005: IFFALSE 30016
// ComWalk ( un ) ;
30007: LD_VAR 0 2
30011: PPUSH
30012: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
30016: LD_VAR 0 2
30020: PPUSH
30021: LD_INT 9
30023: PPUSH
30024: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
30028: LD_INT 28
30030: PPUSH
30031: LD_OWVAR 2
30035: PPUSH
30036: LD_INT 2
30038: PPUSH
30039: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
30043: LD_INT 29
30045: PPUSH
30046: LD_OWVAR 2
30050: PPUSH
30051: LD_INT 2
30053: PPUSH
30054: CALL_OW 322
// end ;
30058: PPOPN 3
30060: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
30061: LD_EXP 90
30065: PUSH
30066: LD_EXP 133
30070: AND
30071: IFFALSE 30182
30073: GO 30075
30075: DISABLE
30076: LD_INT 0
30078: PPUSH
30079: PPUSH
30080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
30081: LD_ADDR_VAR 0 3
30085: PUSH
30086: LD_INT 22
30088: PUSH
30089: LD_OWVAR 2
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 25
30100: PUSH
30101: LD_INT 1
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PPUSH
30112: CALL_OW 69
30116: ST_TO_ADDR
// if not tmp then
30117: LD_VAR 0 3
30121: NOT
30122: IFFALSE 30126
// exit ;
30124: GO 30182
// un := tmp [ rand ( 1 , tmp ) ] ;
30126: LD_ADDR_VAR 0 2
30130: PUSH
30131: LD_VAR 0 3
30135: PUSH
30136: LD_INT 1
30138: PPUSH
30139: LD_VAR 0 3
30143: PPUSH
30144: CALL_OW 12
30148: ARRAY
30149: ST_TO_ADDR
// if Crawls ( un ) then
30150: LD_VAR 0 2
30154: PPUSH
30155: CALL_OW 318
30159: IFFALSE 30170
// ComWalk ( un ) ;
30161: LD_VAR 0 2
30165: PPUSH
30166: CALL_OW 138
// SetClass ( un , class_mortar ) ;
30170: LD_VAR 0 2
30174: PPUSH
30175: LD_INT 8
30177: PPUSH
30178: CALL_OW 336
// end ;
30182: PPOPN 3
30184: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
30185: LD_EXP 90
30189: PUSH
30190: LD_EXP 134
30194: AND
30195: IFFALSE 30339
30197: GO 30199
30199: DISABLE
30200: LD_INT 0
30202: PPUSH
30203: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
30204: LD_ADDR_VAR 0 2
30208: PUSH
30209: LD_INT 22
30211: PUSH
30212: LD_OWVAR 2
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 21
30223: PUSH
30224: LD_INT 2
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: PUSH
30231: LD_INT 2
30233: PUSH
30234: LD_INT 34
30236: PUSH
30237: LD_INT 12
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 34
30246: PUSH
30247: LD_INT 51
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 34
30256: PUSH
30257: LD_INT 32
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: LIST
30268: LIST
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: LIST
30274: PPUSH
30275: CALL_OW 69
30279: ST_TO_ADDR
// if not tmp then
30280: LD_VAR 0 2
30284: NOT
30285: IFFALSE 30289
// exit ;
30287: GO 30339
// for i in tmp do
30289: LD_ADDR_VAR 0 1
30293: PUSH
30294: LD_VAR 0 2
30298: PUSH
30299: FOR_IN
30300: IFFALSE 30337
// if GetCargo ( i , mat_artifact ) = 0 then
30302: LD_VAR 0 1
30306: PPUSH
30307: LD_INT 4
30309: PPUSH
30310: CALL_OW 289
30314: PUSH
30315: LD_INT 0
30317: EQUAL
30318: IFFALSE 30335
// SetCargo ( i , mat_siberit , 100 ) ;
30320: LD_VAR 0 1
30324: PPUSH
30325: LD_INT 3
30327: PPUSH
30328: LD_INT 100
30330: PPUSH
30331: CALL_OW 290
30335: GO 30299
30337: POP
30338: POP
// end ;
30339: PPOPN 2
30341: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
30342: LD_EXP 90
30346: PUSH
30347: LD_EXP 135
30351: AND
30352: IFFALSE 30535
30354: GO 30356
30356: DISABLE
30357: LD_INT 0
30359: PPUSH
30360: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
30361: LD_ADDR_VAR 0 2
30365: PUSH
30366: LD_INT 22
30368: PUSH
30369: LD_OWVAR 2
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PPUSH
30378: CALL_OW 69
30382: ST_TO_ADDR
// if not tmp then
30383: LD_VAR 0 2
30387: NOT
30388: IFFALSE 30392
// exit ;
30390: GO 30535
// for i := 1 to 2 do
30392: LD_ADDR_VAR 0 1
30396: PUSH
30397: DOUBLE
30398: LD_INT 1
30400: DEC
30401: ST_TO_ADDR
30402: LD_INT 2
30404: PUSH
30405: FOR_TO
30406: IFFALSE 30533
// begin uc_side := your_side ;
30408: LD_ADDR_OWVAR 20
30412: PUSH
30413: LD_OWVAR 2
30417: ST_TO_ADDR
// uc_nation := nation_american ;
30418: LD_ADDR_OWVAR 21
30422: PUSH
30423: LD_INT 1
30425: ST_TO_ADDR
// vc_chassis := us_morphling ;
30426: LD_ADDR_OWVAR 37
30430: PUSH
30431: LD_INT 5
30433: ST_TO_ADDR
// vc_engine := engine_siberite ;
30434: LD_ADDR_OWVAR 39
30438: PUSH
30439: LD_INT 3
30441: ST_TO_ADDR
// vc_control := control_computer ;
30442: LD_ADDR_OWVAR 38
30446: PUSH
30447: LD_INT 3
30449: ST_TO_ADDR
// vc_weapon := us_double_laser ;
30450: LD_ADDR_OWVAR 40
30454: PUSH
30455: LD_INT 10
30457: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
30458: LD_VAR 0 2
30462: PUSH
30463: LD_INT 1
30465: ARRAY
30466: PPUSH
30467: CALL_OW 310
30471: NOT
30472: IFFALSE 30519
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
30474: CALL_OW 45
30478: PPUSH
30479: LD_VAR 0 2
30483: PUSH
30484: LD_INT 1
30486: ARRAY
30487: PPUSH
30488: CALL_OW 250
30492: PPUSH
30493: LD_VAR 0 2
30497: PUSH
30498: LD_INT 1
30500: ARRAY
30501: PPUSH
30502: CALL_OW 251
30506: PPUSH
30507: LD_INT 12
30509: PPUSH
30510: LD_INT 1
30512: PPUSH
30513: CALL_OW 50
30517: GO 30531
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
30519: CALL_OW 45
30523: PPUSH
30524: LD_INT 1
30526: PPUSH
30527: CALL_OW 51
// end ;
30531: GO 30405
30533: POP
30534: POP
// end ;
30535: PPOPN 2
30537: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
30538: LD_EXP 90
30542: PUSH
30543: LD_EXP 136
30547: AND
30548: IFFALSE 30770
30550: GO 30552
30552: DISABLE
30553: LD_INT 0
30555: PPUSH
30556: PPUSH
30557: PPUSH
30558: PPUSH
30559: PPUSH
30560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
30561: LD_ADDR_VAR 0 6
30565: PUSH
30566: LD_INT 22
30568: PUSH
30569: LD_OWVAR 2
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 21
30580: PUSH
30581: LD_INT 1
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: PUSH
30588: LD_INT 3
30590: PUSH
30591: LD_INT 23
30593: PUSH
30594: LD_INT 0
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: PUSH
30601: EMPTY
30602: LIST
30603: LIST
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: LIST
30609: PPUSH
30610: CALL_OW 69
30614: ST_TO_ADDR
// if not tmp then
30615: LD_VAR 0 6
30619: NOT
30620: IFFALSE 30624
// exit ;
30622: GO 30770
// s1 := rand ( 1 , 4 ) ;
30624: LD_ADDR_VAR 0 2
30628: PUSH
30629: LD_INT 1
30631: PPUSH
30632: LD_INT 4
30634: PPUSH
30635: CALL_OW 12
30639: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
30640: LD_ADDR_VAR 0 4
30644: PUSH
30645: LD_VAR 0 6
30649: PUSH
30650: LD_INT 1
30652: ARRAY
30653: PPUSH
30654: LD_VAR 0 2
30658: PPUSH
30659: CALL_OW 259
30663: ST_TO_ADDR
// if s1 = 1 then
30664: LD_VAR 0 2
30668: PUSH
30669: LD_INT 1
30671: EQUAL
30672: IFFALSE 30692
// s2 := rand ( 2 , 4 ) else
30674: LD_ADDR_VAR 0 3
30678: PUSH
30679: LD_INT 2
30681: PPUSH
30682: LD_INT 4
30684: PPUSH
30685: CALL_OW 12
30689: ST_TO_ADDR
30690: GO 30700
// s2 := 1 ;
30692: LD_ADDR_VAR 0 3
30696: PUSH
30697: LD_INT 1
30699: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
30700: LD_ADDR_VAR 0 5
30704: PUSH
30705: LD_VAR 0 6
30709: PUSH
30710: LD_INT 1
30712: ARRAY
30713: PPUSH
30714: LD_VAR 0 3
30718: PPUSH
30719: CALL_OW 259
30723: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
30724: LD_VAR 0 6
30728: PUSH
30729: LD_INT 1
30731: ARRAY
30732: PPUSH
30733: LD_VAR 0 2
30737: PPUSH
30738: LD_VAR 0 5
30742: PPUSH
30743: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
30747: LD_VAR 0 6
30751: PUSH
30752: LD_INT 1
30754: ARRAY
30755: PPUSH
30756: LD_VAR 0 3
30760: PPUSH
30761: LD_VAR 0 4
30765: PPUSH
30766: CALL_OW 237
// end ;
30770: PPOPN 6
30772: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
30773: LD_EXP 90
30777: PUSH
30778: LD_EXP 137
30782: AND
30783: IFFALSE 30862
30785: GO 30787
30787: DISABLE
30788: LD_INT 0
30790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
30791: LD_ADDR_VAR 0 1
30795: PUSH
30796: LD_INT 22
30798: PUSH
30799: LD_OWVAR 2
30803: PUSH
30804: EMPTY
30805: LIST
30806: LIST
30807: PUSH
30808: LD_INT 30
30810: PUSH
30811: LD_INT 3
30813: PUSH
30814: EMPTY
30815: LIST
30816: LIST
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: PPUSH
30822: CALL_OW 69
30826: ST_TO_ADDR
// if not tmp then
30827: LD_VAR 0 1
30831: NOT
30832: IFFALSE 30836
// exit ;
30834: GO 30862
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
30836: LD_VAR 0 1
30840: PUSH
30841: LD_INT 1
30843: PPUSH
30844: LD_VAR 0 1
30848: PPUSH
30849: CALL_OW 12
30853: ARRAY
30854: PPUSH
30855: LD_INT 1
30857: PPUSH
30858: CALL_OW 234
// end ;
30862: PPOPN 1
30864: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
30865: LD_EXP 90
30869: PUSH
30870: LD_EXP 138
30874: AND
30875: IFFALSE 30987
30877: GO 30879
30879: DISABLE
30880: LD_INT 0
30882: PPUSH
30883: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
30884: LD_ADDR_VAR 0 2
30888: PUSH
30889: LD_INT 22
30891: PUSH
30892: LD_OWVAR 2
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 2
30903: PUSH
30904: LD_INT 30
30906: PUSH
30907: LD_INT 27
30909: PUSH
30910: EMPTY
30911: LIST
30912: LIST
30913: PUSH
30914: LD_INT 30
30916: PUSH
30917: LD_INT 26
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 30
30926: PUSH
30927: LD_INT 28
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: EMPTY
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PPUSH
30944: CALL_OW 69
30948: ST_TO_ADDR
// if not tmp then
30949: LD_VAR 0 2
30953: NOT
30954: IFFALSE 30958
// exit ;
30956: GO 30987
// for i in tmp do
30958: LD_ADDR_VAR 0 1
30962: PUSH
30963: LD_VAR 0 2
30967: PUSH
30968: FOR_IN
30969: IFFALSE 30985
// SetLives ( i , 1 ) ;
30971: LD_VAR 0 1
30975: PPUSH
30976: LD_INT 1
30978: PPUSH
30979: CALL_OW 234
30983: GO 30968
30985: POP
30986: POP
// end ;
30987: PPOPN 2
30989: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
30990: LD_EXP 90
30994: PUSH
30995: LD_EXP 139
30999: AND
31000: IFFALSE 31274
31002: GO 31004
31004: DISABLE
31005: LD_INT 0
31007: PPUSH
31008: PPUSH
31009: PPUSH
// begin i := rand ( 1 , 7 ) ;
31010: LD_ADDR_VAR 0 1
31014: PUSH
31015: LD_INT 1
31017: PPUSH
31018: LD_INT 7
31020: PPUSH
31021: CALL_OW 12
31025: ST_TO_ADDR
// case i of 1 :
31026: LD_VAR 0 1
31030: PUSH
31031: LD_INT 1
31033: DOUBLE
31034: EQUAL
31035: IFTRUE 31039
31037: GO 31049
31039: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
31040: LD_STRING earthquake(getX(game), 0, 32)
31042: PPUSH
31043: CALL_OW 559
31047: GO 31274
31049: LD_INT 2
31051: DOUBLE
31052: EQUAL
31053: IFTRUE 31057
31055: GO 31071
31057: POP
// begin ToLua ( displayStucuk(); ) ;
31058: LD_STRING displayStucuk();
31060: PPUSH
31061: CALL_OW 559
// ResetFog ;
31065: CALL_OW 335
// end ; 3 :
31069: GO 31274
31071: LD_INT 3
31073: DOUBLE
31074: EQUAL
31075: IFTRUE 31079
31077: GO 31183
31079: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
31080: LD_ADDR_VAR 0 2
31084: PUSH
31085: LD_INT 22
31087: PUSH
31088: LD_OWVAR 2
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 25
31099: PUSH
31100: LD_INT 1
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PPUSH
31111: CALL_OW 69
31115: ST_TO_ADDR
// if not tmp then
31116: LD_VAR 0 2
31120: NOT
31121: IFFALSE 31125
// exit ;
31123: GO 31274
// un := tmp [ rand ( 1 , tmp ) ] ;
31125: LD_ADDR_VAR 0 3
31129: PUSH
31130: LD_VAR 0 2
31134: PUSH
31135: LD_INT 1
31137: PPUSH
31138: LD_VAR 0 2
31142: PPUSH
31143: CALL_OW 12
31147: ARRAY
31148: ST_TO_ADDR
// if Crawls ( un ) then
31149: LD_VAR 0 3
31153: PPUSH
31154: CALL_OW 318
31158: IFFALSE 31169
// ComWalk ( un ) ;
31160: LD_VAR 0 3
31164: PPUSH
31165: CALL_OW 138
// SetClass ( un , class_mortar ) ;
31169: LD_VAR 0 3
31173: PPUSH
31174: LD_INT 8
31176: PPUSH
31177: CALL_OW 336
// end ; 4 :
31181: GO 31274
31183: LD_INT 4
31185: DOUBLE
31186: EQUAL
31187: IFTRUE 31191
31189: GO 31252
31191: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
31192: LD_ADDR_VAR 0 2
31196: PUSH
31197: LD_INT 22
31199: PUSH
31200: LD_OWVAR 2
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 30
31211: PUSH
31212: LD_INT 29
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PPUSH
31223: CALL_OW 69
31227: ST_TO_ADDR
// if not tmp then
31228: LD_VAR 0 2
31232: NOT
31233: IFFALSE 31237
// exit ;
31235: GO 31274
// DestroyUnit ( tmp [ 1 ] ) ;
31237: LD_VAR 0 2
31241: PUSH
31242: LD_INT 1
31244: ARRAY
31245: PPUSH
31246: CALL_OW 65
// end ; 5 .. 7 :
31250: GO 31274
31252: LD_INT 5
31254: DOUBLE
31255: GREATEREQUAL
31256: IFFALSE 31264
31258: LD_INT 7
31260: DOUBLE
31261: LESSEQUAL
31262: IFTRUE 31266
31264: GO 31273
31266: POP
// StreamSibBomb ; end ;
31267: CALL 27524 0 0
31271: GO 31274
31273: POP
// end ;
31274: PPOPN 3
31276: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
31277: LD_EXP 90
31281: PUSH
31282: LD_EXP 140
31286: AND
31287: IFFALSE 31443
31289: GO 31291
31291: DISABLE
31292: LD_INT 0
31294: PPUSH
31295: PPUSH
31296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
31297: LD_ADDR_VAR 0 2
31301: PUSH
31302: LD_INT 81
31304: PUSH
31305: LD_OWVAR 2
31309: PUSH
31310: EMPTY
31311: LIST
31312: LIST
31313: PUSH
31314: LD_INT 2
31316: PUSH
31317: LD_INT 21
31319: PUSH
31320: LD_INT 1
31322: PUSH
31323: EMPTY
31324: LIST
31325: LIST
31326: PUSH
31327: LD_INT 21
31329: PUSH
31330: LD_INT 2
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: LIST
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PPUSH
31346: CALL_OW 69
31350: ST_TO_ADDR
// if not tmp then
31351: LD_VAR 0 2
31355: NOT
31356: IFFALSE 31360
// exit ;
31358: GO 31443
// p := 0 ;
31360: LD_ADDR_VAR 0 3
31364: PUSH
31365: LD_INT 0
31367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31368: LD_INT 35
31370: PPUSH
31371: CALL_OW 67
// p := p + 1 ;
31375: LD_ADDR_VAR 0 3
31379: PUSH
31380: LD_VAR 0 3
31384: PUSH
31385: LD_INT 1
31387: PLUS
31388: ST_TO_ADDR
// for i in tmp do
31389: LD_ADDR_VAR 0 1
31393: PUSH
31394: LD_VAR 0 2
31398: PUSH
31399: FOR_IN
31400: IFFALSE 31431
// if GetLives ( i ) < 1000 then
31402: LD_VAR 0 1
31406: PPUSH
31407: CALL_OW 256
31411: PUSH
31412: LD_INT 1000
31414: LESS
31415: IFFALSE 31429
// SetLives ( i , 1000 ) ;
31417: LD_VAR 0 1
31421: PPUSH
31422: LD_INT 1000
31424: PPUSH
31425: CALL_OW 234
31429: GO 31399
31431: POP
31432: POP
// until p > 20 ;
31433: LD_VAR 0 3
31437: PUSH
31438: LD_INT 20
31440: GREATER
31441: IFFALSE 31368
// end ;
31443: PPOPN 3
31445: END
// every 0 0$1 trigger StreamModeActive and sTime do
31446: LD_EXP 90
31450: PUSH
31451: LD_EXP 141
31455: AND
31456: IFFALSE 31491
31458: GO 31460
31460: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
31461: LD_INT 28
31463: PPUSH
31464: LD_OWVAR 2
31468: PPUSH
31469: LD_INT 2
31471: PPUSH
31472: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
31476: LD_INT 30
31478: PPUSH
31479: LD_OWVAR 2
31483: PPUSH
31484: LD_INT 2
31486: PPUSH
31487: CALL_OW 322
// end ;
31491: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
31492: LD_EXP 90
31496: PUSH
31497: LD_EXP 142
31501: AND
31502: IFFALSE 31623
31504: GO 31506
31506: DISABLE
31507: LD_INT 0
31509: PPUSH
31510: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
31511: LD_ADDR_VAR 0 2
31515: PUSH
31516: LD_INT 22
31518: PUSH
31519: LD_OWVAR 2
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 21
31530: PUSH
31531: LD_INT 1
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: LD_INT 3
31540: PUSH
31541: LD_INT 23
31543: PUSH
31544: LD_INT 0
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: LIST
31559: PPUSH
31560: CALL_OW 69
31564: ST_TO_ADDR
// if not tmp then
31565: LD_VAR 0 2
31569: NOT
31570: IFFALSE 31574
// exit ;
31572: GO 31623
// for i in tmp do
31574: LD_ADDR_VAR 0 1
31578: PUSH
31579: LD_VAR 0 2
31583: PUSH
31584: FOR_IN
31585: IFFALSE 31621
// begin if Crawls ( i ) then
31587: LD_VAR 0 1
31591: PPUSH
31592: CALL_OW 318
31596: IFFALSE 31607
// ComWalk ( i ) ;
31598: LD_VAR 0 1
31602: PPUSH
31603: CALL_OW 138
// SetClass ( i , 2 ) ;
31607: LD_VAR 0 1
31611: PPUSH
31612: LD_INT 2
31614: PPUSH
31615: CALL_OW 336
// end ;
31619: GO 31584
31621: POP
31622: POP
// end ;
31623: PPOPN 2
31625: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
31626: LD_EXP 90
31630: PUSH
31631: LD_EXP 143
31635: AND
31636: IFFALSE 31917
31638: GO 31640
31640: DISABLE
31641: LD_INT 0
31643: PPUSH
31644: PPUSH
31645: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
31646: LD_OWVAR 2
31650: PPUSH
31651: LD_INT 9
31653: PPUSH
31654: LD_INT 1
31656: PPUSH
31657: LD_INT 1
31659: PPUSH
31660: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
31664: LD_INT 9
31666: PPUSH
31667: LD_OWVAR 2
31671: PPUSH
31672: CALL_OW 343
// uc_side := 9 ;
31676: LD_ADDR_OWVAR 20
31680: PUSH
31681: LD_INT 9
31683: ST_TO_ADDR
// uc_nation := 2 ;
31684: LD_ADDR_OWVAR 21
31688: PUSH
31689: LD_INT 2
31691: ST_TO_ADDR
// hc_name := Dark Warrior ;
31692: LD_ADDR_OWVAR 26
31696: PUSH
31697: LD_STRING Dark Warrior
31699: ST_TO_ADDR
// hc_gallery :=  ;
31700: LD_ADDR_OWVAR 33
31704: PUSH
31705: LD_STRING 
31707: ST_TO_ADDR
// hc_noskilllimit := true ;
31708: LD_ADDR_OWVAR 76
31712: PUSH
31713: LD_INT 1
31715: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
31716: LD_ADDR_OWVAR 31
31720: PUSH
31721: LD_INT 30
31723: PUSH
31724: LD_INT 30
31726: PUSH
31727: LD_INT 30
31729: PUSH
31730: LD_INT 30
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: ST_TO_ADDR
// un := CreateHuman ;
31739: LD_ADDR_VAR 0 3
31743: PUSH
31744: CALL_OW 44
31748: ST_TO_ADDR
// hc_noskilllimit := false ;
31749: LD_ADDR_OWVAR 76
31753: PUSH
31754: LD_INT 0
31756: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
31757: LD_VAR 0 3
31761: PPUSH
31762: LD_INT 1
31764: PPUSH
31765: CALL_OW 51
// p := 0 ;
31769: LD_ADDR_VAR 0 2
31773: PUSH
31774: LD_INT 0
31776: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31777: LD_INT 35
31779: PPUSH
31780: CALL_OW 67
// p := p + 1 ;
31784: LD_ADDR_VAR 0 2
31788: PUSH
31789: LD_VAR 0 2
31793: PUSH
31794: LD_INT 1
31796: PLUS
31797: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
31798: LD_VAR 0 3
31802: PPUSH
31803: CALL_OW 256
31807: PUSH
31808: LD_INT 1000
31810: LESS
31811: IFFALSE 31825
// SetLives ( un , 1000 ) ;
31813: LD_VAR 0 3
31817: PPUSH
31818: LD_INT 1000
31820: PPUSH
31821: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
31825: LD_VAR 0 3
31829: PPUSH
31830: LD_INT 81
31832: PUSH
31833: LD_OWVAR 2
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 91
31844: PUSH
31845: LD_VAR 0 3
31849: PUSH
31850: LD_INT 30
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: LIST
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PPUSH
31862: CALL_OW 69
31866: PPUSH
31867: LD_VAR 0 3
31871: PPUSH
31872: CALL_OW 74
31876: PPUSH
31877: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
31881: LD_VAR 0 2
31885: PUSH
31886: LD_INT 60
31888: GREATER
31889: PUSH
31890: LD_VAR 0 3
31894: PPUSH
31895: CALL_OW 301
31899: OR
31900: IFFALSE 31777
// if un then
31902: LD_VAR 0 3
31906: IFFALSE 31917
// RemoveUnit ( un ) ;
31908: LD_VAR 0 3
31912: PPUSH
31913: CALL_OW 64
// end ;
31917: PPOPN 3
31919: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
31920: LD_INT 0
31922: PPUSH
31923: PPUSH
31924: PPUSH
31925: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31926: LD_ADDR_VAR 0 4
31930: PUSH
31931: LD_INT 22
31933: PUSH
31934: LD_OWVAR 2
31938: PUSH
31939: EMPTY
31940: LIST
31941: LIST
31942: PUSH
31943: LD_INT 2
31945: PUSH
31946: LD_INT 30
31948: PUSH
31949: LD_INT 0
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 30
31958: PUSH
31959: LD_INT 1
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: LIST
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PPUSH
31975: CALL_OW 69
31979: ST_TO_ADDR
// if not tmp then
31980: LD_VAR 0 4
31984: NOT
31985: IFFALSE 31989
// exit ;
31987: GO 32048
// for i in tmp do
31989: LD_ADDR_VAR 0 2
31993: PUSH
31994: LD_VAR 0 4
31998: PUSH
31999: FOR_IN
32000: IFFALSE 32046
// for j = 1 to 3 do
32002: LD_ADDR_VAR 0 3
32006: PUSH
32007: DOUBLE
32008: LD_INT 1
32010: DEC
32011: ST_TO_ADDR
32012: LD_INT 3
32014: PUSH
32015: FOR_TO
32016: IFFALSE 32042
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
32018: LD_VAR 0 2
32022: PPUSH
32023: CALL_OW 274
32027: PPUSH
32028: LD_VAR 0 3
32032: PPUSH
32033: LD_INT 99999
32035: PPUSH
32036: CALL_OW 277
32040: GO 32015
32042: POP
32043: POP
32044: GO 31999
32046: POP
32047: POP
// end ;
32048: LD_VAR 0 1
32052: RET
// export function hHackSetLevel10 ; var i , j ; begin
32053: LD_INT 0
32055: PPUSH
32056: PPUSH
32057: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
32058: LD_ADDR_VAR 0 2
32062: PUSH
32063: LD_INT 21
32065: PUSH
32066: LD_INT 1
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PPUSH
32073: CALL_OW 69
32077: PUSH
32078: FOR_IN
32079: IFFALSE 32131
// if IsSelected ( i ) then
32081: LD_VAR 0 2
32085: PPUSH
32086: CALL_OW 306
32090: IFFALSE 32129
// begin for j := 1 to 4 do
32092: LD_ADDR_VAR 0 3
32096: PUSH
32097: DOUBLE
32098: LD_INT 1
32100: DEC
32101: ST_TO_ADDR
32102: LD_INT 4
32104: PUSH
32105: FOR_TO
32106: IFFALSE 32127
// SetSkill ( i , j , 10 ) ;
32108: LD_VAR 0 2
32112: PPUSH
32113: LD_VAR 0 3
32117: PPUSH
32118: LD_INT 10
32120: PPUSH
32121: CALL_OW 237
32125: GO 32105
32127: POP
32128: POP
// end ;
32129: GO 32078
32131: POP
32132: POP
// end ;
32133: LD_VAR 0 1
32137: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
32138: LD_INT 0
32140: PPUSH
32141: PPUSH
32142: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
32143: LD_ADDR_VAR 0 2
32147: PUSH
32148: LD_INT 22
32150: PUSH
32151: LD_OWVAR 2
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 21
32162: PUSH
32163: LD_INT 1
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PPUSH
32174: CALL_OW 69
32178: PUSH
32179: FOR_IN
32180: IFFALSE 32221
// begin for j := 1 to 4 do
32182: LD_ADDR_VAR 0 3
32186: PUSH
32187: DOUBLE
32188: LD_INT 1
32190: DEC
32191: ST_TO_ADDR
32192: LD_INT 4
32194: PUSH
32195: FOR_TO
32196: IFFALSE 32217
// SetSkill ( i , j , 10 ) ;
32198: LD_VAR 0 2
32202: PPUSH
32203: LD_VAR 0 3
32207: PPUSH
32208: LD_INT 10
32210: PPUSH
32211: CALL_OW 237
32215: GO 32195
32217: POP
32218: POP
// end ;
32219: GO 32179
32221: POP
32222: POP
// end ;
32223: LD_VAR 0 1
32227: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
32228: LD_INT 0
32230: PPUSH
// uc_side := your_side ;
32231: LD_ADDR_OWVAR 20
32235: PUSH
32236: LD_OWVAR 2
32240: ST_TO_ADDR
// uc_nation := nation ;
32241: LD_ADDR_OWVAR 21
32245: PUSH
32246: LD_VAR 0 1
32250: ST_TO_ADDR
// InitHc ;
32251: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
32255: LD_INT 0
32257: PPUSH
32258: LD_VAR 0 2
32262: PPUSH
32263: LD_VAR 0 3
32267: PPUSH
32268: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
32272: CALL_OW 44
32276: PPUSH
32277: LD_INT 1
32279: PPUSH
32280: CALL_OW 51
// end ;
32284: LD_VAR 0 4
32288: RET
// export function hHackSpawnVehicle ; begin
32289: LD_INT 0
32291: PPUSH
// uc_side := your_side ;
32292: LD_ADDR_OWVAR 20
32296: PUSH
32297: LD_OWVAR 2
32301: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
32302: LD_ADDR_OWVAR 21
32306: PUSH
32307: LD_INT 1
32309: PPUSH
32310: LD_INT 3
32312: PPUSH
32313: CALL_OW 12
32317: ST_TO_ADDR
// InitVc ;
32318: CALL_OW 20
// case uc_nation of 1 :
32322: LD_OWVAR 21
32326: PUSH
32327: LD_INT 1
32329: DOUBLE
32330: EQUAL
32331: IFTRUE 32335
32333: GO 32479
32335: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
32336: LD_ADDR_OWVAR 37
32340: PUSH
32341: LD_INT 1
32343: PUSH
32344: LD_INT 2
32346: PUSH
32347: LD_INT 3
32349: PUSH
32350: LD_INT 4
32352: PUSH
32353: LD_INT 5
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: LIST
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 1
32365: PPUSH
32366: LD_INT 5
32368: PPUSH
32369: CALL_OW 12
32373: ARRAY
32374: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
32375: LD_ADDR_OWVAR 39
32379: PUSH
32380: LD_INT 1
32382: PPUSH
32383: LD_INT 3
32385: PPUSH
32386: CALL_OW 12
32390: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
32391: LD_ADDR_OWVAR 38
32395: PUSH
32396: LD_INT 1
32398: PUSH
32399: LD_INT 2
32401: PUSH
32402: LD_INT 3
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 1
32412: PPUSH
32413: LD_INT 3
32415: PPUSH
32416: CALL_OW 12
32420: ARRAY
32421: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
32422: LD_ADDR_OWVAR 40
32426: PUSH
32427: LD_INT 2
32429: PUSH
32430: LD_INT 4
32432: PUSH
32433: LD_INT 5
32435: PUSH
32436: LD_INT 3
32438: PUSH
32439: LD_INT 7
32441: PUSH
32442: LD_INT 8
32444: PUSH
32445: LD_INT 9
32447: PUSH
32448: LD_INT 10
32450: PUSH
32451: LD_INT 6
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: LIST
32463: LIST
32464: PUSH
32465: LD_INT 1
32467: PPUSH
32468: LD_INT 9
32470: PPUSH
32471: CALL_OW 12
32475: ARRAY
32476: ST_TO_ADDR
// end ; 2 :
32477: GO 32744
32479: LD_INT 2
32481: DOUBLE
32482: EQUAL
32483: IFTRUE 32487
32485: GO 32611
32487: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
32488: LD_ADDR_OWVAR 37
32492: PUSH
32493: LD_INT 11
32495: PUSH
32496: LD_INT 12
32498: PUSH
32499: LD_INT 13
32501: PUSH
32502: LD_INT 14
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 1
32513: PPUSH
32514: LD_INT 4
32516: PPUSH
32517: CALL_OW 12
32521: ARRAY
32522: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
32523: LD_ADDR_OWVAR 39
32527: PUSH
32528: LD_INT 1
32530: PPUSH
32531: LD_INT 3
32533: PPUSH
32534: CALL_OW 12
32538: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
32539: LD_ADDR_OWVAR 38
32543: PUSH
32544: LD_INT 1
32546: PUSH
32547: LD_INT 2
32549: PUSH
32550: LD_INT 5
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: LIST
32557: PUSH
32558: LD_INT 1
32560: PPUSH
32561: LD_INT 3
32563: PPUSH
32564: CALL_OW 12
32568: ARRAY
32569: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
32570: LD_ADDR_OWVAR 40
32574: PUSH
32575: LD_INT 24
32577: PUSH
32578: LD_INT 26
32580: PUSH
32581: LD_INT 27
32583: PUSH
32584: LD_INT 28
32586: PUSH
32587: LD_INT 29
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 1
32599: PPUSH
32600: LD_INT 5
32602: PPUSH
32603: CALL_OW 12
32607: ARRAY
32608: ST_TO_ADDR
// end ; 3 :
32609: GO 32744
32611: LD_INT 3
32613: DOUBLE
32614: EQUAL
32615: IFTRUE 32619
32617: GO 32743
32619: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
32620: LD_ADDR_OWVAR 37
32624: PUSH
32625: LD_INT 21
32627: PUSH
32628: LD_INT 23
32630: PUSH
32631: LD_INT 22
32633: PUSH
32634: LD_INT 24
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 1
32645: PPUSH
32646: LD_INT 4
32648: PPUSH
32649: CALL_OW 12
32653: ARRAY
32654: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
32655: LD_ADDR_OWVAR 39
32659: PUSH
32660: LD_INT 1
32662: PPUSH
32663: LD_INT 3
32665: PPUSH
32666: CALL_OW 12
32670: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
32671: LD_ADDR_OWVAR 38
32675: PUSH
32676: LD_INT 1
32678: PUSH
32679: LD_INT 3
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 1
32688: PPUSH
32689: LD_INT 2
32691: PPUSH
32692: CALL_OW 12
32696: ARRAY
32697: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
32698: LD_ADDR_OWVAR 40
32702: PUSH
32703: LD_INT 42
32705: PUSH
32706: LD_INT 43
32708: PUSH
32709: LD_INT 44
32711: PUSH
32712: LD_INT 46
32714: PUSH
32715: LD_INT 48
32717: PUSH
32718: LD_INT 47
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: LIST
32725: LIST
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 1
32731: PPUSH
32732: LD_INT 6
32734: PPUSH
32735: CALL_OW 12
32739: ARRAY
32740: ST_TO_ADDR
// end ; end ;
32741: GO 32744
32743: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
32744: CALL_OW 45
32748: PPUSH
32749: LD_INT 1
32751: PPUSH
32752: CALL_OW 51
// end ;
32756: LD_VAR 0 1
32760: RET
// export hInvincible ; every 1 do
32761: GO 32763
32763: DISABLE
// hInvincible := [ ] ;
32764: LD_ADDR_EXP 144
32768: PUSH
32769: EMPTY
32770: ST_TO_ADDR
32771: END
// every 10 do var i ;
32772: GO 32774
32774: DISABLE
32775: LD_INT 0
32777: PPUSH
// begin enable ;
32778: ENABLE
// if not hInvincible then
32779: LD_EXP 144
32783: NOT
32784: IFFALSE 32788
// exit ;
32786: GO 32832
// for i in hInvincible do
32788: LD_ADDR_VAR 0 1
32792: PUSH
32793: LD_EXP 144
32797: PUSH
32798: FOR_IN
32799: IFFALSE 32830
// if GetLives ( i ) < 1000 then
32801: LD_VAR 0 1
32805: PPUSH
32806: CALL_OW 256
32810: PUSH
32811: LD_INT 1000
32813: LESS
32814: IFFALSE 32828
// SetLives ( i , 1000 ) ;
32816: LD_VAR 0 1
32820: PPUSH
32821: LD_INT 1000
32823: PPUSH
32824: CALL_OW 234
32828: GO 32798
32830: POP
32831: POP
// end ;
32832: PPOPN 1
32834: END
// export function hHackInvincible ; var i ; begin
32835: LD_INT 0
32837: PPUSH
32838: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
32839: LD_ADDR_VAR 0 2
32843: PUSH
32844: LD_INT 2
32846: PUSH
32847: LD_INT 21
32849: PUSH
32850: LD_INT 1
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 21
32859: PUSH
32860: LD_INT 2
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: LIST
32871: PPUSH
32872: CALL_OW 69
32876: PUSH
32877: FOR_IN
32878: IFFALSE 32939
// if IsSelected ( i ) then
32880: LD_VAR 0 2
32884: PPUSH
32885: CALL_OW 306
32889: IFFALSE 32937
// begin if i in hInvincible then
32891: LD_VAR 0 2
32895: PUSH
32896: LD_EXP 144
32900: IN
32901: IFFALSE 32921
// hInvincible := hInvincible diff i else
32903: LD_ADDR_EXP 144
32907: PUSH
32908: LD_EXP 144
32912: PUSH
32913: LD_VAR 0 2
32917: DIFF
32918: ST_TO_ADDR
32919: GO 32937
// hInvincible := hInvincible union i ;
32921: LD_ADDR_EXP 144
32925: PUSH
32926: LD_EXP 144
32930: PUSH
32931: LD_VAR 0 2
32935: UNION
32936: ST_TO_ADDR
// end ;
32937: GO 32877
32939: POP
32940: POP
// end ;
32941: LD_VAR 0 1
32945: RET
// export function hHackInvisible ; var i , j ; begin
32946: LD_INT 0
32948: PPUSH
32949: PPUSH
32950: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
32951: LD_ADDR_VAR 0 2
32955: PUSH
32956: LD_INT 21
32958: PUSH
32959: LD_INT 1
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PPUSH
32966: CALL_OW 69
32970: PUSH
32971: FOR_IN
32972: IFFALSE 32996
// if IsSelected ( i ) then
32974: LD_VAR 0 2
32978: PPUSH
32979: CALL_OW 306
32983: IFFALSE 32994
// ComForceInvisible ( i ) ;
32985: LD_VAR 0 2
32989: PPUSH
32990: CALL_OW 496
32994: GO 32971
32996: POP
32997: POP
// end ;
32998: LD_VAR 0 1
33002: RET
// export function hHackChangeYourSide ; begin
33003: LD_INT 0
33005: PPUSH
// if your_side = 8 then
33006: LD_OWVAR 2
33010: PUSH
33011: LD_INT 8
33013: EQUAL
33014: IFFALSE 33026
// your_side := 0 else
33016: LD_ADDR_OWVAR 2
33020: PUSH
33021: LD_INT 0
33023: ST_TO_ADDR
33024: GO 33040
// your_side := your_side + 1 ;
33026: LD_ADDR_OWVAR 2
33030: PUSH
33031: LD_OWVAR 2
33035: PUSH
33036: LD_INT 1
33038: PLUS
33039: ST_TO_ADDR
// end ;
33040: LD_VAR 0 1
33044: RET
// export function hHackChangeUnitSide ; var i , j ; begin
33045: LD_INT 0
33047: PPUSH
33048: PPUSH
33049: PPUSH
// for i in all_units do
33050: LD_ADDR_VAR 0 2
33054: PUSH
33055: LD_OWVAR 3
33059: PUSH
33060: FOR_IN
33061: IFFALSE 33139
// if IsSelected ( i ) then
33063: LD_VAR 0 2
33067: PPUSH
33068: CALL_OW 306
33072: IFFALSE 33137
// begin j := GetSide ( i ) ;
33074: LD_ADDR_VAR 0 3
33078: PUSH
33079: LD_VAR 0 2
33083: PPUSH
33084: CALL_OW 255
33088: ST_TO_ADDR
// if j = 8 then
33089: LD_VAR 0 3
33093: PUSH
33094: LD_INT 8
33096: EQUAL
33097: IFFALSE 33109
// j := 0 else
33099: LD_ADDR_VAR 0 3
33103: PUSH
33104: LD_INT 0
33106: ST_TO_ADDR
33107: GO 33123
// j := j + 1 ;
33109: LD_ADDR_VAR 0 3
33113: PUSH
33114: LD_VAR 0 3
33118: PUSH
33119: LD_INT 1
33121: PLUS
33122: ST_TO_ADDR
// SetSide ( i , j ) ;
33123: LD_VAR 0 2
33127: PPUSH
33128: LD_VAR 0 3
33132: PPUSH
33133: CALL_OW 235
// end ;
33137: GO 33060
33139: POP
33140: POP
// end ;
33141: LD_VAR 0 1
33145: RET
// export function hHackFog ; begin
33146: LD_INT 0
33148: PPUSH
// FogOff ( true ) ;
33149: LD_INT 1
33151: PPUSH
33152: CALL_OW 344
// end ;
33156: LD_VAR 0 1
33160: RET
// export function hHackApeman ; begin
33161: LD_INT 0
33163: PPUSH
// uc_side := your_side ;
33164: LD_ADDR_OWVAR 20
33168: PUSH
33169: LD_OWVAR 2
33173: ST_TO_ADDR
// uc_nation := 0 ;
33174: LD_ADDR_OWVAR 21
33178: PUSH
33179: LD_INT 0
33181: ST_TO_ADDR
// hc_name :=  ;
33182: LD_ADDR_OWVAR 26
33186: PUSH
33187: LD_STRING 
33189: ST_TO_ADDR
// hc_gallery :=  ;
33190: LD_ADDR_OWVAR 33
33194: PUSH
33195: LD_STRING 
33197: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
33198: LD_ADDR_OWVAR 31
33202: PUSH
33203: LD_INT 0
33205: PUSH
33206: LD_INT 0
33208: PUSH
33209: LD_INT 0
33211: PUSH
33212: LD_INT 0
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: ST_TO_ADDR
// hc_class := class_apeman ;
33221: LD_ADDR_OWVAR 28
33225: PUSH
33226: LD_INT 12
33228: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
33229: CALL_OW 44
33233: PPUSH
33234: LD_INT 1
33236: PPUSH
33237: CALL_OW 51
// end ;
33241: LD_VAR 0 1
33245: RET
// export function hHackBoom ; begin
33246: LD_INT 0
33248: PPUSH
// uc_side := your_side ;
33249: LD_ADDR_OWVAR 20
33253: PUSH
33254: LD_OWVAR 2
33258: ST_TO_ADDR
// uc_nation := 1 ;
33259: LD_ADDR_OWVAR 21
33263: PUSH
33264: LD_INT 1
33266: ST_TO_ADDR
// vc_chassis := us_morphling ;
33267: LD_ADDR_OWVAR 37
33271: PUSH
33272: LD_INT 5
33274: ST_TO_ADDR
// vc_engine := engine_siberite ;
33275: LD_ADDR_OWVAR 39
33279: PUSH
33280: LD_INT 3
33282: ST_TO_ADDR
// vc_control := control_computer ;
33283: LD_ADDR_OWVAR 38
33287: PUSH
33288: LD_INT 3
33290: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
33291: LD_ADDR_OWVAR 40
33295: PUSH
33296: LD_INT 8
33298: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
33299: CALL_OW 45
33303: PPUSH
33304: LD_INT 1
33306: PPUSH
33307: CALL_OW 51
// end ;
33311: LD_VAR 0 1
33315: RET
