// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export playerVehicles ; export beriaBase ; export kirovBase ; export belkovReturn ; export meetPlatonov ; export labConstructed , workshopConstructed , engineResearched , canBuildSameBuilding ; export constructedFirstVehicle , firstVeh ; export vehicleForKurin ; export backToBeria1 , backToBeria2 ; export construcMoreVehicles , constructedVehiclesCounter ; export canExitBase ; export spawnCrates ; export canRemoveBelkovUnits , removedBelkovUntis , immortalBelkovTeam ; export kirovConstructedBunkers ; export activateAMAI ; export sawLeftBunker , sawRightBunker ; export dialogAttackLeftBunkers , dialogAttackRightBunkers ; export playerGetSupport ; export saveBelkovDecision ; export saveBelkovObjective , belkovSaved ; export raportForPlatonov , medalForGetSupport ; export northMapExplored ; export initiative ; export lostComradesCounter ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 304 0 0
// PrepareRussian ;
  24: CALL 892 0 0
// playerVehicles = [ ] ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: EMPTY
  34: ST_TO_ADDR
// beriaBase = [ ] ;
  35: LD_ADDR_EXP 2
  39: PUSH
  40: EMPTY
  41: ST_TO_ADDR
// kirovBase = [ ] ;
  42: LD_ADDR_EXP 3
  46: PUSH
  47: EMPTY
  48: ST_TO_ADDR
// belkovReturn = TestCharacters ( 01_Belkov ) ;
  49: LD_ADDR_EXP 4
  53: PUSH
  54: LD_STRING 01_Belkov
  56: PPUSH
  57: CALL_OW 28
  61: ST_TO_ADDR
// meetPlatonov = false ;
  62: LD_ADDR_EXP 5
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// labConstructed = false ;
  70: LD_ADDR_EXP 6
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// workshopConstructed = false ;
  78: LD_ADDR_EXP 7
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// engineResearched = false ;
  86: LD_ADDR_EXP 8
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// canBuildSameBuilding = false ;
  94: LD_ADDR_EXP 9
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// constructedFirstVehicle = false ;
 102: LD_ADDR_EXP 10
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// vehicleForKurin = false ;
 110: LD_ADDR_EXP 12
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// backToBeria1 = false ;
 118: LD_ADDR_EXP 13
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// backToBeria2 = false ;
 126: LD_ADDR_EXP 14
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// construcMoreVehicles = false ;
 134: LD_ADDR_EXP 15
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// constructedVehiclesCounter = 0 ;
 142: LD_ADDR_EXP 16
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// spawnCrates = false ;
 150: LD_ADDR_EXP 18
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// canRemoveBelkovUnits = false ;
 158: LD_ADDR_EXP 19
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// removedBelkovUntis = 0 ;
 166: LD_ADDR_EXP 20
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// immortalBelkovTeam = false ;
 174: LD_ADDR_EXP 21
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// canExitBase = false ;
 182: LD_ADDR_EXP 17
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// sawLeftBunker = false ;
 190: LD_ADDR_EXP 24
 194: PUSH
 195: LD_INT 0
 197: ST_TO_ADDR
// sawRightBunker = false ;
 198: LD_ADDR_EXP 25
 202: PUSH
 203: LD_INT 0
 205: ST_TO_ADDR
// dialogAttackLeftBunkers = false ;
 206: LD_ADDR_EXP 26
 210: PUSH
 211: LD_INT 0
 213: ST_TO_ADDR
// dialogAttackRightBunkers = false ;
 214: LD_ADDR_EXP 27
 218: PUSH
 219: LD_INT 0
 221: ST_TO_ADDR
// playerGetSupport = false ;
 222: LD_ADDR_EXP 28
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// saveBelkovObjective = false ;
 230: LD_ADDR_EXP 30
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// medalForGetSupport = true ;
 238: LD_ADDR_EXP 33
 242: PUSH
 243: LD_INT 1
 245: ST_TO_ADDR
// raportForPlatonov = - 1 ;
 246: LD_ADDR_EXP 32
 250: PUSH
 251: LD_INT 1
 253: NEG
 254: ST_TO_ADDR
// initiative = 0 ;
 255: LD_ADDR_EXP 35
 259: PUSH
 260: LD_INT 0
 262: ST_TO_ADDR
// lostComradesCounter = 0 ;
 263: LD_ADDR_EXP 36
 267: PUSH
 268: LD_INT 0
 270: ST_TO_ADDR
// northMapExplored = false ;
 271: LD_ADDR_EXP 34
 275: PUSH
 276: LD_INT 0
 278: ST_TO_ADDR
// kirovConstructedBunkers = 0 ;
 279: LD_ADDR_EXP 22
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// activateAMAI = false ;
 287: LD_ADDR_EXP 23
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// MissionIntro ;
 295: CALL 4946 0 0
// end ; end_of_file
 299: LD_VAR 0 1
 303: RET
// export function InitMapConfig ; begin
 304: LD_INT 0
 306: PPUSH
// BaseMapConfig ;
 307: CALL 320 0 0
// MissionMapConfig ;
 311: CALL 406 0 0
// end ;
 315: LD_VAR 0 1
 319: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 320: LD_INT 0
 322: PPUSH
// animalsAmount = [ 2 , 4 , 1 , 0 ] ;
 323: LD_ADDR_EXP 37
 327: PUSH
 328: LD_INT 2
 330: PUSH
 331: LD_INT 4
 333: PUSH
 334: LD_INT 1
 336: PUSH
 337: LD_INT 0
 339: PUSH
 340: EMPTY
 341: LIST
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 346: LD_ADDR_EXP 38
 350: PUSH
 351: LD_INT 2
 353: PUSH
 354: LD_INT 2
 356: PUSH
 357: LD_INT 2
 359: PUSH
 360: LD_INT 2
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: LIST
 367: LIST
 368: ST_TO_ADDR
// animalsAgression = 0 ;
 369: LD_ADDR_EXP 39
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// debugMode = 0 ;
 377: LD_ADDR_EXP 42
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// missionPrefix = 02_ ;
 385: LD_ADDR_EXP 40
 389: PUSH
 390: LD_STRING 02_
 392: ST_TO_ADDR
// previousMissionPrefix = 01_ ;
 393: LD_ADDR_EXP 41
 397: PUSH
 398: LD_STRING 01_
 400: ST_TO_ADDR
// end ;
 401: LD_VAR 0 1
 405: RET
// export kirovAmountPeople ; export meetWithKurinPositions , meetWithPlatonovPositions ; export labCratesRefund , workshopCratesRefund ; export enemySkillLevel ; export trapAmountPeople ; export belkovAttackTime ; function MissionMapConfig ; begin
 406: LD_INT 0
 408: PPUSH
// meetWithKurinPositions = [ [ 162 , 107 ] , [ 162 , 108 ] , [ 163 , 109 ] , [ 163 , 110 ] , [ 162 , 109 ] , [ 161 , 107 ] , [ 161 , 106 ] ] ;
 409: LD_ADDR_EXP 44
 413: PUSH
 414: LD_INT 162
 416: PUSH
 417: LD_INT 107
 419: PUSH
 420: EMPTY
 421: LIST
 422: LIST
 423: PUSH
 424: LD_INT 162
 426: PUSH
 427: LD_INT 108
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: PUSH
 434: LD_INT 163
 436: PUSH
 437: LD_INT 109
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: PUSH
 444: LD_INT 163
 446: PUSH
 447: LD_INT 110
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 162
 456: PUSH
 457: LD_INT 109
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: PUSH
 464: LD_INT 161
 466: PUSH
 467: LD_INT 107
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 161
 476: PUSH
 477: LD_INT 106
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// meetWithPlatonovPositions = [ [ 113 , 96 ] , [ 114 , 97 ] , [ 114 , 98 ] ] ;
 493: LD_ADDR_EXP 45
 497: PUSH
 498: LD_INT 113
 500: PUSH
 501: LD_INT 96
 503: PUSH
 504: EMPTY
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 114
 510: PUSH
 511: LD_INT 97
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: PUSH
 518: LD_INT 114
 520: PUSH
 521: LD_INT 98
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: ST_TO_ADDR
// kirovAmountPeople = [ 10 , 1 , 2 , 1 ] ;
 533: LD_ADDR_EXP 43
 537: PUSH
 538: LD_INT 10
 540: PUSH
 541: LD_INT 1
 543: PUSH
 544: LD_INT 2
 546: PUSH
 547: LD_INT 1
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: ST_TO_ADDR
// labCratesRefund = 20 ;
 556: LD_ADDR_EXP 46
 560: PUSH
 561: LD_INT 20
 563: ST_TO_ADDR
// workshopCratesRefund = 40 ;
 564: LD_ADDR_EXP 47
 568: PUSH
 569: LD_INT 40
 571: ST_TO_ADDR
// enemySkillLevel = [ 1 , 2 , 2 ] [ Difficulty ] ;
 572: LD_ADDR_EXP 48
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: LD_INT 2
 582: PUSH
 583: LD_INT 2
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: PUSH
 591: LD_OWVAR 67
 595: ARRAY
 596: ST_TO_ADDR
// trapAmountPeople = [ [ 2 , 2 ] , [ 3 , 3 ] , [ 4 , 4 ] ] [ Difficulty ] ;
 597: LD_ADDR_EXP 49
 601: PUSH
 602: LD_INT 2
 604: PUSH
 605: LD_INT 2
 607: PUSH
 608: EMPTY
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 3
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: EMPTY
 619: LIST
 620: LIST
 621: PUSH
 622: LD_INT 4
 624: PUSH
 625: LD_INT 4
 627: PUSH
 628: EMPTY
 629: LIST
 630: LIST
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: PUSH
 637: LD_OWVAR 67
 641: ARRAY
 642: ST_TO_ADDR
// belkovAttackTime = [ 10 10$0 , 8 8$0 , 6 6$0 ] [ Difficulty ] ;
 643: LD_ADDR_EXP 50
 647: PUSH
 648: LD_INT 21000
 650: PUSH
 651: LD_INT 16800
 653: PUSH
 654: LD_INT 12600
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: PUSH
 662: LD_OWVAR 67
 666: ARRAY
 667: ST_TO_ADDR
// end ;
 668: LD_VAR 0 1
 672: RET
// every 0 0$1 trigger debugMode do var i ;
 673: LD_EXP 42
 677: IFFALSE 889
 679: GO 681
 681: DISABLE
 682: LD_INT 0
 684: PPUSH
// begin enable ;
 685: ENABLE
// FogOff ( your_side ) ;
 686: LD_OWVAR 2
 690: PPUSH
 691: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 695: LD_ADDR_VAR 0 1
 699: PUSH
 700: LD_INT 22
 702: PUSH
 703: LD_OWVAR 2
 707: PUSH
 708: EMPTY
 709: LIST
 710: LIST
 711: PUSH
 712: LD_INT 2
 714: PUSH
 715: LD_INT 21
 717: PUSH
 718: LD_INT 1
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: PUSH
 725: LD_INT 21
 727: PUSH
 728: LD_INT 2
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: PPUSH
 744: CALL_OW 69
 748: PUSH
 749: FOR_IN
 750: IFFALSE 766
// SetLives ( i , 1000 ) ;
 752: LD_VAR 0 1
 756: PPUSH
 757: LD_INT 1000
 759: PPUSH
 760: CALL_OW 234
 764: GO 749
 766: POP
 767: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
 768: LD_ADDR_VAR 0 1
 772: PUSH
 773: LD_INT 22
 775: PUSH
 776: LD_OWVAR 2
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: PUSH
 785: LD_INT 2
 787: PUSH
 788: LD_INT 30
 790: PUSH
 791: LD_INT 0
 793: PUSH
 794: EMPTY
 795: LIST
 796: LIST
 797: PUSH
 798: LD_INT 30
 800: PUSH
 801: LD_INT 1
 803: PUSH
 804: EMPTY
 805: LIST
 806: LIST
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: PPUSH
 817: CALL_OW 69
 821: PUSH
 822: FOR_IN
 823: IFFALSE 887
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
 825: LD_VAR 0 1
 829: PPUSH
 830: CALL_OW 274
 834: PPUSH
 835: LD_INT 1
 837: PPUSH
 838: LD_INT 9999
 840: PPUSH
 841: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
 845: LD_VAR 0 1
 849: PPUSH
 850: CALL_OW 274
 854: PPUSH
 855: LD_INT 2
 857: PPUSH
 858: LD_INT 9999
 860: PPUSH
 861: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
 865: LD_VAR 0 1
 869: PPUSH
 870: CALL_OW 274
 874: PPUSH
 875: LD_INT 3
 877: PPUSH
 878: LD_INT 9999
 880: PPUSH
 881: CALL_OW 277
// end ;
 885: GO 822
 887: POP
 888: POP
// end ; end_of_file
 889: PPOPN 1
 891: END
// export Burlak , Gnyevko , Belkov , Kirilenkova ; export other_survivors ; export Kurin , Belkov2 , otherKirovUnits ; export Kovalyuk , randomMech ; export kirovVehicle ; export belkovTeam ; export removedBelkovUntisSaved ; export removedBelkovVehicleSaved ; export Platonov , platSoldiers ; export function PrepareRussian ; begin
 892: LD_INT 0
 894: PPUSH
// PrepareCharactersFromPreviousMission ;
 895: CALL 1226 0 0
// PrepareKirovBase ;
 899: CALL 1421 0 0
// PrepareBeriaBase ;
 903: CALL 2139 0 0
// end ;
 907: LD_VAR 0 1
 911: RET
// export function PrepareBelkovReturnTeam ; var unit , others ; begin
 912: LD_INT 0
 914: PPUSH
 915: PPUSH
 916: PPUSH
// belkovTeam = [ ] ;
 917: LD_ADDR_EXP 62
 921: PUSH
 922: EMPTY
 923: ST_TO_ADDR
// uc_side = 6 ;
 924: LD_ADDR_OWVAR 20
 928: PUSH
 929: LD_INT 6
 931: ST_TO_ADDR
// uc_nation = nation_russian ;
 932: LD_ADDR_OWVAR 21
 936: PUSH
 937: LD_INT 3
 939: ST_TO_ADDR
// vc_chassis = removedBelkovVehicleSaved [ 1 ] ;
 940: LD_ADDR_OWVAR 37
 944: PUSH
 945: LD_EXP 64
 949: PUSH
 950: LD_INT 1
 952: ARRAY
 953: ST_TO_ADDR
// vc_engine = removedBelkovVehicleSaved [ 2 ] ;
 954: LD_ADDR_OWVAR 39
 958: PUSH
 959: LD_EXP 64
 963: PUSH
 964: LD_INT 2
 966: ARRAY
 967: ST_TO_ADDR
// vc_control = removedBelkovVehicleSaved [ 3 ] ;
 968: LD_ADDR_OWVAR 38
 972: PUSH
 973: LD_EXP 64
 977: PUSH
 978: LD_INT 3
 980: ARRAY
 981: ST_TO_ADDR
// vc_weapon = removedBelkovVehicleSaved [ 4 ] ;
 982: LD_ADDR_OWVAR 40
 986: PUSH
 987: LD_EXP 64
 991: PUSH
 992: LD_INT 4
 994: ARRAY
 995: ST_TO_ADDR
// vc_fuel_battery = removedBelkovVehicleSaved [ 5 ] ;
 996: LD_ADDR_OWVAR 41
1000: PUSH
1001: LD_EXP 64
1005: PUSH
1006: LD_INT 5
1008: ARRAY
1009: ST_TO_ADDR
// kirovVehicle = CreateVehicle ;
1010: LD_ADDR_EXP 61
1014: PUSH
1015: CALL_OW 45
1019: ST_TO_ADDR
// SetDir ( kirovVehicle , 3 ) ;
1020: LD_EXP 61
1024: PPUSH
1025: LD_INT 3
1027: PPUSH
1028: CALL_OW 233
// PlaceUnitArea ( kirovVehicle , BelkovReturnArea , false ) ;
1032: LD_EXP 61
1036: PPUSH
1037: LD_INT 11
1039: PPUSH
1040: LD_INT 0
1042: PPUSH
1043: CALL_OW 49
// belkovTeam = belkovTeam ^ kirovVehicle ;
1047: LD_ADDR_EXP 62
1051: PUSH
1052: LD_EXP 62
1056: PUSH
1057: LD_EXP 61
1061: ADD
1062: ST_TO_ADDR
// if TestCharacters ( 02_TmpBelkov ) then
1063: LD_STRING 02_TmpBelkov
1065: PPUSH
1066: CALL_OW 28
1070: IFFALSE 1117
// begin Belkov = CreateCharacter ( 02_TmpBelkov ) ;
1072: LD_ADDR_EXP 53
1076: PUSH
1077: LD_STRING 02_TmpBelkov
1079: PPUSH
1080: CALL_OW 34
1084: ST_TO_ADDR
// PlaceHumanInUnit ( Belkov , kirovVehicle ) ;
1085: LD_EXP 53
1089: PPUSH
1090: LD_EXP 61
1094: PPUSH
1095: CALL_OW 52
// belkovTeam = belkovTeam ^ Belkov ;
1099: LD_ADDR_EXP 62
1103: PUSH
1104: LD_EXP 62
1108: PUSH
1109: LD_EXP 53
1113: ADD
1114: ST_TO_ADDR
// end else
1115: GO 1160
// begin Belkov2 = CreateCharacter ( 02_TmpBelkov2 ) ;
1117: LD_ADDR_EXP 57
1121: PUSH
1122: LD_STRING 02_TmpBelkov2
1124: PPUSH
1125: CALL_OW 34
1129: ST_TO_ADDR
// PlaceHumanInUnit ( Belkov2 , kirovVehicle ) ;
1130: LD_EXP 57
1134: PPUSH
1135: LD_EXP 61
1139: PPUSH
1140: CALL_OW 52
// belkovTeam = belkovTeam ^ Belkov2 ;
1144: LD_ADDR_EXP 62
1148: PUSH
1149: LD_EXP 62
1153: PUSH
1154: LD_EXP 57
1158: ADD
1159: ST_TO_ADDR
// end ; others = CreateCharacterSet ( 02_TmpBelkovTeam ) ;
1160: LD_ADDR_VAR 0 3
1164: PUSH
1165: LD_STRING 02_TmpBelkovTeam
1167: PPUSH
1168: CALL_OW 31
1172: ST_TO_ADDR
// for unit in others do
1173: LD_ADDR_VAR 0 2
1177: PUSH
1178: LD_VAR 0 3
1182: PUSH
1183: FOR_IN
1184: IFFALSE 1219
// begin PlaceUnitArea ( unit , BelkovReturnArea , false ) ;
1186: LD_VAR 0 2
1190: PPUSH
1191: LD_INT 11
1193: PPUSH
1194: LD_INT 0
1196: PPUSH
1197: CALL_OW 49
// belkovTeam = belkovTeam ^ unit ;
1201: LD_ADDR_EXP 62
1205: PUSH
1206: LD_EXP 62
1210: PUSH
1211: LD_VAR 0 2
1215: ADD
1216: ST_TO_ADDR
// end ;
1217: GO 1183
1219: POP
1220: POP
// end ;
1221: LD_VAR 0 1
1225: RET
// function PrepareCharactersFromPreviousMission ; var i ; begin
1226: LD_INT 0
1228: PPUSH
1229: PPUSH
// uc_side = 3 ;
1230: LD_ADDR_OWVAR 20
1234: PUSH
1235: LD_INT 3
1237: ST_TO_ADDR
// Burlak = PrepareUnit ( Burlak , true ) ;
1238: LD_ADDR_EXP 51
1242: PUSH
1243: LD_STRING Burlak
1245: PPUSH
1246: LD_INT 1
1248: PPUSH
1249: CALL 3290 0 2
1253: ST_TO_ADDR
// Gnyevko = PrepareUnit ( Gnyevko , true ) ;
1254: LD_ADDR_EXP 52
1258: PUSH
1259: LD_STRING Gnyevko
1261: PPUSH
1262: LD_INT 1
1264: PPUSH
1265: CALL 3290 0 2
1269: ST_TO_ADDR
// Belkov = PrepareUnit ( Belkov , true ) ;
1270: LD_ADDR_EXP 53
1274: PUSH
1275: LD_STRING Belkov
1277: PPUSH
1278: LD_INT 1
1280: PPUSH
1281: CALL 3290 0 2
1285: ST_TO_ADDR
// Kirilenkova = PrepareUnit ( Kirilenkova , true ) ;
1286: LD_ADDR_EXP 54
1290: PUSH
1291: LD_STRING Kirilenkova
1293: PPUSH
1294: LD_INT 1
1296: PPUSH
1297: CALL 3290 0 2
1301: ST_TO_ADDR
// PlaceUnitArea ( Burlak , BurlakSpawnArea , false ) ;
1302: LD_EXP 51
1306: PPUSH
1307: LD_INT 5
1309: PPUSH
1310: LD_INT 0
1312: PPUSH
1313: CALL_OW 49
// PlaceUnitArea ( Gnyevko , BurlakTeamSpawnArea , false ) ;
1317: LD_EXP 52
1321: PPUSH
1322: LD_INT 3
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// PlaceUnitArea ( Belkov , BurlakTeamSpawnArea , false ) ;
1332: LD_EXP 53
1336: PPUSH
1337: LD_INT 3
1339: PPUSH
1340: LD_INT 0
1342: PPUSH
1343: CALL_OW 49
// PlaceUnitArea ( Kirilenkova , BurlakTeamSpawnArea , false ) ;
1347: LD_EXP 54
1351: PPUSH
1352: LD_INT 3
1354: PPUSH
1355: LD_INT 0
1357: PPUSH
1358: CALL_OW 49
// CenterNowOnUnits ( Burlak ) ;
1362: LD_EXP 51
1366: PPUSH
1367: CALL_OW 87
// other_survivors = CreateCharacterSet ( 01_other_survivors ) ;
1371: LD_ADDR_EXP 55
1375: PUSH
1376: LD_STRING 01_other_survivors
1378: PPUSH
1379: CALL_OW 31
1383: ST_TO_ADDR
// for i in other_survivors do
1384: LD_ADDR_VAR 0 2
1388: PUSH
1389: LD_EXP 55
1393: PUSH
1394: FOR_IN
1395: IFFALSE 1414
// PlaceUnitArea ( i , BurlakTeamSpawnArea , false ) ;
1397: LD_VAR 0 2
1401: PPUSH
1402: LD_INT 3
1404: PPUSH
1405: LD_INT 0
1407: PPUSH
1408: CALL_OW 49
1412: GO 1394
1414: POP
1415: POP
// end ;
1416: LD_VAR 0 1
1420: RET
// function PrepareKirovBase ; var i , un ; begin
1421: LD_INT 0
1423: PPUSH
1424: PPUSH
1425: PPUSH
// SetBName ( kirov , kirov ) ;
1426: LD_INT 71
1428: PPUSH
1429: LD_STRING kirov
1431: PPUSH
1432: CALL_OW 500
// uc_side = 6 ;
1436: LD_ADDR_OWVAR 20
1440: PUSH
1441: LD_INT 6
1443: ST_TO_ADDR
// Kurin = PrepareUnit ( Kurin , false ) ;
1444: LD_ADDR_EXP 56
1448: PUSH
1449: LD_STRING Kurin
1451: PPUSH
1452: LD_INT 0
1454: PPUSH
1455: CALL 3290 0 2
1459: ST_TO_ADDR
// Kovalyuk = PrepareUnit ( Kovalyuk , false ) ;
1460: LD_ADDR_EXP 59
1464: PUSH
1465: LD_STRING Kovalyuk
1467: PPUSH
1468: LD_INT 0
1470: PPUSH
1471: CALL 3290 0 2
1475: ST_TO_ADDR
// Belkov2 = PrepareUnit ( Belkov2 , false ) ;
1476: LD_ADDR_EXP 57
1480: PUSH
1481: LD_STRING Belkov2
1483: PPUSH
1484: LD_INT 0
1486: PPUSH
1487: CALL 3290 0 2
1491: ST_TO_ADDR
// PlaceUnitArea ( Kurin , KurinSpawnArea , false ) ;
1492: LD_EXP 56
1496: PPUSH
1497: LD_INT 4
1499: PPUSH
1500: LD_INT 0
1502: PPUSH
1503: CALL_OW 49
// PlaceUnitXYR ( Kovalyuk , 161 , 108 , 6 , false ) ;
1507: LD_EXP 59
1511: PPUSH
1512: LD_INT 161
1514: PPUSH
1515: LD_INT 108
1517: PPUSH
1518: LD_INT 6
1520: PPUSH
1521: LD_INT 0
1523: PPUSH
1524: CALL_OW 50
// ComHold ( Kurin ) ;
1528: LD_EXP 56
1532: PPUSH
1533: CALL_OW 140
// otherKirovUnits = [ ] ;
1537: LD_ADDR_EXP 58
1541: PUSH
1542: EMPTY
1543: ST_TO_ADDR
// kirovAmountPeople = Replace ( kirovAmountPeople , 1 , kirovAmountPeople [ 1 ] - UnitFilter ( other_survivors , [ f_class , class_soldier ] ) ) ;
1544: LD_ADDR_EXP 43
1548: PUSH
1549: LD_EXP 43
1553: PPUSH
1554: LD_INT 1
1556: PPUSH
1557: LD_EXP 43
1561: PUSH
1562: LD_INT 1
1564: ARRAY
1565: PUSH
1566: LD_EXP 55
1570: PPUSH
1571: LD_INT 25
1573: PUSH
1574: LD_INT 1
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: PPUSH
1581: CALL_OW 72
1585: MINUS
1586: PPUSH
1587: CALL_OW 1
1591: ST_TO_ADDR
// for i := 1 to kirovAmountPeople [ 1 ] do
1592: LD_ADDR_VAR 0 2
1596: PUSH
1597: DOUBLE
1598: LD_INT 1
1600: DEC
1601: ST_TO_ADDR
1602: LD_EXP 43
1606: PUSH
1607: LD_INT 1
1609: ARRAY
1610: PUSH
1611: FOR_TO
1612: IFFALSE 1708
// begin uc_nation = 3 ;
1614: LD_ADDR_OWVAR 21
1618: PUSH
1619: LD_INT 3
1621: ST_TO_ADDR
// hc_gallery =  ;
1622: LD_ADDR_OWVAR 33
1626: PUSH
1627: LD_STRING 
1629: ST_TO_ADDR
// hc_name =  ;
1630: LD_ADDR_OWVAR 26
1634: PUSH
1635: LD_STRING 
1637: ST_TO_ADDR
// PrepareHuman ( false , 1 , rand ( 3 , 5 ) ) ;
1638: LD_INT 0
1640: PPUSH
1641: LD_INT 1
1643: PPUSH
1644: LD_INT 3
1646: PPUSH
1647: LD_INT 5
1649: PPUSH
1650: CALL_OW 12
1654: PPUSH
1655: CALL_OW 380
// un = CreateHuman ;
1659: LD_ADDR_VAR 0 3
1663: PUSH
1664: CALL_OW 44
1668: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
1669: LD_ADDR_EXP 58
1673: PUSH
1674: LD_EXP 58
1678: PUSH
1679: LD_VAR 0 3
1683: ADD
1684: ST_TO_ADDR
// PlaceUnitXYR ( un , 161 , 108 , 6 , false ) ;
1685: LD_VAR 0 3
1689: PPUSH
1690: LD_INT 161
1692: PPUSH
1693: LD_INT 108
1695: PPUSH
1696: LD_INT 6
1698: PPUSH
1699: LD_INT 0
1701: PPUSH
1702: CALL_OW 50
// end ;
1706: GO 1611
1708: POP
1709: POP
// for i := 1 to kirovAmountPeople [ 2 ] do
1710: LD_ADDR_VAR 0 2
1714: PUSH
1715: DOUBLE
1716: LD_INT 1
1718: DEC
1719: ST_TO_ADDR
1720: LD_EXP 43
1724: PUSH
1725: LD_INT 2
1727: ARRAY
1728: PUSH
1729: FOR_TO
1730: IFFALSE 1826
// begin uc_nation = 3 ;
1732: LD_ADDR_OWVAR 21
1736: PUSH
1737: LD_INT 3
1739: ST_TO_ADDR
// hc_gallery =  ;
1740: LD_ADDR_OWVAR 33
1744: PUSH
1745: LD_STRING 
1747: ST_TO_ADDR
// hc_name =  ;
1748: LD_ADDR_OWVAR 26
1752: PUSH
1753: LD_STRING 
1755: ST_TO_ADDR
// PrepareHuman ( false , 2 , rand ( 4 , 5 ) ) ;
1756: LD_INT 0
1758: PPUSH
1759: LD_INT 2
1761: PPUSH
1762: LD_INT 4
1764: PPUSH
1765: LD_INT 5
1767: PPUSH
1768: CALL_OW 12
1772: PPUSH
1773: CALL_OW 380
// un = CreateHuman ;
1777: LD_ADDR_VAR 0 3
1781: PUSH
1782: CALL_OW 44
1786: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
1787: LD_ADDR_EXP 58
1791: PUSH
1792: LD_EXP 58
1796: PUSH
1797: LD_VAR 0 3
1801: ADD
1802: ST_TO_ADDR
// PlaceUnitXYR ( un , 161 , 108 , 6 , false ) ;
1803: LD_VAR 0 3
1807: PPUSH
1808: LD_INT 161
1810: PPUSH
1811: LD_INT 108
1813: PPUSH
1814: LD_INT 6
1816: PPUSH
1817: LD_INT 0
1819: PPUSH
1820: CALL_OW 50
// end ;
1824: GO 1729
1826: POP
1827: POP
// for i := 1 to kirovAmountPeople [ 3 ] do
1828: LD_ADDR_VAR 0 2
1832: PUSH
1833: DOUBLE
1834: LD_INT 1
1836: DEC
1837: ST_TO_ADDR
1838: LD_EXP 43
1842: PUSH
1843: LD_INT 3
1845: ARRAY
1846: PUSH
1847: FOR_TO
1848: IFFALSE 1944
// begin uc_nation = 3 ;
1850: LD_ADDR_OWVAR 21
1854: PUSH
1855: LD_INT 3
1857: ST_TO_ADDR
// hc_gallery =  ;
1858: LD_ADDR_OWVAR 33
1862: PUSH
1863: LD_STRING 
1865: ST_TO_ADDR
// hc_name =  ;
1866: LD_ADDR_OWVAR 26
1870: PUSH
1871: LD_STRING 
1873: ST_TO_ADDR
// PrepareHuman ( false , 3 , rand ( 3 , 5 ) ) ;
1874: LD_INT 0
1876: PPUSH
1877: LD_INT 3
1879: PPUSH
1880: LD_INT 3
1882: PPUSH
1883: LD_INT 5
1885: PPUSH
1886: CALL_OW 12
1890: PPUSH
1891: CALL_OW 380
// un = CreateHuman ;
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: CALL_OW 44
1904: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
1905: LD_ADDR_EXP 58
1909: PUSH
1910: LD_EXP 58
1914: PUSH
1915: LD_VAR 0 3
1919: ADD
1920: ST_TO_ADDR
// PlaceUnitXYR ( un , 161 , 108 , 6 , false ) ;
1921: LD_VAR 0 3
1925: PPUSH
1926: LD_INT 161
1928: PPUSH
1929: LD_INT 108
1931: PPUSH
1932: LD_INT 6
1934: PPUSH
1935: LD_INT 0
1937: PPUSH
1938: CALL_OW 50
// end ;
1942: GO 1847
1944: POP
1945: POP
// for i := 1 to kirovAmountPeople [ 4 ] do
1946: LD_ADDR_VAR 0 2
1950: PUSH
1951: DOUBLE
1952: LD_INT 1
1954: DEC
1955: ST_TO_ADDR
1956: LD_EXP 43
1960: PUSH
1961: LD_INT 4
1963: ARRAY
1964: PUSH
1965: FOR_TO
1966: IFFALSE 2062
// begin uc_nation = 3 ;
1968: LD_ADDR_OWVAR 21
1972: PUSH
1973: LD_INT 3
1975: ST_TO_ADDR
// hc_gallery =  ;
1976: LD_ADDR_OWVAR 33
1980: PUSH
1981: LD_STRING 
1983: ST_TO_ADDR
// hc_name =  ;
1984: LD_ADDR_OWVAR 26
1988: PUSH
1989: LD_STRING 
1991: ST_TO_ADDR
// PrepareHuman ( false , 4 , rand ( 3 , 5 ) ) ;
1992: LD_INT 0
1994: PPUSH
1995: LD_INT 4
1997: PPUSH
1998: LD_INT 3
2000: PPUSH
2001: LD_INT 5
2003: PPUSH
2004: CALL_OW 12
2008: PPUSH
2009: CALL_OW 380
// un = CreateHuman ;
2013: LD_ADDR_VAR 0 3
2017: PUSH
2018: CALL_OW 44
2022: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2023: LD_ADDR_EXP 58
2027: PUSH
2028: LD_EXP 58
2032: PUSH
2033: LD_VAR 0 3
2037: ADD
2038: ST_TO_ADDR
// PlaceUnitXYR ( un , 161 , 108 , 6 , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 161
2046: PPUSH
2047: LD_INT 108
2049: PPUSH
2050: LD_INT 6
2052: PPUSH
2053: LD_INT 0
2055: PPUSH
2056: CALL_OW 50
// end ;
2060: GO 1965
2062: POP
2063: POP
// if not TestCharacters ( 01_Gnyevko ) then
2064: LD_STRING 01_Gnyevko
2066: PPUSH
2067: CALL_OW 28
2071: NOT
2072: IFFALSE 2115
// begin PrepareMechanic ( sex_male , 3 ) ;
2074: LD_INT 1
2076: PPUSH
2077: LD_INT 3
2079: PPUSH
2080: CALL_OW 383
// randomMech = CreateHuman ;
2084: LD_ADDR_EXP 60
2088: PUSH
2089: CALL_OW 44
2093: ST_TO_ADDR
// PlaceUnitXYR ( randomMech , 161 , 108 , 6 , false ) ;
2094: LD_EXP 60
2098: PPUSH
2099: LD_INT 161
2101: PPUSH
2102: LD_INT 108
2104: PPUSH
2105: LD_INT 6
2107: PPUSH
2108: LD_INT 0
2110: PPUSH
2111: CALL_OW 50
// end ; if not belkovReturn then
2115: LD_EXP 4
2119: NOT
2120: IFFALSE 2134
// PlaceHumanInUnit ( Belkov2 , ru2_arm ) ;
2122: LD_EXP 57
2126: PPUSH
2127: LD_INT 95
2129: PPUSH
2130: CALL_OW 52
// end ;
2134: LD_VAR 0 1
2138: RET
// function PrepareBeriaBase ; var i , un ; begin
2139: LD_INT 0
2141: PPUSH
2142: PPUSH
2143: PPUSH
// SetBName ( beria , beria ) ;
2144: LD_INT 106
2146: PPUSH
2147: LD_STRING beria
2149: PPUSH
2150: CALL_OW 500
// uc_side = 6 ;
2154: LD_ADDR_OWVAR 20
2158: PUSH
2159: LD_INT 6
2161: ST_TO_ADDR
// Platonov = PrepareUnit ( Platonov , false ) ;
2162: LD_ADDR_EXP 65
2166: PUSH
2167: LD_STRING Platonov
2169: PPUSH
2170: LD_INT 0
2172: PPUSH
2173: CALL 3290 0 2
2177: ST_TO_ADDR
// PlaceUnitXY ( Platonov , 112 , 97 , false ) ;
2178: LD_EXP 65
2182: PPUSH
2183: LD_INT 112
2185: PPUSH
2186: LD_INT 97
2188: PPUSH
2189: LD_INT 0
2191: PPUSH
2192: CALL_OW 48
// ComHold ( Platonov ) ;
2196: LD_EXP 65
2200: PPUSH
2201: CALL_OW 140
// platSoldiers = [ ] ;
2205: LD_ADDR_EXP 66
2209: PUSH
2210: EMPTY
2211: ST_TO_ADDR
// for i := 1 to 4 do
2212: LD_ADDR_VAR 0 2
2216: PUSH
2217: DOUBLE
2218: LD_INT 1
2220: DEC
2221: ST_TO_ADDR
2222: LD_INT 4
2224: PUSH
2225: FOR_TO
2226: IFFALSE 2434
// begin uc_nation = 3 ;
2228: LD_ADDR_OWVAR 21
2232: PUSH
2233: LD_INT 3
2235: ST_TO_ADDR
// hc_gallery =  ;
2236: LD_ADDR_OWVAR 33
2240: PUSH
2241: LD_STRING 
2243: ST_TO_ADDR
// hc_name =  ;
2244: LD_ADDR_OWVAR 26
2248: PUSH
2249: LD_STRING 
2251: ST_TO_ADDR
// if i = 4 and not UnitFilter ( platSoldiers , [ f_sex , sex_male ] ) then
2252: LD_VAR 0 2
2256: PUSH
2257: LD_INT 4
2259: EQUAL
2260: PUSH
2261: LD_EXP 66
2265: PPUSH
2266: LD_INT 26
2268: PUSH
2269: LD_INT 1
2271: PUSH
2272: EMPTY
2273: LIST
2274: LIST
2275: PPUSH
2276: CALL_OW 72
2280: NOT
2281: AND
2282: IFFALSE 2307
// PrepareHuman ( sex_male , 1 , rand ( 1 , 3 ) ) else
2284: LD_INT 1
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 1
2292: PPUSH
2293: LD_INT 3
2295: PPUSH
2296: CALL_OW 12
2300: PPUSH
2301: CALL_OW 380
2305: GO 2328
// PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
2307: LD_INT 0
2309: PPUSH
2310: LD_INT 1
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: LD_INT 3
2318: PPUSH
2319: CALL_OW 12
2323: PPUSH
2324: CALL_OW 380
// un = CreateHuman ;
2328: LD_ADDR_VAR 0 3
2332: PUSH
2333: CALL_OW 44
2337: ST_TO_ADDR
// platSoldiers = platSoldiers ^ un ;
2338: LD_ADDR_EXP 66
2342: PUSH
2343: LD_EXP 66
2347: PUSH
2348: LD_VAR 0 3
2352: ADD
2353: ST_TO_ADDR
// PlaceUnitXYR ( un , 110 , 97 , 6 , false ) ;
2354: LD_VAR 0 3
2358: PPUSH
2359: LD_INT 110
2361: PPUSH
2362: LD_INT 97
2364: PPUSH
2365: LD_INT 6
2367: PPUSH
2368: LD_INT 0
2370: PPUSH
2371: CALL_OW 50
// if i < 4 then
2375: LD_VAR 0 2
2379: PUSH
2380: LD_INT 4
2382: LESS
2383: IFFALSE 2432
// ComEnterUnit ( un , FilterUnitsInArea ( BeriaBaseArea , [ [ f_side , 6 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
2385: LD_VAR 0 3
2389: PPUSH
2390: LD_INT 8
2392: PPUSH
2393: LD_INT 22
2395: PUSH
2396: LD_INT 6
2398: PUSH
2399: EMPTY
2400: LIST
2401: LIST
2402: PUSH
2403: LD_INT 30
2405: PUSH
2406: LD_INT 31
2408: PUSH
2409: EMPTY
2410: LIST
2411: LIST
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: PPUSH
2417: CALL_OW 70
2421: PUSH
2422: LD_VAR 0 2
2426: ARRAY
2427: PPUSH
2428: CALL_OW 120
// end ;
2432: GO 2225
2434: POP
2435: POP
// end ; end_of_file
2436: LD_VAR 0 1
2440: RET
// export trapCommander ; export trapTeam ; export leftBunkers , rightBunkers ; export amLeftDepot , amRightDepot ; export amLeftEngs , amRightEngs ; export function PrepareAmerican ; begin
2441: LD_INT 0
2443: PPUSH
// PrepareTrap end ;
2444: CALL 2453 0 0
2448: LD_VAR 0 1
2452: RET
// function PrepareTrap ; var i , un ; begin
2453: LD_INT 0
2455: PPUSH
2456: PPUSH
2457: PPUSH
// trapTeam = [ ] ;
2458: LD_ADDR_EXP 68
2462: PUSH
2463: EMPTY
2464: ST_TO_ADDR
// uc_nation = 1 ;
2465: LD_ADDR_OWVAR 21
2469: PUSH
2470: LD_INT 1
2472: ST_TO_ADDR
// uc_side = 1 ;
2473: LD_ADDR_OWVAR 20
2477: PUSH
2478: LD_INT 1
2480: ST_TO_ADDR
// hc_gallery =  ;
2481: LD_ADDR_OWVAR 33
2485: PUSH
2486: LD_STRING 
2488: ST_TO_ADDR
// hc_name = profile_name ;
2489: LD_ADDR_OWVAR 26
2493: PUSH
2494: LD_OWVAR 78
2498: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel + 1 ) ;
2499: LD_INT 0
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_EXP 48
2509: PUSH
2510: LD_INT 1
2512: PLUS
2513: PPUSH
2514: CALL_OW 380
// trapCommander = CreateHuman ;
2518: LD_ADDR_EXP 67
2522: PUSH
2523: CALL_OW 44
2527: ST_TO_ADDR
// PlaceUnitArea ( trapCommander , AmCommanderSpawn , false ) ;
2528: LD_EXP 67
2532: PPUSH
2533: LD_INT 13
2535: PPUSH
2536: LD_INT 0
2538: PPUSH
2539: CALL_OW 49
// ComCrawl ( trapCommander ) ;
2543: LD_EXP 67
2547: PPUSH
2548: CALL_OW 137
// trapTeam = trapTeam ^ trapCommander ;
2552: LD_ADDR_EXP 68
2556: PUSH
2557: LD_EXP 68
2561: PUSH
2562: LD_EXP 67
2566: ADD
2567: ST_TO_ADDR
// for i := 1 to trapAmountPeople [ 1 ] do
2568: LD_ADDR_VAR 0 2
2572: PUSH
2573: DOUBLE
2574: LD_INT 1
2576: DEC
2577: ST_TO_ADDR
2578: LD_EXP 49
2582: PUSH
2583: LD_INT 1
2585: ARRAY
2586: PUSH
2587: FOR_TO
2588: IFFALSE 2680
// begin hc_name =  ;
2590: LD_ADDR_OWVAR 26
2594: PUSH
2595: LD_STRING 
2597: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
2598: LD_INT 0
2600: PPUSH
2601: LD_INT 1
2603: PPUSH
2604: LD_EXP 48
2608: PPUSH
2609: CALL_OW 380
// un = CreateHuman ;
2613: LD_ADDR_VAR 0 3
2617: PUSH
2618: CALL_OW 44
2622: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn1 , false ) ;
2623: LD_VAR 0 3
2627: PPUSH
2628: LD_INT 12
2630: PPUSH
2631: LD_INT 0
2633: PPUSH
2634: CALL_OW 49
// ComCrawl ( un ) ;
2638: LD_VAR 0 3
2642: PPUSH
2643: CALL_OW 137
// AddComTurnXY ( un , 116 , 21 ) ;
2647: LD_VAR 0 3
2651: PPUSH
2652: LD_INT 116
2654: PPUSH
2655: LD_INT 21
2657: PPUSH
2658: CALL_OW 178
// trapTeam = trapTeam ^ un ;
2662: LD_ADDR_EXP 68
2666: PUSH
2667: LD_EXP 68
2671: PUSH
2672: LD_VAR 0 3
2676: ADD
2677: ST_TO_ADDR
// end ;
2678: GO 2587
2680: POP
2681: POP
// for i := 1 to trapAmountPeople [ 2 ] do
2682: LD_ADDR_VAR 0 2
2686: PUSH
2687: DOUBLE
2688: LD_INT 1
2690: DEC
2691: ST_TO_ADDR
2692: LD_EXP 49
2696: PUSH
2697: LD_INT 2
2699: ARRAY
2700: PUSH
2701: FOR_TO
2702: IFFALSE 2794
// begin hc_name =  ;
2704: LD_ADDR_OWVAR 26
2708: PUSH
2709: LD_STRING 
2711: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
2712: LD_INT 0
2714: PPUSH
2715: LD_INT 1
2717: PPUSH
2718: LD_EXP 48
2722: PPUSH
2723: CALL_OW 380
// un = CreateHuman ;
2727: LD_ADDR_VAR 0 3
2731: PUSH
2732: CALL_OW 44
2736: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn2 , false ) ;
2737: LD_VAR 0 3
2741: PPUSH
2742: LD_INT 14
2744: PPUSH
2745: LD_INT 0
2747: PPUSH
2748: CALL_OW 49
// ComCrawl ( un ) ;
2752: LD_VAR 0 3
2756: PPUSH
2757: CALL_OW 137
// AddComTurnXY ( un , 116 , 21 ) ;
2761: LD_VAR 0 3
2765: PPUSH
2766: LD_INT 116
2768: PPUSH
2769: LD_INT 21
2771: PPUSH
2772: CALL_OW 178
// trapTeam = trapTeam ^ un ;
2776: LD_ADDR_EXP 68
2780: PUSH
2781: LD_EXP 68
2785: PUSH
2786: LD_VAR 0 3
2790: ADD
2791: ST_TO_ADDR
// end ;
2792: GO 2701
2794: POP
2795: POP
// end ;
2796: LD_VAR 0 1
2800: RET
// function PrepareBunkiers ; var i , un , bunker ; begin
2801: LD_INT 0
2803: PPUSH
2804: PPUSH
2805: PPUSH
2806: PPUSH
// uc_side = 1 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 1
2814: ST_TO_ADDR
// uc_nation = nation_american ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 1
2822: ST_TO_ADDR
// bc_level = 1 ;
2823: LD_ADDR_OWVAR 43
2827: PUSH
2828: LD_INT 1
2830: ST_TO_ADDR
// bc_type = b_breastwork ;
2831: LD_ADDR_OWVAR 42
2835: PUSH
2836: LD_INT 31
2838: ST_TO_ADDR
// bunker = CreateAndPlaceBuildingXYD ( 104 , 59 , 4 ) ;
2839: LD_ADDR_VAR 0 4
2843: PUSH
2844: LD_INT 104
2846: PPUSH
2847: LD_INT 59
2849: PPUSH
2850: LD_INT 4
2852: PPUSH
2853: CALL_OW 47
2857: ST_TO_ADDR
// leftBunkers = leftBunkers ^ bunker ;
2858: LD_ADDR_EXP 69
2862: PUSH
2863: LD_EXP 69
2867: PUSH
2868: LD_VAR 0 4
2872: ADD
2873: ST_TO_ADDR
// bunker = CreateAndPlaceBuildingXYD ( 101 , 55 , 4 ) ;
2874: LD_ADDR_VAR 0 4
2878: PUSH
2879: LD_INT 101
2881: PPUSH
2882: LD_INT 55
2884: PPUSH
2885: LD_INT 4
2887: PPUSH
2888: CALL_OW 47
2892: ST_TO_ADDR
// leftBunkers = leftBunkers ^ bunker ;
2893: LD_ADDR_EXP 69
2897: PUSH
2898: LD_EXP 69
2902: PUSH
2903: LD_VAR 0 4
2907: ADD
2908: ST_TO_ADDR
// bunker = CreateAndPlaceBuildingXYD ( 132 , 66 , 1 ) ;
2909: LD_ADDR_VAR 0 4
2913: PUSH
2914: LD_INT 132
2916: PPUSH
2917: LD_INT 66
2919: PPUSH
2920: LD_INT 1
2922: PPUSH
2923: CALL_OW 47
2927: ST_TO_ADDR
// rightBunkers = rightBunkers ^ bunker ;
2928: LD_ADDR_EXP 70
2932: PUSH
2933: LD_EXP 70
2937: PUSH
2938: LD_VAR 0 4
2942: ADD
2943: ST_TO_ADDR
// bunker = CreateAndPlaceBuildingXYD ( 134 , 62 , 1 ) ;
2944: LD_ADDR_VAR 0 4
2948: PUSH
2949: LD_INT 134
2951: PPUSH
2952: LD_INT 62
2954: PPUSH
2955: LD_INT 1
2957: PPUSH
2958: CALL_OW 47
2962: ST_TO_ADDR
// rightBunkers = rightBunkers ^ bunker ;
2963: LD_ADDR_EXP 70
2967: PUSH
2968: LD_EXP 70
2972: PUSH
2973: LD_VAR 0 4
2977: ADD
2978: ST_TO_ADDR
// bc_type = b_depot ;
2979: LD_ADDR_OWVAR 42
2983: PUSH
2984: LD_INT 0
2986: ST_TO_ADDR
// amLeftDepot = CreateAndPlaceBuildingXYD ( 95 , 51 , 2 ) ;
2987: LD_ADDR_EXP 71
2991: PUSH
2992: LD_INT 95
2994: PPUSH
2995: LD_INT 51
2997: PPUSH
2998: LD_INT 2
3000: PPUSH
3001: CALL_OW 47
3005: ST_TO_ADDR
// amRightDepot = am_dep1 ;
3006: LD_ADDR_EXP 72
3010: PUSH
3011: LD_INT 193
3013: ST_TO_ADDR
// amLeftEngs = [ ] ;
3014: LD_ADDR_EXP 73
3018: PUSH
3019: EMPTY
3020: ST_TO_ADDR
// for i := 1 to [ 1 , 1 , rand ( 1 , 2 ) ] [ Difficulty ] do
3021: LD_ADDR_VAR 0 2
3025: PUSH
3026: DOUBLE
3027: LD_INT 1
3029: DEC
3030: ST_TO_ADDR
3031: LD_INT 1
3033: PUSH
3034: LD_INT 1
3036: PUSH
3037: LD_INT 1
3039: PPUSH
3040: LD_INT 2
3042: PPUSH
3043: CALL_OW 12
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: LIST
3052: PUSH
3053: LD_OWVAR 67
3057: ARRAY
3058: PUSH
3059: FOR_TO
3060: IFFALSE 3151
// begin uc_nation = 1 ;
3062: LD_ADDR_OWVAR 21
3066: PUSH
3067: LD_INT 1
3069: ST_TO_ADDR
// uc_side = 1 ;
3070: LD_ADDR_OWVAR 20
3074: PUSH
3075: LD_INT 1
3077: ST_TO_ADDR
// hc_gallery =  ;
3078: LD_ADDR_OWVAR 33
3082: PUSH
3083: LD_STRING 
3085: ST_TO_ADDR
// hc_name =  ;
3086: LD_ADDR_OWVAR 26
3090: PUSH
3091: LD_STRING 
3093: ST_TO_ADDR
// PrepareHuman ( false , 2 , enemySkillLevel ) ;
3094: LD_INT 0
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 48
3104: PPUSH
3105: CALL_OW 380
// un = CreateHuman ;
3109: LD_ADDR_VAR 0 3
3113: PUSH
3114: CALL_OW 44
3118: ST_TO_ADDR
// amLeftEngs = amLeftEngs ^ un ;
3119: LD_ADDR_EXP 73
3123: PUSH
3124: LD_EXP 73
3128: PUSH
3129: LD_VAR 0 3
3133: ADD
3134: ST_TO_ADDR
// PlaceHumanInUnit ( un , amLeftDepot ) ;
3135: LD_VAR 0 3
3139: PPUSH
3140: LD_EXP 71
3144: PPUSH
3145: CALL_OW 52
// end ;
3149: GO 3059
3151: POP
3152: POP
// if Difficulty = 3 then
3153: LD_OWVAR 67
3157: PUSH
3158: LD_INT 3
3160: EQUAL
3161: IFFALSE 3285
// begin amRightEngs = [ ] ;
3163: LD_ADDR_EXP 74
3167: PUSH
3168: EMPTY
3169: ST_TO_ADDR
// for i := 1 to rand ( 1 , 2 ) do
3170: LD_ADDR_VAR 0 2
3174: PUSH
3175: DOUBLE
3176: LD_INT 1
3178: DEC
3179: ST_TO_ADDR
3180: LD_INT 1
3182: PPUSH
3183: LD_INT 2
3185: PPUSH
3186: CALL_OW 12
3190: PUSH
3191: FOR_TO
3192: IFFALSE 3283
// begin uc_nation = 1 ;
3194: LD_ADDR_OWVAR 21
3198: PUSH
3199: LD_INT 1
3201: ST_TO_ADDR
// uc_side = 1 ;
3202: LD_ADDR_OWVAR 20
3206: PUSH
3207: LD_INT 1
3209: ST_TO_ADDR
// hc_gallery =  ;
3210: LD_ADDR_OWVAR 33
3214: PUSH
3215: LD_STRING 
3217: ST_TO_ADDR
// hc_name =  ;
3218: LD_ADDR_OWVAR 26
3222: PUSH
3223: LD_STRING 
3225: ST_TO_ADDR
// PrepareHuman ( false , 2 , enemySkillLevel ) ;
3226: LD_INT 0
3228: PPUSH
3229: LD_INT 2
3231: PPUSH
3232: LD_EXP 48
3236: PPUSH
3237: CALL_OW 380
// un = CreateHuman ;
3241: LD_ADDR_VAR 0 3
3245: PUSH
3246: CALL_OW 44
3250: ST_TO_ADDR
// amRightEngs = amRightEngs ^ un ;
3251: LD_ADDR_EXP 74
3255: PUSH
3256: LD_EXP 74
3260: PUSH
3261: LD_VAR 0 3
3265: ADD
3266: ST_TO_ADDR
// PlaceHumanInUnit ( un , amRightDepot ) ;
3267: LD_VAR 0 3
3271: PPUSH
3272: LD_EXP 72
3276: PPUSH
3277: CALL_OW 52
// end ;
3281: GO 3191
3283: POP
3284: POP
// end ; end ; end_of_file
3285: LD_VAR 0 1
3289: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
3290: LD_INT 0
3292: PPUSH
3293: PPUSH
// if exist_mode then
3294: LD_VAR 0 2
3298: IFFALSE 3323
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
3300: LD_ADDR_VAR 0 4
3304: PUSH
3305: LD_EXP 41
3309: PUSH
3310: LD_VAR 0 1
3314: STR
3315: PPUSH
3316: CALL_OW 34
3320: ST_TO_ADDR
3321: GO 3338
// unit := NewCharacter ( ident ) ;
3323: LD_ADDR_VAR 0 4
3327: PUSH
3328: LD_VAR 0 1
3332: PPUSH
3333: CALL_OW 25
3337: ST_TO_ADDR
// result := unit ;
3338: LD_ADDR_VAR 0 3
3342: PUSH
3343: LD_VAR 0 4
3347: ST_TO_ADDR
// end ;
3348: LD_VAR 0 3
3352: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio ) ; var i , speaker ; begin
3353: LD_INT 0
3355: PPUSH
3356: PPUSH
3357: PPUSH
// characters := characters diff [ Burlak , Gnyevko , Belkov , Kirilenkova ] ;
3358: LD_ADDR_VAR 0 1
3362: PUSH
3363: LD_VAR 0 1
3367: PUSH
3368: LD_EXP 51
3372: PUSH
3373: LD_EXP 52
3377: PUSH
3378: LD_EXP 53
3382: PUSH
3383: LD_EXP 54
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: DIFF
3394: ST_TO_ADDR
// speaker := characters [ rand ( 1 , characters ) ] ;
3395: LD_ADDR_VAR 0 7
3399: PUSH
3400: LD_VAR 0 1
3404: PUSH
3405: LD_INT 1
3407: PPUSH
3408: LD_VAR 0 1
3412: PPUSH
3413: CALL_OW 12
3417: ARRAY
3418: ST_TO_ADDR
// if radio then
3419: LD_VAR 0 4
3423: IFFALSE 3472
// begin if GetSex ( speaker ) = sex_male then
3425: LD_VAR 0 7
3429: PPUSH
3430: CALL_OW 258
3434: PUSH
3435: LD_INT 1
3437: EQUAL
3438: IFFALSE 3456
// SayRadio ( speaker , dialogMID ) else
3440: LD_VAR 0 7
3444: PPUSH
3445: LD_VAR 0 2
3449: PPUSH
3450: CALL_OW 94
3454: GO 3470
// SayRadio ( speaker , dialogFID ) ;
3456: LD_VAR 0 7
3460: PPUSH
3461: LD_VAR 0 3
3465: PPUSH
3466: CALL_OW 94
// end else
3470: GO 3517
// begin if GetSex ( speaker ) = sex_male then
3472: LD_VAR 0 7
3476: PPUSH
3477: CALL_OW 258
3481: PUSH
3482: LD_INT 1
3484: EQUAL
3485: IFFALSE 3503
// Say ( speaker , dialogMID ) else
3487: LD_VAR 0 7
3491: PPUSH
3492: LD_VAR 0 2
3496: PPUSH
3497: CALL_OW 88
3501: GO 3517
// Say ( speaker , dialogFID ) ;
3503: LD_VAR 0 7
3507: PPUSH
3508: LD_VAR 0 3
3512: PPUSH
3513: CALL_OW 88
// end ; result := speaker ;
3517: LD_ADDR_VAR 0 5
3521: PUSH
3522: LD_VAR 0 7
3526: ST_TO_ADDR
// end ;
3527: LD_VAR 0 5
3531: RET
// export function ExtSaveCharacter ( character , characterStringID ) ; begin
3532: LD_INT 0
3534: PPUSH
// if GetSide ( character ) = your_side and IsOK ( character ) then
3535: LD_VAR 0 1
3539: PPUSH
3540: CALL_OW 255
3544: PUSH
3545: LD_OWVAR 2
3549: EQUAL
3550: PUSH
3551: LD_VAR 0 1
3555: PPUSH
3556: CALL_OW 302
3560: AND
3561: IFFALSE 3583
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
3563: LD_VAR 0 1
3567: PPUSH
3568: LD_EXP 40
3572: PUSH
3573: LD_VAR 0 2
3577: STR
3578: PPUSH
3579: CALL_OW 38
// end ;
3583: LD_VAR 0 3
3587: RET
// export function ExtSaveCharacters ( characters , charactersStringID ) ; var unit , resultCharactersToSave ; begin
3588: LD_INT 0
3590: PPUSH
3591: PPUSH
3592: PPUSH
// resultCharactersToSave = [ ] ;
3593: LD_ADDR_VAR 0 5
3597: PUSH
3598: EMPTY
3599: ST_TO_ADDR
// for unit in characters do
3600: LD_ADDR_VAR 0 4
3604: PUSH
3605: LD_VAR 0 1
3609: PUSH
3610: FOR_IN
3611: IFFALSE 3659
// if GetSide ( unit ) = your_side and IsOK ( unit ) then
3613: LD_VAR 0 4
3617: PPUSH
3618: CALL_OW 255
3622: PUSH
3623: LD_OWVAR 2
3627: EQUAL
3628: PUSH
3629: LD_VAR 0 4
3633: PPUSH
3634: CALL_OW 302
3638: AND
3639: IFFALSE 3657
// resultCharactersToSave = resultCharactersToSave ^ unit ;
3641: LD_ADDR_VAR 0 5
3645: PUSH
3646: LD_VAR 0 5
3650: PUSH
3651: LD_VAR 0 4
3655: ADD
3656: ST_TO_ADDR
3657: GO 3610
3659: POP
3660: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
3661: LD_VAR 0 5
3665: PPUSH
3666: LD_EXP 40
3670: PUSH
3671: LD_VAR 0 2
3675: STR
3676: PPUSH
3677: CALL_OW 38
// end ;
3681: LD_VAR 0 3
3685: RET
// export function Question1 ( q ) ; var dec , q1 ; begin
3686: LD_INT 0
3688: PPUSH
3689: PPUSH
3690: PPUSH
// dec = SelectiveQuery ( QMoreInfo , q ) ;
3691: LD_ADDR_VAR 0 3
3695: PUSH
3696: LD_STRING QMoreInfo
3698: PPUSH
3699: LD_VAR 0 1
3703: PPUSH
3704: CALL_OW 98
3708: ST_TO_ADDR
// case dec of 1 :
3709: LD_VAR 0 3
3713: PUSH
3714: LD_INT 1
3716: DOUBLE
3717: EQUAL
3718: IFTRUE 3722
3720: GO 3782
3722: POP
// begin Say ( Burlak , D2a-Bur-1 ) ;
3723: LD_EXP 51
3727: PPUSH
3728: LD_STRING D2a-Bur-1
3730: PPUSH
3731: CALL_OW 88
// Say ( Platonov , D2a-Pla-1 ) ;
3735: LD_EXP 65
3739: PPUSH
3740: LD_STRING D2a-Pla-1
3742: PPUSH
3743: CALL_OW 88
// q1 = q diff 1 ;
3747: LD_ADDR_VAR 0 4
3751: PUSH
3752: LD_VAR 0 1
3756: PUSH
3757: LD_INT 1
3759: DIFF
3760: ST_TO_ADDR
// if q1 >= 2 then
3761: LD_VAR 0 4
3765: PUSH
3766: LD_INT 2
3768: GREATEREQUAL
3769: IFFALSE 3780
// Question1 ( q1 ) ;
3771: LD_VAR 0 4
3775: PPUSH
3776: CALL 3686 0 1
// end ; 2 :
3780: GO 3919
3782: LD_INT 2
3784: DOUBLE
3785: EQUAL
3786: IFTRUE 3790
3788: GO 3850
3790: POP
// begin Say ( Burlak , D2b-Bur-1 ) ;
3791: LD_EXP 51
3795: PPUSH
3796: LD_STRING D2b-Bur-1
3798: PPUSH
3799: CALL_OW 88
// Say ( Platonov , D2b-Pla-1 ) ;
3803: LD_EXP 65
3807: PPUSH
3808: LD_STRING D2b-Pla-1
3810: PPUSH
3811: CALL_OW 88
// q1 = q diff 2 ;
3815: LD_ADDR_VAR 0 4
3819: PUSH
3820: LD_VAR 0 1
3824: PUSH
3825: LD_INT 2
3827: DIFF
3828: ST_TO_ADDR
// if q1 >= 2 then
3829: LD_VAR 0 4
3833: PUSH
3834: LD_INT 2
3836: GREATEREQUAL
3837: IFFALSE 3848
// Question1 ( q1 ) ;
3839: LD_VAR 0 4
3843: PPUSH
3844: CALL 3686 0 1
// end ; 3 :
3848: GO 3919
3850: LD_INT 3
3852: DOUBLE
3853: EQUAL
3854: IFTRUE 3858
3856: GO 3918
3858: POP
// begin Say ( Burlak , D2c-Bur-1 ) ;
3859: LD_EXP 51
3863: PPUSH
3864: LD_STRING D2c-Bur-1
3866: PPUSH
3867: CALL_OW 88
// Say ( Platonov , D2c-Pla-1 ) ;
3871: LD_EXP 65
3875: PPUSH
3876: LD_STRING D2c-Pla-1
3878: PPUSH
3879: CALL_OW 88
// q1 = q diff 3 ;
3883: LD_ADDR_VAR 0 4
3887: PUSH
3888: LD_VAR 0 1
3892: PUSH
3893: LD_INT 3
3895: DIFF
3896: ST_TO_ADDR
// if q1 >= 2 then
3897: LD_VAR 0 4
3901: PUSH
3902: LD_INT 2
3904: GREATEREQUAL
3905: IFFALSE 3916
// Question1 ( q1 ) ;
3907: LD_VAR 0 4
3911: PPUSH
3912: CALL 3686 0 1
// end ; end ;
3916: GO 3919
3918: POP
// end ;
3919: LD_VAR 0 2
3923: RET
// export function ExtAddComRefuel ( engineer , depot , vehicle ) ; var taskList ; begin
3924: LD_INT 0
3926: PPUSH
3927: PPUSH
// if not IsOK ( engineer ) or not IsOK ( depot ) or not IsOK ( vehicle ) or GetFuel ( vehicle ) = 100 then
3928: LD_VAR 0 1
3932: PPUSH
3933: CALL_OW 302
3937: NOT
3938: PUSH
3939: LD_VAR 0 2
3943: PPUSH
3944: CALL_OW 302
3948: NOT
3949: OR
3950: PUSH
3951: LD_VAR 0 3
3955: PPUSH
3956: CALL_OW 302
3960: NOT
3961: OR
3962: PUSH
3963: LD_VAR 0 3
3967: PPUSH
3968: CALL_OW 261
3972: PUSH
3973: LD_INT 100
3975: EQUAL
3976: OR
3977: IFFALSE 3981
// exit ;
3979: GO 4129
// AddComTransport ( engineer , depot , mat_oil ) ;
3981: LD_VAR 0 1
3985: PPUSH
3986: LD_VAR 0 2
3990: PPUSH
3991: LD_INT 2
3993: PPUSH
3994: CALL_OW 211
// AddComMoveXY ( engineer , GetX ( vehicle ) , GetY ( vehicle ) ) ;
3998: LD_VAR 0 1
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 250
4012: PPUSH
4013: LD_VAR 0 3
4017: PPUSH
4018: CALL_OW 251
4022: PPUSH
4023: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4027: LD_INT 35
4029: PPUSH
4030: CALL_OW 67
// until Carry ( engineer ) ;
4034: LD_VAR 0 1
4038: PPUSH
4039: CALL_OW 281
4043: IFFALSE 4027
// RemoveTasks ( engineer ) ;
4045: LD_VAR 0 1
4049: PPUSH
4050: CALL_OW 493
// SetTaskList ( engineer , [ [ O , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
4054: LD_VAR 0 1
4058: PPUSH
4059: LD_STRING O
4061: PUSH
4062: LD_INT 0
4064: PUSH
4065: LD_INT 0
4067: PUSH
4068: LD_VAR 0 3
4072: PUSH
4073: LD_INT 0
4075: PUSH
4076: LD_INT 0
4078: PUSH
4079: LD_INT 0
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: LIST
4086: LIST
4087: LIST
4088: LIST
4089: LIST
4090: PUSH
4091: EMPTY
4092: LIST
4093: PPUSH
4094: CALL_OW 446
// repeat wait ( 0 0$1 ) ;
4098: LD_INT 35
4100: PPUSH
4101: CALL_OW 67
// until not Carry ( engineer ) ;
4105: LD_VAR 0 1
4109: PPUSH
4110: CALL_OW 281
4114: NOT
4115: IFFALSE 4098
// SetFuel ( vehicle , 100 ) ;
4117: LD_VAR 0 3
4121: PPUSH
4122: LD_INT 100
4124: PPUSH
4125: CALL_OW 240
// end ;
4129: LD_VAR 0 4
4133: RET
// export function ResAllTechs ( side , lab , nation ) ; var i , tech , cout , ru_tech_list ; begin
4134: LD_INT 0
4136: PPUSH
4137: PPUSH
4138: PPUSH
4139: PPUSH
4140: PPUSH
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
4141: LD_ADDR_VAR 0 8
4145: PUSH
4146: LD_INT 48
4148: PUSH
4149: LD_INT 49
4151: PUSH
4152: LD_INT 50
4154: PUSH
4155: LD_INT 20
4157: PUSH
4158: LD_INT 1
4160: PUSH
4161: LD_INT 51
4163: PUSH
4164: LD_INT 52
4166: PUSH
4167: LD_INT 69
4169: PUSH
4170: LD_INT 39
4172: PUSH
4173: LD_INT 34
4175: PUSH
4176: LD_INT 40
4178: PUSH
4179: LD_INT 53
4181: PUSH
4182: LD_INT 71
4184: PUSH
4185: LD_INT 57
4187: PUSH
4188: LD_INT 58
4190: PUSH
4191: LD_INT 44
4193: PUSH
4194: LD_INT 32
4196: PUSH
4197: LD_INT 27
4199: PUSH
4200: LD_INT 23
4202: PUSH
4203: LD_INT 33
4205: PUSH
4206: LD_INT 59
4208: PUSH
4209: LD_INT 54
4211: PUSH
4212: LD_INT 55
4214: PUSH
4215: LD_INT 56
4217: PUSH
4218: LD_INT 63
4220: PUSH
4221: LD_INT 64
4223: PUSH
4224: LD_INT 65
4226: PUSH
4227: LD_INT 30
4229: PUSH
4230: LD_INT 31
4232: PUSH
4233: LD_INT 21
4235: PUSH
4236: LD_INT 22
4238: PUSH
4239: LD_INT 25
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: LIST
4246: LIST
4247: LIST
4248: LIST
4249: LIST
4250: LIST
4251: LIST
4252: LIST
4253: LIST
4254: LIST
4255: LIST
4256: LIST
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: LIST
4272: LIST
4273: LIST
4274: LIST
4275: ST_TO_ADDR
// for i = 1 to ru_tech_list do
4276: LD_ADDR_VAR 0 5
4280: PUSH
4281: DOUBLE
4282: LD_INT 1
4284: DEC
4285: ST_TO_ADDR
4286: LD_VAR 0 8
4290: PUSH
4291: FOR_TO
4292: IFFALSE 4368
// if GetTech ( ru_tech_list [ i ] , side ) = state_enabled and TechNationAvailable ( ru_tech_list [ i ] , nation ) = true then
4294: LD_VAR 0 8
4298: PUSH
4299: LD_VAR 0 5
4303: ARRAY
4304: PPUSH
4305: LD_VAR 0 1
4309: PPUSH
4310: CALL_OW 321
4314: PUSH
4315: LD_INT 1
4317: EQUAL
4318: PUSH
4319: LD_VAR 0 8
4323: PUSH
4324: LD_VAR 0 5
4328: ARRAY
4329: PPUSH
4330: LD_VAR 0 3
4334: PPUSH
4335: CALL_OW 482
4339: PUSH
4340: LD_INT 1
4342: EQUAL
4343: AND
4344: IFFALSE 4366
// AddComResearch ( lab , ru_tech_list [ i ] ) ;
4346: LD_VAR 0 2
4350: PPUSH
4351: LD_VAR 0 8
4355: PUSH
4356: LD_VAR 0 5
4360: ARRAY
4361: PPUSH
4362: CALL_OW 184
4366: GO 4291
4368: POP
4369: POP
// end ;
4370: LD_VAR 0 4
4374: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
4375: LD_INT 0
4377: PPUSH
4378: PPUSH
4379: PPUSH
// uc_side := GetSide ( b ) ;
4380: LD_ADDR_OWVAR 20
4384: PUSH
4385: LD_VAR 0 2
4389: PPUSH
4390: CALL_OW 255
4394: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
4395: LD_ADDR_OWVAR 21
4399: PUSH
4400: LD_VAR 0 2
4404: PPUSH
4405: CALL_OW 248
4409: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4410: LD_INT 0
4412: PPUSH
4413: LD_INT 1
4415: PPUSH
4416: LD_VAR 0 1
4420: PPUSH
4421: CALL_OW 380
// un = CreateHuman ;
4425: LD_ADDR_VAR 0 4
4429: PUSH
4430: CALL_OW 44
4434: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
4435: LD_ADDR_VAR 0 5
4439: PUSH
4440: LD_VAR 0 2
4444: PPUSH
4445: CALL_OW 254
4449: PUSH
4450: LD_INT 3
4452: MINUS
4453: ST_TO_ADDR
// if dir < 0 then
4454: LD_VAR 0 5
4458: PUSH
4459: LD_INT 0
4461: LESS
4462: IFFALSE 4478
// dir := 6 + dir ;
4464: LD_ADDR_VAR 0 5
4468: PUSH
4469: LD_INT 6
4471: PUSH
4472: LD_VAR 0 5
4476: PLUS
4477: ST_TO_ADDR
// SetDir ( un , dir ) ;
4478: LD_VAR 0 4
4482: PPUSH
4483: LD_VAR 0 5
4487: PPUSH
4488: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4492: LD_VAR 0 4
4496: PPUSH
4497: LD_VAR 0 2
4501: PPUSH
4502: CALL_OW 52
// end ;
4506: LD_VAR 0 3
4510: RET
// export function CreateBelkovTeam ; var i , unit , restRandSolds ; begin
4511: LD_INT 0
4513: PPUSH
4514: PPUSH
4515: PPUSH
4516: PPUSH
// belkovTeam = [ ] ;
4517: LD_ADDR_EXP 62
4521: PUSH
4522: EMPTY
4523: ST_TO_ADDR
// if belkovReturn then
4524: LD_EXP 4
4528: IFFALSE 4548
// belkovTeam = belkovTeam ^ Belkov else
4530: LD_ADDR_EXP 62
4534: PUSH
4535: LD_EXP 62
4539: PUSH
4540: LD_EXP 53
4544: ADD
4545: ST_TO_ADDR
4546: GO 4564
// belkovTeam = belkovTeam ^ Belkov2 ;
4548: LD_ADDR_EXP 62
4552: PUSH
4553: LD_EXP 62
4557: PUSH
4558: LD_EXP 57
4562: ADD
4563: ST_TO_ADDR
// for unit in other_survivors do
4564: LD_ADDR_VAR 0 3
4568: PUSH
4569: LD_EXP 55
4573: PUSH
4574: FOR_IN
4575: IFFALSE 4616
// if IsOK ( unit ) and belkovTeam < 5 then
4577: LD_VAR 0 3
4581: PPUSH
4582: CALL_OW 302
4586: PUSH
4587: LD_EXP 62
4591: PUSH
4592: LD_INT 5
4594: LESS
4595: AND
4596: IFFALSE 4614
// belkovTeam = belkovTeam ^ unit ;
4598: LD_ADDR_EXP 62
4602: PUSH
4603: LD_EXP 62
4607: PUSH
4608: LD_VAR 0 3
4612: ADD
4613: ST_TO_ADDR
4614: GO 4574
4616: POP
4617: POP
// if belkovTeam < 5 then
4618: LD_EXP 62
4622: PUSH
4623: LD_INT 5
4625: LESS
4626: IFFALSE 4762
// begin restRandSolds = 5 - belkovTeam ;
4628: LD_ADDR_VAR 0 4
4632: PUSH
4633: LD_INT 5
4635: PUSH
4636: LD_EXP 62
4640: MINUS
4641: ST_TO_ADDR
// for i := 1 to restRandSolds do
4642: LD_ADDR_VAR 0 2
4646: PUSH
4647: DOUBLE
4648: LD_INT 1
4650: DEC
4651: ST_TO_ADDR
4652: LD_VAR 0 4
4656: PUSH
4657: FOR_TO
4658: IFFALSE 4760
// for unit in UnitFilter ( otherKirovUnits , [ [ f_class , class_soldier ] ] ) do
4660: LD_ADDR_VAR 0 3
4664: PUSH
4665: LD_EXP 58
4669: PPUSH
4670: LD_INT 25
4672: PUSH
4673: LD_INT 1
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: EMPTY
4681: LIST
4682: PPUSH
4683: CALL_OW 72
4687: PUSH
4688: FOR_IN
4689: IFFALSE 4756
// if not unit in belkovTeam then
4691: LD_VAR 0 3
4695: PUSH
4696: LD_EXP 62
4700: IN
4701: NOT
4702: IFFALSE 4754
// if not IsInUnit ( unit ) or GetBType ( IsInUnit ( unit ) ) = b_armoury then
4704: LD_VAR 0 3
4708: PPUSH
4709: CALL_OW 310
4713: NOT
4714: PUSH
4715: LD_VAR 0 3
4719: PPUSH
4720: CALL_OW 310
4724: PPUSH
4725: CALL_OW 266
4729: PUSH
4730: LD_INT 4
4732: EQUAL
4733: OR
4734: IFFALSE 4754
// begin belkovTeam = belkovTeam ^ unit ;
4736: LD_ADDR_EXP 62
4740: PUSH
4741: LD_EXP 62
4745: PUSH
4746: LD_VAR 0 3
4750: ADD
4751: ST_TO_ADDR
// break ;
4752: GO 4756
// end ;
4754: GO 4688
4756: POP
4757: POP
4758: GO 4657
4760: POP
4761: POP
// end ; belkovTeam = belkovTeam ^ UnitFilter ( otherKirovUnits , [ [ f_class , class_scientistic ] ] ) [ 1 ] ;
4762: LD_ADDR_EXP 62
4766: PUSH
4767: LD_EXP 62
4771: PUSH
4772: LD_EXP 58
4776: PPUSH
4777: LD_INT 25
4779: PUSH
4780: LD_INT 4
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: PPUSH
4790: CALL_OW 72
4794: PUSH
4795: LD_INT 1
4797: ARRAY
4798: ADD
4799: ST_TO_ADDR
// end ;
4800: LD_VAR 0 1
4804: RET
// export function PlatonovSendSupport ; var i , randValue ; begin
4805: LD_INT 0
4807: PPUSH
4808: PPUSH
4809: PPUSH
// for i := 1 to 2 do
4810: LD_ADDR_VAR 0 2
4814: PUSH
4815: DOUBLE
4816: LD_INT 1
4818: DEC
4819: ST_TO_ADDR
4820: LD_INT 2
4822: PUSH
4823: FOR_TO
4824: IFFALSE 4939
// begin randValue = rand ( 1 , platSoldiers ) ;
4826: LD_ADDR_VAR 0 3
4830: PUSH
4831: LD_INT 1
4833: PPUSH
4834: LD_EXP 66
4838: PPUSH
4839: CALL_OW 12
4843: ST_TO_ADDR
// SetSide ( platSoldiers [ randValue ] , 3 ) ;
4844: LD_EXP 66
4848: PUSH
4849: LD_VAR 0 3
4853: ARRAY
4854: PPUSH
4855: LD_INT 3
4857: PPUSH
4858: CALL_OW 235
// if IsInUnit ( platSoldiers [ randValue ] ) then
4862: LD_EXP 66
4866: PUSH
4867: LD_VAR 0 3
4871: ARRAY
4872: PPUSH
4873: CALL_OW 310
4877: IFFALSE 4894
// ComExitBuilding ( platSoldiers [ randValue ] ) ;
4879: LD_EXP 66
4883: PUSH
4884: LD_VAR 0 3
4888: ARRAY
4889: PPUSH
4890: CALL_OW 122
// AddComMoveXY ( platSoldiers [ randValue ] , 112 , 96 ) ;
4894: LD_EXP 66
4898: PUSH
4899: LD_VAR 0 3
4903: ARRAY
4904: PPUSH
4905: LD_INT 112
4907: PPUSH
4908: LD_INT 96
4910: PPUSH
4911: CALL_OW 171
// platSoldiers = platSoldiers diff platSoldiers [ randValue ] ;
4915: LD_ADDR_EXP 66
4919: PUSH
4920: LD_EXP 66
4924: PUSH
4925: LD_EXP 66
4929: PUSH
4930: LD_VAR 0 3
4934: ARRAY
4935: DIFF
4936: ST_TO_ADDR
// end ;
4937: GO 4823
4939: POP
4940: POP
// end ; end_of_file
4941: LD_VAR 0 1
4945: RET
// export function MissionIntro ; var yourSolds , nearUnit ; var i ; begin
4946: LD_INT 0
4948: PPUSH
4949: PPUSH
4950: PPUSH
4951: PPUSH
// CenterNowOnUnits ( Burlak ) ;
4952: LD_EXP 51
4956: PPUSH
4957: CALL_OW 87
// ComMoveXY ( Burlak , 163 , 108 ) ;
4961: LD_EXP 51
4965: PPUSH
4966: LD_INT 163
4968: PPUSH
4969: LD_INT 108
4971: PPUSH
4972: CALL_OW 111
// AddComTurnUnit ( Burlak , Kurin ) ;
4976: LD_EXP 51
4980: PPUSH
4981: LD_EXP 56
4985: PPUSH
4986: CALL_OW 179
// yourSolds = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff Burlak ;
4990: LD_ADDR_VAR 0 2
4994: PUSH
4995: LD_INT 22
4997: PUSH
4998: LD_INT 3
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: PUSH
5005: LD_INT 21
5007: PUSH
5008: LD_INT 1
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PPUSH
5019: CALL_OW 69
5023: PUSH
5024: LD_EXP 51
5028: DIFF
5029: ST_TO_ADDR
// for i := 1 to meetWithKurinPositions do
5030: LD_ADDR_VAR 0 4
5034: PUSH
5035: DOUBLE
5036: LD_INT 1
5038: DEC
5039: ST_TO_ADDR
5040: LD_EXP 44
5044: PUSH
5045: FOR_TO
5046: IFFALSE 5164
// begin nearUnit = NearestUnitToXY ( yourSolds , meetWithKurinPositions [ i ] [ 1 ] , meetWithKurinPositions [ i ] [ 2 ] ) ;
5048: LD_ADDR_VAR 0 3
5052: PUSH
5053: LD_VAR 0 2
5057: PPUSH
5058: LD_EXP 44
5062: PUSH
5063: LD_VAR 0 4
5067: ARRAY
5068: PUSH
5069: LD_INT 1
5071: ARRAY
5072: PPUSH
5073: LD_EXP 44
5077: PUSH
5078: LD_VAR 0 4
5082: ARRAY
5083: PUSH
5084: LD_INT 2
5086: ARRAY
5087: PPUSH
5088: CALL_OW 73
5092: ST_TO_ADDR
// ComMoveXY ( nearUnit , meetWithKurinPositions [ i ] [ 1 ] , meetWithKurinPositions [ i ] [ 2 ] ) ;
5093: LD_VAR 0 3
5097: PPUSH
5098: LD_EXP 44
5102: PUSH
5103: LD_VAR 0 4
5107: ARRAY
5108: PUSH
5109: LD_INT 1
5111: ARRAY
5112: PPUSH
5113: LD_EXP 44
5117: PUSH
5118: LD_VAR 0 4
5122: ARRAY
5123: PUSH
5124: LD_INT 2
5126: ARRAY
5127: PPUSH
5128: CALL_OW 111
// AddComTurnUnit ( nearUnit , Kurin ) ;
5132: LD_VAR 0 3
5136: PPUSH
5137: LD_EXP 56
5141: PPUSH
5142: CALL_OW 179
// yourSolds = yourSolds diff nearUnit ;
5146: LD_ADDR_VAR 0 2
5150: PUSH
5151: LD_VAR 0 2
5155: PUSH
5156: LD_VAR 0 3
5160: DIFF
5161: ST_TO_ADDR
// end ;
5162: GO 5045
5164: POP
5165: POP
// repeat CenterNowOnUnits ( Burlak ) ;
5166: LD_EXP 51
5170: PPUSH
5171: CALL_OW 87
// wait ( 0 0$1 ) ;
5175: LD_INT 35
5177: PPUSH
5178: CALL_OW 67
// until GetDistUnits ( Burlak , Kurin ) < 4 ;
5182: LD_EXP 51
5186: PPUSH
5187: LD_EXP 56
5191: PPUSH
5192: CALL_OW 296
5196: PUSH
5197: LD_INT 4
5199: LESS
5200: IFFALSE 5166
// CenterNowOnUnits ( [ Burlak , Kurin ] ) ;
5202: LD_EXP 51
5206: PUSH
5207: LD_EXP 56
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: PPUSH
5216: CALL_OW 87
// ComTurnUnit ( Kurin , Burlak ) ;
5220: LD_EXP 56
5224: PPUSH
5225: LD_EXP 51
5229: PPUSH
5230: CALL_OW 119
// Say ( Kurin , D1-Kur-1 ) ;
5234: LD_EXP 56
5238: PPUSH
5239: LD_STRING D1-Kur-1
5241: PPUSH
5242: CALL_OW 88
// Say ( Burlak , D1-Bur-1 ) ;
5246: LD_EXP 51
5250: PPUSH
5251: LD_STRING D1-Bur-1
5253: PPUSH
5254: CALL_OW 88
// Say ( Kurin , D1-Kur-2 ) ;
5258: LD_EXP 56
5262: PPUSH
5263: LD_STRING D1-Kur-2
5265: PPUSH
5266: CALL_OW 88
// Say ( Burlak , D1-Bur-2 ) ;
5270: LD_EXP 51
5274: PPUSH
5275: LD_STRING D1-Bur-2
5277: PPUSH
5278: CALL_OW 88
// Say ( Kurin , D1-Kur-3 ) ;
5282: LD_EXP 56
5286: PPUSH
5287: LD_STRING D1-Kur-3
5289: PPUSH
5290: CALL_OW 88
// if IsOK ( Gnyevko ) then
5294: LD_EXP 52
5298: PPUSH
5299: CALL_OW 302
5303: IFFALSE 5317
// Say ( Kurin , D1-Kur-3a ) ;
5305: LD_EXP 56
5309: PPUSH
5310: LD_STRING D1-Kur-3a
5312: PPUSH
5313: CALL_OW 88
// InGameOff ;
5317: CALL_OW 9
// SetSide ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko ] , 6 ) ;
5321: LD_INT 22
5323: PUSH
5324: LD_INT 3
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 21
5333: PUSH
5334: LD_INT 1
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PPUSH
5345: CALL_OW 69
5349: PUSH
5350: LD_EXP 51
5354: PUSH
5355: LD_EXP 52
5359: PUSH
5360: EMPTY
5361: LIST
5362: LIST
5363: DIFF
5364: PPUSH
5365: LD_INT 6
5367: PPUSH
5368: CALL_OW 235
// SetSide ( Kovalyuk , 3 ) ;
5372: LD_EXP 59
5376: PPUSH
5377: LD_INT 3
5379: PPUSH
5380: CALL_OW 235
// ComFree ( FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Kurin ) ;
5384: LD_INT 9
5386: PPUSH
5387: LD_INT 22
5389: PUSH
5390: LD_INT 6
5392: PUSH
5393: EMPTY
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 21
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PPUSH
5411: CALL_OW 70
5415: PUSH
5416: LD_EXP 56
5420: DIFF
5421: PPUSH
5422: CALL_OW 139
// ComEnterUnit ( other_survivors , ru2_arm ) ;
5426: LD_EXP 55
5430: PPUSH
5431: LD_INT 95
5433: PPUSH
5434: CALL_OW 120
// ComEnterUnit ( Belkov , ru2_arm ) ;
5438: LD_EXP 53
5442: PPUSH
5443: LD_INT 95
5445: PPUSH
5446: CALL_OW 120
// if not TestCharacters ( 01_Gnyevko ) then
5450: LD_STRING 01_Gnyevko
5452: PPUSH
5453: CALL_OW 28
5457: NOT
5458: IFFALSE 5472
// SetSide ( randomMech , 3 ) ;
5460: LD_EXP 60
5464: PPUSH
5465: LD_INT 3
5467: PPUSH
5468: CALL_OW 235
// ChangeMissionObjectives ( M1 ) ;
5472: LD_STRING M1
5474: PPUSH
5475: CALL_OW 337
// HideArea ( 3 , AllMapArea ) ;
5479: LD_INT 3
5481: PPUSH
5482: LD_INT 6
5484: PPUSH
5485: CALL_OW 333
// ShowArea ( 3 , VisibleMapPartArea ) ;
5489: LD_INT 3
5491: PPUSH
5492: LD_INT 7
5494: PPUSH
5495: CALL_OW 334
// HideArea ( 6 , AllMapArea ) ;
5499: LD_INT 6
5501: PPUSH
5502: LD_INT 6
5504: PPUSH
5505: CALL_OW 333
// ShowArea ( 6 , VisibleMapPartArea ) ;
5509: LD_INT 6
5511: PPUSH
5512: LD_INT 7
5514: PPUSH
5515: CALL_OW 334
// SaveForQuickRestart ;
5519: CALL_OW 22
// end ;
5523: LD_VAR 0 1
5527: RET
// every 0 0$1 trigger not meetPlatonov and IsOK ( Burlak ) and FilterUnitsInArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 0 do var i , unit , yourUnits , randomMaleSoldier ;
5528: LD_EXP 5
5532: NOT
5533: PUSH
5534: LD_EXP 51
5538: PPUSH
5539: CALL_OW 302
5543: AND
5544: PUSH
5545: LD_INT 8
5547: PPUSH
5548: LD_INT 22
5550: PUSH
5551: LD_INT 3
5553: PUSH
5554: EMPTY
5555: LIST
5556: LIST
5557: PUSH
5558: LD_INT 21
5560: PUSH
5561: LD_INT 1
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL_OW 70
5576: PUSH
5577: LD_INT 0
5579: GREATER
5580: AND
5581: IFFALSE 6073
5583: GO 5585
5585: DISABLE
5586: LD_INT 0
5588: PPUSH
5589: PPUSH
5590: PPUSH
5591: PPUSH
// begin enable ;
5592: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
5593: LD_ADDR_VAR 0 2
5597: PUSH
5598: LD_INT 22
5600: PUSH
5601: LD_INT 3
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 21
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: PPUSH
5622: CALL_OW 69
5626: PUSH
5627: FOR_IN
5628: IFFALSE 6071
// if See ( 6 , unit ) then
5630: LD_INT 6
5632: PPUSH
5633: LD_VAR 0 2
5637: PPUSH
5638: CALL_OW 292
5642: IFFALSE 6069
// begin meetPlatonov = true ;
5644: LD_ADDR_EXP 5
5648: PUSH
5649: LD_INT 1
5651: ST_TO_ADDR
// InGameOn ;
5652: CALL_OW 8
// DialogueOn ;
5656: CALL_OW 6
// randomMaleSoldier = DialogRandom ( UnitFilter ( platSoldiers , [ f_sex , sex_male ] ) , D2-RSol1-1 ,  , false ) ;
5660: LD_ADDR_VAR 0 4
5664: PUSH
5665: LD_EXP 66
5669: PPUSH
5670: LD_INT 26
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PPUSH
5680: CALL_OW 72
5684: PPUSH
5685: LD_STRING D2-RSol1-1
5687: PPUSH
5688: LD_STRING 
5690: PPUSH
5691: LD_INT 0
5693: PPUSH
5694: CALL 3353 0 4
5698: ST_TO_ADDR
// Say ( Burlak , D2-Bur-1 ) ;
5699: LD_EXP 51
5703: PPUSH
5704: LD_STRING D2-Bur-1
5706: PPUSH
5707: CALL_OW 88
// Say ( randomMaleSoldier , D2-RSol1-2 ) ;
5711: LD_VAR 0 4
5715: PPUSH
5716: LD_STRING D2-RSol1-2
5718: PPUSH
5719: CALL_OW 88
// DialogueOff ;
5723: CALL_OW 7
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
5727: LD_ADDR_VAR 0 3
5731: PUSH
5732: LD_INT 22
5734: PUSH
5735: LD_INT 3
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: PUSH
5742: LD_INT 21
5744: PUSH
5745: LD_INT 1
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: PUSH
5752: LD_INT 50
5754: PUSH
5755: EMPTY
5756: LIST
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: LIST
5762: PPUSH
5763: CALL_OW 69
5767: ST_TO_ADDR
// for i := 1 to yourUnits do
5768: LD_ADDR_VAR 0 1
5772: PUSH
5773: DOUBLE
5774: LD_INT 1
5776: DEC
5777: ST_TO_ADDR
5778: LD_VAR 0 3
5782: PUSH
5783: FOR_TO
5784: IFFALSE 5853
// begin ComMoveXY ( yourUnits [ i ] , meetWithPlatonovPositions [ i ] [ 1 ] , meetWithPlatonovPositions [ i ] [ 2 ] ) ;
5786: LD_VAR 0 3
5790: PUSH
5791: LD_VAR 0 1
5795: ARRAY
5796: PPUSH
5797: LD_EXP 45
5801: PUSH
5802: LD_VAR 0 1
5806: ARRAY
5807: PUSH
5808: LD_INT 1
5810: ARRAY
5811: PPUSH
5812: LD_EXP 45
5816: PUSH
5817: LD_VAR 0 1
5821: ARRAY
5822: PUSH
5823: LD_INT 2
5825: ARRAY
5826: PPUSH
5827: CALL_OW 111
// AddComTurnUnit ( yourUnits [ i ] , Platonov ) ;
5831: LD_VAR 0 3
5835: PUSH
5836: LD_VAR 0 1
5840: ARRAY
5841: PPUSH
5842: LD_EXP 65
5846: PPUSH
5847: CALL_OW 179
// end ;
5851: GO 5783
5853: POP
5854: POP
// repeat CenterNowOnUnits ( Burlak ) ;
5855: LD_EXP 51
5859: PPUSH
5860: CALL_OW 87
// wait ( 0 0$1 ) ;
5864: LD_INT 35
5866: PPUSH
5867: CALL_OW 67
// until GetDistUnits ( Burlak , Platonov ) < 4 ;
5871: LD_EXP 51
5875: PPUSH
5876: LD_EXP 65
5880: PPUSH
5881: CALL_OW 296
5885: PUSH
5886: LD_INT 4
5888: LESS
5889: IFFALSE 5855
// ComTurnUnit ( Platonov , Burlak ) ;
5891: LD_EXP 65
5895: PPUSH
5896: LD_EXP 51
5900: PPUSH
5901: CALL_OW 119
// Say ( Platonov , D2-Pla-2 ) ;
5905: LD_EXP 65
5909: PPUSH
5910: LD_STRING D2-Pla-2
5912: PPUSH
5913: CALL_OW 88
// Say ( Burlak , D2-Bur-2 ) ;
5917: LD_EXP 51
5921: PPUSH
5922: LD_STRING D2-Bur-2
5924: PPUSH
5925: CALL_OW 88
// Say ( Platonov , D2-Pla-3 ) ;
5929: LD_EXP 65
5933: PPUSH
5934: LD_STRING D2-Pla-3
5936: PPUSH
5937: CALL_OW 88
// Say ( Burlak , D2-Bur-3 ) ;
5941: LD_EXP 51
5945: PPUSH
5946: LD_STRING D2-Bur-3
5948: PPUSH
5949: CALL_OW 88
// Say ( Platonov , D2-Pla-4 ) ;
5953: LD_EXP 65
5957: PPUSH
5958: LD_STRING D2-Pla-4
5960: PPUSH
5961: CALL_OW 88
// Say ( Burlak , D2-Bur-4 ) ;
5965: LD_EXP 51
5969: PPUSH
5970: LD_STRING D2-Bur-4
5972: PPUSH
5973: CALL_OW 88
// Say ( Platonov , D2-Pla-5 ) ;
5977: LD_EXP 65
5981: PPUSH
5982: LD_STRING D2-Pla-5
5984: PPUSH
5985: CALL_OW 88
// Question1 ( [ 1 , 2 , 3 , 4 ] ) ;
5989: LD_INT 1
5991: PUSH
5992: LD_INT 2
5994: PUSH
5995: LD_INT 3
5997: PUSH
5998: LD_INT 4
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: PPUSH
6007: CALL 3686 0 1
// Say ( Platonov , D3-Pla-1 ) ;
6011: LD_EXP 65
6015: PPUSH
6016: LD_STRING D3-Pla-1
6018: PPUSH
6019: CALL_OW 88
// Say ( Burlak , D3-Bur-1 ) ;
6023: LD_EXP 51
6027: PPUSH
6028: LD_STRING D3-Bur-1
6030: PPUSH
6031: CALL_OW 88
// InGameOff ;
6035: CALL_OW 9
// ChangeMissionObjectives ( M2a ) ;
6039: LD_STRING M2a
6041: PPUSH
6042: CALL_OW 337
// ComFree ( Platonov ) ;
6046: LD_EXP 65
6050: PPUSH
6051: CALL_OW 139
// SetSide ( beria , 3 ) ;
6055: LD_INT 106
6057: PPUSH
6058: LD_INT 3
6060: PPUSH
6061: CALL_OW 235
// exit ;
6065: POP
6066: POP
6067: GO 6073
// end ;
6069: GO 5627
6071: POP
6072: POP
// end ;
6073: PPOPN 4
6075: END
// export function Dial_LabConstructed ; begin
6076: LD_INT 0
6078: PPUSH
// labConstructed = true ;
6079: LD_ADDR_EXP 6
6083: PUSH
6084: LD_INT 1
6086: ST_TO_ADDR
// DialogueOn ;
6087: CALL_OW 6
// Say ( Burlak , D5a-Bur-1 ) ;
6091: LD_EXP 51
6095: PPUSH
6096: LD_STRING D5a-Bur-1
6098: PPUSH
6099: CALL_OW 88
// if workshopConstructed then
6103: LD_EXP 7
6107: IFFALSE 6123
// Say ( Platonov , D5a-Pla-1a ) else
6109: LD_EXP 65
6113: PPUSH
6114: LD_STRING D5a-Pla-1a
6116: PPUSH
6117: CALL_OW 88
6121: GO 6135
// Say ( Platonov , D5a-Pla-1a ) ;
6123: LD_EXP 65
6127: PPUSH
6128: LD_STRING D5a-Pla-1a
6130: PPUSH
6131: CALL_OW 88
// DialogueOff ;
6135: CALL_OW 7
// ChangeMissionObjectives ( M2b ) ;
6139: LD_STRING M2b
6141: PPUSH
6142: CALL_OW 337
// end ;
6146: LD_VAR 0 1
6150: RET
// export function Dial_WorkshopConstructed ; begin
6151: LD_INT 0
6153: PPUSH
// workshopConstructed = true ;
6154: LD_ADDR_EXP 7
6158: PUSH
6159: LD_INT 1
6161: ST_TO_ADDR
// DialogueOn ;
6162: CALL_OW 6
// Say ( Burlak , D5b-Bur-1 ) ;
6166: LD_EXP 51
6170: PPUSH
6171: LD_STRING D5b-Bur-1
6173: PPUSH
6174: CALL_OW 88
// if labConstructed then
6178: LD_EXP 6
6182: IFFALSE 6198
// Say ( Platonov , D5b-Pla-1 ) else
6184: LD_EXP 65
6188: PPUSH
6189: LD_STRING D5b-Pla-1
6191: PPUSH
6192: CALL_OW 88
6196: GO 6210
// Say ( Platonov , D5b-Pla-1a ) ;
6198: LD_EXP 65
6202: PPUSH
6203: LD_STRING D5b-Pla-1a
6205: PPUSH
6206: CALL_OW 88
// DialogueOff ;
6210: CALL_OW 7
// ChangeMissionObjectives ( M2c ) ;
6214: LD_STRING M2c
6216: PPUSH
6217: CALL_OW 337
// end ;
6221: LD_VAR 0 1
6225: RET
// export function Dial_StopConstructAgainSameBuilding ( building ) ; begin
6226: LD_INT 0
6228: PPUSH
// CenterNowOnUnits ( building ) ;
6229: LD_VAR 0 1
6233: PPUSH
6234: CALL_OW 87
// ComStop ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
6238: LD_INT 22
6240: PUSH
6241: LD_INT 3
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: LD_INT 21
6250: PUSH
6251: LD_INT 1
6253: PUSH
6254: EMPTY
6255: LIST
6256: LIST
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: PPUSH
6262: CALL_OW 69
6266: PPUSH
6267: CALL_OW 141
// DialogueOn ;
6271: CALL_OW 6
// Say ( Platonov , D6-Pla-1 ) ;
6275: LD_EXP 65
6279: PPUSH
6280: LD_STRING D6-Pla-1
6282: PPUSH
6283: CALL_OW 88
// Say ( Burlak , D6-Bur-1 ) ;
6287: LD_EXP 51
6291: PPUSH
6292: LD_STRING D6-Bur-1
6294: PPUSH
6295: CALL_OW 88
// DialogueOff ;
6299: CALL_OW 7
// if GetBType ( building ) = b_lab then
6303: LD_VAR 0 1
6307: PPUSH
6308: CALL_OW 266
6312: PUSH
6313: LD_INT 6
6315: EQUAL
6316: IFFALSE 6357
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + labCratesRefund ) else
6318: LD_INT 106
6320: PPUSH
6321: CALL_OW 274
6325: PPUSH
6326: LD_INT 1
6328: PPUSH
6329: LD_INT 106
6331: PPUSH
6332: CALL_OW 274
6336: PPUSH
6337: LD_INT 1
6339: PPUSH
6340: CALL_OW 275
6344: PUSH
6345: LD_EXP 46
6349: PLUS
6350: PPUSH
6351: CALL_OW 277
6355: GO 6394
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + workshopCratesRefund ) ;
6357: LD_INT 106
6359: PPUSH
6360: CALL_OW 274
6364: PPUSH
6365: LD_INT 1
6367: PPUSH
6368: LD_INT 106
6370: PPUSH
6371: CALL_OW 274
6375: PPUSH
6376: LD_INT 1
6378: PPUSH
6379: CALL_OW 275
6383: PUSH
6384: LD_EXP 47
6388: PLUS
6389: PPUSH
6390: CALL_OW 277
// RemoveUnit ( building ) ;
6394: LD_VAR 0 1
6398: PPUSH
6399: CALL_OW 64
// end ;
6403: LD_VAR 0 2
6407: RET
// every 0 0$2 trigger workshopConstructed and labConstructed do
6408: LD_EXP 7
6412: PUSH
6413: LD_EXP 6
6417: AND
6418: IFFALSE 6527
6420: GO 6422
6422: DISABLE
// begin DialogueOn ;
6423: CALL_OW 6
// if engineResearched then
6427: LD_EXP 8
6431: IFFALSE 6459
// begin Say ( Burlak , D7b-Bur-1 ) ;
6433: LD_EXP 51
6437: PPUSH
6438: LD_STRING D7b-Bur-1
6440: PPUSH
6441: CALL_OW 88
// Say ( Platonov , D7b-Pla-1 ) ;
6445: LD_EXP 65
6449: PPUSH
6450: LD_STRING D7b-Pla-1
6452: PPUSH
6453: CALL_OW 88
// end else
6457: GO 6483
// begin Say ( Burlak , D7a-Bur-1 ) ;
6459: LD_EXP 51
6463: PPUSH
6464: LD_STRING D7a-Bur-1
6466: PPUSH
6467: CALL_OW 88
// Say ( Platonov , D7a-Pla-1 ) ;
6471: LD_EXP 65
6475: PPUSH
6476: LD_STRING D7a-Pla-1
6478: PPUSH
6479: CALL_OW 88
// end ; DialogueOff ;
6483: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
6487: LD_STRING M2
6489: PPUSH
6490: CALL_OW 337
// CreateCratesXYR ( 5 , GetX ( Platonov ) , GetY ( Platonov ) , 5 , true ) ;
6494: LD_INT 5
6496: PPUSH
6497: LD_EXP 65
6501: PPUSH
6502: CALL_OW 250
6506: PPUSH
6507: LD_EXP 65
6511: PPUSH
6512: CALL_OW 251
6516: PPUSH
6517: LD_INT 5
6519: PPUSH
6520: LD_INT 1
6522: PPUSH
6523: CALL_OW 56
// end ;
6527: END
// export function Dial_NewCrates ( x , y ) ; begin
6528: LD_INT 0
6530: PPUSH
// wait ( 0 0$6 ) ;
6531: LD_INT 210
6533: PPUSH
6534: CALL_OW 67
// ComMoveXY ( Platonov , x , y ) ;
6538: LD_EXP 65
6542: PPUSH
6543: LD_VAR 0 1
6547: PPUSH
6548: LD_VAR 0 2
6552: PPUSH
6553: CALL_OW 111
// Say ( Platonov , D4-Pla-1 ) ;
6557: LD_EXP 65
6561: PPUSH
6562: LD_STRING D4-Pla-1
6564: PPUSH
6565: CALL_OW 88
// end ;
6569: LD_VAR 0 3
6573: RET
// export function Dial_FirstVehConstructed ( factory ) ; begin
6574: LD_INT 0
6576: PPUSH
// firstVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
6577: LD_ADDR_EXP 11
6581: PUSH
6582: LD_INT 22
6584: PUSH
6585: LD_INT 3
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: LD_INT 21
6594: PUSH
6595: LD_INT 2
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: PPUSH
6606: CALL_OW 69
6610: PUSH
6611: LD_INT 1
6613: ARRAY
6614: ST_TO_ADDR
// constructedFirstVehicle = true ;
6615: LD_ADDR_EXP 10
6619: PUSH
6620: LD_INT 1
6622: ST_TO_ADDR
// InGameOn ;
6623: CALL_OW 8
// CenterNowOnUnits ( factory ) ;
6627: LD_VAR 0 1
6631: PPUSH
6632: CALL_OW 87
// wait ( 0 0$3 ) ;
6636: LD_INT 105
6638: PPUSH
6639: CALL_OW 67
// Say ( Burlak , D9-Bur-1 ) ;
6643: LD_EXP 51
6647: PPUSH
6648: LD_STRING D9-Bur-1
6650: PPUSH
6651: CALL_OW 88
// ComMoveXY ( Platonov , GetX ( firstVeh ) , GetY ( firstVeh ) ) ;
6655: LD_EXP 65
6659: PPUSH
6660: LD_EXP 11
6664: PPUSH
6665: CALL_OW 250
6669: PPUSH
6670: LD_EXP 11
6674: PPUSH
6675: CALL_OW 251
6679: PPUSH
6680: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6684: LD_INT 35
6686: PPUSH
6687: CALL_OW 67
// until GetDistUnits ( Platonov , firstVeh ) < 4 ;
6691: LD_EXP 65
6695: PPUSH
6696: LD_EXP 11
6700: PPUSH
6701: CALL_OW 296
6705: PUSH
6706: LD_INT 4
6708: LESS
6709: IFFALSE 6684
// ComTurnUnit ( Platonov , firstVeh ) ;
6711: LD_EXP 65
6715: PPUSH
6716: LD_EXP 11
6720: PPUSH
6721: CALL_OW 119
// Say ( Platonov , D9-Pla-1 ) ;
6725: LD_EXP 65
6729: PPUSH
6730: LD_STRING D9-Pla-1
6732: PPUSH
6733: CALL_OW 88
// InGameOff ;
6737: CALL_OW 9
// ChangeMissionObjectives ( M3 ) ;
6741: LD_STRING M3
6743: PPUSH
6744: CALL_OW 337
// ComMoveXY ( Platonov , 112 , 97 ) ;
6748: LD_EXP 65
6752: PPUSH
6753: LD_INT 112
6755: PPUSH
6756: LD_INT 97
6758: PPUSH
6759: CALL_OW 111
// end ;
6763: LD_VAR 0 2
6767: RET
// every 0 0$1 trigger IsInArea ( firstVeh , KirovBaseArea ) and not vehicleForKurin do var i , eng , mech ;
6768: LD_EXP 11
6772: PPUSH
6773: LD_INT 9
6775: PPUSH
6776: CALL_OW 308
6780: PUSH
6781: LD_EXP 12
6785: NOT
6786: AND
6787: IFFALSE 7579
6789: GO 6791
6791: DISABLE
6792: LD_INT 0
6794: PPUSH
6795: PPUSH
6796: PPUSH
// begin vehicleForKurin = true ;
6797: LD_ADDR_EXP 12
6801: PUSH
6802: LD_INT 1
6804: ST_TO_ADDR
// eng = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) [ 1 ] ;
6805: LD_ADDR_VAR 0 2
6809: PUSH
6810: LD_EXP 58
6814: PPUSH
6815: LD_INT 25
6817: PUSH
6818: LD_INT 2
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: PPUSH
6825: CALL_OW 72
6829: PUSH
6830: LD_INT 1
6832: ARRAY
6833: ST_TO_ADDR
// mech = UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) [ 1 ] ;
6834: LD_ADDR_VAR 0 3
6838: PUSH
6839: LD_EXP 58
6843: PPUSH
6844: LD_INT 25
6846: PUSH
6847: LD_INT 3
6849: PUSH
6850: EMPTY
6851: LIST
6852: LIST
6853: PPUSH
6854: CALL_OW 72
6858: PUSH
6859: LD_INT 1
6861: ARRAY
6862: ST_TO_ADDR
// CenterNowOnUnits ( Kurin ) ;
6863: LD_EXP 56
6867: PPUSH
6868: CALL_OW 87
// ComMoveXY ( firstVeh , GetX ( Kurin ) , GetY ( Kurin ) ) ;
6872: LD_EXP 11
6876: PPUSH
6877: LD_EXP 56
6881: PPUSH
6882: CALL_OW 250
6886: PPUSH
6887: LD_EXP 56
6891: PPUSH
6892: CALL_OW 251
6896: PPUSH
6897: CALL_OW 111
// Say ( Kurin , D10-Kur-1 ) ;
6901: LD_EXP 56
6905: PPUSH
6906: LD_STRING D10-Kur-1
6908: PPUSH
6909: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6913: LD_INT 35
6915: PPUSH
6916: CALL_OW 67
// ComMoveXY ( firstVeh , GetX ( Kurin ) , GetY ( Kurin ) ) ;
6920: LD_EXP 11
6924: PPUSH
6925: LD_EXP 56
6929: PPUSH
6930: CALL_OW 250
6934: PPUSH
6935: LD_EXP 56
6939: PPUSH
6940: CALL_OW 251
6944: PPUSH
6945: CALL_OW 111
// until GetDistUnits ( firstVeh , Kurin ) < 6 ;
6949: LD_EXP 11
6953: PPUSH
6954: LD_EXP 56
6958: PPUSH
6959: CALL_OW 296
6963: PUSH
6964: LD_INT 6
6966: LESS
6967: IFFALSE 6913
// ComExitVehicle ( UnitsInside ( firstVeh ) ) ;
6969: LD_EXP 11
6973: PPUSH
6974: CALL_OW 313
6978: PPUSH
6979: CALL_OW 121
// wait ( 0 0$1 ) ;
6983: LD_INT 35
6985: PPUSH
6986: CALL_OW 67
// if GetLives ( firstVeh ) < 1000 then
6990: LD_EXP 11
6994: PPUSH
6995: CALL_OW 256
6999: PUSH
7000: LD_INT 1000
7002: LESS
7003: IFFALSE 7035
// begin ComExitBuilding ( mech ) ;
7005: LD_VAR 0 3
7009: PPUSH
7010: CALL_OW 122
// wait ( 0 0$1 ) ;
7014: LD_INT 35
7016: PPUSH
7017: CALL_OW 67
// AddComRepairVehicle ( mech , firstVeh ) ;
7021: LD_VAR 0 3
7025: PPUSH
7026: LD_EXP 11
7030: PPUSH
7031: CALL_OW 189
// end ; if GetFuel ( firstVeh ) < 90 then
7035: LD_EXP 11
7039: PPUSH
7040: CALL_OW 261
7044: PUSH
7045: LD_INT 90
7047: LESS
7048: IFFALSE 7083
// begin ComExitBuilding ( eng ) ;
7050: LD_VAR 0 2
7054: PPUSH
7055: CALL_OW 122
// wait ( 0 0$1 ) ;
7059: LD_INT 35
7061: PPUSH
7062: CALL_OW 67
// ExtAddComRefuel ( eng , kirov , firstVeh ) ;
7066: LD_VAR 0 2
7070: PPUSH
7071: LD_INT 71
7073: PPUSH
7074: LD_EXP 11
7078: PPUSH
7079: CALL 3924 0 3
// end ; repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until GetLives ( firstVeh ) = 1000 and GetFuel ( firstVeh ) > 90 ;
7090: LD_EXP 11
7094: PPUSH
7095: CALL_OW 256
7099: PUSH
7100: LD_INT 1000
7102: EQUAL
7103: PUSH
7104: LD_EXP 11
7108: PPUSH
7109: CALL_OW 261
7113: PUSH
7114: LD_INT 90
7116: GREATER
7117: AND
7118: IFFALSE 7083
// ComEnterUnit ( eng , kirov ) ;
7120: LD_VAR 0 2
7124: PPUSH
7125: LD_INT 71
7127: PPUSH
7128: CALL_OW 120
// SetSide ( firstVeh , 6 ) ;
7132: LD_EXP 11
7136: PPUSH
7137: LD_INT 6
7139: PPUSH
7140: CALL_OW 235
// if belkovReturn then
7144: LD_EXP 4
7148: IFFALSE 7210
// begin if IsInUnit ( Belkov ) then
7150: LD_EXP 53
7154: PPUSH
7155: CALL_OW 310
7159: IFFALSE 7170
// ComExitBuilding ( Belkov ) ;
7161: LD_EXP 53
7165: PPUSH
7166: CALL_OW 122
// AddComEnterUnit ( Belkov , firstVeh ) ;
7170: LD_EXP 53
7174: PPUSH
7175: LD_EXP 11
7179: PPUSH
7180: CALL_OW 180
// Say ( Belkov , D10-Bel-1 ) ;
7184: LD_EXP 53
7188: PPUSH
7189: LD_STRING D10-Bel-1
7191: PPUSH
7192: CALL_OW 88
// Say ( Kurin , D10-Kur-2 ) ;
7196: LD_EXP 56
7200: PPUSH
7201: LD_STRING D10-Kur-2
7203: PPUSH
7204: CALL_OW 88
// end else
7208: GO 7304
// begin if IsInUnit ( Belkov2 ) then
7210: LD_EXP 57
7214: PPUSH
7215: CALL_OW 310
7219: IFFALSE 7230
// ComExitBuilding ( Belkov2 ) ;
7221: LD_EXP 57
7225: PPUSH
7226: CALL_OW 122
// AddComEnterUnit ( Belkov2 , firstVeh ) ;
7230: LD_EXP 57
7234: PPUSH
7235: LD_EXP 11
7239: PPUSH
7240: CALL_OW 180
// Say ( Belkov2 , D10-Bel-1 ) ;
7244: LD_EXP 57
7248: PPUSH
7249: LD_STRING D10-Bel-1
7251: PPUSH
7252: CALL_OW 88
// Say ( Burlak , D10-Bur-1 ) ;
7256: LD_EXP 51
7260: PPUSH
7261: LD_STRING D10-Bur-1
7263: PPUSH
7264: CALL_OW 88
// Say ( Belkov2 , D10-Bel-2 ) ;
7268: LD_EXP 57
7272: PPUSH
7273: LD_STRING D10-Bel-2
7275: PPUSH
7276: CALL_OW 88
// Say ( Burlak , D10-Bur-2 ) ;
7280: LD_EXP 51
7284: PPUSH
7285: LD_STRING D10-Bur-2
7287: PPUSH
7288: CALL_OW 88
// Say ( Kurin , D10-Kur-2a ) ;
7292: LD_EXP 56
7296: PPUSH
7297: LD_STRING D10-Kur-2a
7299: PPUSH
7300: CALL_OW 88
// end ; removedBelkovUntisSaved = [ ] ;
7304: LD_ADDR_EXP 63
7308: PUSH
7309: EMPTY
7310: ST_TO_ADDR
// removedBelkovVehicleSaved = [ ] ;
7311: LD_ADDR_EXP 64
7315: PUSH
7316: EMPTY
7317: ST_TO_ADDR
// canRemoveBelkovUnits = true ;
7318: LD_ADDR_EXP 19
7322: PUSH
7323: LD_INT 1
7325: ST_TO_ADDR
// CreateBelkovTeam ;
7326: CALL 4511 0 0
// ComExitBuilding ( belkovTeam ) ;
7330: LD_EXP 62
7334: PPUSH
7335: CALL_OW 122
// wait ( 0 0$1 ) ;
7339: LD_INT 35
7341: PPUSH
7342: CALL_OW 67
// kirovVehicle = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
7346: LD_ADDR_EXP 61
7350: PUSH
7351: LD_INT 22
7353: PUSH
7354: LD_INT 6
7356: PUSH
7357: EMPTY
7358: LIST
7359: LIST
7360: PUSH
7361: LD_INT 21
7363: PUSH
7364: LD_INT 2
7366: PUSH
7367: EMPTY
7368: LIST
7369: LIST
7370: PUSH
7371: EMPTY
7372: LIST
7373: LIST
7374: PPUSH
7375: CALL_OW 69
7379: PUSH
7380: LD_INT 1
7382: ARRAY
7383: ST_TO_ADDR
// belkovTeam = belkovTeam ^ kirovVehicle ;
7384: LD_ADDR_EXP 62
7388: PUSH
7389: LD_EXP 62
7393: PUSH
7394: LD_EXP 61
7398: ADD
7399: ST_TO_ADDR
// ComMoveXY ( belkovTeam , 147 , 102 ) ;
7400: LD_EXP 62
7404: PPUSH
7405: LD_INT 147
7407: PPUSH
7408: LD_INT 102
7410: PPUSH
7411: CALL_OW 111
// AddComMoveXY ( belkovTeam , 133 , 94 ) ;
7415: LD_EXP 62
7419: PPUSH
7420: LD_INT 133
7422: PPUSH
7423: LD_INT 94
7425: PPUSH
7426: CALL_OW 171
// AddComMoveXY ( belkovTeam , 123 , 74 ) ;
7430: LD_EXP 62
7434: PPUSH
7435: LD_INT 123
7437: PPUSH
7438: LD_INT 74
7440: PPUSH
7441: CALL_OW 171
// AddComMoveXY ( belkovTeam , 111 , 48 ) ;
7445: LD_EXP 62
7449: PPUSH
7450: LD_INT 111
7452: PPUSH
7453: LD_INT 48
7455: PPUSH
7456: CALL_OW 171
// AddComMoveXY ( belkovTeam , 122 , 43 ) ;
7460: LD_EXP 62
7464: PPUSH
7465: LD_INT 122
7467: PPUSH
7468: LD_INT 43
7470: PPUSH
7471: CALL_OW 171
// AddComMoveXY ( belkovTeam , 129 , 32 ) ;
7475: LD_EXP 62
7479: PPUSH
7480: LD_INT 129
7482: PPUSH
7483: LD_INT 32
7485: PPUSH
7486: CALL_OW 171
// AddComMoveXY ( belkovTeam , 132 , 22 ) ;
7490: LD_EXP 62
7494: PPUSH
7495: LD_INT 132
7497: PPUSH
7498: LD_INT 22
7500: PPUSH
7501: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7505: LD_INT 35
7507: PPUSH
7508: CALL_OW 67
// CenterNowOnUnits ( kirovVehicle ) ;
7512: LD_EXP 61
7516: PPUSH
7517: CALL_OW 87
// until GetDistUnitArea ( kirovVehicle , belkovExitArea ) < 7 ;
7521: LD_EXP 61
7525: PPUSH
7526: LD_INT 10
7528: PPUSH
7529: CALL_OW 299
7533: PUSH
7534: LD_INT 7
7536: LESS
7537: IFFALSE 7505
// CenterNowOnUnits ( Kurin ) ;
7539: LD_EXP 56
7543: PPUSH
7544: CALL_OW 87
// Say ( Kurin , D10-Kur-2b ) ;
7548: LD_EXP 56
7552: PPUSH
7553: LD_STRING D10-Kur-2b
7555: PPUSH
7556: CALL_OW 88
// InGameOff ;
7560: CALL_OW 9
// ChangeMissionObjectives ( M4 ) ;
7564: LD_STRING M4
7566: PPUSH
7567: CALL_OW 337
// backToBeria1 = true ;
7571: LD_ADDR_EXP 13
7575: PUSH
7576: LD_INT 1
7578: ST_TO_ADDR
// end ;
7579: PPOPN 3
7581: END
// every 0 0$1 trigger canRemoveBelkovUnits do var unit , driver ;
7582: LD_EXP 19
7586: IFFALSE 7927
7588: GO 7590
7590: DISABLE
7591: LD_INT 0
7593: PPUSH
7594: PPUSH
// begin enable ;
7595: ENABLE
// if FilterUnitsInArea ( BelkovExitArea , [ f_side , 6 ] ) = 0 then
7596: LD_INT 10
7598: PPUSH
7599: LD_INT 22
7601: PUSH
7602: LD_INT 6
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PPUSH
7609: CALL_OW 70
7613: PUSH
7614: LD_INT 0
7616: EQUAL
7617: IFFALSE 7621
// exit ;
7619: GO 7927
// for unit in FilterUnitsInArea ( BelkovExitArea , [ f_side , 6 ] ) do
7621: LD_ADDR_VAR 0 1
7625: PUSH
7626: LD_INT 10
7628: PPUSH
7629: LD_INT 22
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: CALL_OW 70
7643: PUSH
7644: FOR_IN
7645: IFFALSE 7913
// begin if GetType ( unit ) = unit_human and ( not unit = Belkov and not unit = Belkov2 ) then
7647: LD_VAR 0 1
7651: PPUSH
7652: CALL_OW 247
7656: PUSH
7657: LD_INT 1
7659: EQUAL
7660: PUSH
7661: LD_VAR 0 1
7665: PUSH
7666: LD_EXP 53
7670: EQUAL
7671: NOT
7672: PUSH
7673: LD_VAR 0 1
7677: PUSH
7678: LD_EXP 57
7682: EQUAL
7683: NOT
7684: AND
7685: AND
7686: IFFALSE 7727
// begin removedBelkovUntis = removedBelkovUntis + 1 ;
7688: LD_ADDR_EXP 20
7692: PUSH
7693: LD_EXP 20
7697: PUSH
7698: LD_INT 1
7700: PLUS
7701: ST_TO_ADDR
// removedBelkovUntisSaved = removedBelkovUntisSaved ^ unit ;
7702: LD_ADDR_EXP 63
7706: PUSH
7707: LD_EXP 63
7711: PUSH
7712: LD_VAR 0 1
7716: ADD
7717: ST_TO_ADDR
// RemoveUnit ( unit ) ;
7718: LD_VAR 0 1
7722: PPUSH
7723: CALL_OW 64
// end ; if GetType ( unit ) = unit_vehicle then
7727: LD_VAR 0 1
7731: PPUSH
7732: CALL_OW 247
7736: PUSH
7737: LD_INT 2
7739: EQUAL
7740: IFFALSE 7911
// begin driver = UnitsInside ( unit ) ;
7742: LD_ADDR_VAR 0 2
7746: PUSH
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 313
7756: ST_TO_ADDR
// Display_strings = [ driver , driver ] ;
7757: LD_ADDR_OWVAR 47
7761: PUSH
7762: LD_STRING driver
7764: PUSH
7765: LD_VAR 0 2
7769: PUSH
7770: EMPTY
7771: LIST
7772: LIST
7773: ST_TO_ADDR
// if driver [ 1 ] = Belkov then
7774: LD_VAR 0 2
7778: PUSH
7779: LD_INT 1
7781: ARRAY
7782: PUSH
7783: LD_EXP 53
7787: EQUAL
7788: IFFALSE 7813
// begin SaveCharacters ( Belkov , 02_TmpBelkov ) ;
7790: LD_EXP 53
7794: PPUSH
7795: LD_STRING 02_TmpBelkov
7797: PPUSH
7798: CALL_OW 38
// RemoveUnit ( unit ) ;
7802: LD_VAR 0 1
7806: PPUSH
7807: CALL_OW 64
// end else
7811: GO 7834
// begin SaveCharacters ( Belkov2 , 02_TmpBelkov2 ) ;
7813: LD_EXP 57
7817: PPUSH
7818: LD_STRING 02_TmpBelkov2
7820: PPUSH
7821: CALL_OW 38
// RemoveUnit ( unit ) ;
7825: LD_VAR 0 1
7829: PPUSH
7830: CALL_OW 64
// end ; removedBelkovVehicleSaved = removedBelkovVehicleSaved ^ [ GetChassis ( unit ) , GetEngine ( unit ) , GetControl ( unit ) , GetWeapon ( unit ) , GetFuel ( unit ) ] ;
7834: LD_ADDR_EXP 64
7838: PUSH
7839: LD_EXP 64
7843: PUSH
7844: LD_VAR 0 1
7848: PPUSH
7849: CALL_OW 265
7853: PUSH
7854: LD_VAR 0 1
7858: PPUSH
7859: CALL_OW 262
7863: PUSH
7864: LD_VAR 0 1
7868: PPUSH
7869: CALL_OW 263
7873: PUSH
7874: LD_VAR 0 1
7878: PPUSH
7879: CALL_OW 264
7883: PUSH
7884: LD_VAR 0 1
7888: PPUSH
7889: CALL_OW 261
7893: PUSH
7894: EMPTY
7895: LIST
7896: LIST
7897: LIST
7898: LIST
7899: LIST
7900: ADD
7901: ST_TO_ADDR
// RemoveUnit ( unit ) ;
7902: LD_VAR 0 1
7906: PPUSH
7907: CALL_OW 64
// end ; end ;
7911: GO 7644
7913: POP
7914: POP
// SaveCharacters ( removedBelkovUntisSaved , 02_TmpBelkovTeam ) ;
7915: LD_EXP 63
7919: PPUSH
7920: LD_STRING 02_TmpBelkovTeam
7922: PPUSH
7923: CALL_OW 38
// end ;
7927: PPOPN 2
7929: END
// every 0 0$1 trigger FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and backToBeria1 do
7930: LD_INT 8
7932: PPUSH
7933: LD_INT 22
7935: PUSH
7936: LD_INT 3
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: PUSH
7943: LD_INT 21
7945: PUSH
7946: LD_INT 1
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PUSH
7953: EMPTY
7954: LIST
7955: LIST
7956: PPUSH
7957: CALL_OW 71
7961: PUSH
7962: LD_INT 0
7964: EQUAL
7965: PUSH
7966: LD_EXP 13
7970: AND
7971: IFFALSE 8079
7973: GO 7975
7975: DISABLE
// begin backToBeria1 = false ;
7976: LD_ADDR_EXP 13
7980: PUSH
7981: LD_INT 0
7983: ST_TO_ADDR
// Say ( Platonov , D11-Pla-1 ) ;
7984: LD_EXP 65
7988: PPUSH
7989: LD_STRING D11-Pla-1
7991: PPUSH
7992: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 1 then
7996: LD_INT 22
7998: PUSH
7999: LD_INT 3
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PUSH
8006: LD_INT 21
8008: PUSH
8009: LD_INT 1
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: PPUSH
8020: CALL_OW 69
8024: PUSH
8025: LD_INT 1
8027: GREATER
8028: IFFALSE 8044
// Say ( Burlak , D11-Bur-1a ) else
8030: LD_EXP 51
8034: PPUSH
8035: LD_STRING D11-Bur-1a
8037: PPUSH
8038: CALL_OW 88
8042: GO 8056
// Say ( Burlak , D11-Bur-1 ) ;
8044: LD_EXP 51
8048: PPUSH
8049: LD_STRING D11-Bur-1
8051: PPUSH
8052: CALL_OW 88
// ChangeMissionObjectives ( M5 ) ;
8056: LD_STRING M5
8058: PPUSH
8059: CALL_OW 337
// construcMoreVehicles = true ;
8063: LD_ADDR_EXP 15
8067: PUSH
8068: LD_INT 1
8070: ST_TO_ADDR
// spawnCrates = true ;
8071: LD_ADDR_EXP 18
8075: PUSH
8076: LD_INT 1
8078: ST_TO_ADDR
// end ;
8079: END
// every 0 0$1 trigger constructedVehiclesCounter >= FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do var tmpBelkov , nearRuUnit ;
8080: LD_EXP 16
8084: PUSH
8085: LD_INT 22
8087: PUSH
8088: LD_INT 3
8090: PUSH
8091: EMPTY
8092: LIST
8093: LIST
8094: PUSH
8095: LD_INT 21
8097: PUSH
8098: LD_INT 1
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PPUSH
8109: CALL_OW 69
8113: GREATEREQUAL
8114: IFFALSE 8945
8116: GO 8118
8118: DISABLE
8119: LD_INT 0
8121: PPUSH
8122: PPUSH
// begin canRemoveBelkovUnits = false ;
8123: LD_ADDR_EXP 19
8127: PUSH
8128: LD_INT 0
8130: ST_TO_ADDR
// ComStop ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ) ;
8131: LD_INT 22
8133: PUSH
8134: LD_INT 3
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: PUSH
8141: LD_INT 2
8143: PUSH
8144: LD_INT 21
8146: PUSH
8147: LD_INT 1
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PUSH
8154: LD_INT 21
8156: PUSH
8157: LD_INT 2
8159: PUSH
8160: EMPTY
8161: LIST
8162: LIST
8163: PUSH
8164: EMPTY
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PPUSH
8173: CALL_OW 69
8177: PPUSH
8178: CALL_OW 141
// InGameOn ;
8182: CALL_OW 8
// CenterOnUnits ( Platonov ) ;
8186: LD_EXP 65
8190: PPUSH
8191: CALL_OW 85
// DialogueOn ;
8195: CALL_OW 6
// Say ( Burlak , D12-Bur-1 ) ;
8199: LD_EXP 51
8203: PPUSH
8204: LD_STRING D12-Bur-1
8206: PPUSH
8207: CALL_OW 88
// Say ( Platonov , D12-Pla-1 ) ;
8211: LD_EXP 65
8215: PPUSH
8216: LD_STRING D12-Pla-1
8218: PPUSH
8219: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
8223: LD_EXP 51
8227: PPUSH
8228: LD_STRING D12-Bur-2
8230: PPUSH
8231: CALL_OW 88
// Say ( Platonov , D12-Pla-2 ) ;
8235: LD_EXP 65
8239: PPUSH
8240: LD_STRING D12-Pla-2
8242: PPUSH
8243: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
8247: LD_EXP 51
8251: PPUSH
8252: LD_STRING D12-Bur-3
8254: PPUSH
8255: CALL_OW 88
// Say ( Platonov , D12-Pla-3 ) ;
8259: LD_EXP 65
8263: PPUSH
8264: LD_STRING D12-Pla-3
8266: PPUSH
8267: CALL_OW 88
// DialogueOff ;
8271: CALL_OW 7
// SetAttitude ( 6 , 1 , att_friend , true ) ;
8275: LD_INT 6
8277: PPUSH
8278: LD_INT 1
8280: PPUSH
8281: LD_INT 1
8283: PPUSH
8284: LD_INT 1
8286: PPUSH
8287: CALL_OW 80
// PrepareAmerican ;
8291: CALL 2441 0 0
// PrepareBelkovReturnTeam ;
8295: CALL 912 0 0
// if IsOK ( Belkov ) then
8299: LD_EXP 53
8303: PPUSH
8304: CALL_OW 302
8308: IFFALSE 8322
// tmpBelkov = Belkov else
8310: LD_ADDR_VAR 0 1
8314: PUSH
8315: LD_EXP 53
8319: ST_TO_ADDR
8320: GO 8332
// tmpBelkov = Belkov2 ;
8322: LD_ADDR_VAR 0 1
8326: PUSH
8327: LD_EXP 57
8331: ST_TO_ADDR
// CenterNowOnUnits ( kirovVehicle ) ;
8332: LD_EXP 61
8336: PPUSH
8337: CALL_OW 87
// SayRadio ( trapCommander , D13-Sol1-1 ) ;
8341: LD_EXP 67
8345: PPUSH
8346: LD_STRING D13-Sol1-1
8348: PPUSH
8349: CALL_OW 94
// SayRadio ( tmpBelkov , D13-Bel-1 ) ;
8353: LD_VAR 0 1
8357: PPUSH
8358: LD_STRING D13-Bel-1
8360: PPUSH
8361: CALL_OW 94
// SayRadio ( Kurin , D13-Kur-1 ) ;
8365: LD_EXP 56
8369: PPUSH
8370: LD_STRING D13-Kur-1
8372: PPUSH
8373: CALL_OW 94
// SayRadio ( tmpBelkov , D13-Bel-2 ) ;
8377: LD_VAR 0 1
8381: PPUSH
8382: LD_STRING D13-Bel-2
8384: PPUSH
8385: CALL_OW 94
// ComMoveXY ( belkovTeam , 121 , 29 ) ;
8389: LD_EXP 62
8393: PPUSH
8394: LD_INT 121
8396: PPUSH
8397: LD_INT 29
8399: PPUSH
8400: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8404: LD_INT 35
8406: PPUSH
8407: CALL_OW 67
// CenterNowOnUnits ( kirovVehicle ) ;
8411: LD_EXP 61
8415: PPUSH
8416: CALL_OW 87
// nearRuUnit = NearestUnitToUnit ( UnitFilter ( belkovTeam , [ [ f_type , unit_human ] , [ f_outside ] ] ) , kirovVehicle ) ;
8420: LD_ADDR_VAR 0 2
8424: PUSH
8425: LD_EXP 62
8429: PPUSH
8430: LD_INT 21
8432: PUSH
8433: LD_INT 1
8435: PUSH
8436: EMPTY
8437: LIST
8438: LIST
8439: PUSH
8440: LD_INT 56
8442: PUSH
8443: EMPTY
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: PPUSH
8450: CALL_OW 72
8454: PPUSH
8455: LD_EXP 61
8459: PPUSH
8460: CALL_OW 74
8464: ST_TO_ADDR
// if GetDistUnits ( kirovVehicle , nearRuUnit ) < 5 then
8465: LD_EXP 61
8469: PPUSH
8470: LD_VAR 0 2
8474: PPUSH
8475: CALL_OW 296
8479: PUSH
8480: LD_INT 5
8482: LESS
8483: IFFALSE 8496
// ComStop ( kirovVehicle ) else
8485: LD_EXP 61
8489: PPUSH
8490: CALL_OW 141
8494: GO 8511
// ComMoveXY ( belkovTeam , 121 , 29 ) ;
8496: LD_EXP 62
8500: PPUSH
8501: LD_INT 121
8503: PPUSH
8504: LD_INT 29
8506: PPUSH
8507: CALL_OW 111
// until GetDistUnits ( NearestUnitToUnit ( belkovTeam , trapCommander ) , trapCommander ) < 7 ;
8511: LD_EXP 62
8515: PPUSH
8516: LD_EXP 67
8520: PPUSH
8521: CALL_OW 74
8525: PPUSH
8526: LD_EXP 67
8530: PPUSH
8531: CALL_OW 296
8535: PUSH
8536: LD_INT 7
8538: LESS
8539: IFFALSE 8404
// CenterNowOnUnits ( [ kirovVehicle , trapCommander ] ) ;
8541: LD_EXP 61
8545: PUSH
8546: LD_EXP 67
8550: PUSH
8551: EMPTY
8552: LIST
8553: LIST
8554: PPUSH
8555: CALL_OW 87
// ComWalk ( trapTeam ) ;
8559: LD_EXP 68
8563: PPUSH
8564: CALL_OW 138
// AddComTurnUnit ( trapTeam , kirovVehicle ) ;
8568: LD_EXP 68
8572: PPUSH
8573: LD_EXP 61
8577: PPUSH
8578: CALL_OW 179
// ComStop ( belkovTeam ) ;
8582: LD_EXP 62
8586: PPUSH
8587: CALL_OW 141
// AddComTurnUnit ( belkovTeam , trapCommander ) ;
8591: LD_EXP 62
8595: PPUSH
8596: LD_EXP 67
8600: PPUSH
8601: CALL_OW 179
// Say ( trapCommander , D14-Sol1-1 ) ;
8605: LD_EXP 67
8609: PPUSH
8610: LD_STRING D14-Sol1-1
8612: PPUSH
8613: CALL_OW 88
// SayRadio ( tmpBelkov , D14-Bel-1 ) ;
8617: LD_VAR 0 1
8621: PPUSH
8622: LD_STRING D14-Bel-1
8624: PPUSH
8625: CALL_OW 94
// immortalBelkovTeam = true ;
8629: LD_ADDR_EXP 21
8633: PUSH
8634: LD_INT 1
8636: ST_TO_ADDR
// ComExitVehicle ( tmpBelkov ) ;
8637: LD_VAR 0 1
8641: PPUSH
8642: CALL_OW 121
// wait ( 0 0$1 ) ;
8646: LD_INT 35
8648: PPUSH
8649: CALL_OW 67
// ComEnterUnit ( trapCommander , kirovVehicle ) ;
8653: LD_EXP 67
8657: PPUSH
8658: LD_EXP 61
8662: PPUSH
8663: CALL_OW 120
// AddComHold ( trapTeam ) ;
8667: LD_EXP 68
8671: PPUSH
8672: CALL_OW 200
// SetAttitude ( 6 , 1 , att_enemy , true ) ;
8676: LD_INT 6
8678: PPUSH
8679: LD_INT 1
8681: PPUSH
8682: LD_INT 2
8684: PPUSH
8685: LD_INT 1
8687: PPUSH
8688: CALL_OW 80
// ComMoveToArea ( belkovTeam , BelkovRetreatArea ) ;
8692: LD_EXP 62
8696: PPUSH
8697: LD_INT 15
8699: PPUSH
8700: CALL_OW 113
// repeat wait ( 0 0$1 ) ;
8704: LD_INT 35
8706: PPUSH
8707: CALL_OW 67
// CenterNowOnUnits ( tmpBelkov ) ;
8711: LD_VAR 0 1
8715: PPUSH
8716: CALL_OW 87
// until IsInArea ( tmpBelkov , BelkovRetreatArea ) ;
8720: LD_VAR 0 1
8724: PPUSH
8725: LD_INT 15
8727: PPUSH
8728: CALL_OW 308
8732: IFFALSE 8704
// SayRadio ( tmpBelkov , D14-Bel-1a ) ;
8734: LD_VAR 0 1
8738: PPUSH
8739: LD_STRING D14-Bel-1a
8741: PPUSH
8742: CALL_OW 94
// SayRadio ( Kurin , D14-Kur-1 ) ;
8746: LD_EXP 56
8750: PPUSH
8751: LD_STRING D14-Kur-1
8753: PPUSH
8754: CALL_OW 94
// SayRadio ( tmpBelkov , D14-Bel-2 ) ;
8758: LD_VAR 0 1
8762: PPUSH
8763: LD_STRING D14-Bel-2
8765: PPUSH
8766: CALL_OW 94
// SayRadio ( Kurin , D14-Kur-2 ) ;
8770: LD_EXP 56
8774: PPUSH
8775: LD_STRING D14-Kur-2
8777: PPUSH
8778: CALL_OW 94
// CenterOnUnits ( Platonov ) ;
8782: LD_EXP 65
8786: PPUSH
8787: CALL_OW 85
// wait ( 0 0$2 ) ;
8791: LD_INT 70
8793: PPUSH
8794: CALL_OW 67
// Say ( Burlak , D14a-Bur-1 ) ;
8798: LD_EXP 51
8802: PPUSH
8803: LD_STRING D14a-Bur-1
8805: PPUSH
8806: CALL_OW 88
// Say ( Platonov , D14a-Pla-1 ) ;
8810: LD_EXP 65
8814: PPUSH
8815: LD_STRING D14a-Pla-1
8817: PPUSH
8818: CALL_OW 88
// Say ( Burlak , D14a-Bur-2 ) ;
8822: LD_EXP 51
8826: PPUSH
8827: LD_STRING D14a-Bur-2
8829: PPUSH
8830: CALL_OW 88
// Say ( Platonov , D14a-Pla-2 ) ;
8834: LD_EXP 65
8838: PPUSH
8839: LD_STRING D14a-Pla-2
8841: PPUSH
8842: CALL_OW 88
// Say ( Burlak , D14a-Bur-3 ) ;
8846: LD_EXP 51
8850: PPUSH
8851: LD_STRING D14a-Bur-3
8853: PPUSH
8854: CALL_OW 88
// Say ( Platonov , D14a-Pla-3 ) ;
8858: LD_EXP 65
8862: PPUSH
8863: LD_STRING D14a-Pla-3
8865: PPUSH
8866: CALL_OW 88
// Say ( Burlak , D14a-Bur-4 ) ;
8870: LD_EXP 51
8874: PPUSH
8875: LD_STRING D14a-Bur-4
8877: PPUSH
8878: CALL_OW 88
// Say ( Platonov , D14a-Pla-4 ) ;
8882: LD_EXP 65
8886: PPUSH
8887: LD_STRING D14a-Pla-4
8889: PPUSH
8890: CALL_OW 88
// InGameOff ;
8894: CALL_OW 9
// immortalBelkovTeam = false ;
8898: LD_ADDR_EXP 21
8902: PUSH
8903: LD_INT 0
8905: ST_TO_ADDR
// activateAMAI = true ;
8906: LD_ADDR_EXP 23
8910: PUSH
8911: LD_INT 1
8913: ST_TO_ADDR
// canExitBase = true ;
8914: LD_ADDR_EXP 17
8918: PUSH
8919: LD_INT 1
8921: ST_TO_ADDR
// construcMoreVehicles = false ;
8922: LD_ADDR_EXP 15
8926: PUSH
8927: LD_INT 0
8929: ST_TO_ADDR
// spawnCrates = false ;
8930: LD_ADDR_EXP 18
8934: PUSH
8935: LD_INT 0
8937: ST_TO_ADDR
// ChangeMissionObjectives ( M6 ) ;
8938: LD_STRING M6
8940: PPUSH
8941: CALL_OW 337
// end ;
8945: PPOPN 2
8947: END
// every 0 0$1 trigger immortalBelkovTeam do
8948: LD_EXP 21
8952: IFFALSE 8970
8954: GO 8956
8956: DISABLE
// begin enable ;
8957: ENABLE
// SetLives ( belkovTeam , 1000 ) ;
8958: LD_EXP 62
8962: PPUSH
8963: LD_INT 1000
8965: PPUSH
8966: CALL_OW 234
// end ;
8970: END
// every 0 0$1 trigger canExitBase and not belkovSaved and belkovAttackTime > 0 0$00 do
8971: LD_EXP 17
8975: PUSH
8976: LD_EXP 31
8980: NOT
8981: AND
8982: PUSH
8983: LD_EXP 50
8987: PUSH
8988: LD_INT 0
8990: GREATER
8991: AND
8992: IFFALSE 9011
8994: GO 8996
8996: DISABLE
// belkovAttackTime = belkovAttackTime - 0 0$01 ;
8997: LD_ADDR_EXP 50
9001: PUSH
9002: LD_EXP 50
9006: PUSH
9007: LD_INT 35
9009: MINUS
9010: ST_TO_ADDR
9011: END
// every 0 0$1 trigger belkovAttackTime < 0 0$01 and trapTeam do
9012: LD_EXP 50
9016: PUSH
9017: LD_INT 35
9019: LESS
9020: PUSH
9021: LD_EXP 68
9025: AND
9026: IFFALSE 9060
9028: GO 9030
9030: DISABLE
// begin enable ;
9031: ENABLE
// ComAttackUnit ( belkovTeam , NearestUnitToUnit ( trapTeam , belkovTeam [ 1 ] ) ) ;
9032: LD_EXP 62
9036: PPUSH
9037: LD_EXP 68
9041: PPUSH
9042: LD_EXP 62
9046: PUSH
9047: LD_INT 1
9049: ARRAY
9050: PPUSH
9051: CALL_OW 74
9055: PPUSH
9056: CALL_OW 115
// end ;
9060: END
// every 0 0$1 trigger not sawLeftBunker or not sawRightBunker do var bunker ;
9061: LD_EXP 24
9065: NOT
9066: PUSH
9067: LD_EXP 25
9071: NOT
9072: OR
9073: IFFALSE 9450
9075: GO 9077
9077: DISABLE
9078: LD_INT 0
9080: PPUSH
// begin enable ;
9081: ENABLE
// for bunker in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] ] ) do
9082: LD_ADDR_VAR 0 1
9086: PUSH
9087: LD_INT 22
9089: PUSH
9090: LD_INT 1
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: PUSH
9097: LD_INT 21
9099: PUSH
9100: LD_INT 3
9102: PUSH
9103: EMPTY
9104: LIST
9105: LIST
9106: PUSH
9107: LD_INT 30
9109: PUSH
9110: LD_INT 31
9112: PUSH
9113: EMPTY
9114: LIST
9115: LIST
9116: PUSH
9117: EMPTY
9118: LIST
9119: LIST
9120: LIST
9121: PPUSH
9122: CALL_OW 69
9126: PUSH
9127: FOR_IN
9128: IFFALSE 9448
// begin if See ( 3 , bunker ) then
9130: LD_INT 3
9132: PPUSH
9133: LD_VAR 0 1
9137: PPUSH
9138: CALL_OW 292
9142: IFFALSE 9446
// begin if bunker in leftBunkers and not sawLeftBunker then
9144: LD_VAR 0 1
9148: PUSH
9149: LD_EXP 69
9153: IN
9154: PUSH
9155: LD_EXP 24
9159: NOT
9160: AND
9161: IFFALSE 9312
// begin sawLeftBunker = true ;
9163: LD_ADDR_EXP 24
9167: PUSH
9168: LD_INT 1
9170: ST_TO_ADDR
// CenterOnUnits ( bunker ) ;
9171: LD_VAR 0 1
9175: PPUSH
9176: CALL_OW 85
// DialogueOn ;
9180: CALL_OW 6
// Say ( Burlak , D15-Bur-1 ) ;
9184: LD_EXP 51
9188: PPUSH
9189: LD_STRING D15-Bur-1
9191: PPUSH
9192: CALL_OW 88
// if IsOK ( Gnyevko ) then
9196: LD_EXP 52
9200: PPUSH
9201: CALL_OW 302
9205: IFFALSE 9219
// Say ( Gnyevko , D15-Gny-1 ) ;
9207: LD_EXP 52
9211: PPUSH
9212: LD_STRING D15-Gny-1
9214: PPUSH
9215: CALL_OW 88
// if IsOK ( Kovalyuk ) then
9219: LD_EXP 59
9223: PPUSH
9224: CALL_OW 302
9228: IFFALSE 9242
// Say ( Kovalyuk , D15-Kov-1 ) ;
9230: LD_EXP 59
9234: PPUSH
9235: LD_STRING D15-Kov-1
9237: PPUSH
9238: CALL_OW 88
// Say ( Burlak , D15-Bur-2 ) ;
9242: LD_EXP 51
9246: PPUSH
9247: LD_STRING D15-Bur-2
9249: PPUSH
9250: CALL_OW 88
// if IsOK ( Kovalyuk ) then
9254: LD_EXP 59
9258: PPUSH
9259: CALL_OW 302
9263: IFFALSE 9277
// Say ( Kovalyuk , D15-Kov-2 ) ;
9265: LD_EXP 59
9269: PPUSH
9270: LD_STRING D15-Kov-2
9272: PPUSH
9273: CALL_OW 88
// Say ( Burlak , D15-Bur-3 ) ;
9277: LD_EXP 51
9281: PPUSH
9282: LD_STRING D15-Bur-3
9284: PPUSH
9285: CALL_OW 88
// DialogueOff ;
9289: CALL_OW 7
// raportForPlatonov = 3 ;
9293: LD_ADDR_EXP 32
9297: PUSH
9298: LD_INT 3
9300: ST_TO_ADDR
// ChangeMissionObjectives ( M7 ) ;
9301: LD_STRING M7
9303: PPUSH
9304: CALL_OW 337
// exit ;
9308: POP
9309: POP
9310: GO 9450
// end ; if bunker in rightBunkers and not sawRightBunker then
9312: LD_VAR 0 1
9316: PUSH
9317: LD_EXP 70
9321: IN
9322: PUSH
9323: LD_EXP 25
9327: NOT
9328: AND
9329: IFFALSE 9446
// begin sawRightBunker = true ;
9331: LD_ADDR_EXP 25
9335: PUSH
9336: LD_INT 1
9338: ST_TO_ADDR
// CenterOnUnits ( bunker ) ;
9339: LD_VAR 0 1
9343: PPUSH
9344: CALL_OW 85
// DialogueOn ;
9348: CALL_OW 6
// if IsOK ( Kovalyuk ) then
9352: LD_EXP 59
9356: PPUSH
9357: CALL_OW 302
9361: IFFALSE 9395
// begin if sawLeftBunker then
9363: LD_EXP 24
9367: IFFALSE 9383
// Say ( Kovalyuk , D15-Kov-2a ) else
9369: LD_EXP 59
9373: PPUSH
9374: LD_STRING D15-Kov-2a
9376: PPUSH
9377: CALL_OW 88
9381: GO 9395
// Say ( Kovalyuk , D15-Kov-2 ) ;
9383: LD_EXP 59
9387: PPUSH
9388: LD_STRING D15-Kov-2
9390: PPUSH
9391: CALL_OW 88
// end ; Say ( Burlak , D16-Bur-1 ) ;
9395: LD_EXP 51
9399: PPUSH
9400: LD_STRING D16-Bur-1
9402: PPUSH
9403: CALL_OW 88
// if IsOK ( Gnyevko ) then
9407: LD_EXP 52
9411: PPUSH
9412: CALL_OW 302
9416: IFFALSE 9430
// Say ( Gnyevko , D16-Gny-1 ) ;
9418: LD_EXP 52
9422: PPUSH
9423: LD_STRING D16-Gny-1
9425: PPUSH
9426: CALL_OW 88
// DialogueOff ;
9430: CALL_OW 7
// raportForPlatonov = 2 ;
9434: LD_ADDR_EXP 32
9438: PUSH
9439: LD_INT 2
9441: ST_TO_ADDR
// exit ;
9442: POP
9443: POP
9444: GO 9450
// end ; end ; end ;
9446: GO 9127
9448: POP
9449: POP
// end ;
9450: PPOPN 1
9452: END
// every 0 0$2 trigger not dialogAttackRightBunkers and rightBunkers and ( IsOK ( Kovalyuk ) or IsOK ( Gnyevko ) ) do var unit ;
9453: LD_EXP 27
9457: NOT
9458: PUSH
9459: LD_EXP 70
9463: AND
9464: PUSH
9465: LD_EXP 59
9469: PPUSH
9470: CALL_OW 302
9474: PUSH
9475: LD_EXP 52
9479: PPUSH
9480: CALL_OW 302
9484: OR
9485: AND
9486: IFFALSE 9674
9488: GO 9490
9490: DISABLE
9491: LD_INT 0
9493: PPUSH
// begin enable ;
9494: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
9495: LD_ADDR_VAR 0 1
9499: PUSH
9500: LD_INT 22
9502: PUSH
9503: LD_INT 3
9505: PUSH
9506: EMPTY
9507: LIST
9508: LIST
9509: PUSH
9510: LD_INT 2
9512: PUSH
9513: LD_INT 21
9515: PUSH
9516: LD_INT 1
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: PUSH
9523: LD_INT 21
9525: PUSH
9526: LD_INT 2
9528: PUSH
9529: EMPTY
9530: LIST
9531: LIST
9532: PUSH
9533: EMPTY
9534: LIST
9535: LIST
9536: LIST
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: PPUSH
9542: CALL_OW 69
9546: PUSH
9547: FOR_IN
9548: IFFALSE 9672
// begin if Attacks ( unit ) = rightBunkers [ 1 ] or Attacks ( unit ) = rightBunkers [ 2 ] then
9550: LD_VAR 0 1
9554: PPUSH
9555: CALL_OW 320
9559: PUSH
9560: LD_EXP 70
9564: PUSH
9565: LD_INT 1
9567: ARRAY
9568: EQUAL
9569: PUSH
9570: LD_VAR 0 1
9574: PPUSH
9575: CALL_OW 320
9579: PUSH
9580: LD_EXP 70
9584: PUSH
9585: LD_INT 2
9587: ARRAY
9588: EQUAL
9589: OR
9590: IFFALSE 9670
// begin dialogAttackRightBunkers = true ;
9592: LD_ADDR_EXP 27
9596: PUSH
9597: LD_INT 1
9599: ST_TO_ADDR
// DialogueOn ;
9600: CALL_OW 6
// if IsOK ( Gnyevko ) then
9604: LD_EXP 52
9608: PPUSH
9609: CALL_OW 302
9613: IFFALSE 9627
// Say ( Gnyevko , D16A-Gny-1 ) ;
9615: LD_EXP 52
9619: PPUSH
9620: LD_STRING D16A-Gny-1
9622: PPUSH
9623: CALL_OW 88
// if IsOK ( Kovalyuk ) then
9627: LD_EXP 59
9631: PPUSH
9632: CALL_OW 302
9636: IFFALSE 9650
// Say ( Kovalyuk , D16A-Kov-1 ) ;
9638: LD_EXP 59
9642: PPUSH
9643: LD_STRING D16A-Kov-1
9645: PPUSH
9646: CALL_OW 88
// Say ( Burlak , D16A-Bur-1 ) ;
9650: LD_EXP 51
9654: PPUSH
9655: LD_STRING D16A-Bur-1
9657: PPUSH
9658: CALL_OW 88
// DialogueOff ;
9662: CALL_OW 7
// exit ;
9666: POP
9667: POP
9668: GO 9674
// end ; end ;
9670: GO 9547
9672: POP
9673: POP
// end ;
9674: PPOPN 1
9676: END
// every 0 0$3 trigger FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) do var decsToChoose ;
9677: LD_INT 18
9679: PPUSH
9680: LD_INT 22
9682: PUSH
9683: LD_INT 3
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: PUSH
9690: EMPTY
9691: LIST
9692: PPUSH
9693: CALL_OW 70
9697: IFFALSE 10048
9699: GO 9701
9701: DISABLE
9702: LD_INT 0
9704: PPUSH
// begin if playerGetSupport then
9705: LD_EXP 28
9709: IFFALSE 9728
// decsToChoose = [ 1 , 3 ] else
9711: LD_ADDR_VAR 0 1
9715: PUSH
9716: LD_INT 1
9718: PUSH
9719: LD_INT 3
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: ST_TO_ADDR
9726: GO 9747
// decsToChoose = [ 1 , 2 , 3 ] ;
9728: LD_ADDR_VAR 0 1
9732: PUSH
9733: LD_INT 1
9735: PUSH
9736: LD_INT 2
9738: PUSH
9739: LD_INT 3
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: LIST
9746: ST_TO_ADDR
// case SelectiveQuery ( QAttackBw , decsToChoose ) of 1 :
9747: LD_STRING QAttackBw
9749: PPUSH
9750: LD_VAR 0 1
9754: PPUSH
9755: CALL_OW 98
9759: PUSH
9760: LD_INT 1
9762: DOUBLE
9763: EQUAL
9764: IFTRUE 9768
9766: GO 9853
9768: POP
// begin DialogueOn ;
9769: CALL_OW 6
// Say ( Burlak , D17-Bur-1 ) ;
9773: LD_EXP 51
9777: PPUSH
9778: LD_STRING D17-Bur-1
9780: PPUSH
9781: CALL_OW 88
// SayRadio ( Platonov , D17-Pla-1 ) ;
9785: LD_EXP 65
9789: PPUSH
9790: LD_STRING D17-Pla-1
9792: PPUSH
9793: CALL_OW 94
// Say ( Burlak , D17-Bur-2 ) ;
9797: LD_EXP 51
9801: PPUSH
9802: LD_STRING D17-Bur-2
9804: PPUSH
9805: CALL_OW 88
// SayRadio ( Platonov , D17-Pla-2 ) ;
9809: LD_EXP 65
9813: PPUSH
9814: LD_STRING D17-Pla-2
9816: PPUSH
9817: CALL_OW 94
// DialogueOff ;
9821: CALL_OW 7
// if not ( initiative in [ 2 , 3 ] ) then
9825: LD_EXP 35
9829: PUSH
9830: LD_INT 2
9832: PUSH
9833: LD_INT 3
9835: PUSH
9836: EMPTY
9837: LIST
9838: LIST
9839: IN
9840: NOT
9841: IFFALSE 9851
// initiative = 1 ;
9843: LD_ADDR_EXP 35
9847: PUSH
9848: LD_INT 1
9850: ST_TO_ADDR
// end ; 2 :
9851: GO 9978
9853: LD_INT 2
9855: DOUBLE
9856: EQUAL
9857: IFTRUE 9861
9859: GO 9958
9861: POP
// begin DialogueOn ;
9862: CALL_OW 6
// Say ( Burlak , D18-Bur-1 ) ;
9866: LD_EXP 51
9870: PPUSH
9871: LD_STRING D18-Bur-1
9873: PPUSH
9874: CALL_OW 88
// SayRadio ( Platonov , D18-Pla-1 ) ;
9878: LD_EXP 65
9882: PPUSH
9883: LD_STRING D18-Pla-1
9885: PPUSH
9886: CALL_OW 94
// Say ( Burlak , D18-Bur-2 ) ;
9890: LD_EXP 51
9894: PPUSH
9895: LD_STRING D18-Bur-2
9897: PPUSH
9898: CALL_OW 88
// SayRadio ( Platonov , D18-Pla-2 ) ;
9902: LD_EXP 65
9906: PPUSH
9907: LD_STRING D18-Pla-2
9909: PPUSH
9910: CALL_OW 94
// DialogueOff ;
9914: CALL_OW 7
// playerGetSupport = true ;
9918: LD_ADDR_EXP 28
9922: PUSH
9923: LD_INT 1
9925: ST_TO_ADDR
// medalForGetSupport = false ;
9926: LD_ADDR_EXP 33
9930: PUSH
9931: LD_INT 0
9933: ST_TO_ADDR
// PlatonovSendSupport ;
9934: CALL 4805 0 0
// if initiative <> 3 then
9938: LD_EXP 35
9942: PUSH
9943: LD_INT 3
9945: NONEQUAL
9946: IFFALSE 9956
// initiative = 1 ;
9948: LD_ADDR_EXP 35
9952: PUSH
9953: LD_INT 1
9955: ST_TO_ADDR
// end ; 3 :
9956: GO 9978
9958: LD_INT 3
9960: DOUBLE
9961: EQUAL
9962: IFTRUE 9966
9964: GO 9977
9966: POP
// initiative = 3 ; end ;
9967: LD_ADDR_EXP 35
9971: PUSH
9972: LD_INT 3
9974: ST_TO_ADDR
9975: GO 9978
9977: POP
// if IsOK ( Gnyevko ) then
9978: LD_EXP 52
9982: PPUSH
9983: CALL_OW 302
9987: IFFALSE 10013
// begin Say ( Gnyevko , D19-Gny-1 ) ;
9989: LD_EXP 52
9993: PPUSH
9994: LD_STRING D19-Gny-1
9996: PPUSH
9997: CALL_OW 88
// Say ( Burlak , D19-Bur-1 ) ;
10001: LD_EXP 51
10005: PPUSH
10006: LD_STRING D19-Bur-1
10008: PPUSH
10009: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
10013: LD_EXP 59
10017: PPUSH
10018: CALL_OW 302
10022: IFFALSE 10048
// begin Say ( Kovalyuk , D19-Kov-1 ) ;
10024: LD_EXP 59
10028: PPUSH
10029: LD_STRING D19-Kov-1
10031: PPUSH
10032: CALL_OW 88
// Say ( Burlak , D19-Bur-2 ) ;
10036: LD_EXP 51
10040: PPUSH
10041: LD_STRING D19-Bur-2
10043: PPUSH
10044: CALL_OW 88
// end ; end ;
10048: PPOPN 1
10050: END
// every 0 0$2 trigger not dialogAttackLeftBunkers and leftBunkers and FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) = 0 and ( IsOK ( Kovalyuk ) or IsOK ( Gnyevko ) ) do var unit ;
10051: LD_EXP 26
10055: NOT
10056: PUSH
10057: LD_EXP 69
10061: AND
10062: PUSH
10063: LD_INT 18
10065: PPUSH
10066: LD_INT 22
10068: PUSH
10069: LD_INT 3
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: PUSH
10076: EMPTY
10077: LIST
10078: PPUSH
10079: CALL_OW 70
10083: PUSH
10084: LD_INT 0
10086: EQUAL
10087: AND
10088: PUSH
10089: LD_EXP 59
10093: PPUSH
10094: CALL_OW 302
10098: PUSH
10099: LD_EXP 52
10103: PPUSH
10104: CALL_OW 302
10108: OR
10109: AND
10110: IFFALSE 10298
10112: GO 10114
10114: DISABLE
10115: LD_INT 0
10117: PPUSH
// begin enable ;
10118: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
10119: LD_ADDR_VAR 0 1
10123: PUSH
10124: LD_INT 22
10126: PUSH
10127: LD_INT 3
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: PUSH
10134: LD_INT 2
10136: PUSH
10137: LD_INT 21
10139: PUSH
10140: LD_INT 1
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: PUSH
10147: LD_INT 21
10149: PUSH
10150: LD_INT 2
10152: PUSH
10153: EMPTY
10154: LIST
10155: LIST
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: LIST
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: PPUSH
10166: CALL_OW 69
10170: PUSH
10171: FOR_IN
10172: IFFALSE 10296
// begin if Attacks ( unit ) = leftBunkers [ 1 ] or Attacks ( unit ) = leftBunkers [ 2 ] then
10174: LD_VAR 0 1
10178: PPUSH
10179: CALL_OW 320
10183: PUSH
10184: LD_EXP 69
10188: PUSH
10189: LD_INT 1
10191: ARRAY
10192: EQUAL
10193: PUSH
10194: LD_VAR 0 1
10198: PPUSH
10199: CALL_OW 320
10203: PUSH
10204: LD_EXP 69
10208: PUSH
10209: LD_INT 2
10211: ARRAY
10212: EQUAL
10213: OR
10214: IFFALSE 10294
// begin dialogAttackLeftBunkers = true ;
10216: LD_ADDR_EXP 26
10220: PUSH
10221: LD_INT 1
10223: ST_TO_ADDR
// DialogueOn ;
10224: CALL_OW 6
// if IsOK ( Gnyevko ) then
10228: LD_EXP 52
10232: PPUSH
10233: CALL_OW 302
10237: IFFALSE 10251
// Say ( Gnyevko , D19A-Gny-1 ) ;
10239: LD_EXP 52
10243: PPUSH
10244: LD_STRING D19A-Gny-1
10246: PPUSH
10247: CALL_OW 88
// if IsOK ( Kovalyuk ) then
10251: LD_EXP 59
10255: PPUSH
10256: CALL_OW 302
10260: IFFALSE 10274
// Say ( Kovalyuk , D19A-Kov-1 ) ;
10262: LD_EXP 59
10266: PPUSH
10267: LD_STRING D19A-Kov-1
10269: PPUSH
10270: CALL_OW 88
// Say ( Burlak , D16A-Bur-1 ) ;
10274: LD_EXP 51
10278: PPUSH
10279: LD_STRING D16A-Bur-1
10281: PPUSH
10282: CALL_OW 88
// DialogueOff ;
10286: CALL_OW 7
// exit ;
10290: POP
10291: POP
10292: GO 10298
// end ; end ;
10294: GO 10171
10296: POP
10297: POP
// end ;
10298: PPOPN 1
10300: END
// every 0 0$1 trigger not leftBunkers do
10301: LD_EXP 69
10305: NOT
10306: IFFALSE 10350
10308: GO 10310
10310: DISABLE
// begin DialogueOn ;
10311: CALL_OW 6
// Say ( Burlak , D20-Bur-1 ) ;
10315: LD_EXP 51
10319: PPUSH
10320: LD_STRING D20-Bur-1
10322: PPUSH
10323: CALL_OW 88
// Say ( Platonov , D20-Pla-1 ) ;
10327: LD_EXP 65
10331: PPUSH
10332: LD_STRING D20-Pla-1
10334: PPUSH
10335: CALL_OW 88
// DialogueOff ;
10339: CALL_OW 7
// ChangeMissionObjectives ( M8 ) ;
10343: LD_STRING M8
10345: PPUSH
10346: CALL_OW 337
// end ;
10350: END
// every 0 0$1 trigger not rightBunkers do
10351: LD_EXP 70
10355: NOT
10356: IFFALSE 10393
10358: GO 10360
10360: DISABLE
// begin DialogueOn ;
10361: CALL_OW 6
// Say ( Burlak , D20a-Bur-1 ) ;
10365: LD_EXP 51
10369: PPUSH
10370: LD_STRING D20a-Bur-1
10372: PPUSH
10373: CALL_OW 88
// Say ( Platonov , D20a-Pla-1 ) ;
10377: LD_EXP 65
10381: PPUSH
10382: LD_STRING D20a-Pla-1
10384: PPUSH
10385: CALL_OW 88
// DialogueOff ;
10389: CALL_OW 7
// end ;
10393: END
// every 0 0$1 trigger not saveBelkovDecision do var yourUnit , trapUnit , decsToChoose ;
10394: LD_EXP 29
10398: NOT
10399: IFFALSE 10869
10401: GO 10403
10403: DISABLE
10404: LD_INT 0
10406: PPUSH
10407: PPUSH
10408: PPUSH
// begin for yourUnit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
10409: LD_ADDR_VAR 0 1
10413: PUSH
10414: LD_INT 22
10416: PUSH
10417: LD_INT 3
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: PUSH
10424: LD_INT 2
10426: PUSH
10427: LD_INT 21
10429: PUSH
10430: LD_INT 1
10432: PUSH
10433: EMPTY
10434: LIST
10435: LIST
10436: PUSH
10437: LD_INT 21
10439: PUSH
10440: LD_INT 2
10442: PUSH
10443: EMPTY
10444: LIST
10445: LIST
10446: PUSH
10447: EMPTY
10448: LIST
10449: LIST
10450: LIST
10451: PUSH
10452: EMPTY
10453: LIST
10454: LIST
10455: PPUSH
10456: CALL_OW 69
10460: PUSH
10461: FOR_IN
10462: IFFALSE 10867
// for trapUnit in trapTeam do
10464: LD_ADDR_VAR 0 2
10468: PUSH
10469: LD_EXP 68
10473: PUSH
10474: FOR_IN
10475: IFFALSE 10863
// if GetDistUnits ( yourUnit , trapUnit ) < 10 then
10477: LD_VAR 0 1
10481: PPUSH
10482: LD_VAR 0 2
10486: PPUSH
10487: CALL_OW 296
10491: PUSH
10492: LD_INT 10
10494: LESS
10495: IFFALSE 10861
// begin saveBelkovDecision = true ;
10497: LD_ADDR_EXP 29
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// if playerGetSupport then
10505: LD_EXP 28
10509: IFFALSE 10528
// decsToChoose = [ 1 , 3 ] else
10511: LD_ADDR_VAR 0 3
10515: PUSH
10516: LD_INT 1
10518: PUSH
10519: LD_INT 3
10521: PUSH
10522: EMPTY
10523: LIST
10524: LIST
10525: ST_TO_ADDR
10526: GO 10547
// decsToChoose = [ 1 , 2 , 3 ] ;
10528: LD_ADDR_VAR 0 3
10532: PUSH
10533: LD_INT 1
10535: PUSH
10536: LD_INT 2
10538: PUSH
10539: LD_INT 3
10541: PUSH
10542: EMPTY
10543: LIST
10544: LIST
10545: LIST
10546: ST_TO_ADDR
// case SelectiveQuery ( QAttackAm , decsToChoose ) of 1 :
10547: LD_STRING QAttackAm
10549: PPUSH
10550: LD_VAR 0 3
10554: PPUSH
10555: CALL_OW 98
10559: PUSH
10560: LD_INT 1
10562: DOUBLE
10563: EQUAL
10564: IFTRUE 10568
10566: GO 10629
10568: POP
// begin DialogueOn ;
10569: CALL_OW 6
// Say ( Burlak , D21-Bur-1 ) ;
10573: LD_EXP 51
10577: PPUSH
10578: LD_STRING D21-Bur-1
10580: PPUSH
10581: CALL_OW 88
// SayRadio ( Platonov , D21-Pla-1 ) ;
10585: LD_EXP 65
10589: PPUSH
10590: LD_STRING D21-Pla-1
10592: PPUSH
10593: CALL_OW 94
// DialogueOff ;
10597: CALL_OW 7
// if not ( initiative in [ 2 , 3 ] ) then
10601: LD_EXP 35
10605: PUSH
10606: LD_INT 2
10608: PUSH
10609: LD_INT 3
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: IN
10616: NOT
10617: IFFALSE 10627
// initiative = 1 ;
10619: LD_ADDR_EXP 35
10623: PUSH
10624: LD_INT 1
10626: ST_TO_ADDR
// end ; 2 :
10627: GO 10805
10629: LD_INT 2
10631: DOUBLE
10632: EQUAL
10633: IFTRUE 10637
10635: GO 10785
10637: POP
// begin DialogueOn ;
10638: CALL_OW 6
// Say ( Burlak , D22-Bur-1 ) ;
10642: LD_EXP 51
10646: PPUSH
10647: LD_STRING D22-Bur-1
10649: PPUSH
10650: CALL_OW 88
// if playerGetSupport and ( leftBunkers = 0 or rightBunkers = 0 ) then
10654: LD_EXP 28
10658: PUSH
10659: LD_EXP 69
10663: PUSH
10664: LD_INT 0
10666: EQUAL
10667: PUSH
10668: LD_EXP 70
10672: PUSH
10673: LD_INT 0
10675: EQUAL
10676: OR
10677: AND
10678: IFFALSE 10692
// Say ( Platonov , D22-Pla-1b ) ;
10680: LD_EXP 65
10684: PPUSH
10685: LD_STRING D22-Pla-1b
10687: PPUSH
10688: CALL_OW 88
// if playerGetSupport and ( leftBunkers or rightBunkers ) then
10692: LD_EXP 28
10696: PUSH
10697: LD_EXP 69
10701: PUSH
10702: LD_EXP 70
10706: OR
10707: AND
10708: IFFALSE 10722
// Say ( Platonov , D22-Pla-1a ) ;
10710: LD_EXP 65
10714: PPUSH
10715: LD_STRING D22-Pla-1a
10717: PPUSH
10718: CALL_OW 88
// if not playerGetSupport then
10722: LD_EXP 28
10726: NOT
10727: IFFALSE 10761
// begin Say ( Platonov , D22-Pla-1 ) ;
10729: LD_EXP 65
10733: PPUSH
10734: LD_STRING D22-Pla-1
10736: PPUSH
10737: CALL_OW 88
// playerGetSupport = true ;
10741: LD_ADDR_EXP 28
10745: PUSH
10746: LD_INT 1
10748: ST_TO_ADDR
// medalForGetSupport = false ;
10749: LD_ADDR_EXP 33
10753: PUSH
10754: LD_INT 0
10756: ST_TO_ADDR
// PlatonovSendSupport ;
10757: CALL 4805 0 0
// end ; DialogueOff ;
10761: CALL_OW 7
// if initiative <> 3 then
10765: LD_EXP 35
10769: PUSH
10770: LD_INT 3
10772: NONEQUAL
10773: IFFALSE 10783
// initiative = 2 ;
10775: LD_ADDR_EXP 35
10779: PUSH
10780: LD_INT 2
10782: ST_TO_ADDR
// end ; 3 :
10783: GO 10805
10785: LD_INT 3
10787: DOUBLE
10788: EQUAL
10789: IFTRUE 10793
10791: GO 10804
10793: POP
// initiative = 3 ; end ;
10794: LD_ADDR_EXP 35
10798: PUSH
10799: LD_INT 3
10801: ST_TO_ADDR
10802: GO 10805
10804: POP
// if IsOK ( Gnyevko ) then
10805: LD_EXP 52
10809: PPUSH
10810: CALL_OW 302
10814: IFFALSE 10840
// begin Say ( Gnyevko , D23-Gny-1 ) ;
10816: LD_EXP 52
10820: PPUSH
10821: LD_STRING D23-Gny-1
10823: PPUSH
10824: CALL_OW 88
// Say ( Burlak , D23-Bur-1 ) ;
10828: LD_EXP 51
10832: PPUSH
10833: LD_STRING D23-Bur-1
10835: PPUSH
10836: CALL_OW 88
// end ; saveBelkovObjective = true ;
10840: LD_ADDR_EXP 30
10844: PUSH
10845: LD_INT 1
10847: ST_TO_ADDR
// ChangeMissionObjectives ( M9 ) ;
10848: LD_STRING M9
10850: PPUSH
10851: CALL_OW 337
// exit ;
10855: POP
10856: POP
10857: POP
10858: POP
10859: GO 10869
// end ;
10861: GO 10474
10863: POP
10864: POP
10865: GO 10461
10867: POP
10868: POP
// end ;
10869: PPOPN 3
10871: END
// every 0 0$1 trigger not trapTeam and saveBelkovObjective and not belkovSaved do
10872: LD_EXP 68
10876: NOT
10877: PUSH
10878: LD_EXP 30
10882: AND
10883: PUSH
10884: LD_EXP 31
10888: NOT
10889: AND
10890: IFFALSE 10915
10892: GO 10894
10894: DISABLE
// begin belkovSaved = true ;
10895: LD_ADDR_EXP 31
10899: PUSH
10900: LD_INT 1
10902: ST_TO_ADDR
// SetSide ( belkovTeam , 3 ) ;
10903: LD_EXP 62
10907: PPUSH
10908: LD_INT 3
10910: PPUSH
10911: CALL_OW 235
// end ;
10915: END
// every 0 0$5 trigger belkovSaved and ( GetDistUnits ( Burlak , Belkov ) < 6 or GetDistUnits ( Burlak , Belkov2 ) < 6 ) do
10916: LD_EXP 31
10920: PUSH
10921: LD_EXP 51
10925: PPUSH
10926: LD_EXP 53
10930: PPUSH
10931: CALL_OW 296
10935: PUSH
10936: LD_INT 6
10938: LESS
10939: PUSH
10940: LD_EXP 51
10944: PPUSH
10945: LD_EXP 57
10949: PPUSH
10950: CALL_OW 296
10954: PUSH
10955: LD_INT 6
10957: LESS
10958: OR
10959: AND
10960: IFFALSE 11135
10962: GO 10964
10964: DISABLE
// begin InGameOn ;
10965: CALL_OW 8
// if IsOk ( Belkov ) then
10969: LD_EXP 53
10973: PPUSH
10974: CALL_OW 302
10978: IFFALSE 11074
// begin CenterNowOnUnits ( [ Burlak , Belkov ] ) ;
10980: LD_EXP 51
10984: PUSH
10985: LD_EXP 53
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PPUSH
10994: CALL_OW 87
// ComTurnUnit ( Burlak , Belkov ) ;
10998: LD_EXP 51
11002: PPUSH
11003: LD_EXP 53
11007: PPUSH
11008: CALL_OW 119
// ComTurnUnit ( Belkov , Burlak ) ;
11012: LD_EXP 53
11016: PPUSH
11017: LD_EXP 51
11021: PPUSH
11022: CALL_OW 119
// Say ( Belkov , D24-Bel-1 ) ;
11026: LD_EXP 53
11030: PPUSH
11031: LD_STRING D24-Bel-1
11033: PPUSH
11034: CALL_OW 88
// Say ( Burlak , D24-Bur-1 ) ;
11038: LD_EXP 51
11042: PPUSH
11043: LD_STRING D24-Bur-1
11045: PPUSH
11046: CALL_OW 88
// Say ( Belkov , D24-Bel-2 ) ;
11050: LD_EXP 53
11054: PPUSH
11055: LD_STRING D24-Bel-2
11057: PPUSH
11058: CALL_OW 88
// Say ( Burlak , D24-Bur-2 ) ;
11062: LD_EXP 51
11066: PPUSH
11067: LD_STRING D24-Bur-2
11069: PPUSH
11070: CALL_OW 88
// end ; if GetSide ( kirovVehicle ) = 3 then
11074: LD_EXP 61
11078: PPUSH
11079: CALL_OW 255
11083: PUSH
11084: LD_INT 3
11086: EQUAL
11087: IFFALSE 11101
// Say ( Burlak , D24-Bur-2a ) ;
11089: LD_EXP 51
11093: PPUSH
11094: LD_STRING D24-Bur-2a
11096: PPUSH
11097: CALL_OW 88
// SayRadio ( Platonov , D24-Pla-2 ) ;
11101: LD_EXP 65
11105: PPUSH
11106: LD_STRING D24-Pla-2
11108: PPUSH
11109: CALL_OW 94
// if leftBunkers then
11113: LD_EXP 69
11117: IFFALSE 11131
// SayRadio ( Platonov , D24-Pla-2a ) ;
11119: LD_EXP 65
11123: PPUSH
11124: LD_STRING D24-Pla-2a
11126: PPUSH
11127: CALL_OW 94
// InGameOff ;
11131: CALL_OW 9
// end ;
11135: END
// every 0 0$1 trigger canExitBase and not IsInArea ( Burlak , BeriaBaseArea ) and raportForPlatonov = - 1 do
11136: LD_EXP 17
11140: PUSH
11141: LD_EXP 51
11145: PPUSH
11146: LD_INT 8
11148: PPUSH
11149: CALL_OW 308
11153: NOT
11154: AND
11155: PUSH
11156: LD_EXP 32
11160: PUSH
11161: LD_INT 1
11163: NEG
11164: EQUAL
11165: AND
11166: IFFALSE 11180
11168: GO 11170
11170: DISABLE
// begin enable ;
11171: ENABLE
// raportForPlatonov = 0 ;
11172: LD_ADDR_EXP 32
11176: PUSH
11177: LD_INT 0
11179: ST_TO_ADDR
// end ;
11180: END
// every 0 0$1 trigger canExitBase and raportForPlatonov >= 0 and not backToBeria2 do
11181: LD_EXP 17
11185: PUSH
11186: LD_EXP 32
11190: PUSH
11191: LD_INT 0
11193: GREATEREQUAL
11194: AND
11195: PUSH
11196: LD_EXP 14
11200: NOT
11201: AND
11202: IFFALSE 11447
11204: GO 11206
11206: DISABLE
// begin DialogueOn ;
11207: CALL_OW 6
// case raportForPlatonov of 0 :
11211: LD_EXP 32
11215: PUSH
11216: LD_INT 0
11218: DOUBLE
11219: EQUAL
11220: IFTRUE 11224
11222: GO 11251
11224: POP
// begin Say ( Platonov , D25a-Pla-1 ) ;
11225: LD_EXP 65
11229: PPUSH
11230: LD_STRING D25a-Pla-1
11232: PPUSH
11233: CALL_OW 88
// Say ( Burlak , D25a-Bur-1 ) ;
11237: LD_EXP 51
11241: PPUSH
11242: LD_STRING D25a-Bur-1
11244: PPUSH
11245: CALL_OW 88
// end ; 1 :
11249: GO 11431
11251: LD_INT 1
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11286
11259: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
11260: LD_EXP 65
11264: PPUSH
11265: LD_STRING D25-Pla-1
11267: PPUSH
11268: CALL_OW 88
// Say ( Burlak , D25-Bur-1 ) ;
11272: LD_EXP 51
11276: PPUSH
11277: LD_STRING D25-Bur-1
11279: PPUSH
11280: CALL_OW 88
// end ; 2 :
11284: GO 11431
11286: LD_INT 2
11288: DOUBLE
11289: EQUAL
11290: IFTRUE 11294
11292: GO 11340
11294: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
11295: LD_EXP 65
11299: PPUSH
11300: LD_STRING D25-Pla-1
11302: PPUSH
11303: CALL_OW 88
// Say ( Burlak , D25-Bur-1a ) ;
11307: LD_EXP 51
11311: PPUSH
11312: LD_STRING D25-Bur-1a
11314: PPUSH
11315: CALL_OW 88
// if not sawLeftBunker then
11319: LD_EXP 24
11323: NOT
11324: IFFALSE 11338
// Say ( Platonov , D25c-Pla-1 ) ;
11326: LD_EXP 65
11330: PPUSH
11331: LD_STRING D25c-Pla-1
11333: PPUSH
11334: CALL_OW 88
// end ; 3 :
11338: GO 11431
11340: LD_INT 3
11342: DOUBLE
11343: EQUAL
11344: IFTRUE 11348
11346: GO 11430
11348: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
11349: LD_EXP 65
11353: PPUSH
11354: LD_STRING D25-Pla-1
11356: PPUSH
11357: CALL_OW 88
// Say ( Burlak , D25a-Bur-1b ) ;
11361: LD_EXP 51
11365: PPUSH
11366: LD_STRING D25a-Bur-1b
11368: PPUSH
11369: CALL_OW 88
// Say ( Burlak , D25b-Bur-1 ) ;
11373: LD_EXP 51
11377: PPUSH
11378: LD_STRING D25b-Bur-1
11380: PPUSH
11381: CALL_OW 88
// Say ( Platonov , D25b-Pla-1 ) ;
11385: LD_EXP 65
11389: PPUSH
11390: LD_STRING D25b-Pla-1
11392: PPUSH
11393: CALL_OW 88
// playerGetSupport = true ;
11397: LD_ADDR_EXP 28
11401: PUSH
11402: LD_INT 1
11404: ST_TO_ADDR
// PlatonovSendSupport ;
11405: CALL 4805 0 0
// if not sawRightBunker then
11409: LD_EXP 25
11413: NOT
11414: IFFALSE 11428
// Say ( Platonov , D25c-Pla-1 ) ;
11416: LD_EXP 65
11420: PPUSH
11421: LD_STRING D25c-Pla-1
11423: PPUSH
11424: CALL_OW 88
// end ; end ;
11428: GO 11431
11430: POP
// Say ( Platonov , D25c-Pla-1a ) ;
11431: LD_EXP 65
11435: PPUSH
11436: LD_STRING D25c-Pla-1a
11438: PPUSH
11439: CALL_OW 88
// DialogueOff ;
11443: CALL_OW 7
// end ;
11447: END
// every 0 0$1 trigger FilterUnitsInArea ( NorthArea , [ [ f_side , 3 ] ] ) > 0 do
11448: LD_INT 19
11450: PPUSH
11451: LD_INT 22
11453: PUSH
11454: LD_INT 3
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: PUSH
11461: EMPTY
11462: LIST
11463: PPUSH
11464: CALL_OW 70
11468: PUSH
11469: LD_INT 0
11471: GREATER
11472: IFFALSE 11492
11474: GO 11476
11476: DISABLE
// begin northMapExplored = true ;
11477: LD_ADDR_EXP 34
11481: PUSH
11482: LD_INT 1
11484: ST_TO_ADDR
// ChangeMissionObjectives ( M10 ) ;
11485: LD_STRING M10
11487: PPUSH
11488: CALL_OW 337
// end ;
11492: END
// every 0 0$1 trigger not leftBunkers and northMapExplored and ( belkovSaved or not saveBelkovObjective ) do
11493: LD_EXP 69
11497: NOT
11498: PUSH
11499: LD_EXP 34
11503: AND
11504: PUSH
11505: LD_EXP 31
11509: PUSH
11510: LD_EXP 30
11514: NOT
11515: OR
11516: AND
11517: IFFALSE 11537
11519: GO 11521
11521: DISABLE
// begin backToBeria2 = true ;
11522: LD_ADDR_EXP 14
11526: PUSH
11527: LD_INT 1
11529: ST_TO_ADDR
// ChangeMissionObjectives ( M10a ) ;
11530: LD_STRING M10a
11532: PPUSH
11533: CALL_OW 337
// end ; end_of_file end_of_file
11537: END
// every 0 0$1 trigger spawnCrates do var i , unit , carryCratesEngs , playerEngs , spawnNextCrates ;
11538: LD_EXP 18
11542: IFFALSE 11771
11544: GO 11546
11546: DISABLE
11547: LD_INT 0
11549: PPUSH
11550: PPUSH
11551: PPUSH
11552: PPUSH
11553: PPUSH
// begin repeat playerEngs = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_class , class_engineer ] ] ) ;
11554: LD_ADDR_VAR 0 4
11558: PUSH
11559: LD_INT 22
11561: PUSH
11562: LD_INT 3
11564: PUSH
11565: EMPTY
11566: LIST
11567: LIST
11568: PUSH
11569: LD_INT 21
11571: PUSH
11572: LD_INT 1
11574: PUSH
11575: EMPTY
11576: LIST
11577: LIST
11578: PUSH
11579: LD_INT 25
11581: PUSH
11582: LD_INT 2
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: LIST
11593: PPUSH
11594: CALL_OW 69
11598: ST_TO_ADDR
// wait ( 0 0$40 ) ;
11599: LD_INT 1400
11601: PPUSH
11602: CALL_OW 67
// carryCratesEngs = 0 ;
11606: LD_ADDR_VAR 0 3
11610: PUSH
11611: LD_INT 0
11613: ST_TO_ADDR
// for unit in playerEngs do
11614: LD_ADDR_VAR 0 2
11618: PUSH
11619: LD_VAR 0 4
11623: PUSH
11624: FOR_IN
11625: IFFALSE 11653
// carryCratesEngs = carryCratesEngs + GetCargo ( unit , mat_cans ) ;
11627: LD_ADDR_VAR 0 3
11631: PUSH
11632: LD_VAR 0 3
11636: PUSH
11637: LD_VAR 0 2
11641: PPUSH
11642: LD_INT 1
11644: PPUSH
11645: CALL_OW 289
11649: PLUS
11650: ST_TO_ADDR
11651: GO 11624
11653: POP
11654: POP
// if GetResourceType ( GetBase ( beria ) , mat_cans ) < 50 and ( GetResourceArea ( beriaBaseArea , mat_cans ) * 10 ) + GetResourceType ( GetBase ( beria ) , mat_cans ) + carryCratesEngs < 50 then
11655: LD_INT 106
11657: PPUSH
11658: CALL_OW 274
11662: PPUSH
11663: LD_INT 1
11665: PPUSH
11666: CALL_OW 275
11670: PUSH
11671: LD_INT 50
11673: LESS
11674: PUSH
11675: LD_INT 8
11677: PPUSH
11678: LD_INT 1
11680: PPUSH
11681: CALL_OW 287
11685: PUSH
11686: LD_INT 10
11688: MUL
11689: PUSH
11690: LD_INT 106
11692: PPUSH
11693: CALL_OW 274
11697: PPUSH
11698: LD_INT 1
11700: PPUSH
11701: CALL_OW 275
11705: PLUS
11706: PUSH
11707: LD_VAR 0 3
11711: PLUS
11712: PUSH
11713: LD_INT 50
11715: LESS
11716: AND
11717: IFFALSE 11729
// spawnNextCrates = true else
11719: LD_ADDR_VAR 0 5
11723: PUSH
11724: LD_INT 1
11726: ST_TO_ADDR
11727: GO 11737
// spawnNextCrates = false ;
11729: LD_ADDR_VAR 0 5
11733: PUSH
11734: LD_INT 0
11736: ST_TO_ADDR
// if spawnNextCrates then
11737: LD_VAR 0 5
11741: IFFALSE 11764
// CreateCratesArea ( rand ( 1 , 5 ) , BeriaBaseArea , true ) ;
11743: LD_INT 1
11745: PPUSH
11746: LD_INT 5
11748: PPUSH
11749: CALL_OW 12
11753: PPUSH
11754: LD_INT 8
11756: PPUSH
11757: LD_INT 1
11759: PPUSH
11760: CALL_OW 55
// until not spawnCrates ;
11764: LD_EXP 18
11768: NOT
11769: IFFALSE 11554
// end ; end_of_file
11771: PPOPN 5
11773: END
// on BuildingStarted ( building , builder ) do begin if GetBType ( building ) = b_lab and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) > 1 and not canBuildSameBuilding then
11774: LD_VAR 0 1
11778: PPUSH
11779: CALL_OW 266
11783: PUSH
11784: LD_INT 6
11786: EQUAL
11787: PUSH
11788: LD_INT 22
11790: PUSH
11791: LD_INT 3
11793: PUSH
11794: EMPTY
11795: LIST
11796: LIST
11797: PUSH
11798: LD_INT 30
11800: PUSH
11801: LD_INT 6
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: EMPTY
11809: LIST
11810: LIST
11811: PPUSH
11812: CALL_OW 69
11816: PUSH
11817: LD_INT 1
11819: GREATER
11820: AND
11821: PUSH
11822: LD_EXP 9
11826: NOT
11827: AND
11828: IFFALSE 11839
// Dial_StopConstructAgainSameBuilding ( building ) ;
11830: LD_VAR 0 1
11834: PPUSH
11835: CALL 6226 0 1
// if GetBType ( building ) = b_workshop and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_workshop ] ] ) > 1 and not canBuildSameBuilding then
11839: LD_VAR 0 1
11843: PPUSH
11844: CALL_OW 266
11848: PUSH
11849: LD_INT 2
11851: EQUAL
11852: PUSH
11853: LD_INT 22
11855: PUSH
11856: LD_INT 3
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: PUSH
11863: LD_INT 30
11865: PUSH
11866: LD_INT 2
11868: PUSH
11869: EMPTY
11870: LIST
11871: LIST
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PPUSH
11877: CALL_OW 69
11881: PUSH
11882: LD_INT 1
11884: GREATER
11885: AND
11886: PUSH
11887: LD_EXP 9
11891: NOT
11892: AND
11893: IFFALSE 11904
// Dial_StopConstructAgainSameBuilding ( building ) ;
11895: LD_VAR 0 1
11899: PPUSH
11900: CALL 6226 0 1
// end ;
11904: PPOPN 2
11906: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 and GetBType ( building ) = b_lab and not labConstructed then
11907: LD_VAR 0 1
11911: PPUSH
11912: CALL_OW 255
11916: PUSH
11917: LD_INT 3
11919: EQUAL
11920: PUSH
11921: LD_VAR 0 1
11925: PPUSH
11926: CALL_OW 266
11930: PUSH
11931: LD_INT 6
11933: EQUAL
11934: AND
11935: PUSH
11936: LD_EXP 6
11940: NOT
11941: AND
11942: IFFALSE 11948
// Dial_LabConstructed ;
11944: CALL 6076 0 0
// if GetSide ( building ) = 3 and GetBType ( building ) = b_workshop and not workshopConstructed then
11948: LD_VAR 0 1
11952: PPUSH
11953: CALL_OW 255
11957: PUSH
11958: LD_INT 3
11960: EQUAL
11961: PUSH
11962: LD_VAR 0 1
11966: PPUSH
11967: CALL_OW 266
11971: PUSH
11972: LD_INT 2
11974: EQUAL
11975: AND
11976: PUSH
11977: LD_EXP 7
11981: NOT
11982: AND
11983: IFFALSE 11989
// Dial_WorkshopConstructed ;
11985: CALL 6151 0 0
// if GetSide ( building ) = 6 then
11989: LD_VAR 0 1
11993: PPUSH
11994: CALL_OW 255
11998: PUSH
11999: LD_INT 6
12001: EQUAL
12002: IFFALSE 12179
// begin if GetBType ( building ) = b_breastwork then
12004: LD_VAR 0 1
12008: PPUSH
12009: CALL_OW 266
12013: PUSH
12014: LD_INT 31
12016: EQUAL
12017: IFFALSE 12062
// ComEnterUnit ( UnitFilter ( otherKirovUnits , [ [ f_class , class_soldier ] , [ f_outside ] ] ) [ 1 ] , building ) ;
12019: LD_EXP 58
12023: PPUSH
12024: LD_INT 25
12026: PUSH
12027: LD_INT 1
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: PUSH
12034: LD_INT 56
12036: PUSH
12037: EMPTY
12038: LIST
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PPUSH
12044: CALL_OW 72
12048: PUSH
12049: LD_INT 1
12051: ARRAY
12052: PPUSH
12053: LD_VAR 0 1
12057: PPUSH
12058: CALL_OW 120
// if GetBType ( building ) = b_lab then
12062: LD_VAR 0 1
12066: PPUSH
12067: CALL_OW 266
12071: PUSH
12072: LD_INT 6
12074: EQUAL
12075: IFFALSE 12135
// begin ResAllTechs ( 6 , building , 3 ) ;
12077: LD_INT 6
12079: PPUSH
12080: LD_VAR 0 1
12084: PPUSH
12085: LD_INT 3
12087: PPUSH
12088: CALL 4134 0 3
// ComEnterUnit ( UnitFilter ( otherKirovUnits , [ f_class , class_scientistic ] ) , building ) ;
12092: LD_EXP 58
12096: PPUSH
12097: LD_INT 25
12099: PUSH
12100: LD_INT 4
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PPUSH
12107: CALL_OW 72
12111: PPUSH
12112: LD_VAR 0 1
12116: PPUSH
12117: CALL_OW 120
// ComEnterUnit ( Kirilenkova , building ) ;
12121: LD_EXP 54
12125: PPUSH
12126: LD_VAR 0 1
12130: PPUSH
12131: CALL_OW 120
// end ; if GetBType ( building ) = b_workshop then
12135: LD_VAR 0 1
12139: PPUSH
12140: CALL_OW 266
12144: PUSH
12145: LD_INT 2
12147: EQUAL
12148: IFFALSE 12179
// ComEnterUnit ( UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) , building ) ;
12150: LD_EXP 58
12154: PPUSH
12155: LD_INT 25
12157: PUSH
12158: LD_INT 3
12160: PUSH
12161: EMPTY
12162: LIST
12163: LIST
12164: PPUSH
12165: CALL_OW 72
12169: PPUSH
12170: LD_VAR 0 1
12174: PPUSH
12175: CALL_OW 120
// end ; end ;
12179: PPOPN 1
12181: END
// on ResearchComplete ( tech , building ) do begin if tech = tech_oilEng and GetSide ( building ) = 3 then
12182: LD_VAR 0 1
12186: PUSH
12187: LD_INT 47
12189: EQUAL
12190: PUSH
12191: LD_VAR 0 2
12195: PPUSH
12196: CALL_OW 255
12200: PUSH
12201: LD_INT 3
12203: EQUAL
12204: AND
12205: IFFALSE 12215
// engineResearched = true ;
12207: LD_ADDR_EXP 8
12211: PUSH
12212: LD_INT 1
12214: ST_TO_ADDR
// end ;
12215: PPOPN 2
12217: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( factory ) = your_side and IsOK ( factory ) and not constructedFirstVehicle and not construcMoreVehicles then
12218: LD_VAR 0 2
12222: PPUSH
12223: CALL_OW 255
12227: PUSH
12228: LD_OWVAR 2
12232: EQUAL
12233: PUSH
12234: LD_VAR 0 2
12238: PPUSH
12239: CALL_OW 302
12243: AND
12244: PUSH
12245: LD_EXP 10
12249: NOT
12250: AND
12251: PUSH
12252: LD_EXP 15
12256: NOT
12257: AND
12258: IFFALSE 12269
// Dial_FirstVehConstructed ( factory ) ;
12260: LD_VAR 0 2
12264: PPUSH
12265: CALL 6574 0 1
// if GetSide ( factory ) = your_side and IsOK ( factory ) and construcMoreVehicles then
12269: LD_VAR 0 2
12273: PPUSH
12274: CALL_OW 255
12278: PUSH
12279: LD_OWVAR 2
12283: EQUAL
12284: PUSH
12285: LD_VAR 0 2
12289: PPUSH
12290: CALL_OW 302
12294: AND
12295: PUSH
12296: LD_EXP 15
12300: AND
12301: IFFALSE 12317
// constructedVehiclesCounter = constructedVehiclesCounter + 1 ;
12303: LD_ADDR_EXP 16
12307: PUSH
12308: LD_EXP 16
12312: PUSH
12313: LD_INT 1
12315: PLUS
12316: ST_TO_ADDR
// end ;
12317: PPOPN 2
12319: END
// on CrateSpawn ( unit , x , y , amount , mode ) do begin if not canExitBase then
12320: LD_EXP 17
12324: NOT
12325: IFFALSE 12341
// Dial_NewCrates ( x , y ) ;
12327: LD_VAR 0 2
12331: PPUSH
12332: LD_VAR 0 3
12336: PPUSH
12337: CALL 6528 0 2
// end ;
12341: PPOPN 5
12343: END
// on Command ( com ) do var i , j , temp , order , destiny ;
12344: LD_INT 0
12346: PPUSH
12347: PPUSH
12348: PPUSH
12349: PPUSH
12350: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
12351: LD_ADDR_VAR 0 2
12355: PUSH
12356: LD_INT 22
12358: PUSH
12359: LD_INT 3
12361: PUSH
12362: EMPTY
12363: LIST
12364: LIST
12365: PUSH
12366: LD_INT 21
12368: PUSH
12369: LD_INT 1
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: PUSH
12376: EMPTY
12377: LIST
12378: LIST
12379: PPUSH
12380: CALL_OW 69
12384: PUSH
12385: FOR_IN
12386: IFFALSE 12533
// if GetTaskList ( i ) > 0 then
12388: LD_VAR 0 2
12392: PPUSH
12393: CALL_OW 437
12397: PUSH
12398: LD_INT 0
12400: GREATER
12401: IFFALSE 12531
// for j = 1 to GetTaskList ( i ) do
12403: LD_ADDR_VAR 0 3
12407: PUSH
12408: DOUBLE
12409: LD_INT 1
12411: DEC
12412: ST_TO_ADDR
12413: LD_VAR 0 2
12417: PPUSH
12418: CALL_OW 437
12422: PUSH
12423: FOR_TO
12424: IFFALSE 12529
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
12426: LD_ADDR_VAR 0 4
12430: PUSH
12431: LD_VAR 0 2
12435: PPUSH
12436: CALL_OW 437
12440: PUSH
12441: LD_VAR 0 3
12445: ARRAY
12446: PUSH
12447: LD_INT 4
12449: ARRAY
12450: ST_TO_ADDR
// if temp = kirov or ( GetSide ( temp ) = 6 and GetTaskList ( i ) [ j ] [ 1 ] = e and GetType ( temp ) = unit_vehicle ) then
12451: LD_VAR 0 4
12455: PUSH
12456: LD_INT 71
12458: EQUAL
12459: PUSH
12460: LD_VAR 0 4
12464: PPUSH
12465: CALL_OW 255
12469: PUSH
12470: LD_INT 6
12472: EQUAL
12473: PUSH
12474: LD_VAR 0 2
12478: PPUSH
12479: CALL_OW 437
12483: PUSH
12484: LD_VAR 0 3
12488: ARRAY
12489: PUSH
12490: LD_INT 1
12492: ARRAY
12493: PUSH
12494: LD_STRING e
12496: EQUAL
12497: AND
12498: PUSH
12499: LD_VAR 0 4
12503: PPUSH
12504: CALL_OW 247
12508: PUSH
12509: LD_INT 2
12511: EQUAL
12512: AND
12513: OR
12514: IFFALSE 12527
// SetTaskList ( i , [ ] ) ;
12516: LD_VAR 0 2
12520: PPUSH
12521: EMPTY
12522: PPUSH
12523: CALL_OW 446
// end ;
12527: GO 12423
12529: POP
12530: POP
12531: GO 12385
12533: POP
12534: POP
// destiny = [ ] ;
12535: LD_ADDR_VAR 0 6
12539: PUSH
12540: EMPTY
12541: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12542: LD_ADDR_VAR 0 2
12546: PUSH
12547: LD_INT 22
12549: PUSH
12550: LD_INT 3
12552: PUSH
12553: EMPTY
12554: LIST
12555: LIST
12556: PUSH
12557: LD_INT 2
12559: PUSH
12560: LD_INT 21
12562: PUSH
12563: LD_INT 1
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: PUSH
12570: LD_INT 21
12572: PUSH
12573: LD_INT 2
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: PUSH
12580: EMPTY
12581: LIST
12582: LIST
12583: LIST
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PPUSH
12589: CALL_OW 69
12593: PUSH
12594: FOR_IN
12595: IFFALSE 12777
// if GetTaskList ( i ) > 0 then
12597: LD_VAR 0 2
12601: PPUSH
12602: CALL_OW 437
12606: PUSH
12607: LD_INT 0
12609: GREATER
12610: IFFALSE 12775
// for j = 1 to GetTaskList ( i ) do
12612: LD_ADDR_VAR 0 3
12616: PUSH
12617: DOUBLE
12618: LD_INT 1
12620: DEC
12621: ST_TO_ADDR
12622: LD_VAR 0 2
12626: PPUSH
12627: CALL_OW 437
12631: PUSH
12632: FOR_TO
12633: IFFALSE 12773
// begin order = GetTaskList ( i ) [ j ] [ 1 ] ;
12635: LD_ADDR_VAR 0 5
12639: PUSH
12640: LD_VAR 0 2
12644: PPUSH
12645: CALL_OW 437
12649: PUSH
12650: LD_VAR 0 3
12654: ARRAY
12655: PUSH
12656: LD_INT 1
12658: ARRAY
12659: ST_TO_ADDR
// destiny = destiny ^ GetTaskList ( i ) [ j ] [ 2 ] ;
12660: LD_ADDR_VAR 0 6
12664: PUSH
12665: LD_VAR 0 6
12669: PUSH
12670: LD_VAR 0 2
12674: PPUSH
12675: CALL_OW 437
12679: PUSH
12680: LD_VAR 0 3
12684: ARRAY
12685: PUSH
12686: LD_INT 2
12688: ARRAY
12689: ADD
12690: ST_TO_ADDR
// destiny = destiny ^ GetTaskList ( i ) [ j ] [ 3 ] ;
12691: LD_ADDR_VAR 0 6
12695: PUSH
12696: LD_VAR 0 6
12700: PUSH
12701: LD_VAR 0 2
12705: PPUSH
12706: CALL_OW 437
12710: PUSH
12711: LD_VAR 0 3
12715: ARRAY
12716: PUSH
12717: LD_INT 3
12719: ARRAY
12720: ADD
12721: ST_TO_ADDR
// if order = M and not InArea ( destiny [ 1 ] , destiny [ 2 ] , VisibleMapPartArea ) then
12722: LD_VAR 0 5
12726: PUSH
12727: LD_STRING M
12729: EQUAL
12730: PUSH
12731: LD_VAR 0 6
12735: PUSH
12736: LD_INT 1
12738: ARRAY
12739: PPUSH
12740: LD_VAR 0 6
12744: PUSH
12745: LD_INT 2
12747: ARRAY
12748: PPUSH
12749: LD_INT 7
12751: PPUSH
12752: CALL_OW 309
12756: NOT
12757: AND
12758: IFFALSE 12771
// SetTaskList ( i , [ ] ) ;
12760: LD_VAR 0 2
12764: PPUSH
12765: EMPTY
12766: PPUSH
12767: CALL_OW 446
// end ;
12771: GO 12632
12773: POP
12774: POP
12775: GO 12594
12777: POP
12778: POP
// end ;
12779: PPOPN 6
12781: END
// on UnitDestroyed ( unit ) do begin if GetSide ( unit ) = 1 and GetType ( unit ) = unit_building then
12782: LD_VAR 0 1
12786: PPUSH
12787: CALL_OW 255
12791: PUSH
12792: LD_INT 1
12794: EQUAL
12795: PUSH
12796: LD_VAR 0 1
12800: PPUSH
12801: CALL_OW 247
12805: PUSH
12806: LD_INT 3
12808: EQUAL
12809: AND
12810: IFFALSE 12868
// begin if unit in leftBunkers then
12812: LD_VAR 0 1
12816: PUSH
12817: LD_EXP 69
12821: IN
12822: IFFALSE 12840
// leftBunkers = leftBunkers diff unit ;
12824: LD_ADDR_EXP 69
12828: PUSH
12829: LD_EXP 69
12833: PUSH
12834: LD_VAR 0 1
12838: DIFF
12839: ST_TO_ADDR
// if unit in rightBunkers then
12840: LD_VAR 0 1
12844: PUSH
12845: LD_EXP 70
12849: IN
12850: IFFALSE 12868
// rightBunkers = rightBunkers diff unit ;
12852: LD_ADDR_EXP 70
12856: PUSH
12857: LD_EXP 70
12861: PUSH
12862: LD_VAR 0 1
12866: DIFF
12867: ST_TO_ADDR
// end ; if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
12868: LD_VAR 0 1
12872: PPUSH
12873: CALL_OW 255
12877: PUSH
12878: LD_INT 1
12880: EQUAL
12881: PUSH
12882: LD_VAR 0 1
12886: PPUSH
12887: CALL_OW 247
12891: PUSH
12892: LD_INT 1
12894: EQUAL
12895: AND
12896: IFFALSE 12926
// if unit in trapTeam then
12898: LD_VAR 0 1
12902: PUSH
12903: LD_EXP 68
12907: IN
12908: IFFALSE 12926
// trapTeam = trapTeam diff unit ;
12910: LD_ADDR_EXP 68
12914: PUSH
12915: LD_EXP 68
12919: PUSH
12920: LD_VAR 0 1
12924: DIFF
12925: ST_TO_ADDR
// if GetSide ( unit ) = 6 and GetType ( unit ) = unit_human then
12926: LD_VAR 0 1
12930: PPUSH
12931: CALL_OW 255
12935: PUSH
12936: LD_INT 6
12938: EQUAL
12939: PUSH
12940: LD_VAR 0 1
12944: PPUSH
12945: CALL_OW 247
12949: PUSH
12950: LD_INT 1
12952: EQUAL
12953: AND
12954: IFFALSE 12984
// if unit in belkovTeam then
12956: LD_VAR 0 1
12960: PUSH
12961: LD_EXP 62
12965: IN
12966: IFFALSE 12984
// belkovTeam = belkovTeam diff unit ;
12968: LD_ADDR_EXP 62
12972: PUSH
12973: LD_EXP 62
12977: PUSH
12978: LD_VAR 0 1
12982: DIFF
12983: ST_TO_ADDR
// if GetSide ( unit ) = 3 and GetType ( unit ) = unit_human then
12984: LD_VAR 0 1
12988: PPUSH
12989: CALL_OW 255
12993: PUSH
12994: LD_INT 3
12996: EQUAL
12997: PUSH
12998: LD_VAR 0 1
13002: PPUSH
13003: CALL_OW 247
13007: PUSH
13008: LD_INT 1
13010: EQUAL
13011: AND
13012: IFFALSE 13028
// lostComradesCounter = lostComradesCounter + 1 ;
13014: LD_ADDR_EXP 36
13018: PUSH
13019: LD_EXP 36
13023: PUSH
13024: LD_INT 1
13026: PLUS
13027: ST_TO_ADDR
// if unit = Burlak then
13028: LD_VAR 0 1
13032: PUSH
13033: LD_EXP 51
13037: EQUAL
13038: IFFALSE 13044
// BurlakIsDead ;
13040: CALL 13594 0 0
// end ;
13044: PPOPN 1
13046: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
13047: LD_VAR 0 1
13051: PUSH
13052: LD_INT 3
13054: EQUAL
13055: PUSH
13056: LD_VAR 0 2
13060: PUSH
13061: LD_INT 6
13063: EQUAL
13064: AND
13065: IFFALSE 13071
// AttackComrades ;
13067: CALL 13609 0 0
// end ; end_of_file
13071: PPOPN 2
13073: END
// every 0 0$5 trigger backToBeria2 and FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
13074: LD_EXP 14
13078: PUSH
13079: LD_INT 8
13081: PPUSH
13082: LD_INT 22
13084: PUSH
13085: LD_INT 3
13087: PUSH
13088: EMPTY
13089: LIST
13090: LIST
13091: PUSH
13092: LD_INT 21
13094: PUSH
13095: LD_INT 1
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PPUSH
13106: CALL_OW 71
13110: PUSH
13111: LD_INT 0
13113: EQUAL
13114: AND
13115: IFFALSE 13173
13117: GO 13119
13119: DISABLE
// begin enable ;
13120: ENABLE
// if not saveBelkovObjective then
13121: LD_EXP 30
13125: NOT
13126: IFFALSE 13167
// begin case Query ( QContMission ) of 1 :
13128: LD_STRING QContMission
13130: PPUSH
13131: CALL_OW 97
13135: PUSH
13136: LD_INT 1
13138: DOUBLE
13139: EQUAL
13140: IFTRUE 13144
13142: GO 13147
13144: POP
// begin end ; 2 :
13145: GO 13167
13147: LD_INT 2
13149: DOUBLE
13150: EQUAL
13151: IFTRUE 13155
13153: GO 13166
13155: POP
// begin saveBelkovObjective = true ;
13156: LD_ADDR_EXP 30
13160: PUSH
13161: LD_INT 1
13163: ST_TO_ADDR
// end ; end ;
13164: GO 13167
13166: POP
// end ; if belkovSaved then
13167: LD_EXP 31
13171: IFFALSE 13173
// begin end ; end ;
13173: END
// function SetRewards ; begin
13174: LD_INT 0
13176: PPUSH
// case initiative of 1 :
13177: LD_EXP 35
13181: PUSH
13182: LD_INT 1
13184: DOUBLE
13185: EQUAL
13186: IFTRUE 13190
13188: GO 13203
13190: POP
// AddMedal ( Initiative , 1 ) ; 2 :
13191: LD_STRING Initiative
13193: PPUSH
13194: LD_INT 1
13196: PPUSH
13197: CALL_OW 101
13201: GO 13248
13203: LD_INT 2
13205: DOUBLE
13206: EQUAL
13207: IFTRUE 13211
13209: GO 13225
13211: POP
// AddMedal ( Initiative , - 2 ) ; 3 :
13212: LD_STRING Initiative
13214: PPUSH
13215: LD_INT 2
13217: NEG
13218: PPUSH
13219: CALL_OW 101
13223: GO 13248
13225: LD_INT 3
13227: DOUBLE
13228: EQUAL
13229: IFTRUE 13233
13231: GO 13247
13233: POP
// AddMedal ( Initiative , - 1 ) ; end ;
13234: LD_STRING Initiative
13236: PPUSH
13237: LD_INT 1
13239: NEG
13240: PPUSH
13241: CALL_OW 101
13245: GO 13248
13247: POP
// if belkovSaved and ( IsOK ( Belkov ) or IsOK ( Belkov2 ) ) then
13248: LD_EXP 31
13252: PUSH
13253: LD_EXP 53
13257: PPUSH
13258: CALL_OW 302
13262: PUSH
13263: LD_EXP 57
13267: PPUSH
13268: CALL_OW 302
13272: OR
13273: AND
13274: IFFALSE 13286
// AddMedal ( Belkov , 1 ) ;
13276: LD_STRING Belkov
13278: PPUSH
13279: LD_INT 1
13281: PPUSH
13282: CALL_OW 101
// if not belkovSaved and not saveBelkovObjective then
13286: LD_EXP 31
13290: NOT
13291: PUSH
13292: LD_EXP 30
13296: NOT
13297: AND
13298: IFFALSE 13311
// AddMedal ( Belkov , - 1 ) ;
13300: LD_STRING Belkov
13302: PPUSH
13303: LD_INT 1
13305: NEG
13306: PPUSH
13307: CALL_OW 101
// if not belkovSaved and saveBelkovObjective then
13311: LD_EXP 31
13315: NOT
13316: PUSH
13317: LD_EXP 30
13321: AND
13322: IFFALSE 13335
// AddMedal ( Belkov , - 2 ) ;
13324: LD_STRING Belkov
13326: PPUSH
13327: LD_INT 2
13329: NEG
13330: PPUSH
13331: CALL_OW 101
// if belkovSaved and ( belkovReturn and IsDead ( Belkov ) ) or ( not belkovReturn and IsDead ( Belkov2 ) ) then
13335: LD_EXP 31
13339: PUSH
13340: LD_EXP 4
13344: PUSH
13345: LD_EXP 53
13349: PPUSH
13350: CALL_OW 301
13354: AND
13355: AND
13356: PUSH
13357: LD_EXP 4
13361: NOT
13362: PUSH
13363: LD_EXP 57
13367: PPUSH
13368: CALL_OW 301
13372: AND
13373: OR
13374: IFFALSE 13387
// AddMedal ( Belkov , - 2 ) ;
13376: LD_STRING Belkov
13378: PPUSH
13379: LD_INT 2
13381: NEG
13382: PPUSH
13383: CALL_OW 101
// if lostComradesCounter = 0 then
13387: LD_EXP 36
13391: PUSH
13392: LD_INT 0
13394: EQUAL
13395: IFFALSE 13409
// AddMedal ( NoLosses , 1 ) else
13397: LD_STRING NoLosses
13399: PPUSH
13400: LD_INT 1
13402: PPUSH
13403: CALL_OW 101
13407: GO 13419
// AddMedal ( NoLosses , 0 ) ;
13409: LD_STRING NoLosses
13411: PPUSH
13412: LD_INT 0
13414: PPUSH
13415: CALL_OW 101
// GiveMedals ( Main ) ;
13419: LD_STRING Main
13421: PPUSH
13422: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
13426: LD_INT 22
13428: PUSH
13429: LD_INT 3
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: LD_INT 21
13438: PUSH
13439: LD_INT 1
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PPUSH
13450: CALL_OW 69
13454: PPUSH
13455: CALL_OW 43
// end ;
13459: LD_VAR 0 1
13463: RET
// function SavePlayerCharacters ; var others ; begin
13464: LD_INT 0
13466: PPUSH
13467: PPUSH
// ExtSaveCharacter ( Burlak , Burlak ) ;
13468: LD_EXP 51
13472: PPUSH
13473: LD_STRING Burlak
13475: PPUSH
13476: CALL 3532 0 2
// ExtSaveCharacter ( Gnyevko , Gnyevko ) ;
13480: LD_EXP 52
13484: PPUSH
13485: LD_STRING Gnyevko
13487: PPUSH
13488: CALL 3532 0 2
// ExtSaveCharacter ( Belkov , Belkov ) ;
13492: LD_EXP 53
13496: PPUSH
13497: LD_STRING Belkov
13499: PPUSH
13500: CALL 3532 0 2
// ExtSaveCharacter ( Kirilenkova , Kirilenkova ) ;
13504: LD_EXP 54
13508: PPUSH
13509: LD_STRING Kirilenkova
13511: PPUSH
13512: CALL 3532 0 2
// others = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko , Belkov , Kirilenkova ] ;
13516: LD_ADDR_VAR 0 2
13520: PUSH
13521: LD_INT 22
13523: PUSH
13524: LD_INT 3
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: PUSH
13531: LD_INT 21
13533: PUSH
13534: LD_INT 1
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PPUSH
13545: CALL_OW 69
13549: PUSH
13550: LD_EXP 51
13554: PUSH
13555: LD_EXP 52
13559: PUSH
13560: LD_EXP 53
13564: PUSH
13565: LD_EXP 54
13569: PUSH
13570: EMPTY
13571: LIST
13572: LIST
13573: LIST
13574: LIST
13575: DIFF
13576: ST_TO_ADDR
// ExtSaveCharacters ( others , other_survivors ) ;
13577: LD_VAR 0 2
13581: PPUSH
13582: LD_STRING other_survivors
13584: PPUSH
13585: CALL 3588 0 2
// end ; end_of_file
13589: LD_VAR 0 1
13593: RET
// export function BurlakIsDead ; begin
13594: LD_INT 0
13596: PPUSH
// YouLost ( Burlak ) ;
13597: LD_STRING Burlak
13599: PPUSH
13600: CALL_OW 104
// end ;
13604: LD_VAR 0 1
13608: RET
// export function AttackComrades ; begin
13609: LD_INT 0
13611: PPUSH
// YouLost ( SelfAttack ) ;
13612: LD_STRING SelfAttack
13614: PPUSH
13615: CALL_OW 104
// end ; end_of_file
13619: LD_VAR 0 1
13623: RET
// every 0 0$1 do var engs ;
13624: GO 13626
13626: DISABLE
13627: LD_INT 0
13629: PPUSH
// begin engs = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) ;
13630: LD_ADDR_VAR 0 1
13634: PUSH
13635: LD_EXP 58
13639: PPUSH
13640: LD_INT 25
13642: PUSH
13643: LD_INT 2
13645: PUSH
13646: EMPTY
13647: LIST
13648: LIST
13649: PPUSH
13650: CALL_OW 72
13654: ST_TO_ADDR
// AddComBuild ( engs , b_breastwork , 144 , 96 , 1 ) ;
13655: LD_VAR 0 1
13659: PPUSH
13660: LD_INT 31
13662: PPUSH
13663: LD_INT 144
13665: PPUSH
13666: LD_INT 96
13668: PPUSH
13669: LD_INT 1
13671: PPUSH
13672: CALL_OW 205
// AddComBuild ( engs , b_breastwork , 146 , 107 , 1 ) ;
13676: LD_VAR 0 1
13680: PPUSH
13681: LD_INT 31
13683: PPUSH
13684: LD_INT 146
13686: PPUSH
13687: LD_INT 107
13689: PPUSH
13690: LD_INT 1
13692: PPUSH
13693: CALL_OW 205
// AddComBuild ( engs , b_breastwork , 180 , 118 , 5 ) ;
13697: LD_VAR 0 1
13701: PPUSH
13702: LD_INT 31
13704: PPUSH
13705: LD_INT 180
13707: PPUSH
13708: LD_INT 118
13710: PPUSH
13711: LD_INT 5
13713: PPUSH
13714: CALL_OW 205
// AddComBuild ( engs , b_breastwork , 176 , 123 , 5 ) ;
13718: LD_VAR 0 1
13722: PPUSH
13723: LD_INT 31
13725: PPUSH
13726: LD_INT 176
13728: PPUSH
13729: LD_INT 123
13731: PPUSH
13732: LD_INT 5
13734: PPUSH
13735: CALL_OW 205
// AddComEnterUnit ( engs , kirov ) ;
13739: LD_VAR 0 1
13743: PPUSH
13744: LD_INT 71
13746: PPUSH
13747: CALL_OW 180
// end ;
13751: PPOPN 1
13753: END
// every 0 0$1 trigger activateAMAI do
13754: LD_EXP 23
13758: IFFALSE 13782
13760: GO 13762
13762: DISABLE
// begin enable ;
13763: ENABLE
// RepairDamageLeftBunkers ;
13764: CALL 13783 0 0
// if Difficulty = 3 then
13768: LD_OWVAR 67
13772: PUSH
13773: LD_INT 3
13775: EQUAL
13776: IFFALSE 13782
// RepairDamageRightBunkers ;
13778: CALL 13958 0 0
// end ;
13782: END
// function RepairDamageLeftBunkers ; var eng , bunker , leftBunker ; begin
13783: LD_INT 0
13785: PPUSH
13786: PPUSH
13787: PPUSH
13788: PPUSH
// if amLeftEngs = 0 or FilterUnitsInArea ( LeftHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_ok ] ] ] ) = 0 then
13789: LD_EXP 73
13793: PUSH
13794: LD_INT 0
13796: EQUAL
13797: PUSH
13798: LD_INT 17
13800: PPUSH
13801: LD_INT 22
13803: PUSH
13804: LD_INT 1
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: PUSH
13811: LD_INT 21
13813: PUSH
13814: LD_INT 3
13816: PUSH
13817: EMPTY
13818: LIST
13819: LIST
13820: PUSH
13821: LD_INT 3
13823: PUSH
13824: LD_INT 50
13826: PUSH
13827: EMPTY
13828: LIST
13829: PUSH
13830: EMPTY
13831: LIST
13832: LIST
13833: PUSH
13834: EMPTY
13835: LIST
13836: LIST
13837: LIST
13838: PPUSH
13839: CALL_OW 70
13843: PUSH
13844: LD_INT 0
13846: EQUAL
13847: OR
13848: IFFALSE 13852
// exit ;
13850: GO 13953
// for eng in amLeftEngs do
13852: LD_ADDR_VAR 0 2
13856: PUSH
13857: LD_EXP 73
13861: PUSH
13862: FOR_IN
13863: IFFALSE 13882
// if HasTask ( eng ) then
13865: LD_VAR 0 2
13869: PPUSH
13870: CALL_OW 314
13874: IFFALSE 13880
// exit ;
13876: POP
13877: POP
13878: GO 13953
13880: GO 13862
13882: POP
13883: POP
// ComExitBuilding ( amLeftEngs ) ;
13884: LD_EXP 73
13888: PPUSH
13889: CALL_OW 122
// for bunker in leftBunkers do
13893: LD_ADDR_VAR 0 3
13897: PUSH
13898: LD_EXP 69
13902: PUSH
13903: FOR_IN
13904: IFFALSE 13937
// if GetLives ( bunker ) < 1000 then
13906: LD_VAR 0 3
13910: PPUSH
13911: CALL_OW 256
13915: PUSH
13916: LD_INT 1000
13918: LESS
13919: IFFALSE 13935
// AddComRepairBuilding ( amLeftEngs , bunker ) ;
13921: LD_EXP 73
13925: PPUSH
13926: LD_VAR 0 3
13930: PPUSH
13931: CALL_OW 190
13935: GO 13903
13937: POP
13938: POP
// AddComEnterUnit ( amLeftEngs , amLeftDepot ) ;
13939: LD_EXP 73
13943: PPUSH
13944: LD_EXP 71
13948: PPUSH
13949: CALL_OW 180
// end ;
13953: LD_VAR 0 1
13957: RET
// function RepairDamageRightBunkers ; var eng , bunker , rightBunker ; begin
13958: LD_INT 0
13960: PPUSH
13961: PPUSH
13962: PPUSH
13963: PPUSH
// if amRightEngs = 0 or FilterUnitsInArea ( RightHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_ok ] ] ] ) = 0 then
13964: LD_EXP 74
13968: PUSH
13969: LD_INT 0
13971: EQUAL
13972: PUSH
13973: LD_INT 16
13975: PPUSH
13976: LD_INT 22
13978: PUSH
13979: LD_INT 1
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: PUSH
13986: LD_INT 21
13988: PUSH
13989: LD_INT 3
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: LD_INT 3
13998: PUSH
13999: LD_INT 50
14001: PUSH
14002: EMPTY
14003: LIST
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: LIST
14013: PPUSH
14014: CALL_OW 70
14018: PUSH
14019: LD_INT 0
14021: EQUAL
14022: OR
14023: IFFALSE 14027
// exit ;
14025: GO 14128
// for eng in amRightEngs do
14027: LD_ADDR_VAR 0 2
14031: PUSH
14032: LD_EXP 74
14036: PUSH
14037: FOR_IN
14038: IFFALSE 14057
// if HasTask ( eng ) then
14040: LD_VAR 0 2
14044: PPUSH
14045: CALL_OW 314
14049: IFFALSE 14055
// exit ;
14051: POP
14052: POP
14053: GO 14128
14055: GO 14037
14057: POP
14058: POP
// ComExitBuilding ( amRightEngs ) ;
14059: LD_EXP 74
14063: PPUSH
14064: CALL_OW 122
// for bunker in rightBunker do
14068: LD_ADDR_VAR 0 3
14072: PUSH
14073: LD_VAR 0 4
14077: PUSH
14078: FOR_IN
14079: IFFALSE 14112
// if GetLives ( bunker ) < 1000 then
14081: LD_VAR 0 3
14085: PPUSH
14086: CALL_OW 256
14090: PUSH
14091: LD_INT 1000
14093: LESS
14094: IFFALSE 14110
// AddComRepairBuilding ( amRightEngs , bunker ) ;
14096: LD_EXP 74
14100: PPUSH
14101: LD_VAR 0 3
14105: PPUSH
14106: CALL_OW 190
14110: GO 14078
14112: POP
14113: POP
// AddComEnterUnit ( amRightEngs , amRightDepot ) ;
14114: LD_EXP 74
14118: PPUSH
14119: LD_EXP 72
14123: PPUSH
14124: CALL_OW 180
// end ; end_of_file
14128: LD_VAR 0 1
14132: RET
