// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 45 0 0
// InitTag ;
   8: CALL 229 0 0
// PrepareNature ( natureArea ) ;
  12: LD_INT 2
  14: PPUSH
  15: CALL 704 0 1
// PrepareRussian ;
  19: CALL 3252 0 0
// PrepareArabian ;
  23: CALL 2626 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 2 ) ;
  33: LD_INT 2
  35: PPUSH
  36: CALL_OW 344
// Action ;
  40: CALL 6775 0 0
// end ;
  44: END
// export debug , prefix ; export ibrahimOnRuSide , ruEscapeAllowed , gameTime , loseCounter , flamethrowers , kaiaKilledByRussian , hannibalPath , ruEscapeCounter , baseHill , explodeFirstDepot , explodeSecondDepot , gaidarKilled , outerAreaAchived , earlyEscape ; function Init ; begin
  45: LD_INT 0
  47: PPUSH
// debug := false ;
  48: LD_ADDR_EXP 1
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// prefix := 04_1_ ;
  56: LD_ADDR_EXP 2
  60: PUSH
  61: LD_STRING 04_1_
  63: ST_TO_ADDR
// ibrahimOnRuSide := LoadVariable ( 03_IbrahimHasEscaped , false ) ;
  64: LD_ADDR_EXP 3
  68: PUSH
  69: LD_STRING 03_IbrahimHasEscaped
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: CALL_OW 30
  79: ST_TO_ADDR
// ruEscapeCounter := LoadVariable ( 04_1_EscapeCounter , 0 ) ;
  80: LD_ADDR_EXP 10
  84: PUSH
  85: LD_STRING 04_1_EscapeCounter
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// loseCounter := LoadVariable ( 04_1_DeadCounter , 0 ) ;
  96: LD_ADDR_EXP 6
 100: PUSH
 101: LD_STRING 04_1_DeadCounter
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// baseHill := LoadVariable ( 04_1_BaseHill , false ) ;
 112: LD_ADDR_EXP 11
 116: PUSH
 117: LD_STRING 04_1_BaseHill
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL_OW 30
 127: ST_TO_ADDR
// gameTime := LoadVariable ( 04_1_Time , 40 40$00 ) ;
 128: LD_ADDR_EXP 5
 132: PUSH
 133: LD_STRING 04_1_Time
 135: PPUSH
 136: LD_INT 84000
 138: PPUSH
 139: CALL_OW 30
 143: ST_TO_ADDR
// flamethrowers := LoadVariable ( 04_1_Flamethrower , 0 ) ;
 144: LD_ADDR_EXP 7
 148: PUSH
 149: LD_STRING 04_1_Flamethrower
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: CALL_OW 30
 159: ST_TO_ADDR
// ruEscapeAllowed := false ;
 160: LD_ADDR_EXP 4
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// explodeFirstDepot := false ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// explodeSecondDepot := false ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// gaidarKilled := false ;
 184: LD_ADDR_EXP 14
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// kaiaKilledByRussian := false ;
 192: LD_ADDR_EXP 8
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// outerAreaAchived := false ;
 200: LD_ADDR_EXP 15
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// hannibalPath := false ;
 208: LD_ADDR_EXP 9
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// earlyEscape := false ;
 216: LD_ADDR_EXP 16
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// export tEscape ; function InitTag ; begin
 229: LD_INT 0
 231: PPUSH
// tEscape := 10 ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: LD_INT 10
 239: ST_TO_ADDR
// end ;
 240: LD_VAR 0 1
 244: RET
// every 0 0$1 trigger debug do var i ;
 245: LD_EXP 1
 249: IFFALSE 333
 251: GO 253
 253: DISABLE
 254: LD_INT 0
 256: PPUSH
// begin enable ;
 257: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) do
 258: LD_ADDR_VAR 0 1
 262: PUSH
 263: LD_INT 22
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: LD_INT 21
 278: PUSH
 279: LD_INT 3
 281: PUSH
 282: EMPTY
 283: LIST
 284: LIST
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: FOR_IN
 300: IFFALSE 331
// if GetLives ( i ) < 1000 then
 302: LD_VAR 0 1
 306: PPUSH
 307: CALL_OW 256
 311: PUSH
 312: LD_INT 1000
 314: LESS
 315: IFFALSE 329
// SetLives ( i , 1000 ) ;
 317: LD_VAR 0 1
 321: PPUSH
 322: LD_INT 1000
 324: PPUSH
 325: CALL_OW 234
 329: GO 299
 331: POP
 332: POP
// end ; end_of_file
 333: PPOPN 1
 335: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 336: LD_INT 0
 338: PPUSH
 339: PPUSH
// if exist_mode then
 340: LD_VAR 0 2
 344: IFFALSE 369
// unit := CreateCharacter ( prefix & ident ) else
 346: LD_ADDR_VAR 0 5
 350: PUSH
 351: LD_VAR 0 3
 355: PUSH
 356: LD_VAR 0 1
 360: STR
 361: PPUSH
 362: CALL_OW 34
 366: ST_TO_ADDR
 367: GO 384
// unit := NewCharacter ( ident ) ;
 369: LD_ADDR_VAR 0 5
 373: PUSH
 374: LD_VAR 0 1
 378: PPUSH
 379: CALL_OW 25
 383: ST_TO_ADDR
// result := unit ;
 384: LD_ADDR_VAR 0 4
 388: PUSH
 389: LD_VAR 0 5
 393: ST_TO_ADDR
// end ;
 394: LD_VAR 0 4
 398: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 399: LD_INT 0
 401: PPUSH
// uc_side := side ;
 402: LD_ADDR_OWVAR 20
 406: PUSH
 407: LD_VAR 0 1
 411: ST_TO_ADDR
// uc_nation := nation ;
 412: LD_ADDR_OWVAR 21
 416: PUSH
 417: LD_VAR 0 2
 421: ST_TO_ADDR
// vc_chassis := chassis ;
 422: LD_ADDR_OWVAR 37
 426: PUSH
 427: LD_VAR 0 3
 431: ST_TO_ADDR
// vc_engine := engine ;
 432: LD_ADDR_OWVAR 39
 436: PUSH
 437: LD_VAR 0 4
 441: ST_TO_ADDR
// vc_control := control ;
 442: LD_ADDR_OWVAR 38
 446: PUSH
 447: LD_VAR 0 5
 451: ST_TO_ADDR
// vc_weapon := weapon ;
 452: LD_ADDR_OWVAR 40
 456: PUSH
 457: LD_VAR 0 6
 461: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 462: LD_ADDR_OWVAR 41
 466: PUSH
 467: LD_VAR 0 7
 471: ST_TO_ADDR
// result := CreateVehicle ;
 472: LD_ADDR_VAR 0 8
 476: PUSH
 477: CALL_OW 45
 481: ST_TO_ADDR
// end ;
 482: LD_VAR 0 8
 486: RET
// export function SayX ( units , ident ) ; var i ; begin
 487: LD_INT 0
 489: PPUSH
 490: PPUSH
// result := false ;
 491: LD_ADDR_VAR 0 3
 495: PUSH
 496: LD_INT 0
 498: ST_TO_ADDR
// if not units then
 499: LD_VAR 0 1
 503: NOT
 504: IFFALSE 508
// exit ;
 506: GO 562
// for i in units do
 508: LD_ADDR_VAR 0 4
 512: PUSH
 513: LD_VAR 0 1
 517: PUSH
 518: FOR_IN
 519: IFFALSE 560
// if IsOk ( i ) then
 521: LD_VAR 0 4
 525: PPUSH
 526: CALL_OW 302
 530: IFFALSE 558
// begin Say ( i , ident ) ;
 532: LD_VAR 0 4
 536: PPUSH
 537: LD_VAR 0 2
 541: PPUSH
 542: CALL_OW 88
// result := i ;
 546: LD_ADDR_VAR 0 3
 550: PUSH
 551: LD_VAR 0 4
 555: ST_TO_ADDR
// break ;
 556: GO 560
// end ;
 558: GO 518
 560: POP
 561: POP
// end ;
 562: LD_VAR 0 3
 566: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 567: LD_INT 0
 569: PPUSH
 570: PPUSH
// InitUc ;
 571: CALL_OW 18
// InitHc ;
 575: CALL_OW 19
// uc_side := 0 ;
 579: LD_ADDR_OWVAR 20
 583: PUSH
 584: LD_INT 0
 586: ST_TO_ADDR
// uc_nation := 0 ;
 587: LD_ADDR_OWVAR 21
 591: PUSH
 592: LD_INT 0
 594: ST_TO_ADDR
// for i = 1 to amount do
 595: LD_ADDR_VAR 0 4
 599: PUSH
 600: DOUBLE
 601: LD_INT 1
 603: DEC
 604: ST_TO_ADDR
 605: LD_VAR 0 2
 609: PUSH
 610: FOR_TO
 611: IFFALSE 693
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 613: LD_ADDR_OWVAR 29
 617: PUSH
 618: LD_INT 9
 620: PPUSH
 621: LD_INT 12
 623: PPUSH
 624: CALL_OW 12
 628: PUSH
 629: LD_INT 9
 631: PPUSH
 632: LD_INT 12
 634: PPUSH
 635: CALL_OW 12
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 644: LD_ADDR_OWVAR 35
 648: PUSH
 649: LD_INT 1
 651: NEG
 652: PPUSH
 653: LD_INT 1
 655: PPUSH
 656: CALL_OW 12
 660: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 661: LD_INT 0
 663: PPUSH
 664: LD_INT 12
 666: PPUSH
 667: LD_INT 1
 669: PPUSH
 670: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 674: CALL_OW 44
 678: PPUSH
 679: LD_VAR 0 1
 683: PPUSH
 684: LD_INT 0
 686: PPUSH
 687: CALL_OW 49
// end ;
 691: GO 610
 693: POP
 694: POP
// InitHc ;
 695: CALL_OW 19
// end ;
 699: LD_VAR 0 3
 703: RET
// export function PrepareNature ( forest ) ; var i ; begin
 704: LD_INT 0
 706: PPUSH
 707: PPUSH
// SpawnApeman ( forest , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
 708: LD_VAR 0 1
 712: PPUSH
 713: LD_INT 3
 715: PUSH
 716: LD_INT 3
 718: PUSH
 719: LD_INT 2
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_OWVAR 67
 731: ARRAY
 732: PPUSH
 733: CALL 567 0 2
// for i := 1 to 2 do
 737: LD_ADDR_VAR 0 3
 741: PUSH
 742: DOUBLE
 743: LD_INT 1
 745: DEC
 746: ST_TO_ADDR
 747: LD_INT 2
 749: PUSH
 750: FOR_TO
 751: IFFALSE 788
// begin hc_class := 21 ;
 753: LD_ADDR_OWVAR 28
 757: PUSH
 758: LD_INT 21
 760: ST_TO_ADDR
// hc_gallery :=  ;
 761: LD_ADDR_OWVAR 33
 765: PUSH
 766: LD_STRING 
 768: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 769: CALL_OW 44
 773: PPUSH
 774: LD_VAR 0 1
 778: PPUSH
 779: LD_INT 0
 781: PPUSH
 782: CALL_OW 49
// end ;
 786: GO 750
 788: POP
 789: POP
// for i := 1 to 2 do
 790: LD_ADDR_VAR 0 3
 794: PUSH
 795: DOUBLE
 796: LD_INT 1
 798: DEC
 799: ST_TO_ADDR
 800: LD_INT 2
 802: PUSH
 803: FOR_TO
 804: IFFALSE 841
// begin hc_class := 18 ;
 806: LD_ADDR_OWVAR 28
 810: PUSH
 811: LD_INT 18
 813: ST_TO_ADDR
// hc_gallery :=  ;
 814: LD_ADDR_OWVAR 33
 818: PUSH
 819: LD_STRING 
 821: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 822: CALL_OW 44
 826: PPUSH
 827: LD_VAR 0 1
 831: PPUSH
 832: LD_INT 0
 834: PPUSH
 835: CALL_OW 49
// end ;
 839: GO 803
 841: POP
 842: POP
// for i := 1 to 2 do
 843: LD_ADDR_VAR 0 3
 847: PUSH
 848: DOUBLE
 849: LD_INT 1
 851: DEC
 852: ST_TO_ADDR
 853: LD_INT 2
 855: PUSH
 856: FOR_TO
 857: IFFALSE 894
// begin hc_class := 13 ;
 859: LD_ADDR_OWVAR 28
 863: PUSH
 864: LD_INT 13
 866: ST_TO_ADDR
// hc_gallery :=  ;
 867: LD_ADDR_OWVAR 33
 871: PUSH
 872: LD_STRING 
 874: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 875: CALL_OW 44
 879: PPUSH
 880: LD_VAR 0 1
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// end ;
 892: GO 856
 894: POP
 895: POP
// end ;
 896: LD_VAR 0 2
 900: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 901: LD_INT 0
 903: PPUSH
 904: PPUSH
 905: PPUSH
// if not observer or not unit then
 906: LD_VAR 0 1
 910: NOT
 911: PUSH
 912: LD_VAR 0 2
 916: NOT
 917: OR
 918: IFFALSE 922
// exit ;
 920: GO 970
// if not See ( GetSide ( observer ) , unit ) then
 922: LD_VAR 0 1
 926: PPUSH
 927: CALL_OW 255
 931: PPUSH
 932: LD_VAR 0 2
 936: PPUSH
 937: CALL_OW 292
 941: NOT
 942: IFFALSE 946
// exit ;
 944: GO 970
// result := GetDistUnits ( observer , unit ) < 12 ;
 946: LD_ADDR_VAR 0 3
 950: PUSH
 951: LD_VAR 0 1
 955: PPUSH
 956: LD_VAR 0 2
 960: PPUSH
 961: CALL_OW 296
 965: PUSH
 966: LD_INT 12
 968: LESS
 969: ST_TO_ADDR
// end ;
 970: LD_VAR 0 3
 974: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 975: LD_INT 0
 977: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 978: LD_VAR 0 2
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: LD_VAR 0 2
 991: PUSH
 992: LD_INT 2
 994: ARRAY
 995: PPUSH
 996: CALL_OW 488
1000: PUSH
1001: LD_VAR 0 2
1005: PUSH
1006: LD_INT 1
1008: ARRAY
1009: PPUSH
1010: LD_VAR 0 2
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 428
1023: PUSH
1024: LD_INT 0
1026: EQUAL
1027: AND
1028: IFFALSE 1062
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
1030: LD_VAR 0 1
1034: PPUSH
1035: LD_VAR 0 2
1039: PUSH
1040: LD_INT 1
1042: ARRAY
1043: PPUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_INT 2
1051: ARRAY
1052: PPUSH
1053: LD_VAR 0 3
1057: PPUSH
1058: CALL_OW 48
// end ;
1062: LD_VAR 0 4
1066: RET
// export function Video ( mode ) ; begin
1067: LD_INT 0
1069: PPUSH
// ingame_video = mode ;
1070: LD_ADDR_OWVAR 52
1074: PUSH
1075: LD_VAR 0 1
1079: ST_TO_ADDR
// interface_hidden = mode ;
1080: LD_ADDR_OWVAR 54
1084: PUSH
1085: LD_VAR 0 1
1089: ST_TO_ADDR
// end ;
1090: LD_VAR 0 2
1094: RET
// export function ReverseArray ( array ) ; var i ; begin
1095: LD_INT 0
1097: PPUSH
1098: PPUSH
// if not array then
1099: LD_VAR 0 1
1103: NOT
1104: IFFALSE 1108
// exit ;
1106: GO 1166
// result := [ ] ;
1108: LD_ADDR_VAR 0 2
1112: PUSH
1113: EMPTY
1114: ST_TO_ADDR
// for i := 1 to array do
1115: LD_ADDR_VAR 0 3
1119: PUSH
1120: DOUBLE
1121: LD_INT 1
1123: DEC
1124: ST_TO_ADDR
1125: LD_VAR 0 1
1129: PUSH
1130: FOR_TO
1131: IFFALSE 1164
// result := Insert ( result , 1 , array [ i ] ) ;
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 2
1142: PPUSH
1143: LD_INT 1
1145: PPUSH
1146: LD_VAR 0 1
1150: PUSH
1151: LD_VAR 0 3
1155: ARRAY
1156: PPUSH
1157: CALL_OW 2
1161: ST_TO_ADDR
1162: GO 1130
1164: POP
1165: POP
// end ;
1166: LD_VAR 0 2
1170: RET
// export function ComExit ( unit ) ; begin
1171: LD_INT 0
1173: PPUSH
// result := IsInUnit ( unit ) ;
1174: LD_ADDR_VAR 0 2
1178: PUSH
1179: LD_VAR 0 1
1183: PPUSH
1184: CALL_OW 310
1188: ST_TO_ADDR
// if not result then
1189: LD_VAR 0 2
1193: NOT
1194: IFFALSE 1198
// exit ;
1196: GO 1233
// if GetType ( result ) = unit_vehicle then
1198: LD_VAR 0 2
1202: PPUSH
1203: CALL_OW 247
1207: PUSH
1208: LD_INT 2
1210: EQUAL
1211: IFFALSE 1224
// ComExitVehicle ( unit ) else
1213: LD_VAR 0 1
1217: PPUSH
1218: CALL_OW 121
1222: GO 1233
// ComExitBuilding ( unit ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: CALL_OW 122
// end ;
1233: LD_VAR 0 2
1237: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1238: LD_INT 0
1240: PPUSH
1241: PPUSH
// if not side or not nation then
1242: LD_VAR 0 1
1246: NOT
1247: PUSH
1248: LD_VAR 0 2
1252: NOT
1253: OR
1254: IFFALSE 1258
// exit ;
1256: GO 2022
// case nation of nation_american :
1258: LD_VAR 0 2
1262: PUSH
1263: LD_INT 1
1265: DOUBLE
1266: EQUAL
1267: IFTRUE 1271
1269: GO 1485
1271: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1272: LD_ADDR_VAR 0 4
1276: PUSH
1277: LD_INT 35
1279: PUSH
1280: LD_INT 45
1282: PUSH
1283: LD_INT 46
1285: PUSH
1286: LD_INT 47
1288: PUSH
1289: LD_INT 82
1291: PUSH
1292: LD_INT 83
1294: PUSH
1295: LD_INT 84
1297: PUSH
1298: LD_INT 85
1300: PUSH
1301: LD_INT 86
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: LD_INT 2
1309: PUSH
1310: LD_INT 6
1312: PUSH
1313: LD_INT 15
1315: PUSH
1316: LD_INT 16
1318: PUSH
1319: LD_INT 7
1321: PUSH
1322: LD_INT 12
1324: PUSH
1325: LD_INT 13
1327: PUSH
1328: LD_INT 10
1330: PUSH
1331: LD_INT 14
1333: PUSH
1334: LD_INT 20
1336: PUSH
1337: LD_INT 21
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_INT 25
1345: PUSH
1346: LD_INT 32
1348: PUSH
1349: LD_INT 27
1351: PUSH
1352: LD_INT 36
1354: PUSH
1355: LD_INT 69
1357: PUSH
1358: LD_INT 39
1360: PUSH
1361: LD_INT 34
1363: PUSH
1364: LD_INT 40
1366: PUSH
1367: LD_INT 48
1369: PUSH
1370: LD_INT 49
1372: PUSH
1373: LD_INT 50
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 52
1381: PUSH
1382: LD_INT 53
1384: PUSH
1385: LD_INT 54
1387: PUSH
1388: LD_INT 55
1390: PUSH
1391: LD_INT 56
1393: PUSH
1394: LD_INT 57
1396: PUSH
1397: LD_INT 58
1399: PUSH
1400: LD_INT 59
1402: PUSH
1403: LD_INT 60
1405: PUSH
1406: LD_INT 61
1408: PUSH
1409: LD_INT 62
1411: PUSH
1412: LD_INT 80
1414: PUSH
1415: LD_INT 82
1417: PUSH
1418: LD_INT 83
1420: PUSH
1421: LD_INT 84
1423: PUSH
1424: LD_INT 85
1426: PUSH
1427: LD_INT 86
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: ST_TO_ADDR
1483: GO 1946
1485: LD_INT 2
1487: DOUBLE
1488: EQUAL
1489: IFTRUE 1493
1491: GO 1715
1493: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_INT 35
1501: PUSH
1502: LD_INT 45
1504: PUSH
1505: LD_INT 46
1507: PUSH
1508: LD_INT 47
1510: PUSH
1511: LD_INT 82
1513: PUSH
1514: LD_INT 83
1516: PUSH
1517: LD_INT 84
1519: PUSH
1520: LD_INT 85
1522: PUSH
1523: LD_INT 87
1525: PUSH
1526: LD_INT 70
1528: PUSH
1529: LD_INT 1
1531: PUSH
1532: LD_INT 11
1534: PUSH
1535: LD_INT 3
1537: PUSH
1538: LD_INT 4
1540: PUSH
1541: LD_INT 5
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: LD_INT 15
1549: PUSH
1550: LD_INT 18
1552: PUSH
1553: LD_INT 7
1555: PUSH
1556: LD_INT 17
1558: PUSH
1559: LD_INT 8
1561: PUSH
1562: LD_INT 20
1564: PUSH
1565: LD_INT 21
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: LD_INT 72
1573: PUSH
1574: LD_INT 26
1576: PUSH
1577: LD_INT 69
1579: PUSH
1580: LD_INT 39
1582: PUSH
1583: LD_INT 40
1585: PUSH
1586: LD_INT 41
1588: PUSH
1589: LD_INT 42
1591: PUSH
1592: LD_INT 43
1594: PUSH
1595: LD_INT 48
1597: PUSH
1598: LD_INT 49
1600: PUSH
1601: LD_INT 50
1603: PUSH
1604: LD_INT 51
1606: PUSH
1607: LD_INT 52
1609: PUSH
1610: LD_INT 53
1612: PUSH
1613: LD_INT 54
1615: PUSH
1616: LD_INT 55
1618: PUSH
1619: LD_INT 56
1621: PUSH
1622: LD_INT 60
1624: PUSH
1625: LD_INT 61
1627: PUSH
1628: LD_INT 62
1630: PUSH
1631: LD_INT 66
1633: PUSH
1634: LD_INT 67
1636: PUSH
1637: LD_INT 68
1639: PUSH
1640: LD_INT 81
1642: PUSH
1643: LD_INT 82
1645: PUSH
1646: LD_INT 83
1648: PUSH
1649: LD_INT 84
1651: PUSH
1652: LD_INT 85
1654: PUSH
1655: LD_INT 87
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: LIST
1711: LIST
1712: ST_TO_ADDR
1713: GO 1946
1715: LD_INT 3
1717: DOUBLE
1718: EQUAL
1719: IFTRUE 1723
1721: GO 1945
1723: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_INT 46
1731: PUSH
1732: LD_INT 47
1734: PUSH
1735: LD_INT 1
1737: PUSH
1738: LD_INT 2
1740: PUSH
1741: LD_INT 82
1743: PUSH
1744: LD_INT 83
1746: PUSH
1747: LD_INT 84
1749: PUSH
1750: LD_INT 85
1752: PUSH
1753: LD_INT 86
1755: PUSH
1756: LD_INT 11
1758: PUSH
1759: LD_INT 9
1761: PUSH
1762: LD_INT 20
1764: PUSH
1765: LD_INT 19
1767: PUSH
1768: LD_INT 21
1770: PUSH
1771: LD_INT 24
1773: PUSH
1774: LD_INT 22
1776: PUSH
1777: LD_INT 25
1779: PUSH
1780: LD_INT 28
1782: PUSH
1783: LD_INT 29
1785: PUSH
1786: LD_INT 30
1788: PUSH
1789: LD_INT 31
1791: PUSH
1792: LD_INT 37
1794: PUSH
1795: LD_INT 38
1797: PUSH
1798: LD_INT 32
1800: PUSH
1801: LD_INT 27
1803: PUSH
1804: LD_INT 33
1806: PUSH
1807: LD_INT 69
1809: PUSH
1810: LD_INT 39
1812: PUSH
1813: LD_INT 34
1815: PUSH
1816: LD_INT 40
1818: PUSH
1819: LD_INT 71
1821: PUSH
1822: LD_INT 23
1824: PUSH
1825: LD_INT 44
1827: PUSH
1828: LD_INT 48
1830: PUSH
1831: LD_INT 49
1833: PUSH
1834: LD_INT 50
1836: PUSH
1837: LD_INT 51
1839: PUSH
1840: LD_INT 52
1842: PUSH
1843: LD_INT 53
1845: PUSH
1846: LD_INT 54
1848: PUSH
1849: LD_INT 55
1851: PUSH
1852: LD_INT 56
1854: PUSH
1855: LD_INT 57
1857: PUSH
1858: LD_INT 58
1860: PUSH
1861: LD_INT 59
1863: PUSH
1864: LD_INT 63
1866: PUSH
1867: LD_INT 64
1869: PUSH
1870: LD_INT 65
1872: PUSH
1873: LD_INT 82
1875: PUSH
1876: LD_INT 83
1878: PUSH
1879: LD_INT 84
1881: PUSH
1882: LD_INT 85
1884: PUSH
1885: LD_INT 86
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: ST_TO_ADDR
1943: GO 1946
1945: POP
// if state > - 1 and state < 3 then
1946: LD_VAR 0 3
1950: PUSH
1951: LD_INT 1
1953: NEG
1954: GREATER
1955: PUSH
1956: LD_VAR 0 3
1960: PUSH
1961: LD_INT 3
1963: LESS
1964: AND
1965: IFFALSE 2022
// for i in result do
1967: LD_ADDR_VAR 0 5
1971: PUSH
1972: LD_VAR 0 4
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2020
// if GetTech ( i , side ) <> state then
1980: LD_VAR 0 5
1984: PPUSH
1985: LD_VAR 0 1
1989: PPUSH
1990: CALL_OW 321
1994: PUSH
1995: LD_VAR 0 3
1999: NONEQUAL
2000: IFFALSE 2018
// result := result diff i ;
2002: LD_ADDR_VAR 0 4
2006: PUSH
2007: LD_VAR 0 4
2011: PUSH
2012: LD_VAR 0 5
2016: DIFF
2017: ST_TO_ADDR
2018: GO 1977
2020: POP
2021: POP
// end ;
2022: LD_VAR 0 4
2026: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
2027: LD_INT 0
2029: PPUSH
2030: PPUSH
2031: PPUSH
2032: PPUSH
// if not list then
2033: LD_VAR 0 3
2037: NOT
2038: IFFALSE 2042
// exit ;
2040: GO 2350
// result := [ ] ;
2042: LD_ADDR_VAR 0 5
2046: PUSH
2047: EMPTY
2048: ST_TO_ADDR
// for i in list do
2049: LD_ADDR_VAR 0 6
2053: PUSH
2054: LD_VAR 0 3
2058: PUSH
2059: FOR_IN
2060: IFFALSE 2262
// begin tmp := GetDistUnitXY ( i , x , y ) ;
2062: LD_ADDR_VAR 0 8
2066: PUSH
2067: LD_VAR 0 6
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: LD_VAR 0 2
2081: PPUSH
2082: CALL_OW 297
2086: ST_TO_ADDR
// if not result then
2087: LD_VAR 0 5
2091: NOT
2092: IFFALSE 2118
// result := [ [ i , tmp ] ] else
2094: LD_ADDR_VAR 0 5
2098: PUSH
2099: LD_VAR 0 6
2103: PUSH
2104: LD_VAR 0 8
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: EMPTY
2114: LIST
2115: ST_TO_ADDR
2116: GO 2260
// begin if result [ result ] [ 2 ] < tmp then
2118: LD_VAR 0 5
2122: PUSH
2123: LD_VAR 0 5
2127: ARRAY
2128: PUSH
2129: LD_INT 2
2131: ARRAY
2132: PUSH
2133: LD_VAR 0 8
2137: LESS
2138: IFFALSE 2180
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
2140: LD_ADDR_VAR 0 5
2144: PUSH
2145: LD_VAR 0 5
2149: PPUSH
2150: LD_VAR 0 5
2154: PUSH
2155: LD_INT 1
2157: PLUS
2158: PPUSH
2159: LD_VAR 0 6
2163: PUSH
2164: LD_VAR 0 8
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PPUSH
2173: CALL_OW 2
2177: ST_TO_ADDR
2178: GO 2260
// for j = 1 to result do
2180: LD_ADDR_VAR 0 7
2184: PUSH
2185: DOUBLE
2186: LD_INT 1
2188: DEC
2189: ST_TO_ADDR
2190: LD_VAR 0 5
2194: PUSH
2195: FOR_TO
2196: IFFALSE 2258
// begin if tmp < result [ j ] [ 2 ] then
2198: LD_VAR 0 8
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_VAR 0 7
2212: ARRAY
2213: PUSH
2214: LD_INT 2
2216: ARRAY
2217: LESS
2218: IFFALSE 2256
// begin result := Insert ( result , j , [ i , tmp ] ) ;
2220: LD_ADDR_VAR 0 5
2224: PUSH
2225: LD_VAR 0 5
2229: PPUSH
2230: LD_VAR 0 7
2234: PPUSH
2235: LD_VAR 0 6
2239: PUSH
2240: LD_VAR 0 8
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PPUSH
2249: CALL_OW 2
2253: ST_TO_ADDR
// break ;
2254: GO 2258
// end ; end ;
2256: GO 2195
2258: POP
2259: POP
// end ; end ;
2260: GO 2059
2262: POP
2263: POP
// if result and not asc then
2264: LD_VAR 0 5
2268: PUSH
2269: LD_VAR 0 4
2273: NOT
2274: AND
2275: IFFALSE 2350
// begin tmp := result ;
2277: LD_ADDR_VAR 0 8
2281: PUSH
2282: LD_VAR 0 5
2286: ST_TO_ADDR
// for i = tmp downto 1 do
2287: LD_ADDR_VAR 0 6
2291: PUSH
2292: DOUBLE
2293: LD_VAR 0 8
2297: INC
2298: ST_TO_ADDR
2299: LD_INT 1
2301: PUSH
2302: FOR_DOWNTO
2303: IFFALSE 2348
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PPUSH
2315: LD_VAR 0 8
2319: PUSH
2320: LD_VAR 0 6
2324: MINUS
2325: PUSH
2326: LD_INT 1
2328: PLUS
2329: PPUSH
2330: LD_VAR 0 8
2334: PUSH
2335: LD_VAR 0 6
2339: ARRAY
2340: PPUSH
2341: CALL_OW 1
2345: ST_TO_ADDR
2346: GO 2302
2348: POP
2349: POP
// end ; end ;
2350: LD_VAR 0 5
2354: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
2355: LD_INT 0
2357: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
2358: LD_ADDR_VAR 0 4
2362: PUSH
2363: LD_VAR 0 1
2367: PPUSH
2368: CALL_OW 250
2372: PPUSH
2373: LD_VAR 0 1
2377: PPUSH
2378: CALL_OW 251
2382: PPUSH
2383: LD_VAR 0 2
2387: PPUSH
2388: LD_VAR 0 3
2392: PPUSH
2393: CALL 2027 0 4
2397: ST_TO_ADDR
// end ;
2398: LD_VAR 0 4
2402: RET
// export function NearestEmptyBuilding ( unit , btype ) ; var side , tmp , i , places ; begin
2403: LD_INT 0
2405: PPUSH
2406: PPUSH
2407: PPUSH
2408: PPUSH
2409: PPUSH
// if not unit then
2410: LD_VAR 0 1
2414: NOT
2415: IFFALSE 2419
// exit ;
2417: GO 2621
// side := GetSide ( unit ) ;
2419: LD_ADDR_VAR 0 4
2423: PUSH
2424: LD_VAR 0 1
2428: PPUSH
2429: CALL_OW 255
2433: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
2434: LD_ADDR_VAR 0 5
2438: PUSH
2439: LD_INT 22
2441: PUSH
2442: LD_VAR 0 4
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: PUSH
2451: LD_INT 30
2453: PUSH
2454: LD_VAR 0 2
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PPUSH
2467: CALL_OW 69
2471: ST_TO_ADDR
// if not tmp then
2472: LD_VAR 0 5
2476: NOT
2477: IFFALSE 2481
// exit ;
2479: GO 2621
// tmp := SortByDistanceUnit ( unit , tmp , true ) ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 1
2490: PPUSH
2491: LD_VAR 0 5
2495: PPUSH
2496: LD_INT 1
2498: PPUSH
2499: CALL 2355 0 3
2503: ST_TO_ADDR
// places := 1 ;
2504: LD_ADDR_VAR 0 7
2508: PUSH
2509: LD_INT 1
2511: ST_TO_ADDR
// if btype in [ b_depot , b_warehouse , b_armoury , b_barracks , b_workshop , b_factory , b_lab , b_lab_half , b_lab_full ] then
2512: LD_VAR 0 2
2516: PUSH
2517: LD_INT 0
2519: PUSH
2520: LD_INT 1
2522: PUSH
2523: LD_INT 4
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: LD_INT 2
2531: PUSH
2532: LD_INT 3
2534: PUSH
2535: LD_INT 6
2537: PUSH
2538: LD_INT 7
2540: PUSH
2541: LD_INT 8
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: LIST
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: IN
2555: IFFALSE 2565
// places := 6 ;
2557: LD_ADDR_VAR 0 7
2561: PUSH
2562: LD_INT 6
2564: ST_TO_ADDR
// for i in tmp do
2565: LD_ADDR_VAR 0 6
2569: PUSH
2570: LD_VAR 0 5
2574: PUSH
2575: FOR_IN
2576: IFFALSE 2619
// begin if UnitsInside ( i ) - places <= 0 then
2578: LD_VAR 0 6
2582: PPUSH
2583: CALL_OW 313
2587: PUSH
2588: LD_VAR 0 7
2592: MINUS
2593: PUSH
2594: LD_INT 0
2596: LESSEQUAL
2597: IFFALSE 2603
// continue else
2599: GO 2575
2601: GO 2617
// begin result := i ;
2603: LD_ADDR_VAR 0 3
2607: PUSH
2608: LD_VAR 0 6
2612: ST_TO_ADDR
// exit ;
2613: POP
2614: POP
2615: GO 2621
// end ; end ;
2617: GO 2575
2619: POP
2620: POP
// end ; end_of_file
2621: LD_VAR 0 3
2625: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Shariff , Kurt , Aviradze , heikeSecondSquad , heikeVehicles , heikeApes ; export function PrepareArabian ; var i ; begin
2626: LD_INT 0
2628: PPUSH
2629: PPUSH
// uc_side := 2 ;
2630: LD_ADDR_OWVAR 20
2634: PUSH
2635: LD_INT 2
2637: ST_TO_ADDR
// uc_nation := 2 ;
2638: LD_ADDR_OWVAR 21
2642: PUSH
2643: LD_INT 2
2645: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2646: LD_ADDR_EXP 18
2650: PUSH
2651: LD_STRING Heike
2653: PPUSH
2654: LD_EXP 1
2658: NOT
2659: PPUSH
2660: LD_EXP 2
2664: PPUSH
2665: CALL 336 0 3
2669: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
2670: LD_ADDR_EXP 21
2674: PUSH
2675: LD_STRING Ibrahim
2677: PPUSH
2678: LD_EXP 1
2682: NOT
2683: PPUSH
2684: LD_EXP 2
2688: PPUSH
2689: CALL 336 0 3
2693: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2694: LD_ADDR_EXP 19
2698: PUSH
2699: LD_STRING Givi
2701: PPUSH
2702: LD_EXP 1
2706: NOT
2707: PPUSH
2708: LD_EXP 2
2712: PPUSH
2713: CALL 336 0 3
2717: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2718: LD_ADDR_EXP 22
2722: PUSH
2723: LD_STRING Kamil
2725: PPUSH
2726: LD_EXP 1
2730: NOT
2731: PPUSH
2732: LD_EXP 2
2736: PPUSH
2737: CALL 336 0 3
2741: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2742: LD_ADDR_EXP 23
2746: PUSH
2747: LD_STRING Kaia
2749: PPUSH
2750: LD_EXP 1
2754: NOT
2755: PPUSH
2756: LD_EXP 2
2760: PPUSH
2761: CALL 336 0 3
2765: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2766: LD_ADDR_EXP 24
2770: PUSH
2771: LD_STRING Sophia
2773: PPUSH
2774: LD_EXP 1
2778: NOT
2779: PPUSH
2780: LD_EXP 2
2784: PPUSH
2785: CALL 336 0 3
2789: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2790: LD_ADDR_EXP 25
2794: PUSH
2795: LD_STRING Markov
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_EXP 2
2808: PPUSH
2809: CALL 336 0 3
2813: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2814: LD_ADDR_EXP 28
2818: PUSH
2819: LD_STRING Aviradze
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_EXP 2
2832: PPUSH
2833: CALL 336 0 3
2837: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , false ,  ) ;
2838: LD_ADDR_EXP 27
2842: PUSH
2843: LD_STRING Kurt
2845: PPUSH
2846: LD_INT 0
2848: PPUSH
2849: LD_STRING 
2851: PPUSH
2852: CALL 336 0 3
2856: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2857: LD_ADDR_EXP 20
2861: PUSH
2862: LD_STRING Mike
2864: PPUSH
2865: LD_EXP 1
2869: NOT
2870: PPUSH
2871: LD_EXP 2
2875: PPUSH
2876: CALL 336 0 3
2880: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_1_others ) ;
2881: LD_ADDR_EXP 29
2885: PUSH
2886: LD_STRING 04_1_others
2888: PPUSH
2889: CALL_OW 31
2893: ST_TO_ADDR
// heikeApes := CreateCharacterSet ( 04_1_apes ) ;
2894: LD_ADDR_EXP 31
2898: PUSH
2899: LD_STRING 04_1_apes
2901: PPUSH
2902: CALL_OW 31
2906: ST_TO_ADDR
// heikeVehicles := LoadVariable ( 04_1_Vehicles , [ ] ) ;
2907: LD_ADDR_EXP 30
2911: PUSH
2912: LD_STRING 04_1_Vehicles
2914: PPUSH
2915: EMPTY
2916: PPUSH
2917: CALL_OW 30
2921: ST_TO_ADDR
// uc_side := 5 ;
2922: LD_ADDR_OWVAR 20
2926: PUSH
2927: LD_INT 5
2929: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
2930: LD_ADDR_EXP 26
2934: PUSH
2935: LD_STRING Abdul
2937: PPUSH
2938: LD_INT 0
2940: PPUSH
2941: LD_STRING 
2943: PPUSH
2944: CALL 336 0 3
2948: ST_TO_ADDR
// end ;
2949: LD_VAR 0 1
2953: RET
// export cargoDriver ; every 2 2$00 trigger LoadVariable ( 04_1_KaganCaptured , 0 ) and HexInfo ( 124 , 26 ) = 0 xor GetSide ( HexInfo ( 124 , 26 ) ) = 2 do var veh ;
2954: LD_STRING 04_1_KaganCaptured
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 30
2964: PUSH
2965: LD_INT 124
2967: PPUSH
2968: LD_INT 26
2970: PPUSH
2971: CALL_OW 428
2975: PUSH
2976: LD_INT 0
2978: EQUAL
2979: AND
2980: PUSH
2981: LD_INT 124
2983: PPUSH
2984: LD_INT 26
2986: PPUSH
2987: CALL_OW 428
2991: PPUSH
2992: CALL_OW 255
2996: PUSH
2997: LD_INT 2
2999: EQUAL
3000: XOR
3001: IFFALSE 3249
3003: GO 3005
3005: DISABLE
3006: LD_INT 0
3008: PPUSH
// begin enable ;
3009: ENABLE
// uc_side := 5 ;
3010: LD_ADDR_OWVAR 20
3014: PUSH
3015: LD_INT 5
3017: ST_TO_ADDR
// uc_nation := 2 ;
3018: LD_ADDR_OWVAR 21
3022: PUSH
3023: LD_INT 2
3025: ST_TO_ADDR
// PrepareTank ( 5 , 2 , ar_medium_trike , engine_solar , control_manual , ar_cargo_bay , 70 ) ;
3026: LD_INT 5
3028: PPUSH
3029: LD_INT 2
3031: PPUSH
3032: LD_INT 13
3034: PPUSH
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_INT 32
3043: PPUSH
3044: LD_INT 70
3046: PPUSH
3047: CALL 399 0 7
// veh := CreateVehicle ;
3051: LD_ADDR_VAR 0 1
3055: PUSH
3056: CALL_OW 45
3060: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3061: LD_VAR 0 1
3065: PPUSH
3066: LD_INT 3
3068: PPUSH
3069: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
3073: LD_VAR 0 1
3077: PPUSH
3078: LD_INT 8
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 49
// if not cargoDriver then
3088: LD_EXP 32
3092: NOT
3093: IFFALSE 3118
// begin PrepareHuman ( false , 1 , 3 ) ;
3095: LD_INT 0
3097: PPUSH
3098: LD_INT 1
3100: PPUSH
3101: LD_INT 3
3103: PPUSH
3104: CALL_OW 380
// cargoDriver := CreateHuman ;
3108: LD_ADDR_EXP 32
3112: PUSH
3113: CALL_OW 44
3117: ST_TO_ADDR
// end ; PlaceHumanInUnit ( cargoDriver , veh ) ;
3118: LD_EXP 32
3122: PPUSH
3123: LD_VAR 0 1
3127: PPUSH
3128: CALL_OW 52
// SetCargo ( veh , mat_oil , 100 ) ;
3132: LD_VAR 0 1
3136: PPUSH
3137: LD_INT 2
3139: PPUSH
3140: LD_INT 100
3142: PPUSH
3143: CALL_OW 290
// ComMoveXY ( veh , 142 , 15 ) ;
3147: LD_VAR 0 1
3151: PPUSH
3152: LD_INT 142
3154: PPUSH
3155: LD_INT 15
3157: PPUSH
3158: CALL_OW 111
// AddComUnload ( veh ) ;
3162: LD_VAR 0 1
3166: PPUSH
3167: CALL_OW 219
// AddComMoveXY ( veh , 133 , 2 ) ;
3171: LD_VAR 0 1
3175: PPUSH
3176: LD_INT 133
3178: PPUSH
3179: LD_INT 2
3181: PPUSH
3182: CALL_OW 171
// wait ( 0 0$5 ) ;
3186: LD_INT 175
3188: PPUSH
3189: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
3193: LD_INT 35
3195: PPUSH
3196: CALL_OW 67
// until IsAt ( veh , 133 , 2 ) or IsInArea ( veh , spawnArea ) ;
3200: LD_VAR 0 1
3204: PPUSH
3205: LD_INT 133
3207: PPUSH
3208: LD_INT 2
3210: PPUSH
3211: CALL_OW 307
3215: PUSH
3216: LD_VAR 0 1
3220: PPUSH
3221: LD_INT 8
3223: PPUSH
3224: CALL_OW 308
3228: OR
3229: IFFALSE 3193
// RemoveUnit ( cargoDriver ) ;
3231: LD_EXP 32
3235: PPUSH
3236: CALL_OW 64
// RemoveUnit ( veh ) ;
3240: LD_VAR 0 1
3244: PPUSH
3245: CALL_OW 64
// end ; end_of_file
3249: PPOPN 1
3251: END
// export Burlak , Gaidar , Kuzmov ; export ruForce , ruEng , ruMech , ruSci , ruMobile ; export ruSol ; export function PrepareRussian ; var base , blist , i , b , un , tmp , fac , oil ; begin
3252: LD_INT 0
3254: PPUSH
3255: PPUSH
3256: PPUSH
3257: PPUSH
3258: PPUSH
3259: PPUSH
3260: PPUSH
3261: PPUSH
3262: PPUSH
// uc_side := 3 ;
3263: LD_ADDR_OWVAR 20
3267: PUSH
3268: LD_INT 3
3270: ST_TO_ADDR
// uc_nation := 3 ;
3271: LD_ADDR_OWVAR 21
3275: PUSH
3276: LD_INT 3
3278: ST_TO_ADDR
// ruForce := [ ] ;
3279: LD_ADDR_EXP 36
3283: PUSH
3284: EMPTY
3285: ST_TO_ADDR
// ruMech := [ ] ;
3286: LD_ADDR_EXP 38
3290: PUSH
3291: EMPTY
3292: ST_TO_ADDR
// ruEng := [ ] ;
3293: LD_ADDR_EXP 37
3297: PUSH
3298: EMPTY
3299: ST_TO_ADDR
// ruSci := [ ] ;
3300: LD_ADDR_EXP 39
3304: PUSH
3305: EMPTY
3306: ST_TO_ADDR
// ruMobile := [ ] ;
3307: LD_ADDR_EXP 40
3311: PUSH
3312: EMPTY
3313: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ,  ) ;
3314: LD_ADDR_EXP 33
3318: PUSH
3319: LD_STRING Burlak
3321: PPUSH
3322: LD_INT 0
3324: PPUSH
3325: LD_STRING 
3327: PPUSH
3328: CALL 336 0 3
3332: ST_TO_ADDR
// Gaidar := PrepareUnit ( Gaydar , false ,  ) ;
3333: LD_ADDR_EXP 34
3337: PUSH
3338: LD_STRING Gaydar
3340: PPUSH
3341: LD_INT 0
3343: PPUSH
3344: LD_STRING 
3346: PPUSH
3347: CALL 336 0 3
3351: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , false ,  ) ;
3352: LD_ADDR_EXP 35
3356: PUSH
3357: LD_STRING Kuzmov
3359: PPUSH
3360: LD_INT 0
3362: PPUSH
3363: LD_STRING 
3365: PPUSH
3366: CALL 336 0 3
3370: ST_TO_ADDR
// PlaceHumanInUnit ( Kuzmov , ruMainBase ) ;
3371: LD_EXP 35
3375: PPUSH
3376: LD_INT 200
3378: PPUSH
3379: CALL_OW 52
// SetBName ( ruMainBase , chuikov ) ;
3383: LD_INT 200
3385: PPUSH
3386: LD_STRING chuikov
3388: PPUSH
3389: CALL_OW 500
// SetResourceType ( GetBase ( ruMainBase ) , mat_cans , [ 800 , 1000 , 1250 ] [ Difficulty ] ) ;
3393: LD_INT 200
3395: PPUSH
3396: CALL_OW 274
3400: PPUSH
3401: LD_INT 1
3403: PPUSH
3404: LD_INT 800
3406: PUSH
3407: LD_INT 1000
3409: PUSH
3410: LD_INT 1250
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: PUSH
3418: LD_OWVAR 67
3422: ARRAY
3423: PPUSH
3424: CALL_OW 277
// SetResourceType ( GetBase ( ruMainBase ) , mat_oil , 160 ) ;
3428: LD_INT 200
3430: PPUSH
3431: CALL_OW 274
3435: PPUSH
3436: LD_INT 2
3438: PPUSH
3439: LD_INT 160
3441: PPUSH
3442: CALL_OW 277
// SetResourceType ( GetBase ( ruSecBase ) , mat_cans , 200 ) ;
3446: LD_INT 225
3448: PPUSH
3449: CALL_OW 274
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 200
3459: PPUSH
3460: CALL_OW 277
// oil := 150 ;
3464: LD_ADDR_VAR 0 9
3468: PUSH
3469: LD_INT 150
3471: ST_TO_ADDR
// if gameTime >= [ 45 45$00 , 40 40$00 , 35 35$00 ] [ Difficulty ] then
3472: LD_EXP 5
3476: PUSH
3477: LD_INT 94500
3479: PUSH
3480: LD_INT 84000
3482: PUSH
3483: LD_INT 73500
3485: PUSH
3486: EMPTY
3487: LIST
3488: LIST
3489: LIST
3490: PUSH
3491: LD_OWVAR 67
3495: ARRAY
3496: GREATEREQUAL
3497: IFFALSE 3652
// begin oil := 450 ;
3499: LD_ADDR_VAR 0 9
3503: PUSH
3504: LD_INT 450
3506: ST_TO_ADDR
// tmp := [ [ 123 , 17 , 3 , b_breastwork ] , [ 152 , 38 , 3 , b_breastwork ] , [ 81 , 6 , 4 , b_breastwork ] , [ 113 , 67 , 4 , b_bunker ] ] ;
3507: LD_ADDR_VAR 0 7
3511: PUSH
3512: LD_INT 123
3514: PUSH
3515: LD_INT 17
3517: PUSH
3518: LD_INT 3
3520: PUSH
3521: LD_INT 31
3523: PUSH
3524: EMPTY
3525: LIST
3526: LIST
3527: LIST
3528: LIST
3529: PUSH
3530: LD_INT 152
3532: PUSH
3533: LD_INT 38
3535: PUSH
3536: LD_INT 3
3538: PUSH
3539: LD_INT 31
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: PUSH
3548: LD_INT 81
3550: PUSH
3551: LD_INT 6
3553: PUSH
3554: LD_INT 4
3556: PUSH
3557: LD_INT 31
3559: PUSH
3560: EMPTY
3561: LIST
3562: LIST
3563: LIST
3564: LIST
3565: PUSH
3566: LD_INT 113
3568: PUSH
3569: LD_INT 67
3571: PUSH
3572: LD_INT 4
3574: PUSH
3575: LD_INT 32
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: ST_TO_ADDR
// for i in tmp do
3590: LD_ADDR_VAR 0 4
3594: PUSH
3595: LD_VAR 0 7
3599: PUSH
3600: FOR_IN
3601: IFFALSE 3650
// begin bc_type := i [ 4 ] ;
3603: LD_ADDR_OWVAR 42
3607: PUSH
3608: LD_VAR 0 4
3612: PUSH
3613: LD_INT 4
3615: ARRAY
3616: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3617: LD_VAR 0 4
3621: PUSH
3622: LD_INT 1
3624: ARRAY
3625: PPUSH
3626: LD_VAR 0 4
3630: PUSH
3631: LD_INT 2
3633: ARRAY
3634: PPUSH
3635: LD_VAR 0 4
3639: PUSH
3640: LD_INT 3
3642: ARRAY
3643: PPUSH
3644: CALL_OW 47
// end ;
3648: GO 3600
3650: POP
3651: POP
// end ; SetResourceType ( GetBase ( ruSecBase ) , mat_oil , oil ) ;
3652: LD_INT 225
3654: PPUSH
3655: CALL_OW 274
3659: PPUSH
3660: LD_INT 2
3662: PPUSH
3663: LD_VAR 0 9
3667: PPUSH
3668: CALL_OW 277
// if Difficulty > 1 then
3672: LD_OWVAR 67
3676: PUSH
3677: LD_INT 1
3679: GREATER
3680: IFFALSE 3775
// begin bc_type := b_bunker ;
3682: LD_ADDR_OWVAR 42
3686: PUSH
3687: LD_INT 32
3689: ST_TO_ADDR
// tmp := [ [ 121 , 85 , 5 ] , [ 93 , 72 , 1 ] ] ;
3690: LD_ADDR_VAR 0 7
3694: PUSH
3695: LD_INT 121
3697: PUSH
3698: LD_INT 85
3700: PUSH
3701: LD_INT 5
3703: PUSH
3704: EMPTY
3705: LIST
3706: LIST
3707: LIST
3708: PUSH
3709: LD_INT 93
3711: PUSH
3712: LD_INT 72
3714: PUSH
3715: LD_INT 1
3717: PUSH
3718: EMPTY
3719: LIST
3720: LIST
3721: LIST
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: ST_TO_ADDR
// for i in tmp do
3727: LD_ADDR_VAR 0 4
3731: PUSH
3732: LD_VAR 0 7
3736: PUSH
3737: FOR_IN
3738: IFFALSE 3773
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3740: LD_VAR 0 4
3744: PUSH
3745: LD_INT 1
3747: ARRAY
3748: PPUSH
3749: LD_VAR 0 4
3753: PUSH
3754: LD_INT 2
3756: ARRAY
3757: PPUSH
3758: LD_VAR 0 4
3762: PUSH
3763: LD_INT 3
3765: ARRAY
3766: PPUSH
3767: CALL_OW 47
3771: GO 3737
3773: POP
3774: POP
// end ; base := GetBase ( ruMainBase ) ;
3775: LD_ADDR_VAR 0 2
3779: PUSH
3780: LD_INT 200
3782: PPUSH
3783: CALL_OW 274
3787: ST_TO_ADDR
// blist := GetBuildList ( base ) ;
3788: LD_ADDR_VAR 0 3
3792: PUSH
3793: LD_VAR 0 2
3797: PPUSH
3798: CALL_OW 417
3802: ST_TO_ADDR
// for b in blist do
3803: LD_ADDR_VAR 0 5
3807: PUSH
3808: LD_VAR 0 3
3812: PUSH
3813: FOR_IN
3814: IFFALSE 4217
// begin if b [ 1 ] = b_factory then
3816: LD_VAR 0 5
3820: PUSH
3821: LD_INT 1
3823: ARRAY
3824: PUSH
3825: LD_INT 3
3827: EQUAL
3828: IFFALSE 3958
// begin fac := HexInfo ( b [ 2 ] , b [ 3 ] ) ;
3830: LD_ADDR_VAR 0 8
3834: PUSH
3835: LD_VAR 0 5
3839: PUSH
3840: LD_INT 2
3842: ARRAY
3843: PPUSH
3844: LD_VAR 0 5
3848: PUSH
3849: LD_INT 3
3851: ARRAY
3852: PPUSH
3853: CALL_OW 428
3857: ST_TO_ADDR
// for i := 1 to 2 + Difficulty do
3858: LD_ADDR_VAR 0 4
3862: PUSH
3863: DOUBLE
3864: LD_INT 1
3866: DEC
3867: ST_TO_ADDR
3868: LD_INT 2
3870: PUSH
3871: LD_OWVAR 67
3875: PLUS
3876: PUSH
3877: FOR_TO
3878: IFFALSE 3954
// begin PrepareHuman ( false , 3 , 1 + Difficulty ) ;
3880: LD_INT 0
3882: PPUSH
3883: LD_INT 3
3885: PPUSH
3886: LD_INT 1
3888: PUSH
3889: LD_OWVAR 67
3893: PLUS
3894: PPUSH
3895: CALL_OW 380
// un := CreateHuman ;
3899: LD_ADDR_VAR 0 6
3903: PUSH
3904: CALL_OW 44
3908: ST_TO_ADDR
// ruMech := Replace ( ruMech , ruMech + 1 , un ) ;
3909: LD_ADDR_EXP 38
3913: PUSH
3914: LD_EXP 38
3918: PPUSH
3919: LD_EXP 38
3923: PUSH
3924: LD_INT 1
3926: PLUS
3927: PPUSH
3928: LD_VAR 0 6
3932: PPUSH
3933: CALL_OW 1
3937: ST_TO_ADDR
// PlaceHumanInUnit ( un , fac ) ;
3938: LD_VAR 0 6
3942: PPUSH
3943: LD_VAR 0 8
3947: PPUSH
3948: CALL_OW 52
// end ;
3952: GO 3877
3954: POP
3955: POP
// end else
3956: GO 4215
// if b [ 1 ] in [ b_lab , b_lab_half , b_lab_full , b_lab_weapon ] then
3958: LD_VAR 0 5
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: PUSH
3967: LD_INT 6
3969: PUSH
3970: LD_INT 7
3972: PUSH
3973: LD_INT 8
3975: PUSH
3976: LD_INT 10
3978: PUSH
3979: EMPTY
3980: LIST
3981: LIST
3982: LIST
3983: LIST
3984: IN
3985: IFFALSE 4095
// begin for i := 1 to 2 do
3987: LD_ADDR_VAR 0 4
3991: PUSH
3992: DOUBLE
3993: LD_INT 1
3995: DEC
3996: ST_TO_ADDR
3997: LD_INT 2
3999: PUSH
4000: FOR_TO
4001: IFFALSE 4091
// begin PrepareHuman ( false , 4 , Difficulty ) ;
4003: LD_INT 0
4005: PPUSH
4006: LD_INT 4
4008: PPUSH
4009: LD_OWVAR 67
4013: PPUSH
4014: CALL_OW 380
// un := CreateHuman ;
4018: LD_ADDR_VAR 0 6
4022: PUSH
4023: CALL_OW 44
4027: ST_TO_ADDR
// ruSci := Replace ( ruSci , ruSci + 1 , un ) ;
4028: LD_ADDR_EXP 39
4032: PUSH
4033: LD_EXP 39
4037: PPUSH
4038: LD_EXP 39
4042: PUSH
4043: LD_INT 1
4045: PLUS
4046: PPUSH
4047: LD_VAR 0 6
4051: PPUSH
4052: CALL_OW 1
4056: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4057: LD_VAR 0 6
4061: PPUSH
4062: LD_VAR 0 5
4066: PUSH
4067: LD_INT 2
4069: ARRAY
4070: PPUSH
4071: LD_VAR 0 5
4075: PUSH
4076: LD_INT 3
4078: ARRAY
4079: PPUSH
4080: CALL_OW 428
4084: PPUSH
4085: CALL_OW 52
// end ;
4089: GO 4000
4091: POP
4092: POP
// end else
4093: GO 4215
// if b [ 1 ] = b_warehouse then
4095: LD_VAR 0 5
4099: PUSH
4100: LD_INT 1
4102: ARRAY
4103: PUSH
4104: LD_INT 1
4106: EQUAL
4107: IFFALSE 4215
// begin for i := 1 to 3 do
4109: LD_ADDR_VAR 0 4
4113: PUSH
4114: DOUBLE
4115: LD_INT 1
4117: DEC
4118: ST_TO_ADDR
4119: LD_INT 3
4121: PUSH
4122: FOR_TO
4123: IFFALSE 4213
// begin PrepareHuman ( false , 2 , Difficulty ) ;
4125: LD_INT 0
4127: PPUSH
4128: LD_INT 2
4130: PPUSH
4131: LD_OWVAR 67
4135: PPUSH
4136: CALL_OW 380
// un := CreateHuman ;
4140: LD_ADDR_VAR 0 6
4144: PUSH
4145: CALL_OW 44
4149: ST_TO_ADDR
// ruEng := Replace ( ruEng , ruEng + 1 , un ) ;
4150: LD_ADDR_EXP 37
4154: PUSH
4155: LD_EXP 37
4159: PPUSH
4160: LD_EXP 37
4164: PUSH
4165: LD_INT 1
4167: PLUS
4168: PPUSH
4169: LD_VAR 0 6
4173: PPUSH
4174: CALL_OW 1
4178: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4179: LD_VAR 0 6
4183: PPUSH
4184: LD_VAR 0 5
4188: PUSH
4189: LD_INT 2
4191: ARRAY
4192: PPUSH
4193: LD_VAR 0 5
4197: PUSH
4198: LD_INT 3
4200: ARRAY
4201: PPUSH
4202: CALL_OW 428
4206: PPUSH
4207: CALL_OW 52
// end ;
4211: GO 4122
4213: POP
4214: POP
// end ; end ;
4215: GO 3813
4217: POP
4218: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4219: LD_ADDR_VAR 0 3
4223: PUSH
4224: LD_INT 22
4226: PUSH
4227: LD_INT 3
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 21
4236: PUSH
4237: LD_INT 3
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: PPUSH
4248: CALL_OW 69
4252: ST_TO_ADDR
// for b in blist do
4253: LD_ADDR_VAR 0 5
4257: PUSH
4258: LD_VAR 0 3
4262: PUSH
4263: FOR_IN
4264: IFFALSE 4286
// SetBLevel ( b , 3 + Difficulty ) ;
4266: LD_VAR 0 5
4270: PPUSH
4271: LD_INT 3
4273: PUSH
4274: LD_OWVAR 67
4278: PLUS
4279: PPUSH
4280: CALL_OW 241
4284: GO 4263
4286: POP
4287: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4288: LD_ADDR_VAR 0 3
4292: PUSH
4293: LD_INT 22
4295: PUSH
4296: LD_INT 3
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: PUSH
4303: LD_INT 30
4305: PUSH
4306: LD_INT 32
4308: PUSH
4309: EMPTY
4310: LIST
4311: LIST
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: PPUSH
4317: CALL_OW 69
4321: ST_TO_ADDR
// for b in blist do
4322: LD_ADDR_VAR 0 5
4326: PUSH
4327: LD_VAR 0 3
4331: PUSH
4332: FOR_IN
4333: IFFALSE 4442
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4335: LD_INT 0
4337: PPUSH
4338: LD_INT 1
4340: PPUSH
4341: LD_INT 1
4343: PUSH
4344: LD_OWVAR 67
4348: PLUS
4349: PPUSH
4350: CALL_OW 380
// un := CreateHuman ;
4354: LD_ADDR_VAR 0 6
4358: PUSH
4359: CALL_OW 44
4363: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4364: LD_ADDR_EXP 36
4368: PUSH
4369: LD_EXP 36
4373: PPUSH
4374: LD_EXP 36
4378: PUSH
4379: LD_INT 1
4381: PLUS
4382: PPUSH
4383: LD_VAR 0 6
4387: PPUSH
4388: CALL_OW 1
4392: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4393: LD_VAR 0 6
4397: PPUSH
4398: LD_VAR 0 5
4402: PPUSH
4403: CALL_OW 52
// PlaceWeaponTurret ( b , [ ru_gun , ru_gatling_gun ] [ b mod 2 + 1 ] ) ;
4407: LD_VAR 0 5
4411: PPUSH
4412: LD_INT 44
4414: PUSH
4415: LD_INT 43
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_VAR 0 5
4426: PUSH
4427: LD_INT 2
4429: MOD
4430: PUSH
4431: LD_INT 1
4433: PLUS
4434: ARRAY
4435: PPUSH
4436: CALL_OW 431
// end ;
4440: GO 4332
4442: POP
4443: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4444: LD_ADDR_VAR 0 3
4448: PUSH
4449: LD_INT 22
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: EMPTY
4456: LIST
4457: LIST
4458: PUSH
4459: LD_INT 30
4461: PUSH
4462: LD_INT 31
4464: PUSH
4465: EMPTY
4466: LIST
4467: LIST
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PPUSH
4473: CALL_OW 69
4477: ST_TO_ADDR
// for b in blist do
4478: LD_ADDR_VAR 0 5
4482: PUSH
4483: LD_VAR 0 3
4487: PUSH
4488: FOR_IN
4489: IFFALSE 4588
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4491: LD_INT 0
4493: PPUSH
4494: LD_INT 1
4496: PPUSH
4497: LD_INT 1
4499: PUSH
4500: LD_OWVAR 67
4504: PLUS
4505: PPUSH
4506: CALL_OW 380
// un := CreateHuman ;
4510: LD_ADDR_VAR 0 6
4514: PUSH
4515: CALL_OW 44
4519: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4520: LD_ADDR_EXP 36
4524: PUSH
4525: LD_EXP 36
4529: PPUSH
4530: LD_EXP 36
4534: PUSH
4535: LD_INT 1
4537: PLUS
4538: PPUSH
4539: LD_VAR 0 6
4543: PPUSH
4544: CALL_OW 1
4548: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) + 3 ) ;
4549: LD_VAR 0 6
4553: PPUSH
4554: LD_VAR 0 5
4558: PPUSH
4559: CALL_OW 254
4563: PUSH
4564: LD_INT 3
4566: PLUS
4567: PPUSH
4568: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4572: LD_VAR 0 6
4576: PPUSH
4577: LD_VAR 0 5
4581: PPUSH
4582: CALL_OW 52
// end ;
4586: GO 4488
4588: POP
4589: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4590: LD_ADDR_VAR 0 3
4594: PUSH
4595: LD_INT 22
4597: PUSH
4598: LD_INT 3
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: PUSH
4605: LD_INT 2
4607: PUSH
4608: LD_INT 30
4610: PUSH
4611: LD_INT 4
4613: PUSH
4614: EMPTY
4615: LIST
4616: LIST
4617: PUSH
4618: LD_INT 30
4620: PUSH
4621: LD_INT 5
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: LIST
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: PPUSH
4637: CALL_OW 69
4641: ST_TO_ADDR
// for b in blist do
4642: LD_ADDR_VAR 0 5
4646: PUSH
4647: LD_VAR 0 3
4651: PUSH
4652: FOR_IN
4653: IFFALSE 4749
// begin for i := 1 to 2 do
4655: LD_ADDR_VAR 0 4
4659: PUSH
4660: DOUBLE
4661: LD_INT 1
4663: DEC
4664: ST_TO_ADDR
4665: LD_INT 2
4667: PUSH
4668: FOR_TO
4669: IFFALSE 4745
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4671: LD_INT 0
4673: PPUSH
4674: LD_INT 1
4676: PPUSH
4677: LD_INT 1
4679: PUSH
4680: LD_OWVAR 67
4684: PLUS
4685: PPUSH
4686: CALL_OW 380
// un := CreateHuman ;
4690: LD_ADDR_VAR 0 6
4694: PUSH
4695: CALL_OW 44
4699: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4700: LD_ADDR_EXP 36
4704: PUSH
4705: LD_EXP 36
4709: PPUSH
4710: LD_EXP 36
4714: PUSH
4715: LD_INT 1
4717: PLUS
4718: PPUSH
4719: LD_VAR 0 6
4723: PPUSH
4724: CALL_OW 1
4728: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4729: LD_VAR 0 6
4733: PPUSH
4734: LD_VAR 0 5
4738: PPUSH
4739: CALL_OW 52
// end ;
4743: GO 4668
4745: POP
4746: POP
// end ;
4747: GO 4652
4749: POP
4750: POP
// if ibrahimOnRuSide then
4751: LD_EXP 3
4755: IFFALSE 4853
// begin Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
4757: LD_ADDR_EXP 21
4761: PUSH
4762: LD_STRING IbrahimRu
4764: PPUSH
4765: LD_INT 0
4767: PPUSH
4768: LD_STRING 
4770: PPUSH
4771: CALL 336 0 3
4775: ST_TO_ADDR
// PlaceUnitXY ( Ibrahim , 121 , 78 , false ) ;
4776: LD_EXP 21
4780: PPUSH
4781: LD_INT 121
4783: PPUSH
4784: LD_INT 78
4786: PPUSH
4787: LD_INT 0
4789: PPUSH
4790: CALL_OW 48
// ComHold ( Ibrahim ) ;
4794: LD_EXP 21
4798: PPUSH
4799: CALL_OW 140
// PrepareHuman ( sex_male , 1 , 2 ) ;
4803: LD_INT 1
4805: PPUSH
4806: LD_INT 1
4808: PPUSH
4809: LD_INT 2
4811: PPUSH
4812: CALL_OW 380
// ruSol := CreateHuman ;
4816: LD_ADDR_EXP 41
4820: PUSH
4821: CALL_OW 44
4825: ST_TO_ADDR
// PlaceUnitXY ( ruSol , 121 , 75 , false ) ;
4826: LD_EXP 41
4830: PPUSH
4831: LD_INT 121
4833: PPUSH
4834: LD_INT 75
4836: PPUSH
4837: LD_INT 0
4839: PPUSH
4840: CALL_OW 48
// ComHold ( ruSol ) ;
4844: LD_EXP 41
4848: PPUSH
4849: CALL_OW 140
// end ; for i := 1 to 2 + Difficulty do
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: DOUBLE
4859: LD_INT 1
4861: DEC
4862: ST_TO_ADDR
4863: LD_INT 2
4865: PUSH
4866: LD_OWVAR 67
4870: PLUS
4871: PUSH
4872: FOR_TO
4873: IFFALSE 4942
// AddComConstruct ( fac , [ ru_medium_wheeled , ru_heavy_wheeled , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] ) ;
4875: LD_VAR 0 8
4879: PPUSH
4880: LD_INT 21
4882: PUSH
4883: LD_INT 23
4885: PUSH
4886: LD_INT 24
4888: PUSH
4889: EMPTY
4890: LIST
4891: LIST
4892: LIST
4893: PUSH
4894: LD_VAR 0 4
4898: PUSH
4899: LD_INT 3
4901: MOD
4902: PUSH
4903: LD_INT 1
4905: PLUS
4906: ARRAY
4907: PPUSH
4908: LD_INT 1
4910: PPUSH
4911: LD_INT 1
4913: PPUSH
4914: LD_INT 43
4916: PUSH
4917: LD_INT 44
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: PUSH
4924: LD_INT 1
4926: PPUSH
4927: LD_INT 2
4929: PPUSH
4930: CALL_OW 12
4934: ARRAY
4935: PPUSH
4936: CALL_OW 185
4940: GO 4872
4942: POP
4943: POP
// end ;
4944: LD_VAR 0 1
4948: RET
// every 0 0$1 trigger ruMobile and not ruEscapeAllowed do var i , filter , tmp , enemy , x ;
4949: LD_EXP 40
4953: PUSH
4954: LD_EXP 4
4958: NOT
4959: AND
4960: IFFALSE 5447
4962: GO 4964
4964: DISABLE
4965: LD_INT 0
4967: PPUSH
4968: PPUSH
4969: PPUSH
4970: PPUSH
4971: PPUSH
// begin enable ;
4972: ENABLE
// filter := UnitFilter ( ruMobile , [ f_type , unit_vehicle ] ) ;
4973: LD_ADDR_VAR 0 2
4977: PUSH
4978: LD_EXP 40
4982: PPUSH
4983: LD_INT 21
4985: PUSH
4986: LD_INT 2
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PPUSH
4993: CALL_OW 72
4997: ST_TO_ADDR
// enemy := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_or , [ f_inarea , zone1 ] , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) ;
4998: LD_ADDR_VAR 0 4
5002: PUSH
5003: LD_INT 81
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 2
5015: PUSH
5016: LD_INT 95
5018: PUSH
5019: LD_INT 4
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PUSH
5026: LD_INT 95
5028: PUSH
5029: LD_INT 5
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: LD_INT 95
5038: PUSH
5039: LD_INT 6
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: PUSH
5046: LD_INT 95
5048: PUSH
5049: LD_INT 7
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: PPUSH
5067: CALL_OW 69
5071: ST_TO_ADDR
// for i in filter do
5072: LD_ADDR_VAR 0 1
5076: PUSH
5077: LD_VAR 0 2
5081: PUSH
5082: FOR_IN
5083: IFFALSE 5445
// begin tmp := IsDrivenBy ( i ) ;
5085: LD_ADDR_VAR 0 3
5089: PUSH
5090: LD_VAR 0 1
5094: PPUSH
5095: CALL_OW 311
5099: ST_TO_ADDR
// if not tmp then
5100: LD_VAR 0 3
5104: NOT
5105: IFFALSE 5109
// continue ;
5107: GO 5082
// if GetFuel ( i ) > 90 and GetTag ( i ) = 2 then
5109: LD_VAR 0 1
5113: PPUSH
5114: CALL_OW 261
5118: PUSH
5119: LD_INT 90
5121: GREATER
5122: PUSH
5123: LD_VAR 0 1
5127: PPUSH
5128: CALL_OW 110
5132: PUSH
5133: LD_INT 2
5135: EQUAL
5136: AND
5137: IFFALSE 5153
// SetTag ( i , 0 ) else
5139: LD_VAR 0 1
5143: PPUSH
5144: LD_INT 0
5146: PPUSH
5147: CALL_OW 109
5151: GO 5196
// if GetTag ( i ) = 2 then
5153: LD_VAR 0 1
5157: PPUSH
5158: CALL_OW 110
5162: PUSH
5163: LD_INT 2
5165: EQUAL
5166: IFFALSE 5196
// begin x := rand ( 1 , 2 ) ;
5168: LD_ADDR_VAR 0 5
5172: PUSH
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 2
5178: PPUSH
5179: CALL_OW 12
5183: ST_TO_ADDR
// AddComMoveUnit ( i , ruMainBase ) ;
5184: LD_VAR 0 1
5188: PPUSH
5189: LD_INT 200
5191: PPUSH
5192: CALL_OW 172
// end ; if GetLives ( i ) >= 600 and not GetTag ( i ) then
5196: LD_VAR 0 1
5200: PPUSH
5201: CALL_OW 256
5205: PUSH
5206: LD_INT 600
5208: GREATEREQUAL
5209: PUSH
5210: LD_VAR 0 1
5214: PPUSH
5215: CALL_OW 110
5219: NOT
5220: AND
5221: IFFALSE 5247
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
5223: LD_VAR 0 1
5227: PPUSH
5228: LD_VAR 0 4
5232: PPUSH
5233: LD_VAR 0 1
5237: PPUSH
5238: CALL_OW 74
5242: PPUSH
5243: CALL_OW 115
// if GetLives ( i ) < 600 and not GetTag ( i ) then
5247: LD_VAR 0 1
5251: PPUSH
5252: CALL_OW 256
5256: PUSH
5257: LD_INT 600
5259: LESS
5260: PUSH
5261: LD_VAR 0 1
5265: PPUSH
5266: CALL_OW 110
5270: NOT
5271: AND
5272: IFFALSE 5301
// begin SetTag ( i , 1 ) ;
5274: LD_VAR 0 1
5278: PPUSH
5279: LD_INT 1
5281: PPUSH
5282: CALL_OW 109
// ComMoveXY ( i , 112 , 119 ) ;
5286: LD_VAR 0 1
5290: PPUSH
5291: LD_INT 112
5293: PPUSH
5294: LD_INT 119
5296: PPUSH
5297: CALL_OW 111
// end ; if GetTag ( i ) = 1 and GetDistUnitXY ( i , 112 , 119 ) < 9 and tmp then
5301: LD_VAR 0 1
5305: PPUSH
5306: CALL_OW 110
5310: PUSH
5311: LD_INT 1
5313: EQUAL
5314: PUSH
5315: LD_VAR 0 1
5319: PPUSH
5320: LD_INT 112
5322: PPUSH
5323: LD_INT 119
5325: PPUSH
5326: CALL_OW 297
5330: PUSH
5331: LD_INT 9
5333: LESS
5334: AND
5335: PUSH
5336: LD_VAR 0 3
5340: AND
5341: IFFALSE 5443
// begin ComExitVehicle ( tmp ) ;
5343: LD_VAR 0 3
5347: PPUSH
5348: CALL_OW 121
// AddComRepairVehicle ( tmp , i ) ;
5352: LD_VAR 0 3
5356: PPUSH
5357: LD_VAR 0 1
5361: PPUSH
5362: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
5366: LD_INT 35
5368: PPUSH
5369: CALL_OW 67
// until GetLives ( i ) = 1000 ;
5373: LD_VAR 0 1
5377: PPUSH
5378: CALL_OW 256
5382: PUSH
5383: LD_INT 1000
5385: EQUAL
5386: IFFALSE 5366
// ComEnterUnit ( tmp , i ) ;
5388: LD_VAR 0 3
5392: PPUSH
5393: LD_VAR 0 1
5397: PPUSH
5398: CALL_OW 120
// if GetFuel ( i ) <= 50 then
5402: LD_VAR 0 1
5406: PPUSH
5407: CALL_OW 261
5411: PUSH
5412: LD_INT 50
5414: LESSEQUAL
5415: IFFALSE 5431
// SetTag ( i , 2 ) else
5417: LD_VAR 0 1
5421: PPUSH
5422: LD_INT 2
5424: PPUSH
5425: CALL_OW 109
5429: GO 5443
// SetTag ( i , 0 ) ;
5431: LD_VAR 0 1
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 109
// end ; end ;
5443: GO 5082
5445: POP
5446: POP
// end ;
5447: PPOPN 5
5449: END
// every 0 0$1 trigger not ruEscapeAllowed and ruEng do var i , filter , tmp , enemy ;
5450: LD_EXP 4
5454: NOT
5455: PUSH
5456: LD_EXP 37
5460: AND
5461: IFFALSE 5722
5463: GO 5465
5465: DISABLE
5466: LD_INT 0
5468: PPUSH
5469: PPUSH
5470: PPUSH
5471: PPUSH
// begin enable ;
5472: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5473: LD_ADDR_VAR 0 2
5477: PUSH
5478: LD_INT 3
5480: PPUSH
5481: LD_INT 22
5483: PUSH
5484: LD_INT 3
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 21
5493: PUSH
5494: LD_INT 3
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 3
5503: PUSH
5504: LD_INT 24
5506: PUSH
5507: LD_INT 1000
5509: PUSH
5510: EMPTY
5511: LIST
5512: LIST
5513: PUSH
5514: EMPTY
5515: LIST
5516: LIST
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 70
5527: ST_TO_ADDR
// tmp := UnitFilter ( ruEng , [ f_ok ] ) ;
5528: LD_ADDR_VAR 0 3
5532: PUSH
5533: LD_EXP 37
5537: PPUSH
5538: LD_INT 50
5540: PUSH
5541: EMPTY
5542: LIST
5543: PPUSH
5544: CALL_OW 72
5548: ST_TO_ADDR
// if filter and tmp then
5549: LD_VAR 0 2
5553: PUSH
5554: LD_VAR 0 3
5558: AND
5559: IFFALSE 5651
// begin for i in tmp do
5561: LD_ADDR_VAR 0 1
5565: PUSH
5566: LD_VAR 0 3
5570: PUSH
5571: FOR_IN
5572: IFFALSE 5647
// begin if GetTag ( i ) = tEscape then
5574: LD_VAR 0 1
5578: PPUSH
5579: CALL_OW 110
5583: PUSH
5584: LD_EXP 17
5588: EQUAL
5589: IFFALSE 5593
// continue ;
5591: GO 5571
// if IsInUnit ( i ) then
5593: LD_VAR 0 1
5597: PPUSH
5598: CALL_OW 310
5602: IFFALSE 5615
// ComExitBuilding ( i ) else
5604: LD_VAR 0 1
5608: PPUSH
5609: CALL_OW 122
5613: GO 5645
// if not HasTask ( i ) then
5615: LD_VAR 0 1
5619: PPUSH
5620: CALL_OW 314
5624: NOT
5625: IFFALSE 5645
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5627: LD_VAR 0 1
5631: PPUSH
5632: LD_VAR 0 2
5636: PUSH
5637: LD_INT 1
5639: ARRAY
5640: PPUSH
5641: CALL_OW 130
// end ;
5645: GO 5571
5647: POP
5648: POP
// end else
5649: GO 5722
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5651: LD_VAR 0 3
5655: PPUSH
5656: LD_INT 3
5658: PUSH
5659: LD_INT 54
5661: PUSH
5662: EMPTY
5663: LIST
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL_OW 72
5673: IFFALSE 5722
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5675: LD_ADDR_VAR 0 1
5679: PUSH
5680: LD_VAR 0 3
5684: PPUSH
5685: LD_INT 3
5687: PUSH
5688: LD_INT 54
5690: PUSH
5691: EMPTY
5692: LIST
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PPUSH
5698: CALL_OW 72
5702: PUSH
5703: FOR_IN
5704: IFFALSE 5720
// ComEnterUnit ( i , ruMainBase ) ;
5706: LD_VAR 0 1
5710: PPUSH
5711: LD_INT 200
5713: PPUSH
5714: CALL_OW 120
5718: GO 5703
5720: POP
5721: POP
// end ; end ;
5722: PPOPN 4
5724: END
// every 0 0$1 trigger not ruEscapeAllowed and ruSci do var i , filter , tmp , lab ;
5725: LD_EXP 4
5729: NOT
5730: PUSH
5731: LD_EXP 39
5735: AND
5736: IFFALSE 6015
5738: GO 5740
5740: DISABLE
5741: LD_INT 0
5743: PPUSH
5744: PPUSH
5745: PPUSH
5746: PPUSH
// begin enable ;
5747: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5748: LD_ADDR_VAR 0 2
5752: PUSH
5753: LD_INT 3
5755: PPUSH
5756: LD_INT 22
5758: PUSH
5759: LD_INT 3
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: PUSH
5766: LD_INT 21
5768: PUSH
5769: LD_INT 1
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: PUSH
5776: LD_INT 3
5778: PUSH
5779: LD_INT 24
5781: PUSH
5782: LD_INT 1000
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: PUSH
5793: EMPTY
5794: LIST
5795: LIST
5796: LIST
5797: PPUSH
5798: CALL_OW 70
5802: ST_TO_ADDR
// tmp := UnitFilter ( ruSci , [ f_ok ] ) ;
5803: LD_ADDR_VAR 0 3
5807: PUSH
5808: LD_EXP 39
5812: PPUSH
5813: LD_INT 50
5815: PUSH
5816: EMPTY
5817: LIST
5818: PPUSH
5819: CALL_OW 72
5823: ST_TO_ADDR
// lab := HexInfo ( 118 , 121 ) ;
5824: LD_ADDR_VAR 0 4
5828: PUSH
5829: LD_INT 118
5831: PPUSH
5832: LD_INT 121
5834: PPUSH
5835: CALL_OW 428
5839: ST_TO_ADDR
// if filter and tmp then
5840: LD_VAR 0 2
5844: PUSH
5845: LD_VAR 0 3
5849: AND
5850: IFFALSE 5942
// begin for i in tmp do
5852: LD_ADDR_VAR 0 1
5856: PUSH
5857: LD_VAR 0 3
5861: PUSH
5862: FOR_IN
5863: IFFALSE 5938
// begin if GetTag ( i ) = tEscape then
5865: LD_VAR 0 1
5869: PPUSH
5870: CALL_OW 110
5874: PUSH
5875: LD_EXP 17
5879: EQUAL
5880: IFFALSE 5884
// continue ;
5882: GO 5862
// if IsInUnit ( i ) then
5884: LD_VAR 0 1
5888: PPUSH
5889: CALL_OW 310
5893: IFFALSE 5906
// ComExitBuilding ( i ) else
5895: LD_VAR 0 1
5899: PPUSH
5900: CALL_OW 122
5904: GO 5936
// if not HasTask ( i ) then
5906: LD_VAR 0 1
5910: PPUSH
5911: CALL_OW 314
5915: NOT
5916: IFFALSE 5936
// ComHeal ( i , filter [ 1 ] ) ;
5918: LD_VAR 0 1
5922: PPUSH
5923: LD_VAR 0 2
5927: PUSH
5928: LD_INT 1
5930: ARRAY
5931: PPUSH
5932: CALL_OW 128
// end ;
5936: GO 5862
5938: POP
5939: POP
// end else
5940: GO 6015
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5942: LD_VAR 0 3
5946: PPUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 54
5952: PUSH
5953: EMPTY
5954: LIST
5955: PUSH
5956: EMPTY
5957: LIST
5958: LIST
5959: PPUSH
5960: CALL_OW 72
5964: IFFALSE 6015
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5966: LD_ADDR_VAR 0 1
5970: PUSH
5971: LD_VAR 0 3
5975: PPUSH
5976: LD_INT 3
5978: PUSH
5979: LD_INT 54
5981: PUSH
5982: EMPTY
5983: LIST
5984: PUSH
5985: EMPTY
5986: LIST
5987: LIST
5988: PPUSH
5989: CALL_OW 72
5993: PUSH
5994: FOR_IN
5995: IFFALSE 6013
// ComEnterUnit ( i , lab ) ;
5997: LD_VAR 0 1
6001: PPUSH
6002: LD_VAR 0 4
6006: PPUSH
6007: CALL_OW 120
6011: GO 5994
6013: POP
6014: POP
// end ; end ; end_of_file
6015: PPOPN 4
6017: END
// on UnitDestroyed ( un ) do begin if un = Heike then
6018: LD_VAR 0 1
6022: PUSH
6023: LD_EXP 18
6027: EQUAL
6028: IFFALSE 6037
// YouLost ( Heike ) ;
6030: LD_STRING Heike
6032: PPUSH
6033: CALL_OW 104
// if un in ruEng then
6037: LD_VAR 0 1
6041: PUSH
6042: LD_EXP 37
6046: IN
6047: IFFALSE 6065
// ruEng := ruEng diff un ;
6049: LD_ADDR_EXP 37
6053: PUSH
6054: LD_EXP 37
6058: PUSH
6059: LD_VAR 0 1
6063: DIFF
6064: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) then
6065: LD_VAR 0 1
6069: PUSH
6070: LD_INT 22
6072: PUSH
6073: LD_INT 2
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PUSH
6080: LD_INT 21
6082: PUSH
6083: LD_INT 1
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: PUSH
6090: LD_INT 23
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: PPUSH
6105: CALL_OW 69
6109: IN
6110: IFFALSE 6126
// loseCounter := loseCounter + 1 ;
6112: LD_ADDR_EXP 6
6116: PUSH
6117: LD_EXP 6
6121: PUSH
6122: LD_INT 1
6124: PLUS
6125: ST_TO_ADDR
// end ;
6126: PPOPN 1
6128: END
// on EvacuateVehicle ( driver , un , p1 , p2 ) do var weapon , fac ;
6129: LD_INT 0
6131: PPUSH
6132: PPUSH
// begin if un in ruMobile then
6133: LD_VAR 0 2
6137: PUSH
6138: LD_EXP 40
6142: IN
6143: IFFALSE 6302
// begin ruMobile := ruMobile diff un ;
6145: LD_ADDR_EXP 40
6149: PUSH
6150: LD_EXP 40
6154: PUSH
6155: LD_VAR 0 2
6159: DIFF
6160: ST_TO_ADDR
// weapon := GetWeapon ( un ) ;
6161: LD_ADDR_VAR 0 5
6165: PUSH
6166: LD_VAR 0 2
6170: PPUSH
6171: CALL_OW 264
6175: ST_TO_ADDR
// fac := HexInfo ( 110 , 126 ) ;
6176: LD_ADDR_VAR 0 6
6180: PUSH
6181: LD_INT 110
6183: PPUSH
6184: LD_INT 126
6186: PPUSH
6187: CALL_OW 428
6191: ST_TO_ADDR
// if not driver or not fac then
6192: LD_VAR 0 1
6196: NOT
6197: PUSH
6198: LD_VAR 0 6
6202: NOT
6203: OR
6204: IFFALSE 6208
// exit ;
6206: GO 6302
// AddComMoveXY ( driver , 111 , 121 ) ;
6208: LD_VAR 0 1
6212: PPUSH
6213: LD_INT 111
6215: PPUSH
6216: LD_INT 121
6218: PPUSH
6219: CALL_OW 171
// AddComEnterUnit ( driver , fac ) ;
6223: LD_VAR 0 1
6227: PPUSH
6228: LD_VAR 0 6
6232: PPUSH
6233: CALL_OW 180
// repeat wait ( 0 0$1 ) ;
6237: LD_INT 35
6239: PPUSH
6240: CALL_OW 67
// until IsDead ( driver ) or IsInUnit ( driver ) ;
6244: LD_VAR 0 1
6248: PPUSH
6249: CALL_OW 301
6253: PUSH
6254: LD_VAR 0 1
6258: PPUSH
6259: CALL_OW 310
6263: OR
6264: IFFALSE 6237
// if IsDead ( driver ) then
6266: LD_VAR 0 1
6270: PPUSH
6271: CALL_OW 301
6275: IFFALSE 6279
// exit ;
6277: GO 6302
// AddComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_manual , weapon ) ;
6279: LD_VAR 0 6
6283: PPUSH
6284: LD_INT 21
6286: PPUSH
6287: LD_INT 1
6289: PPUSH
6290: LD_INT 1
6292: PPUSH
6293: LD_VAR 0 5
6297: PPUSH
6298: CALL_OW 185
// end ; end ;
6302: PPOPN 6
6304: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 3 then
6305: LD_VAR 0 2
6309: PPUSH
6310: CALL_OW 255
6314: PUSH
6315: LD_INT 3
6317: EQUAL
6318: IFFALSE 6364
// begin ruMobile := Replace ( ruMobile , ruMobile + 1 , veh ) ;
6320: LD_ADDR_EXP 40
6324: PUSH
6325: LD_EXP 40
6329: PPUSH
6330: LD_EXP 40
6334: PUSH
6335: LD_INT 1
6337: PLUS
6338: PPUSH
6339: LD_VAR 0 1
6343: PPUSH
6344: CALL_OW 1
6348: ST_TO_ADDR
// AddComMoveXY ( veh , 110 , 117 ) ;
6349: LD_VAR 0 1
6353: PPUSH
6354: LD_INT 110
6356: PPUSH
6357: LD_INT 117
6359: PPUSH
6360: CALL_OW 171
// end ; end ;
6364: PPOPN 2
6366: END
// on LeaveBuilding ( b , un ) do var barracks ;
6367: LD_INT 0
6369: PPUSH
// begin if b in [ HexInfo ( 130 , 17 ) , HexInfo ( 138 , 22 ) , HexInfo ( 123 , 17 ) ] then
6370: LD_VAR 0 1
6374: PUSH
6375: LD_INT 130
6377: PPUSH
6378: LD_INT 17
6380: PPUSH
6381: CALL_OW 428
6385: PUSH
6386: LD_INT 138
6388: PPUSH
6389: LD_INT 22
6391: PPUSH
6392: CALL_OW 428
6396: PUSH
6397: LD_INT 123
6399: PPUSH
6400: LD_INT 17
6402: PPUSH
6403: CALL_OW 428
6407: PUSH
6408: EMPTY
6409: LIST
6410: LIST
6411: LIST
6412: IN
6413: IFFALSE 6437
// begin AddComEnterUnit ( un , HexInfo ( 135 , 31 ) ) ;
6415: LD_VAR 0 2
6419: PPUSH
6420: LD_INT 135
6422: PPUSH
6423: LD_INT 31
6425: PPUSH
6426: CALL_OW 428
6430: PPUSH
6431: CALL_OW 180
// exit ;
6435: GO 6711
// end ; if b = HexInfo ( 135 , 31 ) then
6437: LD_VAR 0 1
6441: PUSH
6442: LD_INT 135
6444: PPUSH
6445: LD_INT 31
6447: PPUSH
6448: CALL_OW 428
6452: EQUAL
6453: IFFALSE 6525
// begin AddComEnterUnit ( un , HexInfo ( 106 , 51 ) ) ;
6455: LD_VAR 0 2
6459: PPUSH
6460: LD_INT 106
6462: PPUSH
6463: LD_INT 51
6465: PPUSH
6466: CALL_OW 428
6470: PPUSH
6471: CALL_OW 180
// if not explodeFirstDepot then
6475: LD_EXP 12
6479: NOT
6480: IFFALSE 6523
// begin explodeFirstDepot := true ;
6482: LD_ADDR_EXP 12
6486: PUSH
6487: LD_INT 1
6489: ST_TO_ADDR
// wait ( 0 0$15 ) ;
6490: LD_INT 525
6492: PPUSH
6493: CALL_OW 67
// MineExplosion ( 127 , 27 , 1 ) ;
6497: LD_INT 127
6499: PPUSH
6500: LD_INT 27
6502: PPUSH
6503: LD_INT 1
6505: PPUSH
6506: CALL_OW 453
// MineExplosion ( 125 , 29 , 1 ) ;
6510: LD_INT 125
6512: PPUSH
6513: LD_INT 29
6515: PPUSH
6516: LD_INT 1
6518: PPUSH
6519: CALL_OW 453
// end ; exit ;
6523: GO 6711
// end ; if b = HexInfo ( 106 , 51 ) then
6525: LD_VAR 0 1
6529: PUSH
6530: LD_INT 106
6532: PPUSH
6533: LD_INT 51
6535: PPUSH
6536: CALL_OW 428
6540: EQUAL
6541: IFFALSE 6641
// begin AddComMoveXY ( un , 106 , 93 ) ;
6543: LD_VAR 0 2
6547: PPUSH
6548: LD_INT 106
6550: PPUSH
6551: LD_INT 93
6553: PPUSH
6554: CALL_OW 171
// if not explodeSecondDepot then
6558: LD_EXP 13
6562: NOT
6563: IFFALSE 6639
// begin explodeSecondDepot := true ;
6565: LD_ADDR_EXP 13
6569: PUSH
6570: LD_INT 1
6572: ST_TO_ADDR
// wait ( 0 0$12 ) ;
6573: LD_INT 420
6575: PPUSH
6576: CALL_OW 67
// MineExplosion ( 111 , 75 , 1 ) ;
6580: LD_INT 111
6582: PPUSH
6583: LD_INT 75
6585: PPUSH
6586: LD_INT 1
6588: PPUSH
6589: CALL_OW 453
// MineExplosion ( 111 , 75 , 1 ) ;
6593: LD_INT 111
6595: PPUSH
6596: LD_INT 75
6598: PPUSH
6599: LD_INT 1
6601: PPUSH
6602: CALL_OW 453
// MineExplosion ( 108 , 69 , 1 ) ;
6606: LD_INT 108
6608: PPUSH
6609: LD_INT 69
6611: PPUSH
6612: LD_INT 1
6614: PPUSH
6615: CALL_OW 453
// wait ( 0 0$2 ) ;
6619: LD_INT 70
6621: PPUSH
6622: CALL_OW 67
// MineExplosion ( 94 , 65 , 1 ) ;
6626: LD_INT 94
6628: PPUSH
6629: LD_INT 65
6631: PPUSH
6632: LD_INT 1
6634: PPUSH
6635: CALL_OW 453
// end ; exit ;
6639: GO 6711
// end ; if GetBType ( b ) = b_bunker then
6641: LD_VAR 0 1
6645: PPUSH
6646: CALL_OW 266
6650: PUSH
6651: LD_INT 32
6653: EQUAL
6654: IFFALSE 6711
// begin barracks := NearestEmptyBuilding ( un , b_barracks ) ;
6656: LD_ADDR_VAR 0 3
6660: PUSH
6661: LD_VAR 0 2
6665: PPUSH
6666: LD_INT 5
6668: PPUSH
6669: CALL 2403 0 2
6673: ST_TO_ADDR
// if barracks then
6674: LD_VAR 0 3
6678: IFFALSE 6696
// AddComEnterUnit ( un , barracks ) else
6680: LD_VAR 0 2
6684: PPUSH
6685: LD_VAR 0 3
6689: PPUSH
6690: CALL_OW 180
6694: GO 6711
// AddComMoveXY ( un , 116 , 110 ) ;
6696: LD_VAR 0 2
6700: PPUSH
6701: LD_INT 116
6703: PPUSH
6704: LD_INT 110
6706: PPUSH
6707: CALL_OW 171
// end ; end ;
6711: PPOPN 3
6713: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un = Kaia and killerSide in [ 3 , 6 ] then
6714: LD_VAR 0 1
6718: PUSH
6719: LD_EXP 23
6723: EQUAL
6724: PUSH
6725: LD_VAR 0 2
6729: PUSH
6730: LD_INT 3
6732: PUSH
6733: LD_INT 6
6735: PUSH
6736: EMPTY
6737: LIST
6738: LIST
6739: IN
6740: AND
6741: IFFALSE 6772
// kaiaKilledByRussian := [ GetX ( un ) , GetY ( un ) ] ;
6743: LD_ADDR_EXP 8
6747: PUSH
6748: LD_VAR 0 1
6752: PPUSH
6753: CALL_OW 250
6757: PUSH
6758: LD_VAR 0 1
6762: PPUSH
6763: CALL_OW 251
6767: PUSH
6768: EMPTY
6769: LIST
6770: LIST
6771: ST_TO_ADDR
// end ; end_of_file
6772: PPOPN 3
6774: END
// export function Action ; var i , un , veh , tmp , rutmp ; begin
6775: LD_INT 0
6777: PPUSH
6778: PPUSH
6779: PPUSH
6780: PPUSH
6781: PPUSH
6782: PPUSH
// InGameOn ;
6783: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6787: LD_INT 5
6789: PPUSH
6790: LD_INT 2
6792: PPUSH
6793: CALL_OW 343
// music_nat := 4 ;
6797: LD_ADDR_OWVAR 71
6801: PUSH
6802: LD_INT 4
6804: ST_TO_ADDR
// music_class := music_combat ;
6805: LD_ADDR_OWVAR 72
6809: PUSH
6810: LD_INT 1
6812: ST_TO_ADDR
// PlaceSeeing ( 133 , 2 , 2 , 10 ) ;
6813: LD_INT 133
6815: PPUSH
6816: LD_INT 2
6818: PPUSH
6819: LD_INT 2
6821: PPUSH
6822: LD_INT 10
6824: PPUSH
6825: CALL_OW 330
// CenterNowOnXY ( 133 , 2 ) ;
6829: LD_INT 133
6831: PPUSH
6832: LD_INT 2
6834: PPUSH
6835: CALL_OW 86
// wait ( 0 0$1 ) ;
6839: LD_INT 35
6841: PPUSH
6842: CALL_OW 67
// uc_side := 6 ;
6846: LD_ADDR_OWVAR 20
6850: PUSH
6851: LD_INT 6
6853: ST_TO_ADDR
// uc_nation := 3 ;
6854: LD_ADDR_OWVAR 21
6858: PUSH
6859: LD_INT 3
6861: ST_TO_ADDR
// rutmp := [ ] ;
6862: LD_ADDR_VAR 0 6
6866: PUSH
6867: EMPTY
6868: ST_TO_ADDR
// PrepareTank ( 6 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_gun , 66 ) ;
6869: LD_INT 6
6871: PPUSH
6872: LD_INT 3
6874: PPUSH
6875: LD_INT 21
6877: PPUSH
6878: LD_INT 1
6880: PPUSH
6881: LD_INT 1
6883: PPUSH
6884: LD_INT 44
6886: PPUSH
6887: LD_INT 66
6889: PPUSH
6890: CALL 399 0 7
// veh := CreateVehicle ;
6894: LD_ADDR_VAR 0 4
6898: PUSH
6899: CALL_OW 45
6903: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
6904: LD_VAR 0 4
6908: PPUSH
6909: LD_INT 3
6911: PPUSH
6912: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
6916: LD_VAR 0 4
6920: PPUSH
6921: LD_INT 8
6923: PPUSH
6924: LD_INT 0
6926: PPUSH
6927: CALL_OW 49
// SetLives ( veh , 500 ) ;
6931: LD_VAR 0 4
6935: PPUSH
6936: LD_INT 500
6938: PPUSH
6939: CALL_OW 234
// PrepareHuman ( false , 3 , 3 ) ;
6943: LD_INT 0
6945: PPUSH
6946: LD_INT 3
6948: PPUSH
6949: LD_INT 3
6951: PPUSH
6952: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6956: CALL_OW 44
6960: PPUSH
6961: LD_VAR 0 4
6965: PPUSH
6966: CALL_OW 52
// ComMoveXY ( veh , 133 , 11 ) ;
6970: LD_VAR 0 4
6974: PPUSH
6975: LD_INT 133
6977: PPUSH
6978: LD_INT 11
6980: PPUSH
6981: CALL_OW 111
// rutmp := [ veh ] ;
6985: LD_ADDR_VAR 0 6
6989: PUSH
6990: LD_VAR 0 4
6994: PUSH
6995: EMPTY
6996: LIST
6997: ST_TO_ADDR
// for i := 1 to 4 do
6998: LD_ADDR_VAR 0 2
7002: PUSH
7003: DOUBLE
7004: LD_INT 1
7006: DEC
7007: ST_TO_ADDR
7008: LD_INT 4
7010: PUSH
7011: FOR_TO
7012: IFFALSE 7119
// begin PrepareHuman ( false , i , 2 ) ;
7014: LD_INT 0
7016: PPUSH
7017: LD_VAR 0 2
7021: PPUSH
7022: LD_INT 2
7024: PPUSH
7025: CALL_OW 380
// un := CreateHuman ;
7029: LD_ADDR_VAR 0 3
7033: PUSH
7034: CALL_OW 44
7038: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7039: LD_VAR 0 3
7043: PPUSH
7044: LD_INT 3
7046: PPUSH
7047: CALL_OW 233
// PlaceUnitArea ( un , spawnArea , false ) ;
7051: LD_VAR 0 3
7055: PPUSH
7056: LD_INT 8
7058: PPUSH
7059: LD_INT 0
7061: PPUSH
7062: CALL_OW 49
// rutmp := Replace ( rutmp , rutmp + 1 , un ) ;
7066: LD_ADDR_VAR 0 6
7070: PUSH
7071: LD_VAR 0 6
7075: PPUSH
7076: LD_VAR 0 6
7080: PUSH
7081: LD_INT 1
7083: PLUS
7084: PPUSH
7085: LD_VAR 0 3
7089: PPUSH
7090: CALL_OW 1
7094: ST_TO_ADDR
// ComMoveXY ( un , 133 , 11 ) ;
7095: LD_VAR 0 3
7099: PPUSH
7100: LD_INT 133
7102: PPUSH
7103: LD_INT 11
7105: PPUSH
7106: CALL_OW 111
// wait ( 0 0$0.5 ) ;
7110: LD_INT 18
7112: PPUSH
7113: CALL_OW 67
// end ;
7117: GO 7011
7119: POP
7120: POP
// for i in rutmp do
7121: LD_ADDR_VAR 0 2
7125: PUSH
7126: LD_VAR 0 6
7130: PUSH
7131: FOR_IN
7132: IFFALSE 7181
// begin AddComMoveXY ( i , 99 , 65 ) ;
7134: LD_VAR 0 2
7138: PPUSH
7139: LD_INT 99
7141: PPUSH
7142: LD_INT 65
7144: PPUSH
7145: CALL_OW 171
// AddComMoveXY ( i , 76 , 108 ) ;
7149: LD_VAR 0 2
7153: PPUSH
7154: LD_INT 76
7156: PPUSH
7157: LD_INT 108
7159: PPUSH
7160: CALL_OW 171
// AddComMoveXY ( i , 92 , 176 ) ;
7164: LD_VAR 0 2
7168: PPUSH
7169: LD_INT 92
7171: PPUSH
7172: LD_INT 176
7174: PPUSH
7175: CALL_OW 171
// end ;
7179: GO 7131
7181: POP
7182: POP
// wait ( 0 0$10 ) ;
7183: LD_INT 350
7185: PPUSH
7186: CALL_OW 67
// tmp := [ Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Kurt , Aviradze ] union heikeSecondSquad ;
7190: LD_ADDR_VAR 0 5
7194: PUSH
7195: LD_EXP 18
7199: PUSH
7200: LD_EXP 19
7204: PUSH
7205: LD_EXP 20
7209: PUSH
7210: LD_EXP 21
7214: PUSH
7215: LD_EXP 22
7219: PUSH
7220: LD_EXP 23
7224: PUSH
7225: LD_EXP 24
7229: PUSH
7230: LD_EXP 25
7234: PUSH
7235: LD_EXP 27
7239: PUSH
7240: LD_EXP 28
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: LIST
7249: LIST
7250: LIST
7251: LIST
7252: LIST
7253: LIST
7254: LIST
7255: LIST
7256: PUSH
7257: LD_EXP 29
7261: UNION
7262: ST_TO_ADDR
// tmp := tmp diff 0 ;
7263: LD_ADDR_VAR 0 5
7267: PUSH
7268: LD_VAR 0 5
7272: PUSH
7273: LD_INT 0
7275: DIFF
7276: ST_TO_ADDR
// for i in heikeVehicles do
7277: LD_ADDR_VAR 0 2
7281: PUSH
7282: LD_EXP 30
7286: PUSH
7287: FOR_IN
7288: IFFALSE 7554
// begin if not tmp then
7290: LD_VAR 0 5
7294: NOT
7295: IFFALSE 7299
// continue ;
7297: GO 7287
// PrepareTank ( 2 , i [ 5 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] , 34 ) ;
7299: LD_INT 2
7301: PPUSH
7302: LD_VAR 0 2
7306: PUSH
7307: LD_INT 5
7309: ARRAY
7310: PPUSH
7311: LD_VAR 0 2
7315: PUSH
7316: LD_INT 1
7318: ARRAY
7319: PPUSH
7320: LD_VAR 0 2
7324: PUSH
7325: LD_INT 2
7327: ARRAY
7328: PPUSH
7329: LD_VAR 0 2
7333: PUSH
7334: LD_INT 3
7336: ARRAY
7337: PPUSH
7338: LD_VAR 0 2
7342: PUSH
7343: LD_INT 4
7345: ARRAY
7346: PPUSH
7347: LD_INT 34
7349: PPUSH
7350: CALL 399 0 7
// veh := CreateVehicle ;
7354: LD_ADDR_VAR 0 4
7358: PUSH
7359: CALL_OW 45
7363: ST_TO_ADDR
// if i [ 4 ] in [ ru_cargo_bay , ar_cargo_bay , us_cargo_bay ] then
7364: LD_VAR 0 2
7368: PUSH
7369: LD_INT 4
7371: ARRAY
7372: PUSH
7373: LD_INT 51
7375: PUSH
7376: LD_INT 32
7378: PUSH
7379: LD_INT 12
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: IN
7387: IFFALSE 7467
// begin if i [ 7 ] [ 1 ] then
7389: LD_VAR 0 2
7393: PUSH
7394: LD_INT 7
7396: ARRAY
7397: PUSH
7398: LD_INT 1
7400: ARRAY
7401: IFFALSE 7428
// AddCargo ( veh , mat_cans , i [ 7 ] [ 1 ] ) ;
7403: LD_VAR 0 4
7407: PPUSH
7408: LD_INT 1
7410: PPUSH
7411: LD_VAR 0 2
7415: PUSH
7416: LD_INT 7
7418: ARRAY
7419: PUSH
7420: LD_INT 1
7422: ARRAY
7423: PPUSH
7424: CALL_OW 291
// if i [ 7 ] [ 2 ] then
7428: LD_VAR 0 2
7432: PUSH
7433: LD_INT 7
7435: ARRAY
7436: PUSH
7437: LD_INT 2
7439: ARRAY
7440: IFFALSE 7467
// AddCargo ( veh , mat_oil , i [ 7 ] [ 2 ] ) ;
7442: LD_VAR 0 4
7446: PPUSH
7447: LD_INT 2
7449: PPUSH
7450: LD_VAR 0 2
7454: PUSH
7455: LD_INT 7
7457: ARRAY
7458: PUSH
7459: LD_INT 2
7461: ARRAY
7462: PPUSH
7463: CALL_OW 291
// end ; SetDir ( veh , 3 ) ;
7467: LD_VAR 0 4
7471: PPUSH
7472: LD_INT 3
7474: PPUSH
7475: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7479: LD_VAR 0 4
7483: PPUSH
7484: LD_INT 8
7486: PPUSH
7487: LD_INT 0
7489: PPUSH
7490: CALL_OW 49
// PlaceHumanInUnit ( tmp [ 1 ] , veh ) ;
7494: LD_VAR 0 5
7498: PUSH
7499: LD_INT 1
7501: ARRAY
7502: PPUSH
7503: LD_VAR 0 4
7507: PPUSH
7508: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
7512: LD_ADDR_VAR 0 5
7516: PUSH
7517: LD_VAR 0 5
7521: PPUSH
7522: LD_INT 1
7524: PPUSH
7525: CALL_OW 3
7529: ST_TO_ADDR
// ComAgressiveMove ( veh , 133 , 7 ) ;
7530: LD_VAR 0 4
7534: PPUSH
7535: LD_INT 133
7537: PPUSH
7538: LD_INT 7
7540: PPUSH
7541: CALL_OW 114
// wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// end ;
7552: GO 7287
7554: POP
7555: POP
// if tmp then
7556: LD_VAR 0 5
7560: IFFALSE 7616
// for i in tmp do
7562: LD_ADDR_VAR 0 2
7566: PUSH
7567: LD_VAR 0 5
7571: PUSH
7572: FOR_IN
7573: IFFALSE 7614
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7575: LD_VAR 0 2
7579: PPUSH
7580: LD_INT 10
7582: PPUSH
7583: LD_INT 0
7585: PPUSH
7586: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7590: LD_VAR 0 2
7594: PPUSH
7595: LD_INT 146
7597: PPUSH
7598: LD_INT 7
7600: PPUSH
7601: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7605: LD_INT 18
7607: PPUSH
7608: CALL_OW 67
// end ;
7612: GO 7572
7614: POP
7615: POP
// if heikeApes then
7616: LD_EXP 31
7620: IFFALSE 7676
// for i in heikeApes do
7622: LD_ADDR_VAR 0 2
7626: PUSH
7627: LD_EXP 31
7631: PUSH
7632: FOR_IN
7633: IFFALSE 7674
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7635: LD_VAR 0 2
7639: PPUSH
7640: LD_INT 10
7642: PPUSH
7643: LD_INT 0
7645: PPUSH
7646: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7650: LD_VAR 0 2
7654: PPUSH
7655: LD_INT 146
7657: PPUSH
7658: LD_INT 7
7660: PPUSH
7661: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7665: LD_INT 18
7667: PPUSH
7668: CALL_OW 67
// end ;
7672: GO 7632
7674: POP
7675: POP
// DialogueOn ;
7676: CALL_OW 6
// Say ( Heike , DH-outpost-a-1 ) ;
7680: LD_EXP 18
7684: PPUSH
7685: LD_STRING DH-outpost-a-1
7687: PPUSH
7688: CALL_OW 88
// DialogueOff ;
7692: CALL_OW 7
// RemoveSeeing ( 133 , 2 , 2 ) ;
7696: LD_INT 133
7698: PPUSH
7699: LD_INT 2
7701: PPUSH
7702: LD_INT 2
7704: PPUSH
7705: CALL_OW 331
// InGameOff ;
7709: CALL_OW 9
// music_nat := 0 ;
7713: LD_ADDR_OWVAR 71
7717: PUSH
7718: LD_INT 0
7720: ST_TO_ADDR
// music_class := 0 ;
7721: LD_ADDR_OWVAR 72
7725: PUSH
7726: LD_INT 0
7728: ST_TO_ADDR
// ChangeMissionObjectives ( Outposts ) ;
7729: LD_STRING Outposts
7731: PPUSH
7732: CALL_OW 337
// SaveForQuickRestart ;
7736: CALL_OW 22
// end ;
7740: LD_VAR 0 1
7744: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 20 ] ] ) and ibrahimOnRuSide and IsOk ( Ibrahim ) do
7745: LD_INT 22
7747: PUSH
7748: LD_INT 2
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: PUSH
7755: LD_INT 91
7757: PUSH
7758: LD_EXP 21
7762: PUSH
7763: LD_INT 20
7765: PUSH
7766: EMPTY
7767: LIST
7768: LIST
7769: LIST
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PPUSH
7775: CALL_OW 69
7779: PUSH
7780: LD_EXP 3
7784: AND
7785: PUSH
7786: LD_EXP 21
7790: PPUSH
7791: CALL_OW 302
7795: AND
7796: IFFALSE 7884
7798: GO 7800
7800: DISABLE
// begin IbrahimBetrayal ;
7801: CALL 7885 0 0
// repeat wait ( 0 0$1 ) ;
7805: LD_INT 35
7807: PPUSH
7808: CALL_OW 67
// until IsDead ( Ibrahim ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 6 ] ] ) ;
7812: LD_EXP 21
7816: PPUSH
7817: CALL_OW 301
7821: PUSH
7822: LD_INT 22
7824: PUSH
7825: LD_INT 2
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: PUSH
7832: LD_INT 91
7834: PUSH
7835: LD_EXP 21
7839: PUSH
7840: LD_INT 6
7842: PUSH
7843: EMPTY
7844: LIST
7845: LIST
7846: LIST
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: PPUSH
7852: CALL_OW 69
7856: OR
7857: IFFALSE 7805
// if IsDead ( Ibrahim ) then
7859: LD_EXP 21
7863: PPUSH
7864: CALL_OW 301
7868: IFFALSE 7872
// exit ;
7870: GO 7884
// SetSide ( Ibrahim , 2 ) ;
7872: LD_EXP 21
7876: PPUSH
7877: LD_INT 2
7879: PPUSH
7880: CALL_OW 235
// end ;
7884: END
// export function IbrahimBetrayal ; var i , tmp ; begin
7885: LD_INT 0
7887: PPUSH
7888: PPUSH
7889: PPUSH
// PlaceSeeing ( 122 , 77 , 2 , - 6 ) ;
7890: LD_INT 122
7892: PPUSH
7893: LD_INT 77
7895: PPUSH
7896: LD_INT 2
7898: PPUSH
7899: LD_INT 6
7901: NEG
7902: PPUSH
7903: CALL_OW 330
// ComMoveXY ( Ibrahim , 123 , 79 ) ;
7907: LD_EXP 21
7911: PPUSH
7912: LD_INT 123
7914: PPUSH
7915: LD_INT 79
7917: PPUSH
7918: CALL_OW 111
// AddComTurnXY ( Ibrahim , 125 , 82 ) ;
7922: LD_EXP 21
7926: PPUSH
7927: LD_INT 125
7929: PPUSH
7930: LD_INT 82
7932: PPUSH
7933: CALL_OW 178
// wait ( 0 0$2 ) ;
7937: LD_INT 70
7939: PPUSH
7940: CALL_OW 67
// ComTurnUnit ( ruSol , Ibrahim ) ;
7944: LD_EXP 41
7948: PPUSH
7949: LD_EXP 21
7953: PPUSH
7954: CALL_OW 119
// Say ( ruSol , DRum-outpost-b-3 ) ;
7958: LD_EXP 41
7962: PPUSH
7963: LD_STRING DRum-outpost-b-3
7965: PPUSH
7966: CALL_OW 88
// tmp := [ HexInfo ( 125 , 76 ) , HexInfo ( 125 , 79 ) , HexInfo ( 125 , 82 ) ] ;
7970: LD_ADDR_VAR 0 3
7974: PUSH
7975: LD_INT 125
7977: PPUSH
7978: LD_INT 76
7980: PPUSH
7981: CALL_OW 428
7985: PUSH
7986: LD_INT 125
7988: PPUSH
7989: LD_INT 79
7991: PPUSH
7992: CALL_OW 428
7996: PUSH
7997: LD_INT 125
7999: PPUSH
8000: LD_INT 82
8002: PPUSH
8003: CALL_OW 428
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: LIST
8012: ST_TO_ADDR
// for i in tmp do
8013: LD_ADDR_VAR 0 2
8017: PUSH
8018: LD_VAR 0 3
8022: PUSH
8023: FOR_IN
8024: IFFALSE 8040
// SetLives ( i , 200 ) ;
8026: LD_VAR 0 2
8030: PPUSH
8031: LD_INT 200
8033: PPUSH
8034: CALL_OW 234
8038: GO 8023
8040: POP
8041: POP
// Say ( Ibrahim , DI-outpost-b-4 ) ;
8042: LD_EXP 21
8046: PPUSH
8047: LD_STRING DI-outpost-b-4
8049: PPUSH
8050: CALL_OW 88
// SetSide ( Ibrahim , 5 ) ;
8054: LD_EXP 21
8058: PPUSH
8059: LD_INT 5
8061: PPUSH
8062: CALL_OW 235
// ComFree ( [ Ibrahim , ruSol ] ) ;
8066: LD_EXP 21
8070: PUSH
8071: LD_EXP 41
8075: PUSH
8076: EMPTY
8077: LIST
8078: LIST
8079: PPUSH
8080: CALL_OW 139
// RemoveSeeing ( 122 , 77 , 2 ) ;
8084: LD_INT 122
8086: PPUSH
8087: LD_INT 77
8089: PPUSH
8090: LD_INT 2
8092: PPUSH
8093: CALL_OW 331
// if Givi then
8097: LD_EXP 19
8101: IFFALSE 8117
// Say ( Givi , DG-1-outpost-b-5 ) else
8103: LD_EXP 19
8107: PPUSH
8108: LD_STRING DG-1-outpost-b-5
8110: PPUSH
8111: CALL_OW 88
8115: GO 8182
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-outpost-b-a-5 ) then
8117: LD_EXP 29
8121: PPUSH
8122: LD_INT 26
8124: PUSH
8125: LD_INT 2
8127: PUSH
8128: EMPTY
8129: LIST
8130: LIST
8131: PPUSH
8132: CALL_OW 72
8136: PUSH
8137: LD_INT 1
8139: ARRAY
8140: PPUSH
8141: LD_STRING DArf-outpost-b-a-5
8143: PPUSH
8144: CALL_OW 88
8148: NOT
8149: IFFALSE 8182
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-outpost-b-a-5 ) ;
8151: LD_EXP 29
8155: PPUSH
8156: LD_INT 26
8158: PUSH
8159: LD_INT 1
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: PPUSH
8166: CALL_OW 72
8170: PUSH
8171: LD_INT 1
8173: ARRAY
8174: PPUSH
8175: LD_STRING DArm-outpost-b-a-5
8177: PPUSH
8178: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
8182: LD_INT 35
8184: PPUSH
8185: CALL_OW 67
// until IsDead ( Ibrahim ) or ( GetDistUnits ( Heike , Ibrahim ) < 6 and IsOk ( Ibrahim ) ) ;
8189: LD_EXP 21
8193: PPUSH
8194: CALL_OW 301
8198: PUSH
8199: LD_EXP 18
8203: PPUSH
8204: LD_EXP 21
8208: PPUSH
8209: CALL_OW 296
8213: PUSH
8214: LD_INT 6
8216: LESS
8217: PUSH
8218: LD_EXP 21
8222: PPUSH
8223: CALL_OW 302
8227: AND
8228: OR
8229: IFFALSE 8182
// if IsDead ( Ibrahim ) then
8231: LD_EXP 21
8235: PPUSH
8236: CALL_OW 301
8240: IFFALSE 8256
// begin Say ( Heike , DH-ibrahimdead-1 ) ;
8242: LD_EXP 18
8246: PPUSH
8247: LD_STRING DH-ibrahimdead-1
8249: PPUSH
8250: CALL_OW 88
// exit ;
8254: GO 8301
// end ; CenterNowOnUnits ( Ibrahim ) ;
8256: LD_EXP 21
8260: PPUSH
8261: CALL_OW 87
// Say ( Ibrahim , DI-ibrahimlives-1 ) ;
8265: LD_EXP 21
8269: PPUSH
8270: LD_STRING DI-ibrahimlives-1
8272: PPUSH
8273: CALL_OW 88
// Say ( Heike , DH-Ibrahimlives-2 ) ;
8277: LD_EXP 18
8281: PPUSH
8282: LD_STRING DH-Ibrahimlives-2
8284: PPUSH
8285: CALL_OW 88
// SetSide ( Ibrahim , 2 ) ;
8289: LD_EXP 21
8293: PPUSH
8294: LD_INT 2
8296: PPUSH
8297: CALL_OW 235
// end ;
8301: LD_VAR 0 1
8305: RET
// every 0 0$2 trigger FilterUnitsInArea ( outerArea , [ f_side , 2 ] ) do
8306: LD_INT 11
8308: PPUSH
8309: LD_INT 22
8311: PUSH
8312: LD_INT 2
8314: PUSH
8315: EMPTY
8316: LIST
8317: LIST
8318: PPUSH
8319: CALL_OW 70
8323: IFFALSE 8730
8325: GO 8327
8327: DISABLE
// begin outerAreaAchived := true ;
8328: LD_ADDR_EXP 15
8332: PUSH
8333: LD_INT 1
8335: ST_TO_ADDR
// wait ( 0 0$20 ) ;
8336: LD_INT 700
8338: PPUSH
8339: CALL_OW 67
// DialogueOn ;
8343: CALL_OW 6
// SayRadio ( Shariff , DShar-radio-1 ) ;
8347: LD_EXP 26
8351: PPUSH
8352: LD_STRING DShar-radio-1
8354: PPUSH
8355: CALL_OW 94
// SayRadio ( Shariff , DShar-radio-2 ) ;
8359: LD_EXP 26
8363: PPUSH
8364: LD_STRING DShar-radio-2
8366: PPUSH
8367: CALL_OW 94
// Say ( Heike , DH-radio-2 ) ;
8371: LD_EXP 18
8375: PPUSH
8376: LD_STRING DH-radio-2
8378: PPUSH
8379: CALL_OW 88
// DialogueOff ;
8383: CALL_OW 7
// ChangeMissionObjectives ( Gaidar ) ;
8387: LD_STRING Gaidar
8389: PPUSH
8390: CALL_OW 337
// if Difficulty < 3 then
8394: LD_OWVAR 67
8398: PUSH
8399: LD_INT 3
8401: LESS
8402: IFFALSE 8468
// begin DialogueOn ;
8404: CALL_OW 6
// PlaceSeeing ( 11 , 14 , 2 , - 6 ) ;
8408: LD_INT 11
8410: PPUSH
8411: LD_INT 14
8413: PPUSH
8414: LD_INT 2
8416: PPUSH
8417: LD_INT 6
8419: NEG
8420: PPUSH
8421: CALL_OW 330
// RemoveSeeing ( 11 , 14 , 2 ) ;
8425: LD_INT 11
8427: PPUSH
8428: LD_INT 14
8430: PPUSH
8431: LD_INT 2
8433: PPUSH
8434: CALL_OW 331
// CenterOnXY ( 11 , 14 ) ;
8438: LD_INT 11
8440: PPUSH
8441: LD_INT 14
8443: PPUSH
8444: CALL_OW 84
// dwait ( 0 0$1 ) ;
8448: LD_INT 35
8450: PPUSH
8451: CALL_OW 68
// CenterNowOnUnits ( Heike ) ;
8455: LD_EXP 18
8459: PPUSH
8460: CALL_OW 87
// DialogueOff ;
8464: CALL_OW 7
// end ; wait ( 0 0$10 + rand ( 0 0$10 , 0 0$15 ) * Difficulty ) ;
8468: LD_INT 350
8470: PUSH
8471: LD_INT 350
8473: PPUSH
8474: LD_INT 525
8476: PPUSH
8477: CALL_OW 12
8481: PUSH
8482: LD_OWVAR 67
8486: MUL
8487: PLUS
8488: PPUSH
8489: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8493: LD_INT 35
8495: PPUSH
8496: CALL_OW 67
// until HexInfo ( 2 , 1 ) = 0 ;
8500: LD_INT 2
8502: PPUSH
8503: LD_INT 1
8505: PPUSH
8506: CALL_OW 428
8510: PUSH
8511: LD_INT 0
8513: EQUAL
8514: IFFALSE 8493
// SetDir ( Gaidar , 2 ) ;
8516: LD_EXP 34
8520: PPUSH
8521: LD_INT 2
8523: PPUSH
8524: CALL_OW 233
// PlaceUnitXY ( Gaidar , 2 , 1 , false ) ;
8528: LD_EXP 34
8532: PPUSH
8533: LD_INT 2
8535: PPUSH
8536: LD_INT 1
8538: PPUSH
8539: LD_INT 0
8541: PPUSH
8542: CALL_OW 48
// ComMoveXY ( Gaidar , 19 , 24 ) ;
8546: LD_EXP 34
8550: PPUSH
8551: LD_INT 19
8553: PPUSH
8554: LD_INT 24
8556: PPUSH
8557: CALL_OW 111
// AddComWait ( Gaidar , 0 0$6 ) ;
8561: LD_EXP 34
8565: PPUSH
8566: LD_INT 210
8568: PPUSH
8569: CALL_OW 202
// AddComMoveXY ( Gaidar , 38 , 47 ) ;
8573: LD_EXP 34
8577: PPUSH
8578: LD_INT 38
8580: PPUSH
8581: LD_INT 47
8583: PPUSH
8584: CALL_OW 171
// AddComMoveXY ( Gaidar , 32 , 59 ) ;
8588: LD_EXP 34
8592: PPUSH
8593: LD_INT 32
8595: PPUSH
8596: LD_INT 59
8598: PPUSH
8599: CALL_OW 171
// AddComWait ( Gaidar , 0 0$10 ) ;
8603: LD_EXP 34
8607: PPUSH
8608: LD_INT 350
8610: PPUSH
8611: CALL_OW 202
// AddComMoveXY ( Gaidar , 62 , 116 ) ;
8615: LD_EXP 34
8619: PPUSH
8620: LD_INT 62
8622: PPUSH
8623: LD_INT 116
8625: PPUSH
8626: CALL_OW 171
// AddComMoveXY ( Gaidar , 92 , 177 ) ;
8630: LD_EXP 34
8634: PPUSH
8635: LD_INT 92
8637: PPUSH
8638: LD_INT 177
8640: PPUSH
8641: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8645: LD_INT 35
8647: PPUSH
8648: CALL_OW 67
// until IsDead ( Gaidar ) or IsAt ( Gaidar , 92 , 177 ) ;
8652: LD_EXP 34
8656: PPUSH
8657: CALL_OW 301
8661: PUSH
8662: LD_EXP 34
8666: PPUSH
8667: LD_INT 92
8669: PPUSH
8670: LD_INT 177
8672: PPUSH
8673: CALL_OW 307
8677: OR
8678: IFFALSE 8645
// if IsAt ( Gaidar , 92 , 177 ) then
8680: LD_EXP 34
8684: PPUSH
8685: LD_INT 92
8687: PPUSH
8688: LD_INT 177
8690: PPUSH
8691: CALL_OW 307
8695: IFFALSE 8708
// begin RemoveUnit ( Gaidar ) ;
8697: LD_EXP 34
8701: PPUSH
8702: CALL_OW 64
// exit ;
8706: GO 8730
// end ; gaidarKilled := true ;
8708: LD_ADDR_EXP 14
8712: PUSH
8713: LD_INT 1
8715: ST_TO_ADDR
// ChangeMissionObjectives ( GaidarKilled ) ;
8716: LD_STRING GaidarKilled
8718: PPUSH
8719: CALL_OW 337
// SetAchievement ( ACH_COMMISAR ) ;
8723: LD_STRING ACH_COMMISAR
8725: PPUSH
8726: CALL_OW 543
// end ;
8730: END
// every 0 0$1 trigger See ( 2 , Gaidar ) do
8731: LD_INT 2
8733: PPUSH
8734: LD_EXP 34
8738: PPUSH
8739: CALL_OW 292
8743: IFFALSE 8760
8745: GO 8747
8747: DISABLE
// Say ( Gaidar , DT-objective-1 ) ;
8748: LD_EXP 34
8752: PPUSH
8753: LD_STRING DT-objective-1
8755: PPUSH
8756: CALL_OW 88
8760: END
// every 0 0$5 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) do
8761: LD_INT 22
8763: PUSH
8764: LD_INT 2
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: PUSH
8771: LD_INT 2
8773: PUSH
8774: LD_INT 95
8776: PUSH
8777: LD_INT 5
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: PUSH
8784: LD_INT 95
8786: PUSH
8787: LD_INT 6
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: PUSH
8794: LD_INT 95
8796: PUSH
8797: LD_INT 7
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: EMPTY
8805: LIST
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PPUSH
8814: CALL_OW 69
8818: IFFALSE 8847
8820: GO 8822
8822: DISABLE
// begin Say ( Heike , DH-outpost-last-1 ) ;
8823: LD_EXP 18
8827: PPUSH
8828: LD_STRING DH-outpost-last-1
8830: PPUSH
8831: CALL_OW 88
// SayRadio ( Burlak , DB-outpost-last-2 ) ;
8835: LD_EXP 33
8839: PPUSH
8840: LD_STRING DB-outpost-last-2
8842: PPUSH
8843: CALL_OW 94
// end ;
8847: END
// every 0 0$1 trigger GetLives ( ruMainBase ) < 999 or GetSide ( ruMainBase ) = 2 do var i , tmp ;
8848: LD_INT 200
8850: PPUSH
8851: CALL_OW 256
8855: PUSH
8856: LD_INT 999
8858: LESS
8859: PUSH
8860: LD_INT 200
8862: PPUSH
8863: CALL_OW 255
8867: PUSH
8868: LD_INT 2
8870: EQUAL
8871: OR
8872: IFFALSE 9045
8874: GO 8876
8876: DISABLE
8877: LD_INT 0
8879: PPUSH
8880: PPUSH
// begin if not earlyEscape then
8881: LD_EXP 16
8885: NOT
8886: IFFALSE 8912
// begin SayRadio ( Burlak , DB-end-1 ) ;
8888: LD_EXP 33
8892: PPUSH
8893: LD_STRING DB-end-1
8895: PPUSH
8896: CALL_OW 94
// Say ( Heike , DH-end-2 ) ;
8900: LD_EXP 18
8904: PPUSH
8905: LD_STRING DH-end-2
8907: PPUSH
8908: CALL_OW 88
// end ; if tick <= 15 15$00 then
8912: LD_OWVAR 1
8916: PUSH
8917: LD_INT 31500
8919: LESSEQUAL
8920: IFFALSE 8929
// SetAchievement ( ACH_FIST ) ;
8922: LD_STRING ACH_FIST
8924: PPUSH
8925: CALL_OW 543
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
8929: LD_ADDR_VAR 0 2
8933: PUSH
8934: LD_INT 22
8936: PUSH
8937: LD_INT 3
8939: PUSH
8940: EMPTY
8941: LIST
8942: LIST
8943: PUSH
8944: LD_INT 3
8946: PUSH
8947: LD_INT 21
8949: PUSH
8950: LD_INT 3
8952: PUSH
8953: EMPTY
8954: LIST
8955: LIST
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: EMPTY
8962: LIST
8963: LIST
8964: PPUSH
8965: CALL_OW 69
8969: ST_TO_ADDR
// if not tmp then
8970: LD_VAR 0 2
8974: NOT
8975: IFFALSE 8979
// exit ;
8977: GO 9045
// for i in tmp do
8979: LD_ADDR_VAR 0 1
8983: PUSH
8984: LD_VAR 0 2
8988: PUSH
8989: FOR_IN
8990: IFFALSE 9043
// begin SetTag ( i , tEscape ) ;
8992: LD_VAR 0 1
8996: PPUSH
8997: LD_EXP 17
9001: PPUSH
9002: CALL_OW 109
// if IsInUnit ( i ) then
9006: LD_VAR 0 1
9010: PPUSH
9011: CALL_OW 310
9015: IFFALSE 9026
// ComExitBuilding ( i ) ;
9017: LD_VAR 0 1
9021: PPUSH
9022: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9026: LD_VAR 0 1
9030: PPUSH
9031: LD_INT 92
9033: PPUSH
9034: LD_INT 177
9036: PPUSH
9037: CALL_OW 171
// end ;
9041: GO 8989
9043: POP
9044: POP
// end ;
9045: PPOPN 2
9047: END
// every 0 0$1 trigger FilterUnitsInArea ( zone1 , [ f_side , 2 ] ) and not outerAreaAchived and IsOk ( Kurt ) do
9048: LD_INT 4
9050: PPUSH
9051: LD_INT 22
9053: PUSH
9054: LD_INT 2
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: PPUSH
9061: CALL_OW 70
9065: PUSH
9066: LD_EXP 15
9070: NOT
9071: AND
9072: PUSH
9073: LD_EXP 27
9077: PPUSH
9078: CALL_OW 302
9082: AND
9083: IFFALSE 9303
9085: GO 9087
9087: DISABLE
// begin DialogueOn ;
9088: CALL_OW 6
// ShowArea ( 2 , showDefenceArea ) ;
9092: LD_INT 2
9094: PPUSH
9095: LD_INT 12
9097: PPUSH
9098: CALL_OW 334
// CenterNowOnXY ( 111 , 53 ) ;
9102: LD_INT 111
9104: PPUSH
9105: LD_INT 53
9107: PPUSH
9108: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
9112: LD_INT 10
9114: PPUSH
9115: CALL_OW 68
// Say ( Kurt , DKs-Hannibal-1 ) ;
9119: LD_EXP 27
9123: PPUSH
9124: LD_STRING DKs-Hannibal-1
9126: PPUSH
9127: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-2 ) ;
9131: LD_EXP 27
9135: PPUSH
9136: LD_STRING DKs-Hannibal-2
9138: PPUSH
9139: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-3 ) ;
9143: LD_EXP 27
9147: PPUSH
9148: LD_STRING DKs-Hannibal-3
9150: PPUSH
9151: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-4 ) ;
9155: LD_EXP 27
9159: PPUSH
9160: LD_STRING DKs-Hannibal-4
9162: PPUSH
9163: CALL_OW 88
// dwait ( 0 0$1 ) ;
9167: LD_INT 35
9169: PPUSH
9170: CALL_OW 68
// PlaceSeeing ( 173 , 76 , 2 , - 12 ) ;
9174: LD_INT 173
9176: PPUSH
9177: LD_INT 76
9179: PPUSH
9180: LD_INT 2
9182: PPUSH
9183: LD_INT 12
9185: NEG
9186: PPUSH
9187: CALL_OW 330
// RemoveSeeing ( 173 , 76 , 2 ) ;
9191: LD_INT 173
9193: PPUSH
9194: LD_INT 76
9196: PPUSH
9197: LD_INT 2
9199: PPUSH
9200: CALL_OW 331
// CenterNowOnXY ( 173 , 76 ) ;
9204: LD_INT 173
9206: PPUSH
9207: LD_INT 76
9209: PPUSH
9210: CALL_OW 86
// Say ( Kurt , DKs-Hannibal-5 ) ;
9214: LD_EXP 27
9218: PPUSH
9219: LD_STRING DKs-Hannibal-5
9221: PPUSH
9222: CALL_OW 88
// if Kamil and not FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_flame_thrower ] ] ) then
9226: LD_EXP 22
9230: PUSH
9231: LD_INT 22
9233: PUSH
9234: LD_INT 2
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: PUSH
9241: LD_INT 34
9243: PUSH
9244: LD_INT 26
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: PUSH
9251: EMPTY
9252: LIST
9253: LIST
9254: PPUSH
9255: CALL_OW 69
9259: NOT
9260: AND
9261: IFFALSE 9299
// begin Say ( Kamil , DKam-Hannibal-a-6 ) ;
9263: LD_EXP 22
9267: PPUSH
9268: LD_STRING DKam-Hannibal-a-6
9270: PPUSH
9271: CALL_OW 88
// Say ( Kamil , DKam-Hannibal-a-7 ) ;
9275: LD_EXP 22
9279: PPUSH
9280: LD_STRING DKam-Hannibal-a-7
9282: PPUSH
9283: CALL_OW 88
// Say ( Givi , DG-Hannibal-a-8 ) ;
9287: LD_EXP 19
9291: PPUSH
9292: LD_STRING DG-Hannibal-a-8
9294: PPUSH
9295: CALL_OW 88
// end ; DialogueOff ;
9299: CALL_OW 7
// end ;
9303: END
// every 0 0$1 trigger IsOk ( ruSecBase ) and IsOk ( ruMainBase ) and FilterUnitsInArea ( showDefenceArea , [ f_type , unit_building ] ) > 2 and FilterUnitsInArea ( forestArea , [ f_side , 2 ] ) > 3 do
9304: LD_INT 225
9306: PPUSH
9307: CALL_OW 302
9311: PUSH
9312: LD_INT 200
9314: PPUSH
9315: CALL_OW 302
9319: AND
9320: PUSH
9321: LD_INT 12
9323: PPUSH
9324: LD_INT 21
9326: PUSH
9327: LD_INT 3
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PPUSH
9334: CALL_OW 70
9338: PUSH
9339: LD_INT 2
9341: GREATER
9342: AND
9343: PUSH
9344: LD_INT 13
9346: PPUSH
9347: LD_INT 22
9349: PUSH
9350: LD_INT 2
9352: PUSH
9353: EMPTY
9354: LIST
9355: LIST
9356: PPUSH
9357: CALL_OW 70
9361: PUSH
9362: LD_INT 3
9364: GREATER
9365: AND
9366: IFFALSE 9379
9368: GO 9370
9370: DISABLE
// hannibalPath := true ;
9371: LD_ADDR_EXP 9
9375: PUSH
9376: LD_INT 1
9378: ST_TO_ADDR
9379: END
// every 0 0$3 trigger hannibalPath and FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) do var i , tmp , hasFlameThrower ;
9380: LD_EXP 9
9384: PUSH
9385: LD_INT 6
9387: PPUSH
9388: LD_INT 22
9390: PUSH
9391: LD_INT 2
9393: PUSH
9394: EMPTY
9395: LIST
9396: LIST
9397: PPUSH
9398: CALL_OW 70
9402: AND
9403: IFFALSE 9740
9405: GO 9407
9407: DISABLE
9408: LD_INT 0
9410: PPUSH
9411: PPUSH
9412: PPUSH
// begin tmp := FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) ;
9413: LD_ADDR_VAR 0 2
9417: PUSH
9418: LD_INT 6
9420: PPUSH
9421: LD_INT 22
9423: PUSH
9424: LD_INT 2
9426: PUSH
9427: EMPTY
9428: LIST
9429: LIST
9430: PPUSH
9431: CALL_OW 70
9435: ST_TO_ADDR
// hasFlameThrower := UnitFilter ( tmp , [ f_weapon , ar_flame_thrower ] ) > 0 ;
9436: LD_ADDR_VAR 0 3
9440: PUSH
9441: LD_VAR 0 2
9445: PPUSH
9446: LD_INT 34
9448: PUSH
9449: LD_INT 26
9451: PUSH
9452: EMPTY
9453: LIST
9454: LIST
9455: PPUSH
9456: CALL_OW 72
9460: PUSH
9461: LD_INT 0
9463: GREATER
9464: ST_TO_ADDR
// Say ( Heike , DH-Cleverattack-1 ) ;
9465: LD_EXP 18
9469: PPUSH
9470: LD_STRING DH-Cleverattack-1
9472: PPUSH
9473: CALL_OW 88
// Say ( Heike , DH-Cleverattack-2 ) ;
9477: LD_EXP 18
9481: PPUSH
9482: LD_STRING DH-Cleverattack-2
9484: PPUSH
9485: CALL_OW 88
// if hasFlameThrower then
9489: LD_VAR 0 3
9493: IFFALSE 9521
// begin SayRadio ( Burlak , DB-Cleverattack-3 ) ;
9495: LD_EXP 33
9499: PPUSH
9500: LD_STRING DB-Cleverattack-3
9502: PPUSH
9503: CALL_OW 94
// Say ( Heike , DH-Cleverattack-4 ) ;
9507: LD_EXP 18
9511: PPUSH
9512: LD_STRING DH-Cleverattack-4
9514: PPUSH
9515: CALL_OW 88
// end else
9519: GO 9545
// begin SayRadio ( Burlak , DB-Cleverattack-a-3 ) ;
9521: LD_EXP 33
9525: PPUSH
9526: LD_STRING DB-Cleverattack-a-3
9528: PPUSH
9529: CALL_OW 94
// Say ( Heike , DH-Cleverattack-a-4 ) ;
9533: LD_EXP 18
9537: PPUSH
9538: LD_STRING DH-Cleverattack-a-4
9540: PPUSH
9541: CALL_OW 88
// end ; if not hasFlameThrower then
9545: LD_VAR 0 3
9549: NOT
9550: IFFALSE 9554
// exit ;
9552: GO 9740
// earlyEscape := true ;
9554: LD_ADDR_EXP 16
9558: PUSH
9559: LD_INT 1
9561: ST_TO_ADDR
// wait ( 0 0$4 ) ;
9562: LD_INT 140
9564: PPUSH
9565: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ] ) diff [ Ibrahim , Kuzmov , Gaidar ] ;
9569: LD_ADDR_VAR 0 2
9573: PUSH
9574: LD_INT 22
9576: PUSH
9577: LD_INT 3
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: PUSH
9584: LD_INT 2
9586: PUSH
9587: LD_INT 25
9589: PUSH
9590: LD_INT 1
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PUSH
9597: LD_INT 25
9599: PUSH
9600: LD_INT 2
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 25
9609: PUSH
9610: LD_INT 4
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: LIST
9621: LIST
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: PPUSH
9627: CALL_OW 69
9631: PUSH
9632: LD_EXP 21
9636: PUSH
9637: LD_EXP 35
9641: PUSH
9642: LD_EXP 34
9646: PUSH
9647: EMPTY
9648: LIST
9649: LIST
9650: LIST
9651: DIFF
9652: ST_TO_ADDR
// for i in tmp do
9653: LD_ADDR_VAR 0 1
9657: PUSH
9658: LD_VAR 0 2
9662: PUSH
9663: FOR_IN
9664: IFFALSE 9738
// begin if Prob ( 40 + 10 * Difficulty ) then
9666: LD_INT 40
9668: PUSH
9669: LD_INT 10
9671: PUSH
9672: LD_OWVAR 67
9676: MUL
9677: PLUS
9678: PPUSH
9679: CALL_OW 13
9683: IFFALSE 9687
// continue ;
9685: GO 9663
// SetTag ( i , tEscape ) ;
9687: LD_VAR 0 1
9691: PPUSH
9692: LD_EXP 17
9696: PPUSH
9697: CALL_OW 109
// if IsInUnit ( i ) then
9701: LD_VAR 0 1
9705: PPUSH
9706: CALL_OW 310
9710: IFFALSE 9721
// ComExitBuilding ( i ) ;
9712: LD_VAR 0 1
9716: PPUSH
9717: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9721: LD_VAR 0 1
9725: PPUSH
9726: LD_INT 92
9728: PPUSH
9729: LD_INT 177
9731: PPUSH
9732: CALL_OW 171
// end ;
9736: GO 9663
9738: POP
9739: POP
// end ;
9740: PPOPN 3
9742: END
// every 0 0$1 trigger FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do var i ;
9743: LD_INT 9
9745: PPUSH
9746: LD_INT 2
9748: PUSH
9749: LD_INT 22
9751: PUSH
9752: LD_INT 3
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: PUSH
9759: LD_INT 22
9761: PUSH
9762: LD_INT 6
9764: PUSH
9765: EMPTY
9766: LIST
9767: LIST
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: LIST
9773: PPUSH
9774: CALL_OW 70
9778: IFFALSE 9876
9780: GO 9782
9782: DISABLE
9783: LD_INT 0
9785: PPUSH
// begin enable ;
9786: ENABLE
// for i in FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do
9787: LD_ADDR_VAR 0 1
9791: PUSH
9792: LD_INT 9
9794: PPUSH
9795: LD_INT 2
9797: PUSH
9798: LD_INT 22
9800: PUSH
9801: LD_INT 3
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PUSH
9808: LD_INT 22
9810: PUSH
9811: LD_INT 6
9813: PUSH
9814: EMPTY
9815: LIST
9816: LIST
9817: PUSH
9818: EMPTY
9819: LIST
9820: LIST
9821: LIST
9822: PPUSH
9823: CALL_OW 70
9827: PUSH
9828: FOR_IN
9829: IFFALSE 9874
// if GetTag ( i ) = tEscape or GetSide ( i ) = 6 then
9831: LD_VAR 0 1
9835: PPUSH
9836: CALL_OW 110
9840: PUSH
9841: LD_EXP 17
9845: EQUAL
9846: PUSH
9847: LD_VAR 0 1
9851: PPUSH
9852: CALL_OW 255
9856: PUSH
9857: LD_INT 6
9859: EQUAL
9860: OR
9861: IFFALSE 9872
// RemoveUnit ( i ) ;
9863: LD_VAR 0 1
9867: PPUSH
9868: CALL_OW 64
9872: GO 9828
9874: POP
9875: POP
// end ;
9876: PPOPN 1
9878: END
// every 0 0$1 trigger Kaia and GetLives ( Kaia ) < 3 do
9879: LD_EXP 23
9883: PUSH
9884: LD_EXP 23
9888: PPUSH
9889: CALL_OW 256
9893: PUSH
9894: LD_INT 3
9896: LESS
9897: AND
9898: IFFALSE 9944
9900: GO 9902
9902: DISABLE
// begin DialogueOn ;
9903: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
9907: LD_EXP 23
9911: PPUSH
9912: CALL_OW 87
// ForceSay ( Kaia , DK-Kkilled-1 ) ;
9916: LD_EXP 23
9920: PPUSH
9921: LD_STRING DK-Kkilled-1
9923: PPUSH
9924: CALL_OW 91
// Say ( Heike , DH-Kkilled-2 ) ;
9928: LD_EXP 18
9932: PPUSH
9933: LD_STRING DH-Kkilled-2
9935: PPUSH
9936: CALL_OW 88
// DialogueOff ;
9940: CALL_OW 7
// end ;
9944: END
// every 0 0$1 trigger kaiaKilledByRussian do
9945: LD_EXP 8
9949: IFFALSE 9966
9951: GO 9953
9953: DISABLE
// Say ( Heike , DH-Kkilled-3 ) ;
9954: LD_EXP 18
9958: PPUSH
9959: LD_STRING DH-Kkilled-3
9961: PPUSH
9962: CALL_OW 88
9966: END
// every 0 0$1 trigger tick >= 22 22$00 do
9967: LD_OWVAR 1
9971: PUSH
9972: LD_INT 46200
9974: GREATEREQUAL
9975: IFFALSE 10004
9977: GO 9979
9979: DISABLE
// begin SayRadio ( Shariff , DShar-slow-1 ) ;
9980: LD_EXP 26
9984: PPUSH
9985: LD_STRING DShar-slow-1
9987: PPUSH
9988: CALL_OW 94
// SayRadio ( Shariff , DShar-slow-2 ) ;
9992: LD_EXP 26
9996: PPUSH
9997: LD_STRING DShar-slow-2
9999: PPUSH
10000: CALL_OW 94
// end ;
10004: END
// every 0 0$1 trigger tick >= [ 40 40$00 , 36 36$00 , 32 32$00 ] [ Difficulty ] do
10005: LD_OWVAR 1
10009: PUSH
10010: LD_INT 84000
10012: PUSH
10013: LD_INT 75600
10015: PUSH
10016: LD_INT 67200
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: LIST
10023: PUSH
10024: LD_OWVAR 67
10028: ARRAY
10029: GREATEREQUAL
10030: IFFALSE 10074
10032: GO 10034
10034: DISABLE
// begin DialogueOn ;
10035: CALL_OW 6
// SayRadio ( Shariff , DShar-fail-1 ) ;
10039: LD_EXP 26
10043: PPUSH
10044: LD_STRING DShar-fail-1
10046: PPUSH
10047: CALL_OW 94
// SayRadio ( Shariff , DShar-fail-2 ) ;
10051: LD_EXP 26
10055: PPUSH
10056: LD_STRING DShar-fail-2
10058: PPUSH
10059: CALL_OW 94
// DialogueOff ;
10063: CALL_OW 7
// YouLost ( Time ) ;
10067: LD_STRING Time
10069: PPUSH
10070: CALL_OW 104
// end ;
10074: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) = 0 do var tmp ;
10075: LD_INT 22
10077: PUSH
10078: LD_INT 3
10080: PUSH
10081: EMPTY
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 2
10087: PUSH
10088: LD_INT 30
10090: PUSH
10091: LD_INT 1
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PUSH
10098: LD_INT 30
10100: PUSH
10101: LD_INT 0
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: PUSH
10108: EMPTY
10109: LIST
10110: LIST
10111: LIST
10112: PUSH
10113: EMPTY
10114: LIST
10115: LIST
10116: PPUSH
10117: CALL_OW 69
10121: PUSH
10122: LD_INT 0
10124: EQUAL
10125: IFFALSE 10585
10127: GO 10129
10129: DISABLE
10130: LD_INT 0
10132: PPUSH
// begin if tick + gameTime <= [ 70 70$00 , 65 65$00 , 60 60$00 ] [ Difficulty ] then
10133: LD_OWVAR 1
10137: PUSH
10138: LD_EXP 5
10142: PLUS
10143: PUSH
10144: LD_INT 147000
10146: PUSH
10147: LD_INT 136500
10149: PUSH
10150: LD_INT 126000
10152: PUSH
10153: EMPTY
10154: LIST
10155: LIST
10156: LIST
10157: PUSH
10158: LD_OWVAR 67
10162: ARRAY
10163: LESSEQUAL
10164: IFFALSE 10178
// AddMedal ( med1 , 1 ) else
10166: LD_STRING med1
10168: PPUSH
10169: LD_INT 1
10171: PPUSH
10172: CALL_OW 101
10176: GO 10189
// AddMedal ( med1 , - 1 ) ;
10178: LD_STRING med1
10180: PPUSH
10181: LD_INT 1
10183: NEG
10184: PPUSH
10185: CALL_OW 101
// if ( flamethrowers >= 3 ) * baseHill * hannibalPath * ( loseCounter < [ 6 , 5 , 4 ] [ Difficulty ] ) then
10189: LD_EXP 7
10193: PUSH
10194: LD_INT 3
10196: GREATEREQUAL
10197: PUSH
10198: LD_EXP 11
10202: MUL
10203: PUSH
10204: LD_EXP 9
10208: MUL
10209: PUSH
10210: LD_EXP 6
10214: PUSH
10215: LD_INT 6
10217: PUSH
10218: LD_INT 5
10220: PUSH
10221: LD_INT 4
10223: PUSH
10224: EMPTY
10225: LIST
10226: LIST
10227: LIST
10228: PUSH
10229: LD_OWVAR 67
10233: ARRAY
10234: LESS
10235: MUL
10236: IFFALSE 10250
// AddMedal ( med2 , 1 ) else
10238: LD_STRING med2
10240: PPUSH
10241: LD_INT 1
10243: PPUSH
10244: CALL_OW 101
10248: GO 10261
// AddMedal ( med2 , - 1 ) ;
10250: LD_STRING med2
10252: PPUSH
10253: LD_INT 1
10255: NEG
10256: PPUSH
10257: CALL_OW 101
// if gaidarKilled then
10261: LD_EXP 14
10265: IFFALSE 10279
// AddMedal ( med3 , 1 ) else
10267: LD_STRING med3
10269: PPUSH
10270: LD_INT 1
10272: PPUSH
10273: CALL_OW 101
10277: GO 10290
// AddMedal ( med3 , - 1 ) ;
10279: LD_STRING med3
10281: PPUSH
10282: LD_INT 1
10284: NEG
10285: PPUSH
10286: CALL_OW 101
// GiveMedals ( MAIN ) ;
10290: LD_STRING MAIN
10292: PPUSH
10293: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_nation , 0 ] ] ] ) ) ;
10297: LD_INT 22
10299: PUSH
10300: LD_INT 2
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: LD_INT 23
10312: PUSH
10313: LD_INT 0
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PUSH
10324: EMPTY
10325: LIST
10326: LIST
10327: PPUSH
10328: CALL_OW 69
10332: PPUSH
10333: CALL_OW 43
// SaveCharacters ( Heike , 04_2_Heike ) ;
10337: LD_EXP 18
10341: PPUSH
10342: LD_STRING 04_2_Heike
10344: PPUSH
10345: CALL_OW 38
// if Aviradze then
10349: LD_EXP 28
10353: IFFALSE 10367
// SaveCharacters ( Aviradze , 04_2_Aviradze ) ;
10355: LD_EXP 28
10359: PPUSH
10360: LD_STRING 04_2_Aviradze
10362: PPUSH
10363: CALL_OW 38
// if Ibrahim then
10367: LD_EXP 21
10371: IFFALSE 10385
// SaveCharacters ( Ibrahim , 04_2_Ibrahim ) ;
10373: LD_EXP 21
10377: PPUSH
10378: LD_STRING 04_2_Ibrahim
10380: PPUSH
10381: CALL_OW 38
// if Kamil then
10385: LD_EXP 22
10389: IFFALSE 10403
// SaveCharacters ( Kamil , 04_2_Kamil ) ;
10391: LD_EXP 22
10395: PPUSH
10396: LD_STRING 04_2_Kamil
10398: PPUSH
10399: CALL_OW 38
// if Sophia then
10403: LD_EXP 24
10407: IFFALSE 10421
// SaveCharacters ( Sophia , 04_2_Sophia ) ;
10409: LD_EXP 24
10413: PPUSH
10414: LD_STRING 04_2_Sophia
10416: PPUSH
10417: CALL_OW 38
// if Kaia then
10421: LD_EXP 23
10425: IFFALSE 10439
// SaveCharacters ( Kaia , 04_2_Kaia ) ;
10427: LD_EXP 23
10431: PPUSH
10432: LD_STRING 04_2_Kaia
10434: PPUSH
10435: CALL_OW 38
// if Givi then
10439: LD_EXP 19
10443: IFFALSE 10457
// SaveCharacters ( Givi , 04_2_Givi ) ;
10445: LD_EXP 19
10449: PPUSH
10450: LD_STRING 04_2_Givi
10452: PPUSH
10453: CALL_OW 38
// if Mike then
10457: LD_EXP 20
10461: IFFALSE 10475
// SaveCharacters ( Mike , 04_2_Mike ) ;
10463: LD_EXP 20
10467: PPUSH
10468: LD_STRING 04_2_Mike
10470: PPUSH
10471: CALL_OW 38
// if Markov then
10475: LD_EXP 25
10479: IFFALSE 10493
// SaveCharacters ( Markov , 04_2_Markov ) ;
10481: LD_EXP 25
10485: PPUSH
10486: LD_STRING 04_2_Markov
10488: PPUSH
10489: CALL_OW 38
// if Kurt then
10493: LD_EXP 27
10497: IFFALSE 10511
// SaveCharacters ( Kurt , 04_2_Kurt ) ;
10499: LD_EXP 27
10503: PPUSH
10504: LD_STRING 04_2_Kurt
10506: PPUSH
10507: CALL_OW 38
// if heikeSecondSquad then
10511: LD_EXP 29
10515: IFFALSE 10529
// SaveCharacters ( heikeSecondSquad , 04_2_others ) ;
10517: LD_EXP 29
10521: PPUSH
10522: LD_STRING 04_2_others
10524: PPUSH
10525: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
10529: LD_ADDR_VAR 0 1
10533: PUSH
10534: LD_INT 22
10536: PUSH
10537: LD_INT 2
10539: PUSH
10540: EMPTY
10541: LIST
10542: LIST
10543: PUSH
10544: LD_INT 23
10546: PUSH
10547: LD_INT 0
10549: PUSH
10550: EMPTY
10551: LIST
10552: LIST
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: PPUSH
10558: CALL_OW 69
10562: ST_TO_ADDR
// if tmp then
10563: LD_VAR 0 1
10567: IFFALSE 10581
// SaveCharacters ( tmp , 04_2_apes ) ;
10569: LD_VAR 0 1
10573: PPUSH
10574: LD_STRING 04_2_apes
10576: PPUSH
10577: CALL_OW 38
// YouWin ;
10581: CALL_OW 103
// end ;
10585: PPOPN 1
10587: END
