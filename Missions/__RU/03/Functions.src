// Prepare Hero for use
// ident - ident from start.txt - 'JMM' for example
// exist_mode
//   - false if unit not exist in save
//   - true if unit already exist in save
// example: JMM := PrepareUnitExt('JMM', false);
Export Function PrepareUnitExt(ident, exist_mode);
var unit;
begin

if exist_mode then
   unit := CreateCharacter(previousMissionPrefix&ident)
  else
   unit := NewCharacter(ident);

result := unit;
End;

Export function DialogRandom(characters, dialogMID, dialogFID, radio);
var i, speaker;
begin
   characters := characters diff [Burlak, Gnyevko, Belkov, Belkov2, Kirilenkova, Kovalyuk, Scholtze];
   speaker := characters[rand(1, characters)];

   if radio then
   begin
      if GetSex(speaker) = sex_male then
         SayRadio(speaker, dialogMID)
      else
         SayRadio(speaker, dialogFID);
   end
   else
   begin
      if GetSex(speaker) = sex_male then
         Say(speaker, dialogMID)
      else
         Say(speaker, dialogFID);  
   end;

   result := speaker;
end;

// Summary: Before calling the SaveCharacters function, checks if the character given in the argument is OK and if it is on the side 
// Input: Character, characterStringID
// Example: ExtSaveCharacter(Burlak, 'MyBurlak');
Export Function ExtSaveCharacter(character, characterStringID, side);
begin
   if GetSide(character) = side AND IsOK(character) then
      SaveCharacters(character, missionPrefix&characterStringID);
end;

// Summary: Before calling the SaveCharacters function, checks if the characters list given in the argument is OK and if it is on the side 
// Input: Characters, characterStringID
// Example: ExtSaveCharacter([FilterAllUnits...], 'MySavedTeam');
Export Function ExtSaveCharacters(characters, charactersStringID, side);
var unit, resultCharactersToSave;
begin
   resultCharactersToSave = [];

   for unit in characters do
      if GetSide(unit) = side AND IsOK(unit) then
         resultCharactersToSave = resultCharactersToSave ^ unit;

   SaveCharacters(resultCharactersToSave, missionPrefix&charactersStringID);
end;

Export function SelectCharacters(maxUnitToChoose);
var i, charsToChoose, selectedPeople;
begin
   charsToChoose = otherKirovUnits;
   charsToChoose = charsToChoose ^ otherBeriaUnits;
   charsToChoose = charsToChoose ^ other_survivors;
   charsToChoose = charsToChoose ^ Belkov;
   charsToChoose = charsToChoose ^ Belkov2;

   selectedPeople = CharacterSelection('text', maxUnitToChoose, maxUnitToChoose,
                                [sel_change_class, Burlak, Gnyevko, Kovalyuk, Kirilenkova,
                                 sel_dont_change_class,
                                 sel_not_hired,sel_changeable, sel_change_class]^charsToChoose^
                                [sel_dont_change_class, sel_not_changeable, Kurin],
                                [class_soldier, class_mechanic, [class_engineer, 1], [class_scientistic, 1]]);

   SetSide(charsToChoose, 6);
   SetSide(selectedPeople, 3);

   SetSurvivorsArabianAttack;
end;

// Summary: Looks for a building that has free slots.
// Input: area, side, buildingType
// Output: buildingID if found or 0 if no
// Example: FindNotFullBuildingInArea(OmicronBaseArea, 1, b_armoury)
Export Function FindNotFullBuildingInArea(area, side, buildingType);
var building;
begin
   for building in FilterUnitsInArea(area, [[f_side, side], [f_type, unit_building], [f_btype, buildingType]]) do
   begin
      if UnitsInside(building) < 6 then
      begin
         result = building;
         exit;
      end;
   end;

   result = 0;
end;

Export Function PlaceHumanInBunker(un, bunker);
var dir;
begin
     dir := GetDir(bunker)  - 3;

     if dir < 0 then dir := 6 + dir;

     SetDir(un, dir);
     PlaceHumanInUnit(un, bunker);

     result = un;
End;

Export Function PrepareSolBun(skill, b);
var un, dir;
begin
     uc_side := GetSide(b);
     uc_nation := GetNation(b);

     PrepareHuman(false, 1, skill);
     un = CreateHuman;

     dir := GetDir(b)  - 3;

     if dir < 0 then dir := 6 + dir;

     SetDir(un, dir);
     PlaceHumanInUnit(un, b);

     result = un;
End;

// Summary: Engineers from the units list will approach the buildings which is a breastwork and start to dismantle it, and after then start to build a bunker or an automated turret in its place from upgradeBType
// Input: units, buildings, upgradeBType
// Example: AddComUpgradeBreastwork([FilterAllUnits.... f_class, class_engineer], [b1, b2, b3], b_bunker)
Export Function AddComUpgradeBreastwork(units, buildings, upgradeBType);
var building, x, y, dir;
begin
   for building in buildings do
   begin
      x = GetX(building);
      y = GetY(building);
      dir = GetDir(building);

      AddComDismantle(units, building);
      AddComBuild(units, upgradeBType, x, y, dir);
   end;
end;

Export function ResAllTechs(side, lab, nation);
var i, tech, cout, ru_tech_list;
begin

   ru_tech_list := [48, 49, 50, 20, 1, 51, 52, 69, 39, 34, 40, 53, 71, 57, 58, 44, 32, 27, 23, 33, 59, 54, 55, 56, 63, 64, 65, 30, 31, 21, 22, 25];

  For i = 1 to ru_tech_list do
    If GetTech(ru_tech_list[i], side) = state_enabled and TechNationAvailable(ru_tech_list[i], nation) = true then AddComResearch(lab, ru_tech_list[i]);

end;

// Summary: Units will proceed to the base attacking everything in their path. Additionally, it includes a small AI medics module that will heal damage units.
// Input: unitsList, roadArea
// Example: MoveToBase([Burlak, Platonov, Kurin], MyWonderfullRoad);
Export Function MoveToBase(units, roadArea);
var i, unit, playerUnits, playerUnit, enemyUnitsOnRoad, nearUnit, attackUnits, medics, damageUnits, inBase, newBase;
begin

   inBase = false;

   repeat
      enemyUnitsOnRoad = FilterUnitsInArea(roadArea, [[f_side, 3]]);
      attackUnits = UnitFilter(units, [[f_ok], [f_or, [f_class, class_soldier], [f_class, class_mechanic], [f_type, unit_vehicle]]]);
      medics = UnitFilter(units, [[f_ok], [f_class, class_scientistic]]);
      damageUnits = UnitFilter(units, [f_not, [f_lives, 1000]]);
      playerUnits = FilterAllUnits([[f_side, 3]]);

      for unit in UnitFilter(units, [f_ok]) do
      begin

         if attackUnits AND medics then
         begin
            if damageUnits then
               ComHeal(medics, damageUnits[1])
            else
               ComMoveXY(medics, GetX(attackUnits[1]), GetY(attackUnits[1]));

         end
         else
         begin
            if NOT attackUnits AND medics then
               attackUnits = attackUnits ^ medics;
         end;

         if enemyUnitsOnRoad then
         begin

            for playerUnit in playerUnits do
            begin
               if Attacks(playerUnit) then
               begin
                  if Attacks(playerUnit) in units AND GetDistUnits(playerUnit, unit) < 13 then
                     ComAttackUnit(attackUnits, playerUnit) 
               end
               else
               begin        
                  nearUnit = NearestUnitToUnit(enemyUnitsOnRoad, unit);
                  ComAttackUnit(attackUnits, nearUnit);
               end;  
            end;
         end
         else
         begin
            ComMoveXY(unit, 27, 34);
         end; 

         if GetDistUnitXY(unit, 27, 34) < 5 then
            inBase = true;    
      end;

      wait(0$1);
   until UnitFilter(units, [f_ok]) = 0 OR inBase;

   ComMoveXY(units, 27, 34);

   for i := 1 to units do
      if IsOk(units[i]) then
         americanTroopsArriveOmicronCounter = americanTroopsArriveOmicronCounter + 1;

   amSupportTroops = amSupportTroops diff units;

   newBase = amBase;
   newBase = newBase ^ UnitFilter(units, [f_ok]);

   amBase = newBase;

   mc_bases := Replace(mc_bases, 1, newBase);
end;
