// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export meetBelkovBrother ; export cratesResources , oilResources ; export spawnCrates ; export scholtzeSpawnNearAmericans , scholtzeSaved ; export dialog_workshop , dialog_amSupportTroops ; export kurinGiveMoreTime , extraTime ; export meetNearOmicronBase , attackOmicron ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 137 0 0
// meetBelkovBrother = LoadVariable ( 02_MeetBelkovBrother_6 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 02_MeetBelkovBrother_6
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// cratesResources = LoadVariable ( 02_BeriaResourceCrates_7 , 0 ) ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_STRING 02_BeriaResourceCrates_7
  47: PPUSH
  48: LD_INT 0
  50: PPUSH
  51: CALL_OW 30
  55: ST_TO_ADDR
// oilResources = LoadVariable ( 02_BeriaResourceOil_8 , 0 ) ;
  56: LD_ADDR_EXP 3
  60: PUSH
  61: LD_STRING 02_BeriaResourceOil_8
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: CALL_OW 30
  71: ST_TO_ADDR
// scholtzeSpawnNearAmericans = false ;
  72: LD_ADDR_EXP 5
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// scholtzeSaved = false ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// spawnCrates = true ;
  88: LD_ADDR_EXP 4
  92: PUSH
  93: LD_INT 1
  95: ST_TO_ADDR
// dialog_workshop = false ;
  96: LD_ADDR_EXP 7
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// extraTime = 7 7$00 ;
 104: LD_ADDR_EXP 10
 108: PUSH
 109: LD_INT 14700
 111: ST_TO_ADDR
// kurinGiveMoreTime = false ;
 112: LD_ADDR_EXP 9
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// PrepareRussians ;
 120: CALL 755 0 0
// PrepareAmericans ;
 124: CALL 2710 0 0
// MissionIntro ;
 128: CALL 5144 0 0
// end ; end_of_file
 132: LD_VAR 0 1
 136: RET
// export function InitMapConfig ; begin
 137: LD_INT 0
 139: PPUSH
// BaseMapConfig ;
 140: CALL 153 0 0
// MissionMapConfig ;
 144: CALL 286 0 0
// end ;
 148: LD_VAR 0 1
 152: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 153: LD_INT 0
 155: PPUSH
// animalsAmount = [ 8 , 7 , 6 , 6 ] ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 8
 163: PUSH
 164: LD_INT 7
 166: PUSH
 167: LD_INT 6
 169: PUSH
 170: LD_INT 6
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: LIST
 178: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 179: LD_ADDR_EXP 14
 183: PUSH
 184: LD_INT 2
 186: PUSH
 187: LD_INT 2
 189: PUSH
 190: LD_INT 2
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: LIST
 200: LIST
 201: ST_TO_ADDR
// animalsAgression = [ rand ( 1 , 5 ) , rand ( 5 , 10 ) , rand ( 10 , 15 ) , rand ( 15 , 20 ) ] ;
 202: LD_ADDR_EXP 15
 206: PUSH
 207: LD_INT 1
 209: PPUSH
 210: LD_INT 5
 212: PPUSH
 213: CALL_OW 12
 217: PUSH
 218: LD_INT 5
 220: PPUSH
 221: LD_INT 10
 223: PPUSH
 224: CALL_OW 12
 228: PUSH
 229: LD_INT 10
 231: PPUSH
 232: LD_INT 15
 234: PPUSH
 235: CALL_OW 12
 239: PUSH
 240: LD_INT 15
 242: PPUSH
 243: LD_INT 20
 245: PPUSH
 246: CALL_OW 12
 250: PUSH
 251: EMPTY
 252: LIST
 253: LIST
 254: LIST
 255: LIST
 256: ST_TO_ADDR
// debugMode = 1 ;
 257: LD_ADDR_EXP 18
 261: PUSH
 262: LD_INT 1
 264: ST_TO_ADDR
// missionPrefix = 03_ ;
 265: LD_ADDR_EXP 16
 269: PUSH
 270: LD_STRING 03_
 272: ST_TO_ADDR
// previousMissionPrefix = 02_ ;
 273: LD_ADDR_EXP 17
 277: PUSH
 278: LD_STRING 02_
 280: ST_TO_ADDR
// end ;
 281: LD_VAR 0 1
 285: RET
// export baseUnitsToChoose , scholtzeSpawnPositions ; export timeToPrepareAttack ; export bonusResourcesCrates , bonusResourcesOil ; export enemySkillLevel ; export americanWeapons , russianWeapons ; function MissionMapConfig ; begin
 286: LD_INT 0
 288: PPUSH
// baseUnitsToChoose = [ 7 , 6 , 6 ] [ Difficulty ] ;
 289: LD_ADDR_EXP 19
 293: PUSH
 294: LD_INT 7
 296: PUSH
 297: LD_INT 6
 299: PUSH
 300: LD_INT 6
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: LIST
 307: PUSH
 308: LD_OWVAR 67
 312: ARRAY
 313: ST_TO_ADDR
// scholtzeSpawnPositions = [ [ 150 , 144 ] , [ 51 , 7 , 89 , 19 , 118 , 9 ] , [ 150 , 144 , 51 , 7 , 89 , 19 , 118 , 9 ] ] [ Difficulty ] ;
 314: LD_ADDR_EXP 20
 318: PUSH
 319: LD_INT 150
 321: PUSH
 322: LD_INT 144
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: PUSH
 329: LD_INT 51
 331: PUSH
 332: LD_INT 7
 334: PUSH
 335: LD_INT 89
 337: PUSH
 338: LD_INT 19
 340: PUSH
 341: LD_INT 118
 343: PUSH
 344: LD_INT 9
 346: PUSH
 347: EMPTY
 348: LIST
 349: LIST
 350: LIST
 351: LIST
 352: LIST
 353: LIST
 354: PUSH
 355: LD_INT 150
 357: PUSH
 358: LD_INT 144
 360: PUSH
 361: LD_INT 51
 363: PUSH
 364: LD_INT 7
 366: PUSH
 367: LD_INT 89
 369: PUSH
 370: LD_INT 19
 372: PUSH
 373: LD_INT 118
 375: PUSH
 376: LD_INT 9
 378: PUSH
 379: EMPTY
 380: LIST
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: EMPTY
 390: LIST
 391: LIST
 392: LIST
 393: PUSH
 394: LD_OWVAR 67
 398: ARRAY
 399: ST_TO_ADDR
// timeToPrepareAttack = [ 40 40$0 , 35 35$0 , 30 30$0 ] [ Difficulty ] ;
 400: LD_ADDR_EXP 21
 404: PUSH
 405: LD_INT 84000
 407: PUSH
 408: LD_INT 73500
 410: PUSH
 411: LD_INT 63000
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: PUSH
 419: LD_OWVAR 67
 423: ARRAY
 424: ST_TO_ADDR
// bonusResourcesCrates = [ 150 , 100 , 50 ] [ Difficulty ] ;
 425: LD_ADDR_EXP 22
 429: PUSH
 430: LD_INT 150
 432: PUSH
 433: LD_INT 100
 435: PUSH
 436: LD_INT 50
 438: PUSH
 439: EMPTY
 440: LIST
 441: LIST
 442: LIST
 443: PUSH
 444: LD_OWVAR 67
 448: ARRAY
 449: ST_TO_ADDR
// bonusResourcesOil = [ 100 , 50 , 0 ] [ Difficulty ] ;
 450: LD_ADDR_EXP 23
 454: PUSH
 455: LD_INT 100
 457: PUSH
 458: LD_INT 50
 460: PUSH
 461: LD_INT 0
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: PUSH
 469: LD_OWVAR 67
 473: ARRAY
 474: ST_TO_ADDR
// enemySkillLevel = [ 1 , 2 , 2 ] [ Difficulty ] ;
 475: LD_ADDR_EXP 24
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 2
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: PUSH
 494: LD_OWVAR 67
 498: ARRAY
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 1
 504: RET
// every 0 0$1 trigger debugMode do var i ;
 505: LD_EXP 18
 509: IFFALSE 752
 511: GO 513
 513: DISABLE
 514: LD_INT 0
 516: PPUSH
// begin enable ;
 517: ENABLE
// display_strings = [ #Ru03-1 , timeToPrepareAttack ] ;
 518: LD_ADDR_OWVAR 47
 522: PUSH
 523: LD_STRING #Ru03-1
 525: PUSH
 526: LD_EXP 21
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: ST_TO_ADDR
// timeToPrepareAttack = timeToPrepareAttack - 0 0$01 ;
 535: LD_ADDR_EXP 21
 539: PUSH
 540: LD_EXP 21
 544: PUSH
 545: LD_INT 35
 547: MINUS
 548: ST_TO_ADDR
// FogOff ( your_side ) ;
 549: LD_OWVAR 2
 553: PPUSH
 554: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 558: LD_ADDR_VAR 0 1
 562: PUSH
 563: LD_INT 22
 565: PUSH
 566: LD_OWVAR 2
 570: PUSH
 571: EMPTY
 572: LIST
 573: LIST
 574: PUSH
 575: LD_INT 2
 577: PUSH
 578: LD_INT 21
 580: PUSH
 581: LD_INT 1
 583: PUSH
 584: EMPTY
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 21
 590: PUSH
 591: LD_INT 2
 593: PUSH
 594: EMPTY
 595: LIST
 596: LIST
 597: PUSH
 598: EMPTY
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: PPUSH
 607: CALL_OW 69
 611: PUSH
 612: FOR_IN
 613: IFFALSE 629
// SetLives ( i , 1000 ) ;
 615: LD_VAR 0 1
 619: PPUSH
 620: LD_INT 1000
 622: PPUSH
 623: CALL_OW 234
 627: GO 612
 629: POP
 630: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
 631: LD_ADDR_VAR 0 1
 635: PUSH
 636: LD_INT 22
 638: PUSH
 639: LD_OWVAR 2
 643: PUSH
 644: EMPTY
 645: LIST
 646: LIST
 647: PUSH
 648: LD_INT 2
 650: PUSH
 651: LD_INT 30
 653: PUSH
 654: LD_INT 0
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 30
 663: PUSH
 664: LD_INT 1
 666: PUSH
 667: EMPTY
 668: LIST
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: PPUSH
 680: CALL_OW 69
 684: PUSH
 685: FOR_IN
 686: IFFALSE 750
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
 688: LD_VAR 0 1
 692: PPUSH
 693: CALL_OW 274
 697: PPUSH
 698: LD_INT 1
 700: PPUSH
 701: LD_INT 9999
 703: PPUSH
 704: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
 708: LD_VAR 0 1
 712: PPUSH
 713: CALL_OW 274
 717: PPUSH
 718: LD_INT 2
 720: PPUSH
 721: LD_INT 9999
 723: PPUSH
 724: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
 728: LD_VAR 0 1
 732: PPUSH
 733: CALL_OW 274
 737: PPUSH
 738: LD_INT 3
 740: PPUSH
 741: LD_INT 9999
 743: PPUSH
 744: CALL_OW 277
// end ;
 748: GO 685
 750: POP
 751: POP
// end ; end_of_file
 752: PPOPN 1
 754: END
// export Burlak , Gnyevko , Kirilenkova , Kovalyuk , Belkov , Belkov2 ; export Scholtze ; export other_survivors ; export playerVehicles ; export otherBeriaUnits , beriaBase , beriaDepot ; export Kurin , Popov , BelkovDialog ; export ruScout ; export otherKirovUnits ; export kirovBase , kirovDepot ; export function PrepareRussians ; begin
 755: LD_INT 0
 757: PPUSH
// PrepareKirovBase ;
 758: CALL 1685 0 0
// PrepareHeroes ;
 762: CALL 775 0 0
// PrepareBeriaBase ;
 766: CALL 1087 0 0
// end ;
 770: LD_VAR 0 1
 774: RET
// function PrepareHeroes ; begin
 775: LD_INT 0
 777: PPUSH
// uc_side = 3 ;
 778: LD_ADDR_OWVAR 20
 782: PUSH
 783: LD_INT 3
 785: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , false ) ;
 786: LD_ADDR_EXP 27
 790: PUSH
 791: LD_STRING Burlak
 793: PPUSH
 794: LD_INT 0
 796: PPUSH
 797: CALL 3673 0 2
 801: ST_TO_ADDR
// Gnyevko := PrepareUnitExt ( Gnyevko , false ) ;
 802: LD_ADDR_EXP 28
 806: PUSH
 807: LD_STRING Gnyevko
 809: PPUSH
 810: LD_INT 0
 812: PPUSH
 813: CALL 3673 0 2
 817: ST_TO_ADDR
// Kovalyuk := PrepareUnitExt ( Kovalyuk , false ) ;
 818: LD_ADDR_EXP 30
 822: PUSH
 823: LD_STRING Kovalyuk
 825: PPUSH
 826: LD_INT 0
 828: PPUSH
 829: CALL 3673 0 2
 833: ST_TO_ADDR
// Kirilenkova = CreateCharacter ( 01_Kirilenkova ) ;
 834: LD_ADDR_EXP 29
 838: PUSH
 839: LD_STRING 01_Kirilenkova
 841: PPUSH
 842: CALL_OW 34
 846: ST_TO_ADDR
// uc_side = 6 ;
 847: LD_ADDR_OWVAR 20
 851: PUSH
 852: LD_INT 6
 854: ST_TO_ADDR
// if not meetBelkovBrother and TestCharacters ( 02_Belkov ) then
 855: LD_EXP 1
 859: NOT
 860: PUSH
 861: LD_STRING 02_Belkov
 863: PPUSH
 864: CALL_OW 28
 868: AND
 869: IFFALSE 924
// begin Belkov := PrepareUnitExt ( Belkov , false ) ;
 871: LD_ADDR_EXP 31
 875: PUSH
 876: LD_STRING Belkov
 878: PPUSH
 879: LD_INT 0
 881: PPUSH
 882: CALL 3673 0 2
 886: ST_TO_ADDR
// BelkovDialog = Belkov ;
 887: LD_ADDR_EXP 41
 891: PUSH
 892: LD_EXP 31
 896: ST_TO_ADDR
// PlaceUnitXY ( Belkov , 165 , 110 , false ) ;
 897: LD_EXP 31
 901: PPUSH
 902: LD_INT 165
 904: PPUSH
 905: LD_INT 110
 907: PPUSH
 908: LD_INT 0
 910: PPUSH
 911: CALL_OW 48
// ComHold ( Belkov ) ;
 915: LD_EXP 31
 919: PPUSH
 920: CALL_OW 140
// end ; if meetBelkovBrother and TestCharacters ( 02_Belkov2 ) then
 924: LD_EXP 1
 928: PUSH
 929: LD_STRING 02_Belkov2
 931: PPUSH
 932: CALL_OW 28
 936: AND
 937: IFFALSE 992
// begin Belkov2 := PrepareUnitExt ( Belkov2 , false ) ;
 939: LD_ADDR_EXP 32
 943: PUSH
 944: LD_STRING Belkov2
 946: PPUSH
 947: LD_INT 0
 949: PPUSH
 950: CALL 3673 0 2
 954: ST_TO_ADDR
// BelkovDialog = Belkov2 ;
 955: LD_ADDR_EXP 41
 959: PUSH
 960: LD_EXP 32
 964: ST_TO_ADDR
// PlaceUnitXY ( Belkov2 , 165 , 110 , false ) ;
 965: LD_EXP 32
 969: PPUSH
 970: LD_INT 165
 972: PPUSH
 973: LD_INT 110
 975: PPUSH
 976: LD_INT 0
 978: PPUSH
 979: CALL_OW 48
// ComHold ( Belkov2 ) ;
 983: LD_EXP 32
 987: PPUSH
 988: CALL_OW 140
// end ; PlaceUnitXY ( Burlak , 164 , 108 , false ) ;
 992: LD_EXP 27
 996: PPUSH
 997: LD_INT 164
 999: PPUSH
1000: LD_INT 108
1002: PPUSH
1003: LD_INT 0
1005: PPUSH
1006: CALL_OW 48
// ComHold ( Burlak ) ;
1010: LD_EXP 27
1014: PPUSH
1015: CALL_OW 140
// PlaceUnitXYR ( Gnyevko , 178 , 108 , 5 , false ) ;
1019: LD_EXP 28
1023: PPUSH
1024: LD_INT 178
1026: PPUSH
1027: LD_INT 108
1029: PPUSH
1030: LD_INT 5
1032: PPUSH
1033: LD_INT 0
1035: PPUSH
1036: CALL_OW 50
// PlaceUnitXYR ( Kovalyuk , 178 , 108 , 5 , false ) ;
1040: LD_EXP 30
1044: PPUSH
1045: LD_INT 178
1047: PPUSH
1048: LD_INT 108
1050: PPUSH
1051: LD_INT 5
1053: PPUSH
1054: LD_INT 0
1056: PPUSH
1057: CALL_OW 50
// PlaceUnitXYR ( Kirilenkova , 178 , 108 , 5 , false ) ;
1061: LD_EXP 29
1065: PPUSH
1066: LD_INT 178
1068: PPUSH
1069: LD_INT 108
1071: PPUSH
1072: LD_INT 5
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: CALL_OW 50
// end ;
1082: LD_VAR 0 1
1086: RET
// function PrepareBeriaBase ; var i , bonusResources ; begin
1087: LD_INT 0
1089: PPUSH
1090: PPUSH
1091: PPUSH
// beriaBase = LoadVariable ( 02_BeriaBase_2 , [ ] ) ;
1092: LD_ADDR_EXP 37
1096: PUSH
1097: LD_STRING 02_BeriaBase_2
1099: PPUSH
1100: EMPTY
1101: PPUSH
1102: CALL_OW 30
1106: ST_TO_ADDR
// otherBeriaUnits = CreateCharacterSet ( 02_other_beria ) ;
1107: LD_ADDR_EXP 36
1111: PUSH
1112: LD_STRING 02_other_beria
1114: PPUSH
1115: CALL_OW 31
1119: ST_TO_ADDR
// other_survivors = CreateCharacterSet ( 02_other_survivors ) ;
1120: LD_ADDR_EXP 34
1124: PUSH
1125: LD_STRING 02_other_survivors
1127: PPUSH
1128: CALL_OW 31
1132: ST_TO_ADDR
// uc_side = 3 ;
1133: LD_ADDR_OWVAR 20
1137: PUSH
1138: LD_INT 3
1140: ST_TO_ADDR
// uc_nation = 3 ;
1141: LD_ADDR_OWVAR 21
1145: PUSH
1146: LD_INT 3
1148: ST_TO_ADDR
// for i := 1 to beriaBase do
1149: LD_ADDR_VAR 0 2
1153: PUSH
1154: DOUBLE
1155: LD_INT 1
1157: DEC
1158: ST_TO_ADDR
1159: LD_EXP 37
1163: PUSH
1164: FOR_TO
1165: IFFALSE 1418
// begin bc_type = beriaBase [ i ] [ 1 ] ;
1167: LD_ADDR_OWVAR 42
1171: PUSH
1172: LD_EXP 37
1176: PUSH
1177: LD_VAR 0 2
1181: ARRAY
1182: PUSH
1183: LD_INT 1
1185: ARRAY
1186: ST_TO_ADDR
// bc_level = beriaBase [ i ] [ 5 ] ;
1187: LD_ADDR_OWVAR 43
1191: PUSH
1192: LD_EXP 37
1196: PUSH
1197: LD_VAR 0 2
1201: ARRAY
1202: PUSH
1203: LD_INT 5
1205: ARRAY
1206: ST_TO_ADDR
// if bc_type = b_lab then
1207: LD_OWVAR 42
1211: PUSH
1212: LD_INT 6
1214: EQUAL
1215: IFFALSE 1233
// begin bc_kind1 = b_lab_basic ;
1217: LD_ADDR_OWVAR 44
1221: PUSH
1222: LD_INT 9
1224: ST_TO_ADDR
// bc_kind2 = b_lab_basic ;
1225: LD_ADDR_OWVAR 45
1229: PUSH
1230: LD_INT 9
1232: ST_TO_ADDR
// end ; if bc_type = b_lab_half or bc_type = b_lab_full then
1233: LD_OWVAR 42
1237: PUSH
1238: LD_INT 7
1240: EQUAL
1241: PUSH
1242: LD_OWVAR 42
1246: PUSH
1247: LD_INT 8
1249: EQUAL
1250: OR
1251: IFFALSE 1367
// begin if beriaBase [ i ] [ 7 ] then
1253: LD_EXP 37
1257: PUSH
1258: LD_VAR 0 2
1262: ARRAY
1263: PUSH
1264: LD_INT 7
1266: ARRAY
1267: IFFALSE 1289
// bc_kind1 = beriaBase [ i ] [ 7 ] ;
1269: LD_ADDR_OWVAR 44
1273: PUSH
1274: LD_EXP 37
1278: PUSH
1279: LD_VAR 0 2
1283: ARRAY
1284: PUSH
1285: LD_INT 7
1287: ARRAY
1288: ST_TO_ADDR
// if beriaBase [ i ] [ 8 ] then
1289: LD_EXP 37
1293: PUSH
1294: LD_VAR 0 2
1298: ARRAY
1299: PUSH
1300: LD_INT 8
1302: ARRAY
1303: IFFALSE 1325
// bc_kind2 = beriaBase [ i ] [ 8 ] ;
1305: LD_ADDR_OWVAR 45
1309: PUSH
1310: LD_EXP 37
1314: PUSH
1315: LD_VAR 0 2
1319: ARRAY
1320: PUSH
1321: LD_INT 8
1323: ARRAY
1324: ST_TO_ADDR
// if not beriaBase [ i ] [ 7 ] and not beriaBase [ i ] [ 8 ] then
1325: LD_EXP 37
1329: PUSH
1330: LD_VAR 0 2
1334: ARRAY
1335: PUSH
1336: LD_INT 7
1338: ARRAY
1339: NOT
1340: PUSH
1341: LD_EXP 37
1345: PUSH
1346: LD_VAR 0 2
1350: ARRAY
1351: PUSH
1352: LD_INT 8
1354: ARRAY
1355: NOT
1356: AND
1357: IFFALSE 1367
// bc_type := b_lab ;
1359: LD_ADDR_OWVAR 42
1363: PUSH
1364: LD_INT 6
1366: ST_TO_ADDR
// end ; CreateAndPlaceBuildingXYD ( beriaBase [ i ] [ 2 ] , beriaBase [ i ] [ 3 ] , beriaBase [ i ] [ 4 ] ) ;
1367: LD_EXP 37
1371: PUSH
1372: LD_VAR 0 2
1376: ARRAY
1377: PUSH
1378: LD_INT 2
1380: ARRAY
1381: PPUSH
1382: LD_EXP 37
1386: PUSH
1387: LD_VAR 0 2
1391: ARRAY
1392: PUSH
1393: LD_INT 3
1395: ARRAY
1396: PPUSH
1397: LD_EXP 37
1401: PUSH
1402: LD_VAR 0 2
1406: ARRAY
1407: PUSH
1408: LD_INT 4
1410: ARRAY
1411: PPUSH
1412: CALL_OW 47
// end ;
1416: GO 1164
1418: POP
1419: POP
// beriaDepot = FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1420: LD_ADDR_EXP 38
1424: PUSH
1425: LD_INT 22
1427: PUSH
1428: LD_INT 3
1430: PUSH
1431: EMPTY
1432: LIST
1433: LIST
1434: PUSH
1435: LD_INT 30
1437: PUSH
1438: LD_INT 0
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: PPUSH
1449: CALL_OW 69
1453: PUSH
1454: LD_INT 1
1456: ARRAY
1457: ST_TO_ADDR
// SetBName ( beriaDepot , beria ) ;
1458: LD_EXP 38
1462: PPUSH
1463: LD_STRING beria
1465: PPUSH
1466: CALL_OW 500
// SetResourceType ( GetBase ( beriaDepot ) , mat_cans , cratesResources ) ;
1470: LD_EXP 38
1474: PPUSH
1475: CALL_OW 274
1479: PPUSH
1480: LD_INT 1
1482: PPUSH
1483: LD_EXP 2
1487: PPUSH
1488: CALL_OW 277
// SetResourceType ( GetBase ( beriaDepot ) , mat_oil , oilResources ) ;
1492: LD_EXP 38
1496: PPUSH
1497: CALL_OW 274
1501: PPUSH
1502: LD_INT 2
1504: PPUSH
1505: LD_EXP 3
1509: PPUSH
1510: CALL_OW 277
// SetResourceType ( GetBase ( beriaDepot ) , mat_cans , GetResourceType ( GetBase ( beriaDepot ) , mat_oil ) + bonusResourcesCrates ) ;
1514: LD_EXP 38
1518: PPUSH
1519: CALL_OW 274
1523: PPUSH
1524: LD_INT 1
1526: PPUSH
1527: LD_EXP 38
1531: PPUSH
1532: CALL_OW 274
1536: PPUSH
1537: LD_INT 2
1539: PPUSH
1540: CALL_OW 275
1544: PUSH
1545: LD_EXP 22
1549: PLUS
1550: PPUSH
1551: CALL_OW 277
// SetResourceType ( GetBase ( beriaDepot ) , mat_oil , GetResourceType ( GetBase ( beriaDepot ) , mat_oil ) + bonusResourcesOil ) ;
1555: LD_EXP 38
1559: PPUSH
1560: CALL_OW 274
1564: PPUSH
1565: LD_INT 2
1567: PPUSH
1568: LD_EXP 38
1572: PPUSH
1573: CALL_OW 274
1577: PPUSH
1578: LD_INT 2
1580: PPUSH
1581: CALL_OW 275
1585: PUSH
1586: LD_EXP 23
1590: PLUS
1591: PPUSH
1592: CALL_OW 277
// uc_side = 6 ;
1596: LD_ADDR_OWVAR 20
1600: PUSH
1601: LD_INT 6
1603: ST_TO_ADDR
// for i in otherBeriaUnits do
1604: LD_ADDR_VAR 0 2
1608: PUSH
1609: LD_EXP 36
1613: PUSH
1614: FOR_IN
1615: IFFALSE 1640
// PlaceUnitXYR ( i , 159 , 107 , 10 , false ) ;
1617: LD_VAR 0 2
1621: PPUSH
1622: LD_INT 159
1624: PPUSH
1625: LD_INT 107
1627: PPUSH
1628: LD_INT 10
1630: PPUSH
1631: LD_INT 0
1633: PPUSH
1634: CALL_OW 50
1638: GO 1614
1640: POP
1641: POP
// for i in other_survivors do
1642: LD_ADDR_VAR 0 2
1646: PUSH
1647: LD_EXP 34
1651: PUSH
1652: FOR_IN
1653: IFFALSE 1678
// PlaceUnitXYR ( i , 159 , 107 , 10 , false ) ;
1655: LD_VAR 0 2
1659: PPUSH
1660: LD_INT 159
1662: PPUSH
1663: LD_INT 107
1665: PPUSH
1666: LD_INT 10
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 50
1676: GO 1652
1678: POP
1679: POP
// end ;
1680: LD_VAR 0 1
1684: RET
// function PrepareKirovBase ; var i ; begin
1685: LD_INT 0
1687: PPUSH
1688: PPUSH
// kirovBase = LoadVariable ( 02_KirovBase_3 , [ ] ) ;
1689: LD_ADDR_EXP 44
1693: PUSH
1694: LD_STRING 02_KirovBase_3
1696: PPUSH
1697: EMPTY
1698: PPUSH
1699: CALL_OW 30
1703: ST_TO_ADDR
// otherKirovUnits = CreateCharacterSet ( 02_other_kirov ) ;
1704: LD_ADDR_EXP 43
1708: PUSH
1709: LD_STRING 02_other_kirov
1711: PPUSH
1712: CALL_OW 31
1716: ST_TO_ADDR
// uc_side = 6 ;
1717: LD_ADDR_OWVAR 20
1721: PUSH
1722: LD_INT 6
1724: ST_TO_ADDR
// uc_nation = 3 ;
1725: LD_ADDR_OWVAR 21
1729: PUSH
1730: LD_INT 3
1732: ST_TO_ADDR
// for i := 1 to kirovBase do
1733: LD_ADDR_VAR 0 2
1737: PUSH
1738: DOUBLE
1739: LD_INT 1
1741: DEC
1742: ST_TO_ADDR
1743: LD_EXP 44
1747: PUSH
1748: FOR_TO
1749: IFFALSE 2038
// begin bc_type = kirovBase [ i ] [ 1 ] ;
1751: LD_ADDR_OWVAR 42
1755: PUSH
1756: LD_EXP 44
1760: PUSH
1761: LD_VAR 0 2
1765: ARRAY
1766: PUSH
1767: LD_INT 1
1769: ARRAY
1770: ST_TO_ADDR
// bc_level = kirovBase [ i ] [ 5 ] ;
1771: LD_ADDR_OWVAR 43
1775: PUSH
1776: LD_EXP 44
1780: PUSH
1781: LD_VAR 0 2
1785: ARRAY
1786: PUSH
1787: LD_INT 5
1789: ARRAY
1790: ST_TO_ADDR
// if bc_type = b_depot then
1791: LD_OWVAR 42
1795: PUSH
1796: LD_INT 0
1798: EQUAL
1799: IFFALSE 1809
// bc_type = b_warehouse ;
1801: LD_ADDR_OWVAR 42
1805: PUSH
1806: LD_INT 1
1808: ST_TO_ADDR
// if bc_type = b_armoury then
1809: LD_OWVAR 42
1813: PUSH
1814: LD_INT 4
1816: EQUAL
1817: IFFALSE 1827
// bc_type = b_barracks ;
1819: LD_ADDR_OWVAR 42
1823: PUSH
1824: LD_INT 5
1826: ST_TO_ADDR
// if bc_type = b_lab then
1827: LD_OWVAR 42
1831: PUSH
1832: LD_INT 6
1834: EQUAL
1835: IFFALSE 1853
// begin bc_kind1 = b_lab_basic ;
1837: LD_ADDR_OWVAR 44
1841: PUSH
1842: LD_INT 9
1844: ST_TO_ADDR
// bc_kind2 = b_lab_basic ;
1845: LD_ADDR_OWVAR 45
1849: PUSH
1850: LD_INT 9
1852: ST_TO_ADDR
// end ; if bc_type = b_lab_half or bc_type = b_lab_full then
1853: LD_OWVAR 42
1857: PUSH
1858: LD_INT 7
1860: EQUAL
1861: PUSH
1862: LD_OWVAR 42
1866: PUSH
1867: LD_INT 8
1869: EQUAL
1870: OR
1871: IFFALSE 1987
// begin if kirovBase [ i ] [ 7 ] then
1873: LD_EXP 44
1877: PUSH
1878: LD_VAR 0 2
1882: ARRAY
1883: PUSH
1884: LD_INT 7
1886: ARRAY
1887: IFFALSE 1909
// bc_kind1 = kirovBase [ i ] [ 7 ] ;
1889: LD_ADDR_OWVAR 44
1893: PUSH
1894: LD_EXP 44
1898: PUSH
1899: LD_VAR 0 2
1903: ARRAY
1904: PUSH
1905: LD_INT 7
1907: ARRAY
1908: ST_TO_ADDR
// if kirovBase [ i ] [ 8 ] then
1909: LD_EXP 44
1913: PUSH
1914: LD_VAR 0 2
1918: ARRAY
1919: PUSH
1920: LD_INT 8
1922: ARRAY
1923: IFFALSE 1945
// bc_kind2 = kirovBase [ i ] [ 8 ] ;
1925: LD_ADDR_OWVAR 45
1929: PUSH
1930: LD_EXP 44
1934: PUSH
1935: LD_VAR 0 2
1939: ARRAY
1940: PUSH
1941: LD_INT 8
1943: ARRAY
1944: ST_TO_ADDR
// if not kirovBase [ i ] [ 7 ] and not kirovBase [ i ] [ 8 ] then
1945: LD_EXP 44
1949: PUSH
1950: LD_VAR 0 2
1954: ARRAY
1955: PUSH
1956: LD_INT 7
1958: ARRAY
1959: NOT
1960: PUSH
1961: LD_EXP 44
1965: PUSH
1966: LD_VAR 0 2
1970: ARRAY
1971: PUSH
1972: LD_INT 8
1974: ARRAY
1975: NOT
1976: AND
1977: IFFALSE 1987
// bc_type := b_lab ;
1979: LD_ADDR_OWVAR 42
1983: PUSH
1984: LD_INT 6
1986: ST_TO_ADDR
// end ; CreateAndPlaceBuildingXYD ( kirovBase [ i ] [ 2 ] , kirovBase [ i ] [ 3 ] , kirovBase [ i ] [ 4 ] ) ;
1987: LD_EXP 44
1991: PUSH
1992: LD_VAR 0 2
1996: ARRAY
1997: PUSH
1998: LD_INT 2
2000: ARRAY
2001: PPUSH
2002: LD_EXP 44
2006: PUSH
2007: LD_VAR 0 2
2011: ARRAY
2012: PUSH
2013: LD_INT 3
2015: ARRAY
2016: PPUSH
2017: LD_EXP 44
2021: PUSH
2022: LD_VAR 0 2
2026: ARRAY
2027: PUSH
2028: LD_INT 4
2030: ARRAY
2031: PPUSH
2032: CALL_OW 47
// end ;
2036: GO 1748
2038: POP
2039: POP
// kirovDepot = FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
2040: LD_ADDR_EXP 45
2044: PUSH
2045: LD_INT 22
2047: PUSH
2048: LD_INT 6
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 30
2057: PUSH
2058: LD_INT 1
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: PPUSH
2069: CALL_OW 69
2073: PUSH
2074: LD_INT 1
2076: ARRAY
2077: ST_TO_ADDR
// SetBName ( kirovDepot , kirov ) ;
2078: LD_EXP 45
2082: PPUSH
2083: LD_STRING kirov
2085: PPUSH
2086: CALL_OW 500
// Kurin = PrepareUnitExt ( Kurin , false ) ;
2090: LD_ADDR_EXP 39
2094: PUSH
2095: LD_STRING Kurin
2097: PPUSH
2098: LD_INT 0
2100: PPUSH
2101: CALL 3673 0 2
2105: ST_TO_ADDR
// PlaceUnitXY ( Kurin , 166 , 109 , false ) ;
2106: LD_EXP 39
2110: PPUSH
2111: LD_INT 166
2113: PPUSH
2114: LD_INT 109
2116: PPUSH
2117: LD_INT 0
2119: PPUSH
2120: CALL_OW 48
// ComHold ( Kurin ) ;
2124: LD_EXP 39
2128: PPUSH
2129: CALL_OW 140
// Popov = PrepareUnitExt ( Popov , false ) ;
2133: LD_ADDR_EXP 40
2137: PUSH
2138: LD_STRING Popov
2140: PPUSH
2141: LD_INT 0
2143: PPUSH
2144: CALL 3673 0 2
2148: ST_TO_ADDR
// PlaceUnitArea ( Popov , PopovSpawnArea , false ) ;
2149: LD_EXP 40
2153: PPUSH
2154: LD_INT 4
2156: PPUSH
2157: LD_INT 0
2159: PPUSH
2160: CALL_OW 49
// ComTurnXY ( Popov , 98 , 36 ) ;
2164: LD_EXP 40
2168: PPUSH
2169: LD_INT 98
2171: PPUSH
2172: LD_INT 36
2174: PPUSH
2175: CALL_OW 118
// hc_name :=  ;
2179: LD_ADDR_OWVAR 26
2183: PUSH
2184: LD_STRING 
2186: ST_TO_ADDR
// hc_gallery :=  ;
2187: LD_ADDR_OWVAR 33
2191: PUSH
2192: LD_STRING 
2194: ST_TO_ADDR
// PrepareSoldier ( false , 2 ) ;
2195: LD_INT 0
2197: PPUSH
2198: LD_INT 2
2200: PPUSH
2201: CALL_OW 381
// ruScout = CreateHuman ;
2205: LD_ADDR_EXP 42
2209: PUSH
2210: CALL_OW 44
2214: ST_TO_ADDR
// PlaceUnitArea ( ruScout , RuScoutSpawnArea , false ) ;
2215: LD_EXP 42
2219: PPUSH
2220: LD_INT 3
2222: PPUSH
2223: LD_INT 0
2225: PPUSH
2226: CALL_OW 49
// ComCrawl ( ruScout ) ;
2230: LD_EXP 42
2234: PPUSH
2235: CALL_OW 137
// AddComTurnXY ( ruScout , 98 , 36 ) ;
2239: LD_EXP 42
2243: PPUSH
2244: LD_INT 98
2246: PPUSH
2247: LD_INT 36
2249: PPUSH
2250: CALL_OW 178
// uc_side = 6 ;
2254: LD_ADDR_OWVAR 20
2258: PUSH
2259: LD_INT 6
2261: ST_TO_ADDR
// for i in otherKirovUnits do
2262: LD_ADDR_VAR 0 2
2266: PUSH
2267: LD_EXP 43
2271: PUSH
2272: FOR_IN
2273: IFFALSE 2310
// begin SetSide ( i , 6 ) ;
2275: LD_VAR 0 2
2279: PPUSH
2280: LD_INT 6
2282: PPUSH
2283: CALL_OW 235
// PlaceUnitXYR ( i , 159 , 107 , 10 , false ) ;
2287: LD_VAR 0 2
2291: PPUSH
2292: LD_INT 159
2294: PPUSH
2295: LD_INT 107
2297: PPUSH
2298: LD_INT 10
2300: PPUSH
2301: LD_INT 0
2303: PPUSH
2304: CALL_OW 50
// end ;
2308: GO 2272
2310: POP
2311: POP
// end ;
2312: LD_VAR 0 1
2316: RET
// export function PrepareScholtze ; var rndPos , x , y ; begin
2317: LD_INT 0
2319: PPUSH
2320: PPUSH
2321: PPUSH
2322: PPUSH
// uc_side = 8 ;
2323: LD_ADDR_OWVAR 20
2327: PUSH
2328: LD_INT 8
2330: ST_TO_ADDR
// Scholtze = PrepareUnitExt ( Scholtze , false ) ;
2331: LD_ADDR_EXP 33
2335: PUSH
2336: LD_STRING Scholtze
2338: PPUSH
2339: LD_INT 0
2341: PPUSH
2342: CALL 3673 0 2
2346: ST_TO_ADDR
// case Difficulty of 1 :
2347: LD_OWVAR 67
2351: PUSH
2352: LD_INT 1
2354: DOUBLE
2355: EQUAL
2356: IFTRUE 2360
2358: GO 2396
2360: POP
// PlaceUnitXYR ( Scholtze , scholtzeSpawnPositions [ 1 ] , scholtzeSpawnPositions [ 2 ] , 3 , true ) ; 2 :
2361: LD_EXP 33
2365: PPUSH
2366: LD_EXP 20
2370: PUSH
2371: LD_INT 1
2373: ARRAY
2374: PPUSH
2375: LD_EXP 20
2379: PUSH
2380: LD_INT 2
2382: ARRAY
2383: PPUSH
2384: LD_INT 3
2386: PPUSH
2387: LD_INT 1
2389: PPUSH
2390: CALL_OW 50
2394: GO 2705
2396: LD_INT 2
2398: DOUBLE
2399: EQUAL
2400: IFTRUE 2404
2402: GO 2552
2404: POP
// begin scholtzeSpawnNearAmericans = true ;
2405: LD_ADDR_EXP 5
2409: PUSH
2410: LD_INT 1
2412: ST_TO_ADDR
// rndPos = rand ( 1 , scholtzeSpawnPositions / 2 ) ;
2413: LD_ADDR_VAR 0 2
2417: PUSH
2418: LD_INT 1
2420: PPUSH
2421: LD_EXP 20
2425: PUSH
2426: LD_INT 2
2428: DIVREAL
2429: PPUSH
2430: CALL_OW 12
2434: ST_TO_ADDR
// x = scholtzeSpawnPositions [ rndPos [ 1 ] ] ;
2435: LD_ADDR_VAR 0 3
2439: PUSH
2440: LD_EXP 20
2444: PUSH
2445: LD_VAR 0 2
2449: PUSH
2450: LD_INT 1
2452: ARRAY
2453: ARRAY
2454: ST_TO_ADDR
// y = scholtzeSpawnPositions [ rndPos [ 2 ] ] ;
2455: LD_ADDR_VAR 0 4
2459: PUSH
2460: LD_EXP 20
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_INT 2
2472: ARRAY
2473: ARRAY
2474: ST_TO_ADDR
// if rndPos > 1 then
2475: LD_VAR 0 2
2479: PUSH
2480: LD_INT 1
2482: GREATER
2483: IFFALSE 2525
// begin x = scholtzeSpawnPositions [ rndPos + 1 ] ;
2485: LD_ADDR_VAR 0 3
2489: PUSH
2490: LD_EXP 20
2494: PUSH
2495: LD_VAR 0 2
2499: PUSH
2500: LD_INT 1
2502: PLUS
2503: ARRAY
2504: ST_TO_ADDR
// y = scholtzeSpawnPositions [ rndPos + 2 ] ;
2505: LD_ADDR_VAR 0 4
2509: PUSH
2510: LD_EXP 20
2514: PUSH
2515: LD_VAR 0 2
2519: PUSH
2520: LD_INT 2
2522: PLUS
2523: ARRAY
2524: ST_TO_ADDR
// end ; PlaceUnitXYR ( Scholtze , x , y , 3 , true ) ;
2525: LD_EXP 33
2529: PPUSH
2530: LD_VAR 0 3
2534: PPUSH
2535: LD_VAR 0 4
2539: PPUSH
2540: LD_INT 3
2542: PPUSH
2543: LD_INT 1
2545: PPUSH
2546: CALL_OW 50
// end ; 3 :
2550: GO 2705
2552: LD_INT 3
2554: DOUBLE
2555: EQUAL
2556: IFTRUE 2560
2558: GO 2704
2560: POP
// begin rndPos = rand ( 1 , scholtzeSpawnPositions / 2 ) ;
2561: LD_ADDR_VAR 0 2
2565: PUSH
2566: LD_INT 1
2568: PPUSH
2569: LD_EXP 20
2573: PUSH
2574: LD_INT 2
2576: DIVREAL
2577: PPUSH
2578: CALL_OW 12
2582: ST_TO_ADDR
// x = scholtzeSpawnPositions [ rndPos ] ;
2583: LD_ADDR_VAR 0 3
2587: PUSH
2588: LD_EXP 20
2592: PUSH
2593: LD_VAR 0 2
2597: ARRAY
2598: ST_TO_ADDR
// y = scholtzeSpawnPositions [ rndPos + 1 ] ;
2599: LD_ADDR_VAR 0 4
2603: PUSH
2604: LD_EXP 20
2608: PUSH
2609: LD_VAR 0 2
2613: PUSH
2614: LD_INT 1
2616: PLUS
2617: ARRAY
2618: ST_TO_ADDR
// if rndPos > 1 then
2619: LD_VAR 0 2
2623: PUSH
2624: LD_INT 1
2626: GREATER
2627: IFFALSE 2677
// begin scholtzeSpawnNearAmericans = true ;
2629: LD_ADDR_EXP 5
2633: PUSH
2634: LD_INT 1
2636: ST_TO_ADDR
// x = scholtzeSpawnPositions [ rndPos + 1 ] ;
2637: LD_ADDR_VAR 0 3
2641: PUSH
2642: LD_EXP 20
2646: PUSH
2647: LD_VAR 0 2
2651: PUSH
2652: LD_INT 1
2654: PLUS
2655: ARRAY
2656: ST_TO_ADDR
// y = scholtzeSpawnPositions [ rndPos + 2 ] ;
2657: LD_ADDR_VAR 0 4
2661: PUSH
2662: LD_EXP 20
2666: PUSH
2667: LD_VAR 0 2
2671: PUSH
2672: LD_INT 2
2674: PLUS
2675: ARRAY
2676: ST_TO_ADDR
// end ; PlaceUnitXYR ( Scholtze , x , y , 3 , true ) ;
2677: LD_EXP 33
2681: PPUSH
2682: LD_VAR 0 3
2686: PPUSH
2687: LD_VAR 0 4
2691: PPUSH
2692: LD_INT 3
2694: PPUSH
2695: LD_INT 1
2697: PPUSH
2698: CALL_OW 50
// end ; end ;
2702: GO 2705
2704: POP
// end ; end_of_file
2705: LD_VAR 0 1
2709: RET
// export amIntroUnits ; export amSupportTroops ; export amPatrol ; export amBase ; export function PrepareAmericans ; begin
2710: LD_INT 0
2712: PPUSH
// amSupportTroops = [ ] ;
2713: LD_ADDR_EXP 47
2717: PUSH
2718: EMPTY
2719: ST_TO_ADDR
// PrepareOmicronBase ;
2720: CALL 2729 0 0
// end ;
2724: LD_VAR 0 1
2728: RET
// function PrepareOmicronBase ; var base ; begin
2729: LD_INT 0
2731: PPUSH
2732: PPUSH
// amBase := PrepareBase ( omikron , OmicronBaseArea , omikron , [ 1 , 2 , 2 ] [ Difficulty ] , [ 3000 , 300 , 0 ] , [ 14 , 6 , 6 , 5 ] ) ;
2733: LD_ADDR_EXP 49
2737: PUSH
2738: LD_INT 64
2740: PPUSH
2741: LD_INT 13
2743: PPUSH
2744: LD_STRING omikron
2746: PPUSH
2747: LD_INT 1
2749: PUSH
2750: LD_INT 2
2752: PUSH
2753: LD_INT 2
2755: PUSH
2756: EMPTY
2757: LIST
2758: LIST
2759: LIST
2760: PUSH
2761: LD_OWVAR 67
2765: ARRAY
2766: PPUSH
2767: LD_INT 3000
2769: PUSH
2770: LD_INT 300
2772: PUSH
2773: LD_INT 0
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: LIST
2780: PPUSH
2781: LD_INT 14
2783: PUSH
2784: LD_INT 6
2786: PUSH
2787: LD_INT 6
2789: PUSH
2790: LD_INT 5
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: LIST
2798: PPUSH
2799: CALL 40769 0 6
2803: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , amBase ) ;
2804: LD_ADDR_EXP 52
2808: PUSH
2809: LD_EXP 52
2813: PPUSH
2814: LD_INT 1
2816: PPUSH
2817: LD_EXP 49
2821: PPUSH
2822: CALL_OW 1
2826: ST_TO_ADDR
// end ;
2827: LD_VAR 0 1
2831: RET
// export function PrepareAmericansMissionIntro ; var i , veh , human ; begin
2832: LD_INT 0
2834: PPUSH
2835: PPUSH
2836: PPUSH
2837: PPUSH
// amIntroUnits = [ ] ;
2838: LD_ADDR_EXP 46
2842: PUSH
2843: EMPTY
2844: ST_TO_ADDR
// uc_side = 1 ;
2845: LD_ADDR_OWVAR 20
2849: PUSH
2850: LD_INT 1
2852: ST_TO_ADDR
// uc_nation = nation_american ;
2853: LD_ADDR_OWVAR 21
2857: PUSH
2858: LD_INT 1
2860: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
2861: LD_ADDR_OWVAR 37
2865: PUSH
2866: LD_INT 3
2868: ST_TO_ADDR
// vc_control = control_manual ;
2869: LD_ADDR_OWVAR 38
2873: PUSH
2874: LD_INT 1
2876: ST_TO_ADDR
// vc_engine = engine_combustion ;
2877: LD_ADDR_OWVAR 39
2881: PUSH
2882: LD_INT 1
2884: ST_TO_ADDR
// vc_weapon = us_double_gun ;
2885: LD_ADDR_OWVAR 40
2889: PUSH
2890: LD_INT 5
2892: ST_TO_ADDR
// veh = CreateVehicle ;
2893: LD_ADDR_VAR 0 3
2897: PUSH
2898: CALL_OW 45
2902: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2903: LD_VAR 0 3
2907: PPUSH
2908: LD_INT 4
2910: PPUSH
2911: CALL_OW 233
// amIntroUnits = amIntroUnits ^ veh ;
2915: LD_ADDR_EXP 46
2919: PUSH
2920: LD_EXP 46
2924: PUSH
2925: LD_VAR 0 3
2929: ADD
2930: ST_TO_ADDR
// PlaceUnitArea ( veh , CutsceneAmSupportSpawnArea , false ) ;
2931: LD_VAR 0 3
2935: PPUSH
2936: LD_INT 5
2938: PPUSH
2939: LD_INT 0
2941: PPUSH
2942: CALL_OW 49
// for i := 1 to 5 do
2946: LD_ADDR_VAR 0 2
2950: PUSH
2951: DOUBLE
2952: LD_INT 1
2954: DEC
2955: ST_TO_ADDR
2956: LD_INT 5
2958: PUSH
2959: FOR_TO
2960: IFFALSE 3057
// begin hc_name :=  ;
2962: LD_ADDR_OWVAR 26
2966: PUSH
2967: LD_STRING 
2969: ST_TO_ADDR
// hc_gallery :=  ;
2970: LD_ADDR_OWVAR 33
2974: PUSH
2975: LD_STRING 
2977: ST_TO_ADDR
// PrepareSoldier ( false , 1 ) ;
2978: LD_INT 0
2980: PPUSH
2981: LD_INT 1
2983: PPUSH
2984: CALL_OW 381
// human = CreateHuman ;
2988: LD_ADDR_VAR 0 4
2992: PUSH
2993: CALL_OW 44
2997: ST_TO_ADDR
// amIntroUnits = amIntroUnits ^ human ;
2998: LD_ADDR_EXP 46
3002: PUSH
3003: LD_EXP 46
3007: PUSH
3008: LD_VAR 0 4
3012: ADD
3013: ST_TO_ADDR
// if i < 5 then
3014: LD_VAR 0 2
3018: PUSH
3019: LD_INT 5
3021: LESS
3022: IFFALSE 3041
// PlaceUnitArea ( human , CutsceneAmSupportSpawnArea , false ) else
3024: LD_VAR 0 4
3028: PPUSH
3029: LD_INT 5
3031: PPUSH
3032: LD_INT 0
3034: PPUSH
3035: CALL_OW 49
3039: GO 3055
// begin PlaceHumanInUnit ( human , veh ) ;
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_VAR 0 3
3050: PPUSH
3051: CALL_OW 52
// end ; end ;
3055: GO 2959
3057: POP
3058: POP
// end ;
3059: LD_VAR 0 1
3063: RET
// export function PrepareAmericanSupportTroops ( soldiersAmount , scientistsAmount , vehiclesAmount , area ) ; var i , un , veh , road ; begin
3064: LD_INT 0
3066: PPUSH
3067: PPUSH
3068: PPUSH
3069: PPUSH
3070: PPUSH
// uc_side := 1 ;
3071: LD_ADDR_OWVAR 20
3075: PUSH
3076: LD_INT 1
3078: ST_TO_ADDR
// uc_nation := 1 ;
3079: LD_ADDR_OWVAR 21
3083: PUSH
3084: LD_INT 1
3086: ST_TO_ADDR
// hc_name :=  ;
3087: LD_ADDR_OWVAR 26
3091: PUSH
3092: LD_STRING 
3094: ST_TO_ADDR
// hc_gallery :=  ;
3095: LD_ADDR_OWVAR 33
3099: PUSH
3100: LD_STRING 
3102: ST_TO_ADDR
// for i := 1 to soldiersAmount do
3103: LD_ADDR_VAR 0 6
3107: PUSH
3108: DOUBLE
3109: LD_INT 1
3111: DEC
3112: ST_TO_ADDR
3113: LD_VAR 0 1
3117: PUSH
3118: FOR_TO
3119: IFFALSE 3178
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3121: LD_INT 0
3123: PPUSH
3124: LD_EXP 24
3128: PPUSH
3129: CALL_OW 381
// un = CreateHuman ;
3133: LD_ADDR_VAR 0 7
3137: PUSH
3138: CALL_OW 44
3142: ST_TO_ADDR
// amSupportTroops = amSupportTroops ^ un ;
3143: LD_ADDR_EXP 47
3147: PUSH
3148: LD_EXP 47
3152: PUSH
3153: LD_VAR 0 7
3157: ADD
3158: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
3159: LD_VAR 0 7
3163: PPUSH
3164: LD_VAR 0 4
3168: PPUSH
3169: LD_INT 0
3171: PPUSH
3172: CALL_OW 49
// end ;
3176: GO 3118
3178: POP
3179: POP
// for i := 1 to soldiersAmount do
3180: LD_ADDR_VAR 0 6
3184: PUSH
3185: DOUBLE
3186: LD_INT 1
3188: DEC
3189: ST_TO_ADDR
3190: LD_VAR 0 1
3194: PUSH
3195: FOR_TO
3196: IFFALSE 3255
// begin PrepareScientist ( false , enemySkillLevel ) ;
3198: LD_INT 0
3200: PPUSH
3201: LD_EXP 24
3205: PPUSH
3206: CALL_OW 384
// un = CreateHuman ;
3210: LD_ADDR_VAR 0 7
3214: PUSH
3215: CALL_OW 44
3219: ST_TO_ADDR
// amSupportTroops = amSupportTroops ^ un ;
3220: LD_ADDR_EXP 47
3224: PUSH
3225: LD_EXP 47
3229: PUSH
3230: LD_VAR 0 7
3234: ADD
3235: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
3236: LD_VAR 0 7
3240: PPUSH
3241: LD_VAR 0 4
3245: PPUSH
3246: LD_INT 0
3248: PPUSH
3249: CALL_OW 49
// end ;
3253: GO 3195
3255: POP
3256: POP
// for i := 1 to vehiclesAmount do
3257: LD_ADDR_VAR 0 6
3261: PUSH
3262: DOUBLE
3263: LD_INT 1
3265: DEC
3266: ST_TO_ADDR
3267: LD_VAR 0 3
3271: PUSH
3272: FOR_TO
3273: IFFALSE 3431
// begin vc_weapon = [ us_machine_gun , us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 4 ) ] ;
3275: LD_ADDR_OWVAR 40
3279: PUSH
3280: LD_INT 2
3282: PUSH
3283: LD_INT 4
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 5
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PUSH
3298: LD_INT 1
3300: PPUSH
3301: LD_INT 4
3303: PPUSH
3304: CALL_OW 12
3308: ARRAY
3309: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
3310: LD_ADDR_OWVAR 37
3314: PUSH
3315: LD_INT 3
3317: ST_TO_ADDR
// vc_control = control_manual ;
3318: LD_ADDR_OWVAR 38
3322: PUSH
3323: LD_INT 1
3325: ST_TO_ADDR
// vc_engine = engine_combustion ;
3326: LD_ADDR_OWVAR 39
3330: PUSH
3331: LD_INT 1
3333: ST_TO_ADDR
// veh = CreateVehicle ;
3334: LD_ADDR_VAR 0 8
3338: PUSH
3339: CALL_OW 45
3343: ST_TO_ADDR
// amSupportTroops = amSupportTroops ^ veh ;
3344: LD_ADDR_EXP 47
3348: PUSH
3349: LD_EXP 47
3353: PUSH
3354: LD_VAR 0 8
3358: ADD
3359: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
3360: LD_VAR 0 8
3364: PPUSH
3365: LD_VAR 0 4
3369: PPUSH
3370: LD_INT 0
3372: PPUSH
3373: CALL_OW 49
// PrepareMechanic ( false , enemySkillLevel ) ;
3377: LD_INT 0
3379: PPUSH
3380: LD_EXP 24
3384: PPUSH
3385: CALL_OW 383
// un = CreateHuman ;
3389: LD_ADDR_VAR 0 7
3393: PUSH
3394: CALL_OW 44
3398: ST_TO_ADDR
// amSupportTroops = amSupportTroops ^ un ;
3399: LD_ADDR_EXP 47
3403: PUSH
3404: LD_EXP 47
3408: PUSH
3409: LD_VAR 0 7
3413: ADD
3414: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
3415: LD_VAR 0 7
3419: PPUSH
3420: LD_VAR 0 8
3424: PPUSH
3425: CALL_OW 52
// end ;
3429: GO 3272
3431: POP
3432: POP
// case area of NorthAmericanSpawnArea :
3433: LD_VAR 0 4
3437: PUSH
3438: LD_INT 7
3440: DOUBLE
3441: EQUAL
3442: IFTRUE 3446
3444: GO 3457
3446: POP
// road = NorthRoadArea ; SouthAmericanSpawnArea1 :
3447: LD_ADDR_VAR 0 9
3451: PUSH
3452: LD_INT 10
3454: ST_TO_ADDR
3455: GO 3496
3457: LD_INT 9
3459: DOUBLE
3460: EQUAL
3461: IFTRUE 3465
3463: GO 3476
3465: POP
// road = SouthRoadArea1 ; SouthAmericanSpawnArea2 :
3466: LD_ADDR_VAR 0 9
3470: PUSH
3471: LD_INT 11
3473: ST_TO_ADDR
3474: GO 3496
3476: LD_INT 8
3478: DOUBLE
3479: EQUAL
3480: IFTRUE 3484
3482: GO 3495
3484: POP
// road = SouthRoadArea2 ; end ;
3485: LD_ADDR_VAR 0 9
3489: PUSH
3490: LD_INT 12
3492: ST_TO_ADDR
3493: GO 3496
3495: POP
// MoveToBase ( amSupportTroops , road ) ;
3496: LD_EXP 47
3500: PPUSH
3501: LD_VAR 0 9
3505: PPUSH
3506: CALL 4427 0 2
// end ;
3510: LD_VAR 0 5
3514: RET
// export function PrepareAmericanPatrol ; var un ; begin
3515: LD_INT 0
3517: PPUSH
3518: PPUSH
// amPatrol = [ ] ;
3519: LD_ADDR_EXP 48
3523: PUSH
3524: EMPTY
3525: ST_TO_ADDR
// uc_side = 1 ;
3526: LD_ADDR_OWVAR 20
3530: PUSH
3531: LD_INT 1
3533: ST_TO_ADDR
// uc_nation = 1 ;
3534: LD_ADDR_OWVAR 21
3538: PUSH
3539: LD_INT 1
3541: ST_TO_ADDR
// un = PrepareUnitExt ( Campell , false ) ;
3542: LD_ADDR_VAR 0 2
3546: PUSH
3547: LD_STRING Campell
3549: PPUSH
3550: LD_INT 0
3552: PPUSH
3553: CALL 3673 0 2
3557: ST_TO_ADDR
// amPatrol = amPatrol ^ un ;
3558: LD_ADDR_EXP 48
3562: PUSH
3563: LD_EXP 48
3567: PUSH
3568: LD_VAR 0 2
3572: ADD
3573: ST_TO_ADDR
// PlaceUnitArea ( un , OmicronSpawnArea , false ) ;
3574: LD_VAR 0 2
3578: PPUSH
3579: LD_INT 14
3581: PPUSH
3582: LD_INT 0
3584: PPUSH
3585: CALL_OW 49
// SetClass ( un , 1 ) ;
3589: LD_VAR 0 2
3593: PPUSH
3594: LD_INT 1
3596: PPUSH
3597: CALL_OW 336
// PrepareSoldier ( sex_male , enemySkillLevel ) ;
3601: LD_INT 1
3603: PPUSH
3604: LD_EXP 24
3608: PPUSH
3609: CALL_OW 381
// un = CreateHuman ;
3613: LD_ADDR_VAR 0 2
3617: PUSH
3618: CALL_OW 44
3622: ST_TO_ADDR
// amPatrol = amPatrol ^ un ;
3623: LD_ADDR_EXP 48
3627: PUSH
3628: LD_EXP 48
3632: PUSH
3633: LD_VAR 0 2
3637: ADD
3638: ST_TO_ADDR
// PlaceUnitArea ( un , OmicronSpawnArea , false ) ;
3639: LD_VAR 0 2
3643: PPUSH
3644: LD_INT 14
3646: PPUSH
3647: LD_INT 0
3649: PPUSH
3650: CALL_OW 49
// ComAttackUnit ( amPatrol , Scholtze ) ;
3654: LD_EXP 48
3658: PPUSH
3659: LD_EXP 33
3663: PPUSH
3664: CALL_OW 115
// end ; end_of_file end_of_file
3668: LD_VAR 0 1
3672: RET
// export function PrepareUnitExt ( ident , exist_mode ) ; var unit ; begin
3673: LD_INT 0
3675: PPUSH
3676: PPUSH
// if exist_mode then
3677: LD_VAR 0 2
3681: IFFALSE 3706
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
3683: LD_ADDR_VAR 0 4
3687: PUSH
3688: LD_EXP 17
3692: PUSH
3693: LD_VAR 0 1
3697: STR
3698: PPUSH
3699: CALL_OW 34
3703: ST_TO_ADDR
3704: GO 3721
// unit := NewCharacter ( ident ) ;
3706: LD_ADDR_VAR 0 4
3710: PUSH
3711: LD_VAR 0 1
3715: PPUSH
3716: CALL_OW 25
3720: ST_TO_ADDR
// result := unit ;
3721: LD_ADDR_VAR 0 3
3725: PUSH
3726: LD_VAR 0 4
3730: ST_TO_ADDR
// end ;
3731: LD_VAR 0 3
3735: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio ) ; var i , speaker ; begin
3736: LD_INT 0
3738: PPUSH
3739: PPUSH
3740: PPUSH
// characters := characters diff [ Burlak , Gnyevko , Belkov , Belkov2 , Kirilenkova , Kovalyuk , Scholtze ] ;
3741: LD_ADDR_VAR 0 1
3745: PUSH
3746: LD_VAR 0 1
3750: PUSH
3751: LD_EXP 27
3755: PUSH
3756: LD_EXP 28
3760: PUSH
3761: LD_EXP 31
3765: PUSH
3766: LD_EXP 32
3770: PUSH
3771: LD_EXP 29
3775: PUSH
3776: LD_EXP 30
3780: PUSH
3781: LD_EXP 33
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: LIST
3790: LIST
3791: LIST
3792: LIST
3793: LIST
3794: DIFF
3795: ST_TO_ADDR
// speaker := characters [ rand ( 1 , characters ) ] ;
3796: LD_ADDR_VAR 0 7
3800: PUSH
3801: LD_VAR 0 1
3805: PUSH
3806: LD_INT 1
3808: PPUSH
3809: LD_VAR 0 1
3813: PPUSH
3814: CALL_OW 12
3818: ARRAY
3819: ST_TO_ADDR
// if radio then
3820: LD_VAR 0 4
3824: IFFALSE 3873
// begin if GetSex ( speaker ) = sex_male then
3826: LD_VAR 0 7
3830: PPUSH
3831: CALL_OW 258
3835: PUSH
3836: LD_INT 1
3838: EQUAL
3839: IFFALSE 3857
// SayRadio ( speaker , dialogMID ) else
3841: LD_VAR 0 7
3845: PPUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL_OW 94
3855: GO 3871
// SayRadio ( speaker , dialogFID ) ;
3857: LD_VAR 0 7
3861: PPUSH
3862: LD_VAR 0 3
3866: PPUSH
3867: CALL_OW 94
// end else
3871: GO 3918
// begin if GetSex ( speaker ) = sex_male then
3873: LD_VAR 0 7
3877: PPUSH
3878: CALL_OW 258
3882: PUSH
3883: LD_INT 1
3885: EQUAL
3886: IFFALSE 3904
// Say ( speaker , dialogMID ) else
3888: LD_VAR 0 7
3892: PPUSH
3893: LD_VAR 0 2
3897: PPUSH
3898: CALL_OW 88
3902: GO 3918
// Say ( speaker , dialogFID ) ;
3904: LD_VAR 0 7
3908: PPUSH
3909: LD_VAR 0 3
3913: PPUSH
3914: CALL_OW 88
// end ; result := speaker ;
3918: LD_ADDR_VAR 0 5
3922: PUSH
3923: LD_VAR 0 7
3927: ST_TO_ADDR
// end ;
3928: LD_VAR 0 5
3932: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
3933: LD_INT 0
3935: PPUSH
// if GetSide ( character ) = side and IsOK ( character ) then
3936: LD_VAR 0 1
3940: PPUSH
3941: CALL_OW 255
3945: PUSH
3946: LD_VAR 0 3
3950: EQUAL
3951: PUSH
3952: LD_VAR 0 1
3956: PPUSH
3957: CALL_OW 302
3961: AND
3962: IFFALSE 3984
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
3964: LD_VAR 0 1
3968: PPUSH
3969: LD_EXP 16
3973: PUSH
3974: LD_VAR 0 2
3978: STR
3979: PPUSH
3980: CALL_OW 38
// end ;
3984: LD_VAR 0 4
3988: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
3989: LD_INT 0
3991: PPUSH
3992: PPUSH
3993: PPUSH
// resultCharactersToSave = [ ] ;
3994: LD_ADDR_VAR 0 6
3998: PUSH
3999: EMPTY
4000: ST_TO_ADDR
// for unit in characters do
4001: LD_ADDR_VAR 0 5
4005: PUSH
4006: LD_VAR 0 1
4010: PUSH
4011: FOR_IN
4012: IFFALSE 4060
// if GetSide ( unit ) = side and IsOK ( unit ) then
4014: LD_VAR 0 5
4018: PPUSH
4019: CALL_OW 255
4023: PUSH
4024: LD_VAR 0 3
4028: EQUAL
4029: PUSH
4030: LD_VAR 0 5
4034: PPUSH
4035: CALL_OW 302
4039: AND
4040: IFFALSE 4058
// resultCharactersToSave = resultCharactersToSave ^ unit ;
4042: LD_ADDR_VAR 0 6
4046: PUSH
4047: LD_VAR 0 6
4051: PUSH
4052: LD_VAR 0 5
4056: ADD
4057: ST_TO_ADDR
4058: GO 4011
4060: POP
4061: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
4062: LD_VAR 0 6
4066: PPUSH
4067: LD_EXP 16
4071: PUSH
4072: LD_VAR 0 2
4076: STR
4077: PPUSH
4078: CALL_OW 38
// end ;
4082: LD_VAR 0 4
4086: RET
// export function SelectCharacters ( maxUnitToChoose ) ; var i , charsToChoose , selectedPeople ; begin
4087: LD_INT 0
4089: PPUSH
4090: PPUSH
4091: PPUSH
4092: PPUSH
// charsToChoose = otherKirovUnits ;
4093: LD_ADDR_VAR 0 4
4097: PUSH
4098: LD_EXP 43
4102: ST_TO_ADDR
// charsToChoose = charsToChoose ^ otherBeriaUnits ;
4103: LD_ADDR_VAR 0 4
4107: PUSH
4108: LD_VAR 0 4
4112: PUSH
4113: LD_EXP 36
4117: ADD
4118: ST_TO_ADDR
// charsToChoose = charsToChoose ^ other_survivors ;
4119: LD_ADDR_VAR 0 4
4123: PUSH
4124: LD_VAR 0 4
4128: PUSH
4129: LD_EXP 34
4133: ADD
4134: ST_TO_ADDR
// charsToChoose = charsToChoose ^ Belkov ;
4135: LD_ADDR_VAR 0 4
4139: PUSH
4140: LD_VAR 0 4
4144: PUSH
4145: LD_EXP 31
4149: ADD
4150: ST_TO_ADDR
// charsToChoose = charsToChoose ^ Belkov2 ;
4151: LD_ADDR_VAR 0 4
4155: PUSH
4156: LD_VAR 0 4
4160: PUSH
4161: LD_EXP 32
4165: ADD
4166: ST_TO_ADDR
// selectedPeople = CharacterSelection ( text , maxUnitToChoose , maxUnitToChoose , [ sel_change_class , Burlak , Gnyevko , Kovalyuk , Kirilenkova , sel_dont_change_class , sel_not_hired , sel_changeable , sel_change_class ] ^ charsToChoose ^ [ sel_dont_change_class , sel_not_changeable , Kurin ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] ] ) ;
4167: LD_ADDR_VAR 0 5
4171: PUSH
4172: LD_STRING text
4174: PPUSH
4175: LD_VAR 0 1
4179: PPUSH
4180: LD_VAR 0 1
4184: PPUSH
4185: LD_INT -5
4187: PUSH
4188: LD_EXP 27
4192: PUSH
4193: LD_EXP 28
4197: PUSH
4198: LD_EXP 30
4202: PUSH
4203: LD_EXP 29
4207: PUSH
4208: LD_INT -6
4210: PUSH
4211: LD_INT -2
4213: PUSH
4214: LD_INT -3
4216: PUSH
4217: LD_INT -5
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: LIST
4224: LIST
4225: LIST
4226: LIST
4227: LIST
4228: LIST
4229: LIST
4230: PUSH
4231: LD_VAR 0 4
4235: ADD
4236: PUSH
4237: LD_INT -6
4239: PUSH
4240: LD_INT -4
4242: PUSH
4243: LD_EXP 39
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: LIST
4252: ADD
4253: PPUSH
4254: LD_INT 1
4256: PUSH
4257: LD_INT 3
4259: PUSH
4260: LD_INT 2
4262: PUSH
4263: LD_INT 1
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 4
4272: PUSH
4273: LD_INT 1
4275: PUSH
4276: EMPTY
4277: LIST
4278: LIST
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: LIST
4284: LIST
4285: PPUSH
4286: CALL_OW 42
4290: ST_TO_ADDR
// SetSide ( charsToChoose , 6 ) ;
4291: LD_VAR 0 4
4295: PPUSH
4296: LD_INT 6
4298: PPUSH
4299: CALL_OW 235
// SetSide ( selectedPeople , 3 ) ;
4303: LD_VAR 0 5
4307: PPUSH
4308: LD_INT 3
4310: PPUSH
4311: CALL_OW 235
// end ;
4315: LD_VAR 0 2
4319: RET
// export function FindNotFullBuildingInArea ( area , side , buildingType ) ; var building ; begin
4320: LD_INT 0
4322: PPUSH
4323: PPUSH
// for building in FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , unit_building ] , [ f_btype , buildingType ] ] ) do
4324: LD_ADDR_VAR 0 5
4328: PUSH
4329: LD_VAR 0 1
4333: PPUSH
4334: LD_INT 22
4336: PUSH
4337: LD_VAR 0 2
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: PUSH
4346: LD_INT 21
4348: PUSH
4349: LD_INT 3
4351: PUSH
4352: EMPTY
4353: LIST
4354: LIST
4355: PUSH
4356: LD_INT 30
4358: PUSH
4359: LD_VAR 0 3
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: PUSH
4368: EMPTY
4369: LIST
4370: LIST
4371: LIST
4372: PPUSH
4373: CALL_OW 70
4377: PUSH
4378: FOR_IN
4379: IFFALSE 4412
// begin if UnitsInside ( building ) < 6 then
4381: LD_VAR 0 5
4385: PPUSH
4386: CALL_OW 313
4390: PUSH
4391: LD_INT 6
4393: LESS
4394: IFFALSE 4410
// begin result = building ;
4396: LD_ADDR_VAR 0 4
4400: PUSH
4401: LD_VAR 0 5
4405: ST_TO_ADDR
// exit ;
4406: POP
4407: POP
4408: GO 4422
// end ; end ;
4410: GO 4378
4412: POP
4413: POP
// result = 0 ;
4414: LD_ADDR_VAR 0 4
4418: PUSH
4419: LD_INT 0
4421: ST_TO_ADDR
// end ;
4422: LD_VAR 0 4
4426: RET
// export function MoveToBase ( units , roadArea ) ; var unit , playerUnits , playerUnit , enemyUnitsOnRoad , nearUnit , attackUnits , medics , damageUnits , inBase , newBase ; begin
4427: LD_INT 0
4429: PPUSH
4430: PPUSH
4431: PPUSH
4432: PPUSH
4433: PPUSH
4434: PPUSH
4435: PPUSH
4436: PPUSH
4437: PPUSH
4438: PPUSH
4439: PPUSH
// inBase = false ;
4440: LD_ADDR_VAR 0 12
4444: PUSH
4445: LD_INT 0
4447: ST_TO_ADDR
// repeat enemyUnitsOnRoad = FilterUnitsInArea ( roadArea , [ [ f_side , 3 ] ] ) ;
4448: LD_ADDR_VAR 0 7
4452: PUSH
4453: LD_VAR 0 2
4457: PPUSH
4458: LD_INT 22
4460: PUSH
4461: LD_INT 3
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: PUSH
4468: EMPTY
4469: LIST
4470: PPUSH
4471: CALL_OW 70
4475: ST_TO_ADDR
// attackUnits = UnitFilter ( units , [ [ f_ok ] , [ f_or , [ f_class , class_soldier ] , [ f_class , class_mechanic ] , [ f_type , unit_vehicle ] ] ] ) ;
4476: LD_ADDR_VAR 0 9
4480: PUSH
4481: LD_VAR 0 1
4485: PPUSH
4486: LD_INT 50
4488: PUSH
4489: EMPTY
4490: LIST
4491: PUSH
4492: LD_INT 2
4494: PUSH
4495: LD_INT 25
4497: PUSH
4498: LD_INT 1
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 25
4507: PUSH
4508: LD_INT 3
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 21
4517: PUSH
4518: LD_INT 2
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: LIST
4529: LIST
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL_OW 72
4539: ST_TO_ADDR
// medics = UnitFilter ( units , [ [ f_ok ] , [ f_class , class_scientistic ] ] ) ;
4540: LD_ADDR_VAR 0 10
4544: PUSH
4545: LD_VAR 0 1
4549: PPUSH
4550: LD_INT 50
4552: PUSH
4553: EMPTY
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 4
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PPUSH
4570: CALL_OW 72
4574: ST_TO_ADDR
// damageUnits = UnitFilter ( units , [ f_not , [ f_lives , 1000 ] ] ) ;
4575: LD_ADDR_VAR 0 11
4579: PUSH
4580: LD_VAR 0 1
4584: PPUSH
4585: LD_INT 3
4587: PUSH
4588: LD_INT 24
4590: PUSH
4591: LD_INT 1000
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: PUSH
4598: EMPTY
4599: LIST
4600: LIST
4601: PPUSH
4602: CALL_OW 72
4606: ST_TO_ADDR
// playerUnits = FilterAllUnits ( [ [ f_side , 3 ] ] ) ;
4607: LD_ADDR_VAR 0 5
4611: PUSH
4612: LD_INT 22
4614: PUSH
4615: LD_INT 3
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: PUSH
4622: EMPTY
4623: LIST
4624: PPUSH
4625: CALL_OW 69
4629: ST_TO_ADDR
// for unit in UnitFilter ( units , [ f_ok ] ) do
4630: LD_ADDR_VAR 0 4
4634: PUSH
4635: LD_VAR 0 1
4639: PPUSH
4640: LD_INT 50
4642: PUSH
4643: EMPTY
4644: LIST
4645: PPUSH
4646: CALL_OW 72
4650: PUSH
4651: FOR_IN
4652: IFFALSE 4929
// begin if attackUnits and medics then
4654: LD_VAR 0 9
4658: PUSH
4659: LD_VAR 0 10
4663: AND
4664: IFFALSE 4731
// begin if damageUnits then
4666: LD_VAR 0 11
4670: IFFALSE 4692
// ComHeal ( medics , damageUnits [ 1 ] ) else
4672: LD_VAR 0 10
4676: PPUSH
4677: LD_VAR 0 11
4681: PUSH
4682: LD_INT 1
4684: ARRAY
4685: PPUSH
4686: CALL_OW 128
4690: GO 4729
// ComMoveXY ( medics , GetX ( attackUnits [ 1 ] ) , GetY ( attackUnits [ 1 ] ) ) ;
4692: LD_VAR 0 10
4696: PPUSH
4697: LD_VAR 0 9
4701: PUSH
4702: LD_INT 1
4704: ARRAY
4705: PPUSH
4706: CALL_OW 250
4710: PPUSH
4711: LD_VAR 0 9
4715: PUSH
4716: LD_INT 1
4718: ARRAY
4719: PPUSH
4720: CALL_OW 251
4724: PPUSH
4725: CALL_OW 111
// end else
4729: GO 4760
// begin if not attackUnits and medics then
4731: LD_VAR 0 9
4735: NOT
4736: PUSH
4737: LD_VAR 0 10
4741: AND
4742: IFFALSE 4760
// attackUnits = attackUnits ^ medics ;
4744: LD_ADDR_VAR 0 9
4748: PUSH
4749: LD_VAR 0 9
4753: PUSH
4754: LD_VAR 0 10
4758: ADD
4759: ST_TO_ADDR
// end ; if enemyUnitsOnRoad then
4760: LD_VAR 0 7
4764: IFFALSE 4883
// begin for playerUnit in playerUnits do
4766: LD_ADDR_VAR 0 6
4770: PUSH
4771: LD_VAR 0 5
4775: PUSH
4776: FOR_IN
4777: IFFALSE 4879
// begin if Attacks ( playerUnit ) then
4779: LD_VAR 0 6
4783: PPUSH
4784: CALL_OW 320
4788: IFFALSE 4843
// begin if Attacks ( playerUnit ) in units and GetDistUnits ( playerUnit , unit ) < 13 then
4790: LD_VAR 0 6
4794: PPUSH
4795: CALL_OW 320
4799: PUSH
4800: LD_VAR 0 1
4804: IN
4805: PUSH
4806: LD_VAR 0 6
4810: PPUSH
4811: LD_VAR 0 4
4815: PPUSH
4816: CALL_OW 296
4820: PUSH
4821: LD_INT 13
4823: LESS
4824: AND
4825: IFFALSE 4841
// ComAttackUnit ( attackUnits , playerUnit ) end else
4827: LD_VAR 0 9
4831: PPUSH
4832: LD_VAR 0 6
4836: PPUSH
4837: CALL_OW 115
4841: GO 4877
// begin nearUnit = NearestUnitToUnit ( enemyUnitsOnRoad , unit ) ;
4843: LD_ADDR_VAR 0 8
4847: PUSH
4848: LD_VAR 0 7
4852: PPUSH
4853: LD_VAR 0 4
4857: PPUSH
4858: CALL_OW 74
4862: ST_TO_ADDR
// ComAttackUnit ( attackUnits , nearUnit ) ;
4863: LD_VAR 0 9
4867: PPUSH
4868: LD_VAR 0 8
4872: PPUSH
4873: CALL_OW 115
// end ; end ;
4877: GO 4776
4879: POP
4880: POP
// end else
4881: GO 4898
// begin ComMoveXY ( unit , 27 , 34 ) ;
4883: LD_VAR 0 4
4887: PPUSH
4888: LD_INT 27
4890: PPUSH
4891: LD_INT 34
4893: PPUSH
4894: CALL_OW 111
// end ; if GetDistUnitXY ( unit , 27 , 34 ) < 5 then
4898: LD_VAR 0 4
4902: PPUSH
4903: LD_INT 27
4905: PPUSH
4906: LD_INT 34
4908: PPUSH
4909: CALL_OW 297
4913: PUSH
4914: LD_INT 5
4916: LESS
4917: IFFALSE 4927
// inBase = true ;
4919: LD_ADDR_VAR 0 12
4923: PUSH
4924: LD_INT 1
4926: ST_TO_ADDR
// end ;
4927: GO 4651
4929: POP
4930: POP
// wait ( 0 0$1 ) ;
4931: LD_INT 35
4933: PPUSH
4934: CALL_OW 67
// until UnitFilter ( units , [ f_ok ] ) = 0 or inBase ;
4938: LD_VAR 0 1
4942: PPUSH
4943: LD_INT 50
4945: PUSH
4946: EMPTY
4947: LIST
4948: PPUSH
4949: CALL_OW 72
4953: PUSH
4954: LD_INT 0
4956: EQUAL
4957: PUSH
4958: LD_VAR 0 12
4962: OR
4963: IFFALSE 4448
// ComMoveXY ( units , 27 , 34 ) ;
4965: LD_VAR 0 1
4969: PPUSH
4970: LD_INT 27
4972: PPUSH
4973: LD_INT 34
4975: PPUSH
4976: CALL_OW 111
// amSupportTroops = amSupportTroops diff units ;
4980: LD_ADDR_EXP 47
4984: PUSH
4985: LD_EXP 47
4989: PUSH
4990: LD_VAR 0 1
4994: DIFF
4995: ST_TO_ADDR
// newBase = amBase ;
4996: LD_ADDR_VAR 0 13
5000: PUSH
5001: LD_EXP 49
5005: ST_TO_ADDR
// newBase = newBase ^ UnitFilter ( units , [ f_ok ] ) ;
5006: LD_ADDR_VAR 0 13
5010: PUSH
5011: LD_VAR 0 13
5015: PUSH
5016: LD_VAR 0 1
5020: PPUSH
5021: LD_INT 50
5023: PUSH
5024: EMPTY
5025: LIST
5026: PPUSH
5027: CALL_OW 72
5031: ADD
5032: ST_TO_ADDR
// amBase = newBase ;
5033: LD_ADDR_EXP 49
5037: PUSH
5038: LD_VAR 0 13
5042: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , newBase ) ;
5043: LD_ADDR_EXP 52
5047: PUSH
5048: LD_EXP 52
5052: PPUSH
5053: LD_INT 1
5055: PPUSH
5056: LD_VAR 0 13
5060: PPUSH
5061: CALL_OW 1
5065: ST_TO_ADDR
// end ; end_of_file
5066: LD_VAR 0 3
5070: RET
// every 0 0$1 do
5071: GO 5073
5073: DISABLE
// MC_Start ;
5074: CALL 9358 0 0
5078: END
// export function CustomInitMacro ; begin
5079: LD_INT 0
5081: PPUSH
// end ; end_of_file end_of_file end_of_file
5082: LD_VAR 0 1
5086: RET
// export function CustomEvent ( event ) ; begin
5087: LD_INT 0
5089: PPUSH
// end ;
5090: LD_VAR 0 2
5094: RET
// on UpgradeComplete ( building ) do begin if GetSide ( building ) = 3 and GetBType ( building ) = b_factory and not dialog_workshop then
5095: LD_VAR 0 1
5099: PPUSH
5100: CALL_OW 255
5104: PUSH
5105: LD_INT 3
5107: EQUAL
5108: PUSH
5109: LD_VAR 0 1
5113: PPUSH
5114: CALL_OW 266
5118: PUSH
5119: LD_INT 3
5121: EQUAL
5122: AND
5123: PUSH
5124: LD_EXP 7
5128: NOT
5129: AND
5130: IFFALSE 5141
// Dial_UpgradeWorkshop ( building ) ;
5132: LD_VAR 0 1
5136: PPUSH
5137: CALL 6281 0 1
// end ; end_of_file
5141: PPOPN 1
5143: END
// export function MissionIntro ; var unit ; begin
5144: LD_INT 0
5146: PPUSH
5147: PPUSH
// CenterNowOnUnits ( [ Burlak , Kurin ] ) ;
5148: LD_EXP 27
5152: PUSH
5153: LD_EXP 39
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: PPUSH
5162: CALL_OW 87
// ComTurnUnit ( [ Burlak , BelkovDialog ] , Kurin ) ;
5166: LD_EXP 27
5170: PUSH
5171: LD_EXP 41
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: LD_EXP 39
5184: PPUSH
5185: CALL_OW 119
// ComTurnUnit ( Kurin , Burlak ) ;
5189: LD_EXP 39
5193: PPUSH
5194: LD_EXP 27
5198: PPUSH
5199: CALL_OW 119
// if not IsPlaced ( Belkov ) and not IsPlaced ( Belkov2 ) then
5203: LD_EXP 31
5207: PPUSH
5208: CALL_OW 305
5212: NOT
5213: PUSH
5214: LD_EXP 32
5218: PPUSH
5219: CALL_OW 305
5223: NOT
5224: AND
5225: IFFALSE 5277
// begin Say ( Kurin , D1a-Kur-1 ) ;
5227: LD_EXP 39
5231: PPUSH
5232: LD_STRING D1a-Kur-1
5234: PPUSH
5235: CALL_OW 88
// Say ( Burlak , D1a-Bur-1 ) ;
5239: LD_EXP 27
5243: PPUSH
5244: LD_STRING D1a-Bur-1
5246: PPUSH
5247: CALL_OW 88
// Say ( Kurin , D1a-Kur-2 ) ;
5251: LD_EXP 39
5255: PPUSH
5256: LD_STRING D1a-Kur-2
5258: PPUSH
5259: CALL_OW 88
// Say ( Burlak , D1a-Bur-2 ) ;
5263: LD_EXP 27
5267: PPUSH
5268: LD_STRING D1a-Bur-2
5270: PPUSH
5271: CALL_OW 88
// end else
5275: GO 5313
// begin Say ( Kurin , D1b-Kur-1 ) ;
5277: LD_EXP 39
5281: PPUSH
5282: LD_STRING D1b-Kur-1
5284: PPUSH
5285: CALL_OW 88
// Say ( BelkovDialog , D1b-Bel-1 ) ;
5289: LD_EXP 41
5293: PPUSH
5294: LD_STRING D1b-Bel-1
5296: PPUSH
5297: CALL_OW 88
// Say ( Kurin , D1b-Kur-2 ) ;
5301: LD_EXP 39
5305: PPUSH
5306: LD_STRING D1b-Kur-2
5308: PPUSH
5309: CALL_OW 88
// end ; Say ( Kurin , D2-Kur-1 ) ;
5313: LD_EXP 39
5317: PPUSH
5318: LD_STRING D2-Kur-1
5320: PPUSH
5321: CALL_OW 88
// Say ( Burlak , D2-Bur-1 ) ;
5325: LD_EXP 27
5329: PPUSH
5330: LD_STRING D2-Bur-1
5332: PPUSH
5333: CALL_OW 88
// Say ( Kurin , D2-Kur-2 ) ;
5337: LD_EXP 39
5341: PPUSH
5342: LD_STRING D2-Kur-2
5344: PPUSH
5345: CALL_OW 88
// Say ( Burlak , D2-Bur-2 ) ;
5349: LD_EXP 27
5353: PPUSH
5354: LD_STRING D2-Bur-2
5356: PPUSH
5357: CALL_OW 88
// Say ( Kurin , D2-Kur-3 ) ;
5361: LD_EXP 39
5365: PPUSH
5366: LD_STRING D2-Kur-3
5368: PPUSH
5369: CALL_OW 88
// SetAttitude ( 1 , 6 , att_friend , true ) ;
5373: LD_INT 1
5375: PPUSH
5376: LD_INT 6
5378: PPUSH
5379: LD_INT 1
5381: PPUSH
5382: LD_INT 1
5384: PPUSH
5385: CALL_OW 80
// PrepareAmericansMissionIntro ;
5389: CALL 2832 0 0
// ComMoveXY ( amIntroUnits , 28 , 35 ) ;
5393: LD_EXP 46
5397: PPUSH
5398: LD_INT 28
5400: PPUSH
5401: LD_INT 35
5403: PPUSH
5404: CALL_OW 111
// CenterOnXY ( 93 , 36 ) ;
5408: LD_INT 93
5410: PPUSH
5411: LD_INT 36
5413: PPUSH
5414: CALL_OW 84
// PlaceSeeing ( 93 , 36 , 3 , - 9 ) ;
5418: LD_INT 93
5420: PPUSH
5421: LD_INT 36
5423: PPUSH
5424: LD_INT 3
5426: PPUSH
5427: LD_INT 9
5429: NEG
5430: PPUSH
5431: CALL_OW 330
// wait ( 0 0$6 ) ;
5435: LD_INT 210
5437: PPUSH
5438: CALL_OW 67
// CenterOnUnits ( Popov ) ;
5442: LD_EXP 40
5446: PPUSH
5447: CALL_OW 85
// wait ( 0 0$1 ) ;
5451: LD_INT 35
5453: PPUSH
5454: CALL_OW 67
// SayRadio ( Popov , D2-Pop-3 ) ;
5458: LD_EXP 40
5462: PPUSH
5463: LD_STRING D2-Pop-3
5465: PPUSH
5466: CALL_OW 94
// CenterNowOnUnits ( [ Burlak , Kurin ] ) ;
5470: LD_EXP 27
5474: PUSH
5475: LD_EXP 39
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: PPUSH
5484: CALL_OW 87
// wait ( 0 0$1 ) ;
5488: LD_INT 35
5490: PPUSH
5491: CALL_OW 67
// for unit in amIntroUnits do
5495: LD_ADDR_VAR 0 2
5499: PUSH
5500: LD_EXP 46
5504: PUSH
5505: FOR_IN
5506: IFFALSE 5519
// RemoveUnit ( unit ) ;
5508: LD_VAR 0 2
5512: PPUSH
5513: CALL_OW 64
5517: GO 5505
5519: POP
5520: POP
// Say ( Kurin , D2-Kur-4 ) ;
5521: LD_EXP 39
5525: PPUSH
5526: LD_STRING D2-Kur-4
5528: PPUSH
5529: CALL_OW 88
// Say ( Burlak , D2-Bur-4 ) ;
5533: LD_EXP 27
5537: PPUSH
5538: LD_STRING D2-Bur-4
5540: PPUSH
5541: CALL_OW 88
// Say ( Kurin , D2-Kur-5 ) ;
5545: LD_EXP 39
5549: PPUSH
5550: LD_STRING D2-Kur-5
5552: PPUSH
5553: CALL_OW 88
// Say ( Burlak , D2-Bur-5 ) ;
5557: LD_EXP 27
5561: PPUSH
5562: LD_STRING D2-Bur-5
5564: PPUSH
5565: CALL_OW 88
// Say ( Kurin , D2-Kur-6 ) ;
5569: LD_EXP 39
5573: PPUSH
5574: LD_STRING D2-Kur-6
5576: PPUSH
5577: CALL_OW 88
// if IsPlaced ( Gnyevko ) then
5581: LD_EXP 28
5585: PPUSH
5586: CALL_OW 305
5590: IFFALSE 5606
// baseUnitsToChoose = baseUnitsToChoose - 1 ;
5592: LD_ADDR_EXP 19
5596: PUSH
5597: LD_EXP 19
5601: PUSH
5602: LD_INT 1
5604: MINUS
5605: ST_TO_ADDR
// if IsPlaced ( Kovalyuk ) then
5606: LD_EXP 30
5610: PPUSH
5611: CALL_OW 305
5615: IFFALSE 5631
// baseUnitsToChoose = baseUnitsToChoose - 1 ;
5617: LD_ADDR_EXP 19
5621: PUSH
5622: LD_EXP 19
5626: PUSH
5627: LD_INT 1
5629: MINUS
5630: ST_TO_ADDR
// if IsPlaced ( Kirilenkova ) then
5631: LD_EXP 29
5635: PPUSH
5636: CALL_OW 305
5640: IFFALSE 5656
// baseUnitsToChoose = baseUnitsToChoose - 1 ;
5642: LD_ADDR_EXP 19
5646: PUSH
5647: LD_EXP 19
5651: PUSH
5652: LD_INT 1
5654: MINUS
5655: ST_TO_ADDR
// SelectCharacters ( baseUnitsToChoose ) ;
5656: LD_EXP 19
5660: PPUSH
5661: CALL 4087 0 1
// RemoveSeeing ( 93 , 36 , 3 ) ;
5665: LD_INT 93
5667: PPUSH
5668: LD_INT 36
5670: PPUSH
5671: LD_INT 3
5673: PPUSH
5674: CALL_OW 331
// Resetfog ;
5678: CALL_OW 335
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , GetX ( beriaDepot ) , GetY ( beriaDepot ) ) ;
5682: LD_INT 22
5684: PUSH
5685: LD_INT 3
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 21
5694: PUSH
5695: LD_INT 1
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: PPUSH
5706: CALL_OW 69
5710: PPUSH
5711: LD_EXP 38
5715: PPUSH
5716: CALL_OW 250
5720: PPUSH
5721: LD_EXP 38
5725: PPUSH
5726: CALL_OW 251
5730: PPUSH
5731: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
5735: LD_INT 35
5737: PPUSH
5738: CALL_OW 67
// CenterNowOnUnits ( Burlak ) ;
5742: LD_EXP 27
5746: PPUSH
5747: CALL_OW 87
// until GetDistUnits ( Burlak , beriaDepot ) < 6 ;
5751: LD_EXP 27
5755: PPUSH
5756: LD_EXP 38
5760: PPUSH
5761: CALL_OW 296
5765: PUSH
5766: LD_INT 6
5768: LESS
5769: IFFALSE 5735
// InGameOff ;
5771: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
5775: LD_STRING M1
5777: PPUSH
5778: CALL_OW 337
// SaveForQuickRestart ;
5782: CALL_OW 22
// ComWalk ( ruScout ) ;
5786: LD_EXP 42
5790: PPUSH
5791: CALL_OW 138
// wait ( 0 0$1 ) ;
5795: LD_INT 35
5797: PPUSH
5798: CALL_OW 67
// AddComMoveXY ( [ ruScout , Popov ] , 99 , 37 ) ;
5802: LD_EXP 42
5806: PUSH
5807: LD_EXP 40
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: PPUSH
5816: LD_INT 99
5818: PPUSH
5819: LD_INT 37
5821: PPUSH
5822: CALL_OW 171
// AddComMoveXY ( [ ruScout , Popov ] , 88 , 60 ) ;
5826: LD_EXP 42
5830: PUSH
5831: LD_EXP 40
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: PPUSH
5840: LD_INT 88
5842: PPUSH
5843: LD_INT 60
5845: PPUSH
5846: CALL_OW 171
// AddComMoveXY ( [ ruScout , Popov ] , 129 , 99 ) ;
5850: LD_EXP 42
5854: PUSH
5855: LD_EXP 40
5859: PUSH
5860: EMPTY
5861: LIST
5862: LIST
5863: PPUSH
5864: LD_INT 129
5866: PPUSH
5867: LD_INT 99
5869: PPUSH
5870: CALL_OW 171
// AddComEnterUnit ( [ Popov , ruScout ] , kirovDepot ) ;
5874: LD_EXP 40
5878: PUSH
5879: LD_EXP 42
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PPUSH
5888: LD_EXP 45
5892: PPUSH
5893: CALL_OW 180
// PrepareAmericanSupportTroops ( 3 , 2 , 2 , SouthAmericanSpawnArea1 ) ;
5897: LD_INT 3
5899: PPUSH
5900: LD_INT 2
5902: PPUSH
5903: LD_INT 2
5905: PPUSH
5906: LD_INT 9
5908: PPUSH
5909: CALL 3064 0 4
// end ;
5913: LD_VAR 0 1
5917: RET
// every 0 0$1 trigger GetResourceVisibility ( 78 , 112 , 3 ) do
5918: LD_INT 78
5920: PPUSH
5921: LD_INT 112
5923: PPUSH
5924: LD_INT 3
5926: PPUSH
5927: CALL_OW 440
5931: IFFALSE 5985
5933: GO 5935
5935: DISABLE
// begin CenterOnXY ( 78 , 112 ) ;
5936: LD_INT 78
5938: PPUSH
5939: LD_INT 112
5941: PPUSH
5942: CALL_OW 84
// DialogueOn ;
5946: CALL_OW 6
// Say ( Burlak , D2a-Bur-1 ) ;
5950: LD_EXP 27
5954: PPUSH
5955: LD_STRING D2a-Bur-1
5957: PPUSH
5958: CALL_OW 88
// SayRadio ( Kurin , D2a-Kur-1 ) ;
5962: LD_EXP 39
5966: PPUSH
5967: LD_STRING D2a-Kur-1
5969: PPUSH
5970: CALL_OW 94
// DialogueOff ;
5974: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
5978: LD_STRING M2
5980: PPUSH
5981: CALL_OW 337
// end ;
5985: END
// every 5 5$30 do
5986: GO 5988
5988: DISABLE
// begin PrepareScholtze ;
5989: CALL 2317 0 0
// DialogueOn ;
5993: CALL_OW 6
// SayRadio ( Scholtze , D4-Sch-1 ) ;
5997: LD_EXP 33
6001: PPUSH
6002: LD_STRING D4-Sch-1
6004: PPUSH
6005: CALL_OW 94
// Say ( Burlak , D4-Bur-1 ) ;
6009: LD_EXP 27
6013: PPUSH
6014: LD_STRING D4-Bur-1
6016: PPUSH
6017: CALL_OW 88
// DialogueOff ;
6021: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
6025: LD_STRING M4
6027: PPUSH
6028: CALL_OW 337
// ComHold ( Scholtze ) ;
6032: LD_EXP 33
6036: PPUSH
6037: CALL_OW 140
// end ;
6041: END
// every 0 0$1 trigger See ( 3 , Scholtze ) and not scholtzeSaved do
6042: LD_INT 3
6044: PPUSH
6045: LD_EXP 33
6049: PPUSH
6050: CALL_OW 292
6054: PUSH
6055: LD_EXP 6
6059: NOT
6060: AND
6061: IFFALSE 6154
6063: GO 6065
6065: DISABLE
// begin scholtzeSaved = true ;
6066: LD_ADDR_EXP 6
6070: PUSH
6071: LD_INT 1
6073: ST_TO_ADDR
// CenterNowOnUnits ( Scholtze ) ;
6074: LD_EXP 33
6078: PPUSH
6079: CALL_OW 87
// SetSide ( Scholtze , 3 ) ;
6083: LD_EXP 33
6087: PPUSH
6088: LD_INT 3
6090: PPUSH
6091: CALL_OW 235
// DialogueOn ;
6095: CALL_OW 6
// Say ( Scholtze , D4a-Sch-1 ) ;
6099: LD_EXP 33
6103: PPUSH
6104: LD_STRING D4a-Sch-1
6106: PPUSH
6107: CALL_OW 88
// Say ( Burlak , D4a-Bur-1 ) ;
6111: LD_EXP 27
6115: PPUSH
6116: LD_STRING D4a-Bur-1
6118: PPUSH
6119: CALL_OW 88
// Say ( Scholtze , D4a-Sch-2 ) ;
6123: LD_EXP 33
6127: PPUSH
6128: LD_STRING D4a-Sch-2
6130: PPUSH
6131: CALL_OW 88
// DialogueOff ;
6135: CALL_OW 7
// ComMoveXY ( amPatrol , 28 , 36 ) ;
6139: LD_EXP 48
6143: PPUSH
6144: LD_INT 28
6146: PPUSH
6147: LD_INT 36
6149: PPUSH
6150: CALL_OW 111
// end ;
6154: END
// every 3 3$30 trigger IsPlaced ( Scholtze ) and scholtzeSpawnNearAmericans and not scholtzeSaved do
6155: LD_EXP 33
6159: PPUSH
6160: CALL_OW 305
6164: PUSH
6165: LD_EXP 5
6169: AND
6170: PUSH
6171: LD_EXP 6
6175: NOT
6176: AND
6177: IFFALSE 6186
6179: GO 6181
6181: DISABLE
// PrepareAmericanPatrol ;
6182: CALL 3515 0 0
6186: END
// every 0 0$1 trigger See ( 1 , Scholtze ) do
6187: LD_INT 1
6189: PPUSH
6190: LD_EXP 33
6194: PPUSH
6195: CALL_OW 292
6199: IFFALSE 6280
6201: GO 6203
6203: DISABLE
// begin DialogueOn ;
6204: CALL_OW 6
// Say ( Scholtze , D4b-Sch-1 ) ;
6208: LD_EXP 33
6212: PPUSH
6213: LD_STRING D4b-Sch-1
6215: PPUSH
6216: CALL_OW 88
// Say ( amPatrol [ 2 ] , D4b-Sol1-1 ) ;
6220: LD_EXP 48
6224: PUSH
6225: LD_INT 2
6227: ARRAY
6228: PPUSH
6229: LD_STRING D4b-Sol1-1
6231: PPUSH
6232: CALL_OW 88
// Say ( amPatrol [ 1 ] , D4b-Sol2-1 ) ;
6236: LD_EXP 48
6240: PUSH
6241: LD_INT 1
6243: ARRAY
6244: PPUSH
6245: LD_STRING D4b-Sol2-1
6247: PPUSH
6248: CALL_OW 88
// Say ( Scholtze , D4b-Sch-2 ) ;
6252: LD_EXP 33
6256: PPUSH
6257: LD_STRING D4b-Sch-2
6259: PPUSH
6260: CALL_OW 88
// Say ( Burlak , D4b-Bur-2 ) ;
6264: LD_EXP 27
6268: PPUSH
6269: LD_STRING D4b-Bur-2
6271: PPUSH
6272: CALL_OW 88
// DialogueOff ;
6276: CALL_OW 7
// end ;
6280: END
// export function Dial_UpgradeWorkshop ( building ) ; var maleSci , maleOthers ; begin
6281: LD_INT 0
6283: PPUSH
6284: PPUSH
6285: PPUSH
// dialog_workshop = true ;
6286: LD_ADDR_EXP 7
6290: PUSH
6291: LD_INT 1
6293: ST_TO_ADDR
// CenterNowOnUnits ( building ) ;
6294: LD_VAR 0 1
6298: PPUSH
6299: CALL_OW 87
// DialogueOn ;
6303: CALL_OW 6
// Say ( Burlak , D3aa-Bur-1 ) ;
6307: LD_EXP 27
6311: PPUSH
6312: LD_STRING D3aa-Bur-1
6314: PPUSH
6315: CALL_OW 88
// if IsOk ( Scholtze ) and GetSide ( Scholtze ) = 3 then
6319: LD_EXP 33
6323: PPUSH
6324: CALL_OW 302
6328: PUSH
6329: LD_EXP 33
6333: PPUSH
6334: CALL_OW 255
6338: PUSH
6339: LD_INT 3
6341: EQUAL
6342: AND
6343: IFFALSE 6359
// Say ( Scholtze , D3aa-Sch-1 ) else
6345: LD_EXP 33
6349: PPUSH
6350: LD_STRING D3aa-Sch-1
6352: PPUSH
6353: CALL_OW 88
6357: GO 6586
// begin maleSci = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_class , class_scientistic ] , [ f_sex , sex_male ] , [ f_ok ] ] ) diff [ Burlak , Gnyevko , Kovalyuk , Belkov , Belkov2 ] ;
6359: LD_ADDR_VAR 0 3
6363: PUSH
6364: LD_INT 22
6366: PUSH
6367: LD_INT 3
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PUSH
6374: LD_INT 21
6376: PUSH
6377: LD_INT 1
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: PUSH
6384: LD_INT 25
6386: PUSH
6387: LD_INT 4
6389: PUSH
6390: EMPTY
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 26
6396: PUSH
6397: LD_INT 1
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: PUSH
6404: LD_INT 50
6406: PUSH
6407: EMPTY
6408: LIST
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: PPUSH
6417: CALL_OW 69
6421: PUSH
6422: LD_EXP 27
6426: PUSH
6427: LD_EXP 28
6431: PUSH
6432: LD_EXP 30
6436: PUSH
6437: LD_EXP 31
6441: PUSH
6442: LD_EXP 32
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: DIFF
6454: ST_TO_ADDR
// if maleSci then
6455: LD_VAR 0 3
6459: IFFALSE 6479
// Say ( maleSci [ 1 ] , D3aa-Sci1-1 ) else
6461: LD_VAR 0 3
6465: PUSH
6466: LD_INT 1
6468: ARRAY
6469: PPUSH
6470: LD_STRING D3aa-Sci1-1
6472: PPUSH
6473: CALL_OW 88
6477: GO 6586
// begin maleOthers = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] , [ f_ok ] ] ) diff [ Burlak , Gnyevko , Kovalyuk , Belkov , Belkov2 ] ;
6479: LD_ADDR_VAR 0 4
6483: PUSH
6484: LD_INT 22
6486: PUSH
6487: LD_INT 3
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 21
6496: PUSH
6497: LD_INT 1
6499: PUSH
6500: EMPTY
6501: LIST
6502: LIST
6503: PUSH
6504: LD_INT 26
6506: PUSH
6507: LD_INT 1
6509: PUSH
6510: EMPTY
6511: LIST
6512: LIST
6513: PUSH
6514: LD_INT 50
6516: PUSH
6517: EMPTY
6518: LIST
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PPUSH
6526: CALL_OW 69
6530: PUSH
6531: LD_EXP 27
6535: PUSH
6536: LD_EXP 28
6540: PUSH
6541: LD_EXP 30
6545: PUSH
6546: LD_EXP 31
6550: PUSH
6551: LD_EXP 32
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: LIST
6562: DIFF
6563: ST_TO_ADDR
// if maleOthers then
6564: LD_VAR 0 4
6568: IFFALSE 6586
// Say ( maleOthers [ 1 ] , D3aa-Sci1-1 ) end ;
6570: LD_VAR 0 4
6574: PUSH
6575: LD_INT 1
6577: ARRAY
6578: PPUSH
6579: LD_STRING D3aa-Sci1-1
6581: PPUSH
6582: CALL_OW 88
// end ; Say ( Burlak , D3aa-Bur-2 ) ;
6586: LD_EXP 27
6590: PPUSH
6591: LD_STRING D3aa-Bur-2
6593: PPUSH
6594: CALL_OW 88
// DialogueOff ;
6598: CALL_OW 7
// end ;
6602: LD_VAR 0 2
6606: RET
// every 0 0$1 trigger not dialog_amSupportTroops do var amUnit ;
6607: LD_EXP 8
6611: NOT
6612: IFFALSE 6769
6614: GO 6616
6616: DISABLE
6617: LD_INT 0
6619: PPUSH
// begin enable ;
6620: ENABLE
// for amUnit in amSupportTroops do
6621: LD_ADDR_VAR 0 1
6625: PUSH
6626: LD_EXP 47
6630: PUSH
6631: FOR_IN
6632: IFFALSE 6767
// begin if See ( 3 , amUnit ) then
6634: LD_INT 3
6636: PPUSH
6637: LD_VAR 0 1
6641: PPUSH
6642: CALL_OW 292
6646: IFFALSE 6765
// begin dialog_amSupportTroops = true ;
6648: LD_ADDR_EXP 8
6652: PUSH
6653: LD_INT 1
6655: ST_TO_ADDR
// CenterNowOnUnits ( amUnit ) ;
6656: LD_VAR 0 1
6660: PPUSH
6661: CALL_OW 87
// DialogueOn ;
6665: CALL_OW 6
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , D3b-RSol1-1 ,  , false ) ;
6669: LD_INT 22
6671: PUSH
6672: LD_INT 3
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: PUSH
6679: LD_INT 21
6681: PUSH
6682: LD_INT 1
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: PUSH
6689: LD_INT 26
6691: PUSH
6692: LD_INT 1
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: PPUSH
6704: CALL_OW 69
6708: PPUSH
6709: LD_STRING D3b-RSol1-1
6711: PPUSH
6712: LD_STRING 
6714: PPUSH
6715: LD_INT 0
6717: PPUSH
6718: CALL 3736 0 4
// if IsOK ( Gnyevko ) then
6722: LD_EXP 28
6726: PPUSH
6727: CALL_OW 302
6731: IFFALSE 6745
// Say ( Gnyevko , D3b-Gny-1 ) ;
6733: LD_EXP 28
6737: PPUSH
6738: LD_STRING D3b-Gny-1
6740: PPUSH
6741: CALL_OW 88
// Say ( Burlak , D3b-Bur-1 ) ;
6745: LD_EXP 27
6749: PPUSH
6750: LD_STRING D3b-Bur-1
6752: PPUSH
6753: CALL_OW 88
// DialogueOff ;
6757: CALL_OW 7
// exit ;
6761: POP
6762: POP
6763: GO 6769
// end ; end ;
6765: GO 6631
6767: POP
6768: POP
// end ;
6769: PPOPN 1
6771: END
// every 2 2$0 trigger dialog_amSupportTroops do
6772: LD_EXP 8
6776: IFFALSE 6857
6778: GO 6780
6780: DISABLE
// begin if IsOK ( Kovalyuk ) then
6781: LD_EXP 30
6785: PPUSH
6786: CALL_OW 302
6790: IFFALSE 6804
// Say ( Kovalyuk , D3b-Kov-1 ) ;
6792: LD_EXP 30
6796: PPUSH
6797: LD_STRING D3b-Kov-1
6799: PPUSH
6800: CALL_OW 88
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , D3b-RSol1-2 ,  , false ) ;
6804: LD_INT 22
6806: PUSH
6807: LD_INT 3
6809: PUSH
6810: EMPTY
6811: LIST
6812: LIST
6813: PUSH
6814: LD_INT 21
6816: PUSH
6817: LD_INT 1
6819: PUSH
6820: EMPTY
6821: LIST
6822: LIST
6823: PUSH
6824: LD_INT 26
6826: PUSH
6827: LD_INT 1
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: LIST
6838: PPUSH
6839: CALL_OW 69
6843: PPUSH
6844: LD_STRING D3b-RSol1-2
6846: PPUSH
6847: LD_STRING 
6849: PPUSH
6850: LD_INT 0
6852: PPUSH
6853: CALL 3736 0 4
// end ;
6857: END
// every 0 0$1 trigger timeToPrepareAttack < 0 0$01 do
6858: LD_EXP 21
6862: PUSH
6863: LD_INT 35
6865: LESS
6866: IFFALSE 7070
6868: GO 6870
6870: DISABLE
// begin CenterNowOnUnits ( Kurin ) ;
6871: LD_EXP 39
6875: PPUSH
6876: CALL_OW 87
// InGameOn ;
6880: CALL_OW 8
// DialogueOn ;
6884: CALL_OW 6
// SayRadio ( Kurin , D5-Kur-1 ) ;
6888: LD_EXP 39
6892: PPUSH
6893: LD_STRING D5-Kur-1
6895: PPUSH
6896: CALL_OW 94
// case Query ( QVehicles ) of 1 :
6900: LD_STRING QVehicles
6902: PPUSH
6903: CALL_OW 97
6907: PUSH
6908: LD_INT 1
6910: DOUBLE
6911: EQUAL
6912: IFTRUE 6916
6914: GO 6951
6916: POP
// begin Say ( Burlak , D6a-Bur-1 ) ;
6917: LD_EXP 27
6921: PPUSH
6922: LD_STRING D6a-Bur-1
6924: PPUSH
6925: CALL_OW 88
// SayRadio ( Kurin , D6a-Kur-1 ) ;
6929: LD_EXP 39
6933: PPUSH
6934: LD_STRING D6a-Kur-1
6936: PPUSH
6937: CALL_OW 94
// meetNearOmicronBase = true ;
6941: LD_ADDR_EXP 11
6945: PUSH
6946: LD_INT 1
6948: ST_TO_ADDR
// end ; 2 :
6949: GO 7062
6951: LD_INT 2
6953: DOUBLE
6954: EQUAL
6955: IFTRUE 6959
6957: GO 7006
6959: POP
// begin Say ( Burlak , D6b-Bur-1 ) ;
6960: LD_EXP 27
6964: PPUSH
6965: LD_STRING D6b-Bur-1
6967: PPUSH
6968: CALL_OW 88
// Say ( Kurin , D6b-Kur-1 ) ;
6972: LD_EXP 39
6976: PPUSH
6977: LD_STRING D6b-Kur-1
6979: PPUSH
6980: CALL_OW 88
// Say ( Burlak , D6b-Bur-2 ) ;
6984: LD_EXP 27
6988: PPUSH
6989: LD_STRING D6b-Bur-2
6991: PPUSH
6992: CALL_OW 88
// meetNearOmicronBase = true ;
6996: LD_ADDR_EXP 11
7000: PUSH
7001: LD_INT 1
7003: ST_TO_ADDR
// end ; 3 :
7004: GO 7062
7006: LD_INT 3
7008: DOUBLE
7009: EQUAL
7010: IFTRUE 7014
7012: GO 7061
7014: POP
// begin Say ( Burlak , D6c-Bur-1 ) ;
7015: LD_EXP 27
7019: PPUSH
7020: LD_STRING D6c-Bur-1
7022: PPUSH
7023: CALL_OW 88
// Say ( Kurin , D6c-Kur-1 ) ;
7027: LD_EXP 39
7031: PPUSH
7032: LD_STRING D6c-Kur-1
7034: PPUSH
7035: CALL_OW 88
// Say ( Burlak , D6c-Bur-2 ) ;
7039: LD_EXP 27
7043: PPUSH
7044: LD_STRING D6c-Bur-2
7046: PPUSH
7047: CALL_OW 88
// kurinGiveMoreTime = true ;
7051: LD_ADDR_EXP 9
7055: PUSH
7056: LD_INT 1
7058: ST_TO_ADDR
// end ; end ;
7059: GO 7062
7061: POP
// InGameOff ;
7062: CALL_OW 9
// DialogueOff ;
7066: CALL_OW 7
// end ;
7070: END
// every 0 0$1 trigger extraTime < 0 0$01 and kurinGiveMoreTime do
7071: LD_EXP 10
7075: PUSH
7076: LD_INT 35
7078: LESS
7079: PUSH
7080: LD_EXP 9
7084: AND
7085: IFFALSE 7118
7087: GO 7089
7089: DISABLE
// begin DialogueOn ;
7090: CALL_OW 6
// SayRadio ( Kurin , D6c-Kur-2 ) ;
7094: LD_EXP 39
7098: PPUSH
7099: LD_STRING D6c-Kur-2
7101: PPUSH
7102: CALL_OW 94
// DialogueOff ;
7106: CALL_OW 7
// meetNearOmicronBase = true ;
7110: LD_ADDR_EXP 11
7114: PUSH
7115: LD_INT 1
7117: ST_TO_ADDR
// end ;
7118: END
// every 0 0$1 trigger meetNearOmicronBase do
7119: LD_EXP 11
7123: IFFALSE 7135
7125: GO 7127
7127: DISABLE
// begin ChangeMissionObjectives ( M5 ) ;
7128: LD_STRING M5
7130: PPUSH
7131: CALL_OW 337
// end ; end_of_file
7135: END
// every 0 0$30 do
7136: GO 7138
7138: DISABLE
// CreateCratesXYR ( rand ( 3 , 5 ) , 76 , 111 , 5 , true ) ;
7139: LD_INT 3
7141: PPUSH
7142: LD_INT 5
7144: PPUSH
7145: CALL_OW 12
7149: PPUSH
7150: LD_INT 76
7152: PPUSH
7153: LD_INT 111
7155: PPUSH
7156: LD_INT 5
7158: PPUSH
7159: LD_INT 1
7161: PPUSH
7162: CALL_OW 56
7166: END
// every 0 0$10 trigger spawnCrates do var spawnDelay ;
7167: LD_EXP 4
7171: IFFALSE 7243
7173: GO 7175
7175: DISABLE
7176: LD_INT 0
7178: PPUSH
// begin wait ( Rand ( 50 , 2 2$00 ) ) ;
7179: LD_INT 50
7181: PPUSH
7182: LD_INT 4200
7184: PPUSH
7185: CALL_OW 12
7189: PPUSH
7190: CALL_OW 67
// wait ( spawnDelay * 0 0$5 ) ;
7194: LD_VAR 0 1
7198: PUSH
7199: LD_INT 175
7201: MUL
7202: PPUSH
7203: CALL_OW 67
// spawnDelay = spawnDelay + 1 ;
7207: LD_ADDR_VAR 0 1
7211: PUSH
7212: LD_VAR 0 1
7216: PUSH
7217: LD_INT 1
7219: PLUS
7220: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
7221: LD_INT 3
7223: PPUSH
7224: LD_INT 5
7226: PPUSH
7227: CALL_OW 12
7231: PPUSH
7232: LD_INT 6
7234: PPUSH
7235: LD_INT 1
7237: PPUSH
7238: CALL_OW 55
// enable ;
7242: ENABLE
// end ; end_of_file
7243: PPOPN 1
7245: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
7246: LD_INT 0
7248: PPUSH
7249: PPUSH
// skirmish := false ;
7250: LD_ADDR_EXP 50
7254: PUSH
7255: LD_INT 0
7257: ST_TO_ADDR
// debug_mc := false ;
7258: LD_ADDR_EXP 51
7262: PUSH
7263: LD_INT 0
7265: ST_TO_ADDR
// mc_bases := [ ] ;
7266: LD_ADDR_EXP 52
7270: PUSH
7271: EMPTY
7272: ST_TO_ADDR
// mc_sides := [ ] ;
7273: LD_ADDR_EXP 78
7277: PUSH
7278: EMPTY
7279: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
7280: LD_ADDR_EXP 53
7284: PUSH
7285: EMPTY
7286: ST_TO_ADDR
// mc_building_repairs := [ ] ;
7287: LD_ADDR_EXP 54
7291: PUSH
7292: EMPTY
7293: ST_TO_ADDR
// mc_need_heal := [ ] ;
7294: LD_ADDR_EXP 55
7298: PUSH
7299: EMPTY
7300: ST_TO_ADDR
// mc_healers := [ ] ;
7301: LD_ADDR_EXP 56
7305: PUSH
7306: EMPTY
7307: ST_TO_ADDR
// mc_build_list := [ ] ;
7308: LD_ADDR_EXP 57
7312: PUSH
7313: EMPTY
7314: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
7315: LD_ADDR_EXP 84
7319: PUSH
7320: EMPTY
7321: ST_TO_ADDR
// mc_builders := [ ] ;
7322: LD_ADDR_EXP 58
7326: PUSH
7327: EMPTY
7328: ST_TO_ADDR
// mc_construct_list := [ ] ;
7329: LD_ADDR_EXP 59
7333: PUSH
7334: EMPTY
7335: ST_TO_ADDR
// mc_turret_list := [ ] ;
7336: LD_ADDR_EXP 60
7340: PUSH
7341: EMPTY
7342: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
7343: LD_ADDR_EXP 61
7347: PUSH
7348: EMPTY
7349: ST_TO_ADDR
// mc_miners := [ ] ;
7350: LD_ADDR_EXP 66
7354: PUSH
7355: EMPTY
7356: ST_TO_ADDR
// mc_mines := [ ] ;
7357: LD_ADDR_EXP 65
7361: PUSH
7362: EMPTY
7363: ST_TO_ADDR
// mc_minefields := [ ] ;
7364: LD_ADDR_EXP 67
7368: PUSH
7369: EMPTY
7370: ST_TO_ADDR
// mc_crates := [ ] ;
7371: LD_ADDR_EXP 68
7375: PUSH
7376: EMPTY
7377: ST_TO_ADDR
// mc_crates_collector := [ ] ;
7378: LD_ADDR_EXP 69
7382: PUSH
7383: EMPTY
7384: ST_TO_ADDR
// mc_crates_area := [ ] ;
7385: LD_ADDR_EXP 70
7389: PUSH
7390: EMPTY
7391: ST_TO_ADDR
// mc_vehicles := [ ] ;
7392: LD_ADDR_EXP 71
7396: PUSH
7397: EMPTY
7398: ST_TO_ADDR
// mc_attack := [ ] ;
7399: LD_ADDR_EXP 72
7403: PUSH
7404: EMPTY
7405: ST_TO_ADDR
// mc_produce := [ ] ;
7406: LD_ADDR_EXP 73
7410: PUSH
7411: EMPTY
7412: ST_TO_ADDR
// mc_defender := [ ] ;
7413: LD_ADDR_EXP 74
7417: PUSH
7418: EMPTY
7419: ST_TO_ADDR
// mc_parking := [ ] ;
7420: LD_ADDR_EXP 76
7424: PUSH
7425: EMPTY
7426: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
7427: LD_ADDR_EXP 62
7431: PUSH
7432: EMPTY
7433: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
7434: LD_ADDR_EXP 64
7438: PUSH
7439: EMPTY
7440: ST_TO_ADDR
// mc_scan := [ ] ;
7441: LD_ADDR_EXP 75
7445: PUSH
7446: EMPTY
7447: ST_TO_ADDR
// mc_scan_area := [ ] ;
7448: LD_ADDR_EXP 77
7452: PUSH
7453: EMPTY
7454: ST_TO_ADDR
// mc_tech := [ ] ;
7455: LD_ADDR_EXP 79
7459: PUSH
7460: EMPTY
7461: ST_TO_ADDR
// mc_class := [ ] ;
7462: LD_ADDR_EXP 93
7466: PUSH
7467: EMPTY
7468: ST_TO_ADDR
// mc_class_case_use := [ ] ;
7469: LD_ADDR_EXP 94
7473: PUSH
7474: EMPTY
7475: ST_TO_ADDR
// end ;
7476: LD_VAR 0 1
7480: RET
// export function MC_Kill ( base ) ; begin
7481: LD_INT 0
7483: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
7484: LD_ADDR_EXP 52
7488: PUSH
7489: LD_EXP 52
7493: PPUSH
7494: LD_VAR 0 1
7498: PPUSH
7499: EMPTY
7500: PPUSH
7501: CALL_OW 1
7505: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
7506: LD_ADDR_EXP 53
7510: PUSH
7511: LD_EXP 53
7515: PPUSH
7516: LD_VAR 0 1
7520: PPUSH
7521: EMPTY
7522: PPUSH
7523: CALL_OW 1
7527: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
7528: LD_ADDR_EXP 54
7532: PUSH
7533: LD_EXP 54
7537: PPUSH
7538: LD_VAR 0 1
7542: PPUSH
7543: EMPTY
7544: PPUSH
7545: CALL_OW 1
7549: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
7550: LD_ADDR_EXP 55
7554: PUSH
7555: LD_EXP 55
7559: PPUSH
7560: LD_VAR 0 1
7564: PPUSH
7565: EMPTY
7566: PPUSH
7567: CALL_OW 1
7571: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
7572: LD_ADDR_EXP 56
7576: PUSH
7577: LD_EXP 56
7581: PPUSH
7582: LD_VAR 0 1
7586: PPUSH
7587: EMPTY
7588: PPUSH
7589: CALL_OW 1
7593: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
7594: LD_ADDR_EXP 57
7598: PUSH
7599: LD_EXP 57
7603: PPUSH
7604: LD_VAR 0 1
7608: PPUSH
7609: EMPTY
7610: PPUSH
7611: CALL_OW 1
7615: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
7616: LD_ADDR_EXP 58
7620: PUSH
7621: LD_EXP 58
7625: PPUSH
7626: LD_VAR 0 1
7630: PPUSH
7631: EMPTY
7632: PPUSH
7633: CALL_OW 1
7637: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
7638: LD_ADDR_EXP 59
7642: PUSH
7643: LD_EXP 59
7647: PPUSH
7648: LD_VAR 0 1
7652: PPUSH
7653: EMPTY
7654: PPUSH
7655: CALL_OW 1
7659: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
7660: LD_ADDR_EXP 60
7664: PUSH
7665: LD_EXP 60
7669: PPUSH
7670: LD_VAR 0 1
7674: PPUSH
7675: EMPTY
7676: PPUSH
7677: CALL_OW 1
7681: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
7682: LD_ADDR_EXP 61
7686: PUSH
7687: LD_EXP 61
7691: PPUSH
7692: LD_VAR 0 1
7696: PPUSH
7697: EMPTY
7698: PPUSH
7699: CALL_OW 1
7703: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
7704: LD_ADDR_EXP 62
7708: PUSH
7709: LD_EXP 62
7713: PPUSH
7714: LD_VAR 0 1
7718: PPUSH
7719: EMPTY
7720: PPUSH
7721: CALL_OW 1
7725: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
7726: LD_ADDR_EXP 63
7730: PUSH
7731: LD_EXP 63
7735: PPUSH
7736: LD_VAR 0 1
7740: PPUSH
7741: LD_INT 0
7743: PPUSH
7744: CALL_OW 1
7748: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
7749: LD_ADDR_EXP 64
7753: PUSH
7754: LD_EXP 64
7758: PPUSH
7759: LD_VAR 0 1
7763: PPUSH
7764: EMPTY
7765: PPUSH
7766: CALL_OW 1
7770: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
7771: LD_ADDR_EXP 65
7775: PUSH
7776: LD_EXP 65
7780: PPUSH
7781: LD_VAR 0 1
7785: PPUSH
7786: EMPTY
7787: PPUSH
7788: CALL_OW 1
7792: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
7793: LD_ADDR_EXP 66
7797: PUSH
7798: LD_EXP 66
7802: PPUSH
7803: LD_VAR 0 1
7807: PPUSH
7808: EMPTY
7809: PPUSH
7810: CALL_OW 1
7814: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
7815: LD_ADDR_EXP 67
7819: PUSH
7820: LD_EXP 67
7824: PPUSH
7825: LD_VAR 0 1
7829: PPUSH
7830: EMPTY
7831: PPUSH
7832: CALL_OW 1
7836: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
7837: LD_ADDR_EXP 68
7841: PUSH
7842: LD_EXP 68
7846: PPUSH
7847: LD_VAR 0 1
7851: PPUSH
7852: EMPTY
7853: PPUSH
7854: CALL_OW 1
7858: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
7859: LD_ADDR_EXP 69
7863: PUSH
7864: LD_EXP 69
7868: PPUSH
7869: LD_VAR 0 1
7873: PPUSH
7874: EMPTY
7875: PPUSH
7876: CALL_OW 1
7880: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
7881: LD_ADDR_EXP 70
7885: PUSH
7886: LD_EXP 70
7890: PPUSH
7891: LD_VAR 0 1
7895: PPUSH
7896: EMPTY
7897: PPUSH
7898: CALL_OW 1
7902: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
7903: LD_ADDR_EXP 71
7907: PUSH
7908: LD_EXP 71
7912: PPUSH
7913: LD_VAR 0 1
7917: PPUSH
7918: EMPTY
7919: PPUSH
7920: CALL_OW 1
7924: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
7925: LD_ADDR_EXP 72
7929: PUSH
7930: LD_EXP 72
7934: PPUSH
7935: LD_VAR 0 1
7939: PPUSH
7940: EMPTY
7941: PPUSH
7942: CALL_OW 1
7946: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
7947: LD_ADDR_EXP 73
7951: PUSH
7952: LD_EXP 73
7956: PPUSH
7957: LD_VAR 0 1
7961: PPUSH
7962: EMPTY
7963: PPUSH
7964: CALL_OW 1
7968: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
7969: LD_ADDR_EXP 74
7973: PUSH
7974: LD_EXP 74
7978: PPUSH
7979: LD_VAR 0 1
7983: PPUSH
7984: EMPTY
7985: PPUSH
7986: CALL_OW 1
7990: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
7991: LD_ADDR_EXP 75
7995: PUSH
7996: LD_EXP 75
8000: PPUSH
8001: LD_VAR 0 1
8005: PPUSH
8006: EMPTY
8007: PPUSH
8008: CALL_OW 1
8012: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
8013: LD_ADDR_EXP 76
8017: PUSH
8018: LD_EXP 76
8022: PPUSH
8023: LD_VAR 0 1
8027: PPUSH
8028: EMPTY
8029: PPUSH
8030: CALL_OW 1
8034: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
8035: LD_ADDR_EXP 77
8039: PUSH
8040: LD_EXP 77
8044: PPUSH
8045: LD_VAR 0 1
8049: PPUSH
8050: EMPTY
8051: PPUSH
8052: CALL_OW 1
8056: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
8057: LD_ADDR_EXP 79
8061: PUSH
8062: LD_EXP 79
8066: PPUSH
8067: LD_VAR 0 1
8071: PPUSH
8072: EMPTY
8073: PPUSH
8074: CALL_OW 1
8078: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
8079: LD_ADDR_EXP 81
8083: PUSH
8084: LD_EXP 81
8088: PPUSH
8089: LD_VAR 0 1
8093: PPUSH
8094: EMPTY
8095: PPUSH
8096: CALL_OW 1
8100: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
8101: LD_ADDR_EXP 82
8105: PUSH
8106: LD_EXP 82
8110: PPUSH
8111: LD_VAR 0 1
8115: PPUSH
8116: EMPTY
8117: PPUSH
8118: CALL_OW 1
8122: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
8123: LD_ADDR_EXP 83
8127: PUSH
8128: LD_EXP 83
8132: PPUSH
8133: LD_VAR 0 1
8137: PPUSH
8138: EMPTY
8139: PPUSH
8140: CALL_OW 1
8144: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
8145: LD_ADDR_EXP 84
8149: PUSH
8150: LD_EXP 84
8154: PPUSH
8155: LD_VAR 0 1
8159: PPUSH
8160: EMPTY
8161: PPUSH
8162: CALL_OW 1
8166: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
8167: LD_ADDR_EXP 85
8171: PUSH
8172: LD_EXP 85
8176: PPUSH
8177: LD_VAR 0 1
8181: PPUSH
8182: EMPTY
8183: PPUSH
8184: CALL_OW 1
8188: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
8189: LD_ADDR_EXP 86
8193: PUSH
8194: LD_EXP 86
8198: PPUSH
8199: LD_VAR 0 1
8203: PPUSH
8204: EMPTY
8205: PPUSH
8206: CALL_OW 1
8210: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
8211: LD_ADDR_EXP 87
8215: PUSH
8216: LD_EXP 87
8220: PPUSH
8221: LD_VAR 0 1
8225: PPUSH
8226: EMPTY
8227: PPUSH
8228: CALL_OW 1
8232: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
8233: LD_ADDR_EXP 88
8237: PUSH
8238: LD_EXP 88
8242: PPUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: EMPTY
8249: PPUSH
8250: CALL_OW 1
8254: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
8255: LD_ADDR_EXP 89
8259: PUSH
8260: LD_EXP 89
8264: PPUSH
8265: LD_VAR 0 1
8269: PPUSH
8270: EMPTY
8271: PPUSH
8272: CALL_OW 1
8276: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
8277: LD_ADDR_EXP 90
8281: PUSH
8282: LD_EXP 90
8286: PPUSH
8287: LD_VAR 0 1
8291: PPUSH
8292: EMPTY
8293: PPUSH
8294: CALL_OW 1
8298: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
8299: LD_ADDR_EXP 91
8303: PUSH
8304: LD_EXP 91
8308: PPUSH
8309: LD_VAR 0 1
8313: PPUSH
8314: EMPTY
8315: PPUSH
8316: CALL_OW 1
8320: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
8321: LD_ADDR_EXP 92
8325: PUSH
8326: LD_EXP 92
8330: PPUSH
8331: LD_VAR 0 1
8335: PPUSH
8336: EMPTY
8337: PPUSH
8338: CALL_OW 1
8342: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
8343: LD_ADDR_EXP 93
8347: PUSH
8348: LD_EXP 93
8352: PPUSH
8353: LD_VAR 0 1
8357: PPUSH
8358: EMPTY
8359: PPUSH
8360: CALL_OW 1
8364: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
8365: LD_ADDR_EXP 94
8369: PUSH
8370: LD_EXP 94
8374: PPUSH
8375: LD_VAR 0 1
8379: PPUSH
8380: LD_INT 0
8382: PPUSH
8383: CALL_OW 1
8387: ST_TO_ADDR
// end ;
8388: LD_VAR 0 2
8392: RET
// export function MC_Add ( side , units ) ; var base ; begin
8393: LD_INT 0
8395: PPUSH
8396: PPUSH
// base := mc_bases + 1 ;
8397: LD_ADDR_VAR 0 4
8401: PUSH
8402: LD_EXP 52
8406: PUSH
8407: LD_INT 1
8409: PLUS
8410: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
8411: LD_ADDR_EXP 78
8415: PUSH
8416: LD_EXP 78
8420: PPUSH
8421: LD_VAR 0 4
8425: PPUSH
8426: LD_VAR 0 1
8430: PPUSH
8431: CALL_OW 1
8435: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
8436: LD_ADDR_EXP 52
8440: PUSH
8441: LD_EXP 52
8445: PPUSH
8446: LD_VAR 0 4
8450: PPUSH
8451: LD_VAR 0 2
8455: PPUSH
8456: CALL_OW 1
8460: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
8461: LD_ADDR_EXP 53
8465: PUSH
8466: LD_EXP 53
8470: PPUSH
8471: LD_VAR 0 4
8475: PPUSH
8476: EMPTY
8477: PPUSH
8478: CALL_OW 1
8482: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
8483: LD_ADDR_EXP 54
8487: PUSH
8488: LD_EXP 54
8492: PPUSH
8493: LD_VAR 0 4
8497: PPUSH
8498: EMPTY
8499: PPUSH
8500: CALL_OW 1
8504: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
8505: LD_ADDR_EXP 55
8509: PUSH
8510: LD_EXP 55
8514: PPUSH
8515: LD_VAR 0 4
8519: PPUSH
8520: EMPTY
8521: PPUSH
8522: CALL_OW 1
8526: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
8527: LD_ADDR_EXP 56
8531: PUSH
8532: LD_EXP 56
8536: PPUSH
8537: LD_VAR 0 4
8541: PPUSH
8542: EMPTY
8543: PPUSH
8544: CALL_OW 1
8548: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
8549: LD_ADDR_EXP 57
8553: PUSH
8554: LD_EXP 57
8558: PPUSH
8559: LD_VAR 0 4
8563: PPUSH
8564: EMPTY
8565: PPUSH
8566: CALL_OW 1
8570: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
8571: LD_ADDR_EXP 58
8575: PUSH
8576: LD_EXP 58
8580: PPUSH
8581: LD_VAR 0 4
8585: PPUSH
8586: EMPTY
8587: PPUSH
8588: CALL_OW 1
8592: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
8593: LD_ADDR_EXP 59
8597: PUSH
8598: LD_EXP 59
8602: PPUSH
8603: LD_VAR 0 4
8607: PPUSH
8608: EMPTY
8609: PPUSH
8610: CALL_OW 1
8614: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
8615: LD_ADDR_EXP 60
8619: PUSH
8620: LD_EXP 60
8624: PPUSH
8625: LD_VAR 0 4
8629: PPUSH
8630: EMPTY
8631: PPUSH
8632: CALL_OW 1
8636: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
8637: LD_ADDR_EXP 61
8641: PUSH
8642: LD_EXP 61
8646: PPUSH
8647: LD_VAR 0 4
8651: PPUSH
8652: EMPTY
8653: PPUSH
8654: CALL_OW 1
8658: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
8659: LD_ADDR_EXP 62
8663: PUSH
8664: LD_EXP 62
8668: PPUSH
8669: LD_VAR 0 4
8673: PPUSH
8674: EMPTY
8675: PPUSH
8676: CALL_OW 1
8680: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
8681: LD_ADDR_EXP 63
8685: PUSH
8686: LD_EXP 63
8690: PPUSH
8691: LD_VAR 0 4
8695: PPUSH
8696: LD_INT 0
8698: PPUSH
8699: CALL_OW 1
8703: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
8704: LD_ADDR_EXP 64
8708: PUSH
8709: LD_EXP 64
8713: PPUSH
8714: LD_VAR 0 4
8718: PPUSH
8719: EMPTY
8720: PPUSH
8721: CALL_OW 1
8725: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
8726: LD_ADDR_EXP 65
8730: PUSH
8731: LD_EXP 65
8735: PPUSH
8736: LD_VAR 0 4
8740: PPUSH
8741: EMPTY
8742: PPUSH
8743: CALL_OW 1
8747: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
8748: LD_ADDR_EXP 66
8752: PUSH
8753: LD_EXP 66
8757: PPUSH
8758: LD_VAR 0 4
8762: PPUSH
8763: EMPTY
8764: PPUSH
8765: CALL_OW 1
8769: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
8770: LD_ADDR_EXP 67
8774: PUSH
8775: LD_EXP 67
8779: PPUSH
8780: LD_VAR 0 4
8784: PPUSH
8785: EMPTY
8786: PPUSH
8787: CALL_OW 1
8791: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
8792: LD_ADDR_EXP 68
8796: PUSH
8797: LD_EXP 68
8801: PPUSH
8802: LD_VAR 0 4
8806: PPUSH
8807: EMPTY
8808: PPUSH
8809: CALL_OW 1
8813: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
8814: LD_ADDR_EXP 69
8818: PUSH
8819: LD_EXP 69
8823: PPUSH
8824: LD_VAR 0 4
8828: PPUSH
8829: EMPTY
8830: PPUSH
8831: CALL_OW 1
8835: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
8836: LD_ADDR_EXP 70
8840: PUSH
8841: LD_EXP 70
8845: PPUSH
8846: LD_VAR 0 4
8850: PPUSH
8851: EMPTY
8852: PPUSH
8853: CALL_OW 1
8857: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
8858: LD_ADDR_EXP 71
8862: PUSH
8863: LD_EXP 71
8867: PPUSH
8868: LD_VAR 0 4
8872: PPUSH
8873: EMPTY
8874: PPUSH
8875: CALL_OW 1
8879: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
8880: LD_ADDR_EXP 72
8884: PUSH
8885: LD_EXP 72
8889: PPUSH
8890: LD_VAR 0 4
8894: PPUSH
8895: EMPTY
8896: PPUSH
8897: CALL_OW 1
8901: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
8902: LD_ADDR_EXP 73
8906: PUSH
8907: LD_EXP 73
8911: PPUSH
8912: LD_VAR 0 4
8916: PPUSH
8917: EMPTY
8918: PPUSH
8919: CALL_OW 1
8923: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
8924: LD_ADDR_EXP 74
8928: PUSH
8929: LD_EXP 74
8933: PPUSH
8934: LD_VAR 0 4
8938: PPUSH
8939: EMPTY
8940: PPUSH
8941: CALL_OW 1
8945: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
8946: LD_ADDR_EXP 75
8950: PUSH
8951: LD_EXP 75
8955: PPUSH
8956: LD_VAR 0 4
8960: PPUSH
8961: EMPTY
8962: PPUSH
8963: CALL_OW 1
8967: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
8968: LD_ADDR_EXP 76
8972: PUSH
8973: LD_EXP 76
8977: PPUSH
8978: LD_VAR 0 4
8982: PPUSH
8983: EMPTY
8984: PPUSH
8985: CALL_OW 1
8989: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
8990: LD_ADDR_EXP 77
8994: PUSH
8995: LD_EXP 77
8999: PPUSH
9000: LD_VAR 0 4
9004: PPUSH
9005: EMPTY
9006: PPUSH
9007: CALL_OW 1
9011: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
9012: LD_ADDR_EXP 79
9016: PUSH
9017: LD_EXP 79
9021: PPUSH
9022: LD_VAR 0 4
9026: PPUSH
9027: EMPTY
9028: PPUSH
9029: CALL_OW 1
9033: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
9034: LD_ADDR_EXP 81
9038: PUSH
9039: LD_EXP 81
9043: PPUSH
9044: LD_VAR 0 4
9048: PPUSH
9049: EMPTY
9050: PPUSH
9051: CALL_OW 1
9055: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
9056: LD_ADDR_EXP 82
9060: PUSH
9061: LD_EXP 82
9065: PPUSH
9066: LD_VAR 0 4
9070: PPUSH
9071: EMPTY
9072: PPUSH
9073: CALL_OW 1
9077: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
9078: LD_ADDR_EXP 83
9082: PUSH
9083: LD_EXP 83
9087: PPUSH
9088: LD_VAR 0 4
9092: PPUSH
9093: EMPTY
9094: PPUSH
9095: CALL_OW 1
9099: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
9100: LD_ADDR_EXP 84
9104: PUSH
9105: LD_EXP 84
9109: PPUSH
9110: LD_VAR 0 4
9114: PPUSH
9115: EMPTY
9116: PPUSH
9117: CALL_OW 1
9121: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
9122: LD_ADDR_EXP 85
9126: PUSH
9127: LD_EXP 85
9131: PPUSH
9132: LD_VAR 0 4
9136: PPUSH
9137: EMPTY
9138: PPUSH
9139: CALL_OW 1
9143: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
9144: LD_ADDR_EXP 86
9148: PUSH
9149: LD_EXP 86
9153: PPUSH
9154: LD_VAR 0 4
9158: PPUSH
9159: EMPTY
9160: PPUSH
9161: CALL_OW 1
9165: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
9166: LD_ADDR_EXP 87
9170: PUSH
9171: LD_EXP 87
9175: PPUSH
9176: LD_VAR 0 4
9180: PPUSH
9181: EMPTY
9182: PPUSH
9183: CALL_OW 1
9187: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
9188: LD_ADDR_EXP 88
9192: PUSH
9193: LD_EXP 88
9197: PPUSH
9198: LD_VAR 0 4
9202: PPUSH
9203: EMPTY
9204: PPUSH
9205: CALL_OW 1
9209: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
9210: LD_ADDR_EXP 89
9214: PUSH
9215: LD_EXP 89
9219: PPUSH
9220: LD_VAR 0 4
9224: PPUSH
9225: EMPTY
9226: PPUSH
9227: CALL_OW 1
9231: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
9232: LD_ADDR_EXP 90
9236: PUSH
9237: LD_EXP 90
9241: PPUSH
9242: LD_VAR 0 4
9246: PPUSH
9247: EMPTY
9248: PPUSH
9249: CALL_OW 1
9253: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
9254: LD_ADDR_EXP 91
9258: PUSH
9259: LD_EXP 91
9263: PPUSH
9264: LD_VAR 0 4
9268: PPUSH
9269: EMPTY
9270: PPUSH
9271: CALL_OW 1
9275: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
9276: LD_ADDR_EXP 92
9280: PUSH
9281: LD_EXP 92
9285: PPUSH
9286: LD_VAR 0 4
9290: PPUSH
9291: EMPTY
9292: PPUSH
9293: CALL_OW 1
9297: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
9298: LD_ADDR_EXP 93
9302: PUSH
9303: LD_EXP 93
9307: PPUSH
9308: LD_VAR 0 4
9312: PPUSH
9313: EMPTY
9314: PPUSH
9315: CALL_OW 1
9319: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
9320: LD_ADDR_EXP 94
9324: PUSH
9325: LD_EXP 94
9329: PPUSH
9330: LD_VAR 0 4
9334: PPUSH
9335: LD_INT 0
9337: PPUSH
9338: CALL_OW 1
9342: ST_TO_ADDR
// result := base ;
9343: LD_ADDR_VAR 0 3
9347: PUSH
9348: LD_VAR 0 4
9352: ST_TO_ADDR
// end ;
9353: LD_VAR 0 3
9357: RET
// export function MC_Start ( ) ; var i ; begin
9358: LD_INT 0
9360: PPUSH
9361: PPUSH
// for i = 1 to mc_bases do
9362: LD_ADDR_VAR 0 2
9366: PUSH
9367: DOUBLE
9368: LD_INT 1
9370: DEC
9371: ST_TO_ADDR
9372: LD_EXP 52
9376: PUSH
9377: FOR_TO
9378: IFFALSE 10455
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
9380: LD_ADDR_EXP 52
9384: PUSH
9385: LD_EXP 52
9389: PPUSH
9390: LD_VAR 0 2
9394: PPUSH
9395: LD_EXP 52
9399: PUSH
9400: LD_VAR 0 2
9404: ARRAY
9405: PUSH
9406: LD_INT 0
9408: DIFF
9409: PPUSH
9410: CALL_OW 1
9414: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
9415: LD_ADDR_EXP 53
9419: PUSH
9420: LD_EXP 53
9424: PPUSH
9425: LD_VAR 0 2
9429: PPUSH
9430: EMPTY
9431: PPUSH
9432: CALL_OW 1
9436: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
9437: LD_ADDR_EXP 54
9441: PUSH
9442: LD_EXP 54
9446: PPUSH
9447: LD_VAR 0 2
9451: PPUSH
9452: EMPTY
9453: PPUSH
9454: CALL_OW 1
9458: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
9459: LD_ADDR_EXP 55
9463: PUSH
9464: LD_EXP 55
9468: PPUSH
9469: LD_VAR 0 2
9473: PPUSH
9474: EMPTY
9475: PPUSH
9476: CALL_OW 1
9480: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
9481: LD_ADDR_EXP 56
9485: PUSH
9486: LD_EXP 56
9490: PPUSH
9491: LD_VAR 0 2
9495: PPUSH
9496: EMPTY
9497: PUSH
9498: EMPTY
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: PPUSH
9504: CALL_OW 1
9508: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
9509: LD_ADDR_EXP 57
9513: PUSH
9514: LD_EXP 57
9518: PPUSH
9519: LD_VAR 0 2
9523: PPUSH
9524: EMPTY
9525: PPUSH
9526: CALL_OW 1
9530: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
9531: LD_ADDR_EXP 84
9535: PUSH
9536: LD_EXP 84
9540: PPUSH
9541: LD_VAR 0 2
9545: PPUSH
9546: EMPTY
9547: PPUSH
9548: CALL_OW 1
9552: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
9553: LD_ADDR_EXP 58
9557: PUSH
9558: LD_EXP 58
9562: PPUSH
9563: LD_VAR 0 2
9567: PPUSH
9568: EMPTY
9569: PPUSH
9570: CALL_OW 1
9574: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
9575: LD_ADDR_EXP 59
9579: PUSH
9580: LD_EXP 59
9584: PPUSH
9585: LD_VAR 0 2
9589: PPUSH
9590: EMPTY
9591: PPUSH
9592: CALL_OW 1
9596: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
9597: LD_ADDR_EXP 60
9601: PUSH
9602: LD_EXP 60
9606: PPUSH
9607: LD_VAR 0 2
9611: PPUSH
9612: LD_EXP 52
9616: PUSH
9617: LD_VAR 0 2
9621: ARRAY
9622: PPUSH
9623: LD_INT 2
9625: PUSH
9626: LD_INT 30
9628: PUSH
9629: LD_INT 32
9631: PUSH
9632: EMPTY
9633: LIST
9634: LIST
9635: PUSH
9636: LD_INT 30
9638: PUSH
9639: LD_INT 33
9641: PUSH
9642: EMPTY
9643: LIST
9644: LIST
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: LIST
9650: PPUSH
9651: CALL_OW 72
9655: PPUSH
9656: CALL_OW 1
9660: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
9661: LD_ADDR_EXP 61
9665: PUSH
9666: LD_EXP 61
9670: PPUSH
9671: LD_VAR 0 2
9675: PPUSH
9676: LD_EXP 52
9680: PUSH
9681: LD_VAR 0 2
9685: ARRAY
9686: PPUSH
9687: LD_INT 2
9689: PUSH
9690: LD_INT 30
9692: PUSH
9693: LD_INT 32
9695: PUSH
9696: EMPTY
9697: LIST
9698: LIST
9699: PUSH
9700: LD_INT 30
9702: PUSH
9703: LD_INT 31
9705: PUSH
9706: EMPTY
9707: LIST
9708: LIST
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: LIST
9714: PUSH
9715: LD_INT 58
9717: PUSH
9718: EMPTY
9719: LIST
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 72
9729: PPUSH
9730: CALL_OW 1
9734: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
9735: LD_ADDR_EXP 62
9739: PUSH
9740: LD_EXP 62
9744: PPUSH
9745: LD_VAR 0 2
9749: PPUSH
9750: EMPTY
9751: PPUSH
9752: CALL_OW 1
9756: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
9757: LD_ADDR_EXP 66
9761: PUSH
9762: LD_EXP 66
9766: PPUSH
9767: LD_VAR 0 2
9771: PPUSH
9772: EMPTY
9773: PPUSH
9774: CALL_OW 1
9778: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
9779: LD_ADDR_EXP 65
9783: PUSH
9784: LD_EXP 65
9788: PPUSH
9789: LD_VAR 0 2
9793: PPUSH
9794: EMPTY
9795: PPUSH
9796: CALL_OW 1
9800: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
9801: LD_ADDR_EXP 67
9805: PUSH
9806: LD_EXP 67
9810: PPUSH
9811: LD_VAR 0 2
9815: PPUSH
9816: EMPTY
9817: PPUSH
9818: CALL_OW 1
9822: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
9823: LD_ADDR_EXP 68
9827: PUSH
9828: LD_EXP 68
9832: PPUSH
9833: LD_VAR 0 2
9837: PPUSH
9838: EMPTY
9839: PPUSH
9840: CALL_OW 1
9844: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
9845: LD_ADDR_EXP 69
9849: PUSH
9850: LD_EXP 69
9854: PPUSH
9855: LD_VAR 0 2
9859: PPUSH
9860: EMPTY
9861: PPUSH
9862: CALL_OW 1
9866: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
9867: LD_ADDR_EXP 70
9871: PUSH
9872: LD_EXP 70
9876: PPUSH
9877: LD_VAR 0 2
9881: PPUSH
9882: EMPTY
9883: PPUSH
9884: CALL_OW 1
9888: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
9889: LD_ADDR_EXP 71
9893: PUSH
9894: LD_EXP 71
9898: PPUSH
9899: LD_VAR 0 2
9903: PPUSH
9904: EMPTY
9905: PPUSH
9906: CALL_OW 1
9910: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
9911: LD_ADDR_EXP 72
9915: PUSH
9916: LD_EXP 72
9920: PPUSH
9921: LD_VAR 0 2
9925: PPUSH
9926: EMPTY
9927: PPUSH
9928: CALL_OW 1
9932: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
9933: LD_ADDR_EXP 73
9937: PUSH
9938: LD_EXP 73
9942: PPUSH
9943: LD_VAR 0 2
9947: PPUSH
9948: EMPTY
9949: PPUSH
9950: CALL_OW 1
9954: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
9955: LD_ADDR_EXP 74
9959: PUSH
9960: LD_EXP 74
9964: PPUSH
9965: LD_VAR 0 2
9969: PPUSH
9970: EMPTY
9971: PPUSH
9972: CALL_OW 1
9976: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
9977: LD_ADDR_EXP 63
9981: PUSH
9982: LD_EXP 63
9986: PPUSH
9987: LD_VAR 0 2
9991: PPUSH
9992: LD_INT 0
9994: PPUSH
9995: CALL_OW 1
9999: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
10000: LD_ADDR_EXP 76
10004: PUSH
10005: LD_EXP 76
10009: PPUSH
10010: LD_VAR 0 2
10014: PPUSH
10015: LD_INT 0
10017: PPUSH
10018: CALL_OW 1
10022: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
10023: LD_ADDR_EXP 64
10027: PUSH
10028: LD_EXP 64
10032: PPUSH
10033: LD_VAR 0 2
10037: PPUSH
10038: EMPTY
10039: PPUSH
10040: CALL_OW 1
10044: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
10045: LD_ADDR_EXP 75
10049: PUSH
10050: LD_EXP 75
10054: PPUSH
10055: LD_VAR 0 2
10059: PPUSH
10060: LD_INT 0
10062: PPUSH
10063: CALL_OW 1
10067: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
10068: LD_ADDR_EXP 77
10072: PUSH
10073: LD_EXP 77
10077: PPUSH
10078: LD_VAR 0 2
10082: PPUSH
10083: EMPTY
10084: PPUSH
10085: CALL_OW 1
10089: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
10090: LD_ADDR_EXP 80
10094: PUSH
10095: LD_EXP 80
10099: PPUSH
10100: LD_VAR 0 2
10104: PPUSH
10105: LD_INT 0
10107: PPUSH
10108: CALL_OW 1
10112: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
10113: LD_ADDR_EXP 81
10117: PUSH
10118: LD_EXP 81
10122: PPUSH
10123: LD_VAR 0 2
10127: PPUSH
10128: EMPTY
10129: PPUSH
10130: CALL_OW 1
10134: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
10135: LD_ADDR_EXP 82
10139: PUSH
10140: LD_EXP 82
10144: PPUSH
10145: LD_VAR 0 2
10149: PPUSH
10150: EMPTY
10151: PPUSH
10152: CALL_OW 1
10156: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
10157: LD_ADDR_EXP 83
10161: PUSH
10162: LD_EXP 83
10166: PPUSH
10167: LD_VAR 0 2
10171: PPUSH
10172: EMPTY
10173: PPUSH
10174: CALL_OW 1
10178: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
10179: LD_ADDR_EXP 85
10183: PUSH
10184: LD_EXP 85
10188: PPUSH
10189: LD_VAR 0 2
10193: PPUSH
10194: LD_EXP 52
10198: PUSH
10199: LD_VAR 0 2
10203: ARRAY
10204: PPUSH
10205: LD_INT 2
10207: PUSH
10208: LD_INT 30
10210: PUSH
10211: LD_INT 6
10213: PUSH
10214: EMPTY
10215: LIST
10216: LIST
10217: PUSH
10218: LD_INT 30
10220: PUSH
10221: LD_INT 7
10223: PUSH
10224: EMPTY
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 30
10230: PUSH
10231: LD_INT 8
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: LIST
10242: LIST
10243: PPUSH
10244: CALL_OW 72
10248: PPUSH
10249: CALL_OW 1
10253: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
10254: LD_ADDR_EXP 86
10258: PUSH
10259: LD_EXP 86
10263: PPUSH
10264: LD_VAR 0 2
10268: PPUSH
10269: EMPTY
10270: PPUSH
10271: CALL_OW 1
10275: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
10276: LD_ADDR_EXP 87
10280: PUSH
10281: LD_EXP 87
10285: PPUSH
10286: LD_VAR 0 2
10290: PPUSH
10291: EMPTY
10292: PPUSH
10293: CALL_OW 1
10297: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
10298: LD_ADDR_EXP 88
10302: PUSH
10303: LD_EXP 88
10307: PPUSH
10308: LD_VAR 0 2
10312: PPUSH
10313: EMPTY
10314: PPUSH
10315: CALL_OW 1
10319: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
10320: LD_ADDR_EXP 89
10324: PUSH
10325: LD_EXP 89
10329: PPUSH
10330: LD_VAR 0 2
10334: PPUSH
10335: EMPTY
10336: PPUSH
10337: CALL_OW 1
10341: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
10342: LD_ADDR_EXP 90
10346: PUSH
10347: LD_EXP 90
10351: PPUSH
10352: LD_VAR 0 2
10356: PPUSH
10357: EMPTY
10358: PPUSH
10359: CALL_OW 1
10363: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
10364: LD_ADDR_EXP 91
10368: PUSH
10369: LD_EXP 91
10373: PPUSH
10374: LD_VAR 0 2
10378: PPUSH
10379: EMPTY
10380: PPUSH
10381: CALL_OW 1
10385: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
10386: LD_ADDR_EXP 92
10390: PUSH
10391: LD_EXP 92
10395: PPUSH
10396: LD_VAR 0 2
10400: PPUSH
10401: EMPTY
10402: PPUSH
10403: CALL_OW 1
10407: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
10408: LD_ADDR_EXP 93
10412: PUSH
10413: LD_EXP 93
10417: PPUSH
10418: LD_VAR 0 2
10422: PPUSH
10423: EMPTY
10424: PPUSH
10425: CALL_OW 1
10429: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
10430: LD_ADDR_EXP 94
10434: PUSH
10435: LD_EXP 94
10439: PPUSH
10440: LD_VAR 0 2
10444: PPUSH
10445: LD_INT 0
10447: PPUSH
10448: CALL_OW 1
10452: ST_TO_ADDR
// end ;
10453: GO 9377
10455: POP
10456: POP
// MC_InitSides ( ) ;
10457: CALL 10743 0 0
// MC_InitResearch ( ) ;
10461: CALL 10482 0 0
// CustomInitMacro ( ) ;
10465: CALL 5079 0 0
// skirmish := true ;
10469: LD_ADDR_EXP 50
10473: PUSH
10474: LD_INT 1
10476: ST_TO_ADDR
// end ;
10477: LD_VAR 0 1
10481: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
10482: LD_INT 0
10484: PPUSH
10485: PPUSH
10486: PPUSH
10487: PPUSH
10488: PPUSH
10489: PPUSH
// if not mc_bases then
10490: LD_EXP 52
10494: NOT
10495: IFFALSE 10499
// exit ;
10497: GO 10738
// for i = 1 to 8 do
10499: LD_ADDR_VAR 0 2
10503: PUSH
10504: DOUBLE
10505: LD_INT 1
10507: DEC
10508: ST_TO_ADDR
10509: LD_INT 8
10511: PUSH
10512: FOR_TO
10513: IFFALSE 10539
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
10515: LD_ADDR_EXP 79
10519: PUSH
10520: LD_EXP 79
10524: PPUSH
10525: LD_VAR 0 2
10529: PPUSH
10530: EMPTY
10531: PPUSH
10532: CALL_OW 1
10536: ST_TO_ADDR
10537: GO 10512
10539: POP
10540: POP
// tmp := [ ] ;
10541: LD_ADDR_VAR 0 5
10545: PUSH
10546: EMPTY
10547: ST_TO_ADDR
// for i = 1 to mc_sides do
10548: LD_ADDR_VAR 0 2
10552: PUSH
10553: DOUBLE
10554: LD_INT 1
10556: DEC
10557: ST_TO_ADDR
10558: LD_EXP 78
10562: PUSH
10563: FOR_TO
10564: IFFALSE 10622
// if not mc_sides [ i ] in tmp then
10566: LD_EXP 78
10570: PUSH
10571: LD_VAR 0 2
10575: ARRAY
10576: PUSH
10577: LD_VAR 0 5
10581: IN
10582: NOT
10583: IFFALSE 10620
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
10585: LD_ADDR_VAR 0 5
10589: PUSH
10590: LD_VAR 0 5
10594: PPUSH
10595: LD_VAR 0 5
10599: PUSH
10600: LD_INT 1
10602: PLUS
10603: PPUSH
10604: LD_EXP 78
10608: PUSH
10609: LD_VAR 0 2
10613: ARRAY
10614: PPUSH
10615: CALL_OW 2
10619: ST_TO_ADDR
10620: GO 10563
10622: POP
10623: POP
// if not tmp then
10624: LD_VAR 0 5
10628: NOT
10629: IFFALSE 10633
// exit ;
10631: GO 10738
// for j in tmp do
10633: LD_ADDR_VAR 0 3
10637: PUSH
10638: LD_VAR 0 5
10642: PUSH
10643: FOR_IN
10644: IFFALSE 10736
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
10646: LD_ADDR_VAR 0 6
10650: PUSH
10651: LD_INT 22
10653: PUSH
10654: LD_VAR 0 3
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PPUSH
10663: CALL_OW 69
10667: ST_TO_ADDR
// if not un then
10668: LD_VAR 0 6
10672: NOT
10673: IFFALSE 10677
// continue ;
10675: GO 10643
// nation := GetNation ( un [ 1 ] ) ;
10677: LD_ADDR_VAR 0 4
10681: PUSH
10682: LD_VAR 0 6
10686: PUSH
10687: LD_INT 1
10689: ARRAY
10690: PPUSH
10691: CALL_OW 248
10695: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
10696: LD_ADDR_EXP 79
10700: PUSH
10701: LD_EXP 79
10705: PPUSH
10706: LD_VAR 0 3
10710: PPUSH
10711: LD_VAR 0 3
10715: PPUSH
10716: LD_VAR 0 4
10720: PPUSH
10721: LD_INT 1
10723: PPUSH
10724: CALL 32599 0 3
10728: PPUSH
10729: CALL_OW 1
10733: ST_TO_ADDR
// end ;
10734: GO 10643
10736: POP
10737: POP
// end ;
10738: LD_VAR 0 1
10742: RET
// export function MC_InitSides ( ) ; var i ; begin
10743: LD_INT 0
10745: PPUSH
10746: PPUSH
// if not mc_bases then
10747: LD_EXP 52
10751: NOT
10752: IFFALSE 10756
// exit ;
10754: GO 10830
// for i = 1 to mc_bases do
10756: LD_ADDR_VAR 0 2
10760: PUSH
10761: DOUBLE
10762: LD_INT 1
10764: DEC
10765: ST_TO_ADDR
10766: LD_EXP 52
10770: PUSH
10771: FOR_TO
10772: IFFALSE 10828
// if mc_bases [ i ] then
10774: LD_EXP 52
10778: PUSH
10779: LD_VAR 0 2
10783: ARRAY
10784: IFFALSE 10826
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
10786: LD_ADDR_EXP 78
10790: PUSH
10791: LD_EXP 78
10795: PPUSH
10796: LD_VAR 0 2
10800: PPUSH
10801: LD_EXP 52
10805: PUSH
10806: LD_VAR 0 2
10810: ARRAY
10811: PUSH
10812: LD_INT 1
10814: ARRAY
10815: PPUSH
10816: CALL_OW 255
10820: PPUSH
10821: CALL_OW 1
10825: ST_TO_ADDR
10826: GO 10771
10828: POP
10829: POP
// end ;
10830: LD_VAR 0 1
10834: RET
// every 0 0$01 trigger skirmish do
10835: LD_EXP 50
10839: IFFALSE 10993
10841: GO 10843
10843: DISABLE
// begin enable ;
10844: ENABLE
// MC_CheckBuildings ( ) ;
10845: CALL 15491 0 0
// MC_CheckPeopleLife ( ) ;
10849: CALL 15616 0 0
// RaiseSailEvent ( 100 ) ;
10853: LD_INT 100
10855: PPUSH
10856: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
10860: LD_INT 103
10862: PPUSH
10863: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
10867: LD_INT 104
10869: PPUSH
10870: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
10874: LD_INT 105
10876: PPUSH
10877: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
10881: LD_INT 106
10883: PPUSH
10884: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
10888: LD_INT 107
10890: PPUSH
10891: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
10895: LD_INT 108
10897: PPUSH
10898: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
10902: LD_INT 109
10904: PPUSH
10905: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
10909: LD_INT 110
10911: PPUSH
10912: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
10916: LD_INT 111
10918: PPUSH
10919: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
10923: LD_INT 112
10925: PPUSH
10926: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
10930: LD_INT 113
10932: PPUSH
10933: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
10937: LD_INT 120
10939: PPUSH
10940: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
10944: LD_INT 121
10946: PPUSH
10947: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
10951: LD_INT 122
10953: PPUSH
10954: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
10958: LD_INT 123
10960: PPUSH
10961: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
10965: LD_INT 124
10967: PPUSH
10968: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
10972: LD_INT 125
10974: PPUSH
10975: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
10979: LD_INT 126
10981: PPUSH
10982: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
10986: LD_INT 200
10988: PPUSH
10989: CALL_OW 427
// end ;
10993: END
// on SailEvent ( event ) do begin if event < 100 then
10994: LD_VAR 0 1
10998: PUSH
10999: LD_INT 100
11001: LESS
11002: IFFALSE 11013
// CustomEvent ( event ) ;
11004: LD_VAR 0 1
11008: PPUSH
11009: CALL 5087 0 1
// if event = 100 then
11013: LD_VAR 0 1
11017: PUSH
11018: LD_INT 100
11020: EQUAL
11021: IFFALSE 11027
// MC_ClassManager ( ) ;
11023: CALL 11419 0 0
// if event = 101 then
11027: LD_VAR 0 1
11031: PUSH
11032: LD_INT 101
11034: EQUAL
11035: IFFALSE 11041
// MC_RepairBuildings ( ) ;
11037: CALL 16201 0 0
// if event = 102 then
11041: LD_VAR 0 1
11045: PUSH
11046: LD_INT 102
11048: EQUAL
11049: IFFALSE 11055
// MC_Heal ( ) ;
11051: CALL 17060 0 0
// if event = 103 then
11055: LD_VAR 0 1
11059: PUSH
11060: LD_INT 103
11062: EQUAL
11063: IFFALSE 11069
// MC_Build ( ) ;
11065: CALL 17482 0 0
// if event = 104 then
11069: LD_VAR 0 1
11073: PUSH
11074: LD_INT 104
11076: EQUAL
11077: IFFALSE 11083
// MC_TurretWeapon ( ) ;
11079: CALL 19095 0 0
// if event = 105 then
11083: LD_VAR 0 1
11087: PUSH
11088: LD_INT 105
11090: EQUAL
11091: IFFALSE 11097
// MC_BuildUpgrade ( ) ;
11093: CALL 18646 0 0
// if event = 106 then
11097: LD_VAR 0 1
11101: PUSH
11102: LD_INT 106
11104: EQUAL
11105: IFFALSE 11111
// MC_PlantMines ( ) ;
11107: CALL 19525 0 0
// if event = 107 then
11111: LD_VAR 0 1
11115: PUSH
11116: LD_INT 107
11118: EQUAL
11119: IFFALSE 11125
// MC_CollectCrates ( ) ;
11121: CALL 20323 0 0
// if event = 108 then
11125: LD_VAR 0 1
11129: PUSH
11130: LD_INT 108
11132: EQUAL
11133: IFFALSE 11139
// MC_LinkRemoteControl ( ) ;
11135: CALL 22099 0 0
// if event = 109 then
11139: LD_VAR 0 1
11143: PUSH
11144: LD_INT 109
11146: EQUAL
11147: IFFALSE 11153
// MC_ProduceVehicle ( ) ;
11149: CALL 22280 0 0
// if event = 110 then
11153: LD_VAR 0 1
11157: PUSH
11158: LD_INT 110
11160: EQUAL
11161: IFFALSE 11167
// MC_SendAttack ( ) ;
11163: CALL 22746 0 0
// if event = 111 then
11167: LD_VAR 0 1
11171: PUSH
11172: LD_INT 111
11174: EQUAL
11175: IFFALSE 11181
// MC_Defend ( ) ;
11177: CALL 22854 0 0
// if event = 112 then
11181: LD_VAR 0 1
11185: PUSH
11186: LD_INT 112
11188: EQUAL
11189: IFFALSE 11195
// MC_Research ( ) ;
11191: CALL 23459 0 0
// if event = 113 then
11195: LD_VAR 0 1
11199: PUSH
11200: LD_INT 113
11202: EQUAL
11203: IFFALSE 11209
// MC_MinesTrigger ( ) ;
11205: CALL 24573 0 0
// if event = 120 then
11209: LD_VAR 0 1
11213: PUSH
11214: LD_INT 120
11216: EQUAL
11217: IFFALSE 11223
// MC_RepairVehicle ( ) ;
11219: CALL 24672 0 0
// if event = 121 then
11223: LD_VAR 0 1
11227: PUSH
11228: LD_INT 121
11230: EQUAL
11231: IFFALSE 11237
// MC_TameApe ( ) ;
11233: CALL 25402 0 0
// if event = 122 then
11237: LD_VAR 0 1
11241: PUSH
11242: LD_INT 122
11244: EQUAL
11245: IFFALSE 11251
// MC_ChangeApeClass ( ) ;
11247: CALL 26231 0 0
// if event = 123 then
11251: LD_VAR 0 1
11255: PUSH
11256: LD_INT 123
11258: EQUAL
11259: IFFALSE 11265
// MC_Bazooka ( ) ;
11261: CALL 26881 0 0
// if event = 124 then
11265: LD_VAR 0 1
11269: PUSH
11270: LD_INT 124
11272: EQUAL
11273: IFFALSE 11279
// MC_TeleportExit ( ) ;
11275: CALL 27079 0 0
// if event = 125 then
11279: LD_VAR 0 1
11283: PUSH
11284: LD_INT 125
11286: EQUAL
11287: IFFALSE 11293
// MC_Deposits ( ) ;
11289: CALL 27726 0 0
// if event = 126 then
11293: LD_VAR 0 1
11297: PUSH
11298: LD_INT 126
11300: EQUAL
11301: IFFALSE 11307
// MC_RemoteDriver ( ) ;
11303: CALL 28351 0 0
// if event = 200 then
11307: LD_VAR 0 1
11311: PUSH
11312: LD_INT 200
11314: EQUAL
11315: IFFALSE 11321
// MC_Idle ( ) ;
11317: CALL 30300 0 0
// end ;
11321: PPOPN 1
11323: END
// export function MC_Reset ( base , tag ) ; var i ; begin
11324: LD_INT 0
11326: PPUSH
11327: PPUSH
// if not mc_bases [ base ] or not tag then
11328: LD_EXP 52
11332: PUSH
11333: LD_VAR 0 1
11337: ARRAY
11338: NOT
11339: PUSH
11340: LD_VAR 0 2
11344: NOT
11345: OR
11346: IFFALSE 11350
// exit ;
11348: GO 11414
// for i in mc_bases [ base ] union mc_ape [ base ] do
11350: LD_ADDR_VAR 0 4
11354: PUSH
11355: LD_EXP 52
11359: PUSH
11360: LD_VAR 0 1
11364: ARRAY
11365: PUSH
11366: LD_EXP 81
11370: PUSH
11371: LD_VAR 0 1
11375: ARRAY
11376: UNION
11377: PUSH
11378: FOR_IN
11379: IFFALSE 11412
// if GetTag ( i ) = tag then
11381: LD_VAR 0 4
11385: PPUSH
11386: CALL_OW 110
11390: PUSH
11391: LD_VAR 0 2
11395: EQUAL
11396: IFFALSE 11410
// SetTag ( i , 0 ) ;
11398: LD_VAR 0 4
11402: PPUSH
11403: LD_INT 0
11405: PPUSH
11406: CALL_OW 109
11410: GO 11378
11412: POP
11413: POP
// end ;
11414: LD_VAR 0 3
11418: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
11419: LD_INT 0
11421: PPUSH
11422: PPUSH
11423: PPUSH
11424: PPUSH
11425: PPUSH
11426: PPUSH
11427: PPUSH
11428: PPUSH
// if not mc_bases then
11429: LD_EXP 52
11433: NOT
11434: IFFALSE 11438
// exit ;
11436: GO 11896
// for i = 1 to mc_bases do
11438: LD_ADDR_VAR 0 2
11442: PUSH
11443: DOUBLE
11444: LD_INT 1
11446: DEC
11447: ST_TO_ADDR
11448: LD_EXP 52
11452: PUSH
11453: FOR_TO
11454: IFFALSE 11894
// begin tmp := MC_ClassCheckReq ( i ) ;
11456: LD_ADDR_VAR 0 4
11460: PUSH
11461: LD_VAR 0 2
11465: PPUSH
11466: CALL 11901 0 1
11470: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
11471: LD_ADDR_EXP 93
11475: PUSH
11476: LD_EXP 93
11480: PPUSH
11481: LD_VAR 0 2
11485: PPUSH
11486: LD_VAR 0 4
11490: PPUSH
11491: CALL_OW 1
11495: ST_TO_ADDR
// if not tmp then
11496: LD_VAR 0 4
11500: NOT
11501: IFFALSE 11505
// continue ;
11503: GO 11453
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
11505: LD_ADDR_VAR 0 6
11509: PUSH
11510: LD_EXP 52
11514: PUSH
11515: LD_VAR 0 2
11519: ARRAY
11520: PPUSH
11521: LD_INT 2
11523: PUSH
11524: LD_INT 30
11526: PUSH
11527: LD_INT 4
11529: PUSH
11530: EMPTY
11531: LIST
11532: LIST
11533: PUSH
11534: LD_INT 30
11536: PUSH
11537: LD_INT 5
11539: PUSH
11540: EMPTY
11541: LIST
11542: LIST
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: LIST
11548: PPUSH
11549: CALL_OW 72
11553: PUSH
11554: LD_EXP 52
11558: PUSH
11559: LD_VAR 0 2
11563: ARRAY
11564: PPUSH
11565: LD_INT 2
11567: PUSH
11568: LD_INT 30
11570: PUSH
11571: LD_INT 0
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: PUSH
11578: LD_INT 30
11580: PUSH
11581: LD_INT 1
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: LIST
11592: PPUSH
11593: CALL_OW 72
11597: PUSH
11598: LD_EXP 52
11602: PUSH
11603: LD_VAR 0 2
11607: ARRAY
11608: PPUSH
11609: LD_INT 30
11611: PUSH
11612: LD_INT 3
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PPUSH
11619: CALL_OW 72
11623: PUSH
11624: LD_EXP 52
11628: PUSH
11629: LD_VAR 0 2
11633: ARRAY
11634: PPUSH
11635: LD_INT 2
11637: PUSH
11638: LD_INT 30
11640: PUSH
11641: LD_INT 6
11643: PUSH
11644: EMPTY
11645: LIST
11646: LIST
11647: PUSH
11648: LD_INT 30
11650: PUSH
11651: LD_INT 7
11653: PUSH
11654: EMPTY
11655: LIST
11656: LIST
11657: PUSH
11658: LD_INT 30
11660: PUSH
11661: LD_INT 8
11663: PUSH
11664: EMPTY
11665: LIST
11666: LIST
11667: PUSH
11668: EMPTY
11669: LIST
11670: LIST
11671: LIST
11672: LIST
11673: PPUSH
11674: CALL_OW 72
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: ST_TO_ADDR
// for j = 1 to 4 do
11685: LD_ADDR_VAR 0 3
11689: PUSH
11690: DOUBLE
11691: LD_INT 1
11693: DEC
11694: ST_TO_ADDR
11695: LD_INT 4
11697: PUSH
11698: FOR_TO
11699: IFFALSE 11890
// begin if not tmp [ j ] then
11701: LD_VAR 0 4
11705: PUSH
11706: LD_VAR 0 3
11710: ARRAY
11711: NOT
11712: IFFALSE 11716
// continue ;
11714: GO 11698
// for p in tmp [ j ] do
11716: LD_ADDR_VAR 0 5
11720: PUSH
11721: LD_VAR 0 4
11725: PUSH
11726: LD_VAR 0 3
11730: ARRAY
11731: PUSH
11732: FOR_IN
11733: IFFALSE 11886
// begin if not b [ j ] then
11735: LD_VAR 0 6
11739: PUSH
11740: LD_VAR 0 3
11744: ARRAY
11745: NOT
11746: IFFALSE 11750
// break ;
11748: GO 11886
// e := 0 ;
11750: LD_ADDR_VAR 0 7
11754: PUSH
11755: LD_INT 0
11757: ST_TO_ADDR
// for k in b [ j ] do
11758: LD_ADDR_VAR 0 8
11762: PUSH
11763: LD_VAR 0 6
11767: PUSH
11768: LD_VAR 0 3
11772: ARRAY
11773: PUSH
11774: FOR_IN
11775: IFFALSE 11802
// if IsNotFull ( k ) then
11777: LD_VAR 0 8
11781: PPUSH
11782: CALL 34748 0 1
11786: IFFALSE 11800
// begin e := k ;
11788: LD_ADDR_VAR 0 7
11792: PUSH
11793: LD_VAR 0 8
11797: ST_TO_ADDR
// break ;
11798: GO 11802
// end ;
11800: GO 11774
11802: POP
11803: POP
// if e and not UnitGoingToBuilding ( p , e ) then
11804: LD_VAR 0 7
11808: PUSH
11809: LD_VAR 0 5
11813: PPUSH
11814: LD_VAR 0 7
11818: PPUSH
11819: CALL 67168 0 2
11823: NOT
11824: AND
11825: IFFALSE 11884
// begin if IsInUnit ( p ) then
11827: LD_VAR 0 5
11831: PPUSH
11832: CALL_OW 310
11836: IFFALSE 11847
// ComExitBuilding ( p ) ;
11838: LD_VAR 0 5
11842: PPUSH
11843: CALL_OW 122
// ComEnterUnit ( p , e ) ;
11847: LD_VAR 0 5
11851: PPUSH
11852: LD_VAR 0 7
11856: PPUSH
11857: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
11861: LD_VAR 0 5
11865: PPUSH
11866: LD_VAR 0 3
11870: PPUSH
11871: CALL_OW 183
// AddComExitBuilding ( p ) ;
11875: LD_VAR 0 5
11879: PPUSH
11880: CALL_OW 182
// end ; end ;
11884: GO 11732
11886: POP
11887: POP
// end ;
11888: GO 11698
11890: POP
11891: POP
// end ;
11892: GO 11453
11894: POP
11895: POP
// end ;
11896: LD_VAR 0 1
11900: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
11901: LD_INT 0
11903: PPUSH
11904: PPUSH
11905: PPUSH
11906: PPUSH
11907: PPUSH
11908: PPUSH
11909: PPUSH
11910: PPUSH
11911: PPUSH
11912: PPUSH
11913: PPUSH
11914: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
11915: LD_VAR 0 1
11919: NOT
11920: PUSH
11921: LD_EXP 52
11925: PUSH
11926: LD_VAR 0 1
11930: ARRAY
11931: NOT
11932: OR
11933: PUSH
11934: LD_EXP 52
11938: PUSH
11939: LD_VAR 0 1
11943: ARRAY
11944: PPUSH
11945: LD_INT 2
11947: PUSH
11948: LD_INT 30
11950: PUSH
11951: LD_INT 0
11953: PUSH
11954: EMPTY
11955: LIST
11956: LIST
11957: PUSH
11958: LD_INT 30
11960: PUSH
11961: LD_INT 1
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: LIST
11972: PPUSH
11973: CALL_OW 72
11977: NOT
11978: OR
11979: IFFALSE 11983
// exit ;
11981: GO 15486
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
11983: LD_ADDR_VAR 0 4
11987: PUSH
11988: LD_EXP 52
11992: PUSH
11993: LD_VAR 0 1
11997: ARRAY
11998: PPUSH
11999: LD_INT 2
12001: PUSH
12002: LD_INT 25
12004: PUSH
12005: LD_INT 1
12007: PUSH
12008: EMPTY
12009: LIST
12010: LIST
12011: PUSH
12012: LD_INT 25
12014: PUSH
12015: LD_INT 2
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: PUSH
12022: LD_INT 25
12024: PUSH
12025: LD_INT 3
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: LD_INT 25
12034: PUSH
12035: LD_INT 4
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: LD_INT 25
12044: PUSH
12045: LD_INT 5
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: LD_INT 25
12054: PUSH
12055: LD_INT 8
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: PUSH
12062: LD_INT 25
12064: PUSH
12065: LD_INT 9
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: PUSH
12072: EMPTY
12073: LIST
12074: LIST
12075: LIST
12076: LIST
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: PPUSH
12082: CALL_OW 72
12086: ST_TO_ADDR
// if not tmp then
12087: LD_VAR 0 4
12091: NOT
12092: IFFALSE 12096
// exit ;
12094: GO 15486
// for i in tmp do
12096: LD_ADDR_VAR 0 3
12100: PUSH
12101: LD_VAR 0 4
12105: PUSH
12106: FOR_IN
12107: IFFALSE 12138
// if GetTag ( i ) then
12109: LD_VAR 0 3
12113: PPUSH
12114: CALL_OW 110
12118: IFFALSE 12136
// tmp := tmp diff i ;
12120: LD_ADDR_VAR 0 4
12124: PUSH
12125: LD_VAR 0 4
12129: PUSH
12130: LD_VAR 0 3
12134: DIFF
12135: ST_TO_ADDR
12136: GO 12106
12138: POP
12139: POP
// if not tmp then
12140: LD_VAR 0 4
12144: NOT
12145: IFFALSE 12149
// exit ;
12147: GO 15486
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
12149: LD_ADDR_VAR 0 5
12153: PUSH
12154: LD_EXP 52
12158: PUSH
12159: LD_VAR 0 1
12163: ARRAY
12164: PPUSH
12165: LD_INT 2
12167: PUSH
12168: LD_INT 25
12170: PUSH
12171: LD_INT 1
12173: PUSH
12174: EMPTY
12175: LIST
12176: LIST
12177: PUSH
12178: LD_INT 25
12180: PUSH
12181: LD_INT 5
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PUSH
12188: LD_INT 25
12190: PUSH
12191: LD_INT 8
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: LD_INT 25
12200: PUSH
12201: LD_INT 9
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: LIST
12212: LIST
12213: LIST
12214: PPUSH
12215: CALL_OW 72
12219: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
12220: LD_ADDR_VAR 0 6
12224: PUSH
12225: LD_EXP 52
12229: PUSH
12230: LD_VAR 0 1
12234: ARRAY
12235: PPUSH
12236: LD_INT 25
12238: PUSH
12239: LD_INT 2
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PPUSH
12246: CALL_OW 72
12250: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
12251: LD_ADDR_VAR 0 7
12255: PUSH
12256: LD_EXP 52
12260: PUSH
12261: LD_VAR 0 1
12265: ARRAY
12266: PPUSH
12267: LD_INT 25
12269: PUSH
12270: LD_INT 3
12272: PUSH
12273: EMPTY
12274: LIST
12275: LIST
12276: PPUSH
12277: CALL_OW 72
12281: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
12282: LD_ADDR_VAR 0 8
12286: PUSH
12287: LD_EXP 52
12291: PUSH
12292: LD_VAR 0 1
12296: ARRAY
12297: PPUSH
12298: LD_INT 25
12300: PUSH
12301: LD_INT 4
12303: PUSH
12304: EMPTY
12305: LIST
12306: LIST
12307: PUSH
12308: LD_INT 24
12310: PUSH
12311: LD_INT 251
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PPUSH
12322: CALL_OW 72
12326: ST_TO_ADDR
// if mc_scan [ base ] then
12327: LD_EXP 75
12331: PUSH
12332: LD_VAR 0 1
12336: ARRAY
12337: IFFALSE 12798
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
12339: LD_ADDR_EXP 94
12343: PUSH
12344: LD_EXP 94
12348: PPUSH
12349: LD_VAR 0 1
12353: PPUSH
12354: LD_INT 4
12356: PPUSH
12357: CALL_OW 1
12361: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
12362: LD_ADDR_VAR 0 12
12366: PUSH
12367: LD_EXP 52
12371: PUSH
12372: LD_VAR 0 1
12376: ARRAY
12377: PPUSH
12378: LD_INT 2
12380: PUSH
12381: LD_INT 30
12383: PUSH
12384: LD_INT 4
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: PUSH
12391: LD_INT 30
12393: PUSH
12394: LD_INT 5
12396: PUSH
12397: EMPTY
12398: LIST
12399: LIST
12400: PUSH
12401: EMPTY
12402: LIST
12403: LIST
12404: LIST
12405: PPUSH
12406: CALL_OW 72
12410: ST_TO_ADDR
// if not b then
12411: LD_VAR 0 12
12415: NOT
12416: IFFALSE 12420
// exit ;
12418: GO 15486
// p := [ ] ;
12420: LD_ADDR_VAR 0 11
12424: PUSH
12425: EMPTY
12426: ST_TO_ADDR
// if sci >= 2 then
12427: LD_VAR 0 8
12431: PUSH
12432: LD_INT 2
12434: GREATEREQUAL
12435: IFFALSE 12466
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
12437: LD_ADDR_VAR 0 8
12441: PUSH
12442: LD_VAR 0 8
12446: PUSH
12447: LD_INT 1
12449: ARRAY
12450: PUSH
12451: LD_VAR 0 8
12455: PUSH
12456: LD_INT 2
12458: ARRAY
12459: PUSH
12460: EMPTY
12461: LIST
12462: LIST
12463: ST_TO_ADDR
12464: GO 12527
// if sci = 1 then
12466: LD_VAR 0 8
12470: PUSH
12471: LD_INT 1
12473: EQUAL
12474: IFFALSE 12495
// sci := [ sci [ 1 ] ] else
12476: LD_ADDR_VAR 0 8
12480: PUSH
12481: LD_VAR 0 8
12485: PUSH
12486: LD_INT 1
12488: ARRAY
12489: PUSH
12490: EMPTY
12491: LIST
12492: ST_TO_ADDR
12493: GO 12527
// if sci = 0 then
12495: LD_VAR 0 8
12499: PUSH
12500: LD_INT 0
12502: EQUAL
12503: IFFALSE 12527
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
12505: LD_ADDR_VAR 0 11
12509: PUSH
12510: LD_VAR 0 4
12514: PPUSH
12515: LD_INT 4
12517: PPUSH
12518: CALL 67031 0 2
12522: PUSH
12523: LD_INT 1
12525: ARRAY
12526: ST_TO_ADDR
// if eng > 4 then
12527: LD_VAR 0 6
12531: PUSH
12532: LD_INT 4
12534: GREATER
12535: IFFALSE 12581
// for i = eng downto 4 do
12537: LD_ADDR_VAR 0 3
12541: PUSH
12542: DOUBLE
12543: LD_VAR 0 6
12547: INC
12548: ST_TO_ADDR
12549: LD_INT 4
12551: PUSH
12552: FOR_DOWNTO
12553: IFFALSE 12579
// eng := eng diff eng [ i ] ;
12555: LD_ADDR_VAR 0 6
12559: PUSH
12560: LD_VAR 0 6
12564: PUSH
12565: LD_VAR 0 6
12569: PUSH
12570: LD_VAR 0 3
12574: ARRAY
12575: DIFF
12576: ST_TO_ADDR
12577: GO 12552
12579: POP
12580: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
12581: LD_ADDR_VAR 0 4
12585: PUSH
12586: LD_VAR 0 4
12590: PUSH
12591: LD_VAR 0 5
12595: PUSH
12596: LD_VAR 0 6
12600: UNION
12601: PUSH
12602: LD_VAR 0 7
12606: UNION
12607: PUSH
12608: LD_VAR 0 8
12612: UNION
12613: DIFF
12614: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
12615: LD_ADDR_VAR 0 13
12619: PUSH
12620: LD_EXP 52
12624: PUSH
12625: LD_VAR 0 1
12629: ARRAY
12630: PPUSH
12631: LD_INT 2
12633: PUSH
12634: LD_INT 30
12636: PUSH
12637: LD_INT 32
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: LD_INT 30
12646: PUSH
12647: LD_INT 31
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: LIST
12658: PPUSH
12659: CALL_OW 72
12663: PUSH
12664: LD_EXP 52
12668: PUSH
12669: LD_VAR 0 1
12673: ARRAY
12674: PPUSH
12675: LD_INT 2
12677: PUSH
12678: LD_INT 30
12680: PUSH
12681: LD_INT 4
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: PUSH
12688: LD_INT 30
12690: PUSH
12691: LD_INT 5
12693: PUSH
12694: EMPTY
12695: LIST
12696: LIST
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: LIST
12702: PPUSH
12703: CALL_OW 72
12707: PUSH
12708: LD_INT 6
12710: MUL
12711: PLUS
12712: ST_TO_ADDR
// if bcount < tmp then
12713: LD_VAR 0 13
12717: PUSH
12718: LD_VAR 0 4
12722: LESS
12723: IFFALSE 12769
// for i = tmp downto bcount do
12725: LD_ADDR_VAR 0 3
12729: PUSH
12730: DOUBLE
12731: LD_VAR 0 4
12735: INC
12736: ST_TO_ADDR
12737: LD_VAR 0 13
12741: PUSH
12742: FOR_DOWNTO
12743: IFFALSE 12767
// tmp := Delete ( tmp , tmp ) ;
12745: LD_ADDR_VAR 0 4
12749: PUSH
12750: LD_VAR 0 4
12754: PPUSH
12755: LD_VAR 0 4
12759: PPUSH
12760: CALL_OW 3
12764: ST_TO_ADDR
12765: GO 12742
12767: POP
12768: POP
// result := [ tmp , 0 , 0 , p ] ;
12769: LD_ADDR_VAR 0 2
12773: PUSH
12774: LD_VAR 0 4
12778: PUSH
12779: LD_INT 0
12781: PUSH
12782: LD_INT 0
12784: PUSH
12785: LD_VAR 0 11
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: ST_TO_ADDR
// exit ;
12796: GO 15486
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
12798: LD_EXP 52
12802: PUSH
12803: LD_VAR 0 1
12807: ARRAY
12808: PPUSH
12809: LD_INT 2
12811: PUSH
12812: LD_INT 30
12814: PUSH
12815: LD_INT 6
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 30
12824: PUSH
12825: LD_INT 7
12827: PUSH
12828: EMPTY
12829: LIST
12830: LIST
12831: PUSH
12832: LD_INT 30
12834: PUSH
12835: LD_INT 8
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL_OW 72
12852: NOT
12853: PUSH
12854: LD_EXP 52
12858: PUSH
12859: LD_VAR 0 1
12863: ARRAY
12864: PPUSH
12865: LD_INT 30
12867: PUSH
12868: LD_INT 3
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: PPUSH
12875: CALL_OW 72
12879: NOT
12880: AND
12881: IFFALSE 12953
// begin if eng = tmp then
12883: LD_VAR 0 6
12887: PUSH
12888: LD_VAR 0 4
12892: EQUAL
12893: IFFALSE 12897
// exit ;
12895: GO 15486
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
12897: LD_ADDR_EXP 94
12901: PUSH
12902: LD_EXP 94
12906: PPUSH
12907: LD_VAR 0 1
12911: PPUSH
12912: LD_INT 1
12914: PPUSH
12915: CALL_OW 1
12919: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
12920: LD_ADDR_VAR 0 2
12924: PUSH
12925: LD_INT 0
12927: PUSH
12928: LD_VAR 0 4
12932: PUSH
12933: LD_VAR 0 6
12937: DIFF
12938: PUSH
12939: LD_INT 0
12941: PUSH
12942: LD_INT 0
12944: PUSH
12945: EMPTY
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: ST_TO_ADDR
// exit ;
12951: GO 15486
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
12953: LD_EXP 79
12957: PUSH
12958: LD_EXP 78
12962: PUSH
12963: LD_VAR 0 1
12967: ARRAY
12968: ARRAY
12969: PUSH
12970: LD_EXP 52
12974: PUSH
12975: LD_VAR 0 1
12979: ARRAY
12980: PPUSH
12981: LD_INT 2
12983: PUSH
12984: LD_INT 30
12986: PUSH
12987: LD_INT 6
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: LD_INT 30
12996: PUSH
12997: LD_INT 7
12999: PUSH
13000: EMPTY
13001: LIST
13002: LIST
13003: PUSH
13004: LD_INT 30
13006: PUSH
13007: LD_INT 8
13009: PUSH
13010: EMPTY
13011: LIST
13012: LIST
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 72
13024: AND
13025: PUSH
13026: LD_EXP 52
13030: PUSH
13031: LD_VAR 0 1
13035: ARRAY
13036: PPUSH
13037: LD_INT 30
13039: PUSH
13040: LD_INT 3
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 72
13051: NOT
13052: AND
13053: IFFALSE 13267
// begin if sci >= 6 then
13055: LD_VAR 0 8
13059: PUSH
13060: LD_INT 6
13062: GREATEREQUAL
13063: IFFALSE 13067
// exit ;
13065: GO 15486
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
13067: LD_ADDR_EXP 94
13071: PUSH
13072: LD_EXP 94
13076: PPUSH
13077: LD_VAR 0 1
13081: PPUSH
13082: LD_INT 2
13084: PPUSH
13085: CALL_OW 1
13089: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
13090: LD_ADDR_VAR 0 9
13094: PUSH
13095: LD_VAR 0 4
13099: PUSH
13100: LD_VAR 0 8
13104: DIFF
13105: PPUSH
13106: LD_INT 4
13108: PPUSH
13109: CALL 67031 0 2
13113: ST_TO_ADDR
// p := [ ] ;
13114: LD_ADDR_VAR 0 11
13118: PUSH
13119: EMPTY
13120: ST_TO_ADDR
// if sci < 6 and sort > 6 then
13121: LD_VAR 0 8
13125: PUSH
13126: LD_INT 6
13128: LESS
13129: PUSH
13130: LD_VAR 0 9
13134: PUSH
13135: LD_INT 6
13137: GREATER
13138: AND
13139: IFFALSE 13220
// begin for i = 1 to 6 - sci do
13141: LD_ADDR_VAR 0 3
13145: PUSH
13146: DOUBLE
13147: LD_INT 1
13149: DEC
13150: ST_TO_ADDR
13151: LD_INT 6
13153: PUSH
13154: LD_VAR 0 8
13158: MINUS
13159: PUSH
13160: FOR_TO
13161: IFFALSE 13216
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
13163: LD_ADDR_VAR 0 11
13167: PUSH
13168: LD_VAR 0 11
13172: PPUSH
13173: LD_VAR 0 11
13177: PUSH
13178: LD_INT 1
13180: PLUS
13181: PPUSH
13182: LD_VAR 0 9
13186: PUSH
13187: LD_INT 1
13189: ARRAY
13190: PPUSH
13191: CALL_OW 2
13195: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
13196: LD_ADDR_VAR 0 9
13200: PUSH
13201: LD_VAR 0 9
13205: PPUSH
13206: LD_INT 1
13208: PPUSH
13209: CALL_OW 3
13213: ST_TO_ADDR
// end ;
13214: GO 13160
13216: POP
13217: POP
// end else
13218: GO 13240
// if sort then
13220: LD_VAR 0 9
13224: IFFALSE 13240
// p := sort [ 1 ] ;
13226: LD_ADDR_VAR 0 11
13230: PUSH
13231: LD_VAR 0 9
13235: PUSH
13236: LD_INT 1
13238: ARRAY
13239: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
13240: LD_ADDR_VAR 0 2
13244: PUSH
13245: LD_INT 0
13247: PUSH
13248: LD_INT 0
13250: PUSH
13251: LD_INT 0
13253: PUSH
13254: LD_VAR 0 11
13258: PUSH
13259: EMPTY
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: ST_TO_ADDR
// exit ;
13265: GO 15486
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
13267: LD_EXP 79
13271: PUSH
13272: LD_EXP 78
13276: PUSH
13277: LD_VAR 0 1
13281: ARRAY
13282: ARRAY
13283: PUSH
13284: LD_EXP 52
13288: PUSH
13289: LD_VAR 0 1
13293: ARRAY
13294: PPUSH
13295: LD_INT 2
13297: PUSH
13298: LD_INT 30
13300: PUSH
13301: LD_INT 6
13303: PUSH
13304: EMPTY
13305: LIST
13306: LIST
13307: PUSH
13308: LD_INT 30
13310: PUSH
13311: LD_INT 7
13313: PUSH
13314: EMPTY
13315: LIST
13316: LIST
13317: PUSH
13318: LD_INT 30
13320: PUSH
13321: LD_INT 8
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: LIST
13332: LIST
13333: PPUSH
13334: CALL_OW 72
13338: AND
13339: PUSH
13340: LD_EXP 52
13344: PUSH
13345: LD_VAR 0 1
13349: ARRAY
13350: PPUSH
13351: LD_INT 30
13353: PUSH
13354: LD_INT 3
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: PPUSH
13361: CALL_OW 72
13365: AND
13366: IFFALSE 14100
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
13368: LD_ADDR_EXP 94
13372: PUSH
13373: LD_EXP 94
13377: PPUSH
13378: LD_VAR 0 1
13382: PPUSH
13383: LD_INT 3
13385: PPUSH
13386: CALL_OW 1
13390: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
13391: LD_ADDR_VAR 0 2
13395: PUSH
13396: LD_INT 0
13398: PUSH
13399: LD_INT 0
13401: PUSH
13402: LD_INT 0
13404: PUSH
13405: LD_INT 0
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: LIST
13412: LIST
13413: ST_TO_ADDR
// if not eng then
13414: LD_VAR 0 6
13418: NOT
13419: IFFALSE 13482
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
13421: LD_ADDR_VAR 0 11
13425: PUSH
13426: LD_VAR 0 4
13430: PPUSH
13431: LD_INT 2
13433: PPUSH
13434: CALL 67031 0 2
13438: PUSH
13439: LD_INT 1
13441: ARRAY
13442: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
13443: LD_ADDR_VAR 0 2
13447: PUSH
13448: LD_VAR 0 2
13452: PPUSH
13453: LD_INT 2
13455: PPUSH
13456: LD_VAR 0 11
13460: PPUSH
13461: CALL_OW 1
13465: ST_TO_ADDR
// tmp := tmp diff p ;
13466: LD_ADDR_VAR 0 4
13470: PUSH
13471: LD_VAR 0 4
13475: PUSH
13476: LD_VAR 0 11
13480: DIFF
13481: ST_TO_ADDR
// end ; if tmp and sci < 6 then
13482: LD_VAR 0 4
13486: PUSH
13487: LD_VAR 0 8
13491: PUSH
13492: LD_INT 6
13494: LESS
13495: AND
13496: IFFALSE 13684
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
13498: LD_ADDR_VAR 0 9
13502: PUSH
13503: LD_VAR 0 4
13507: PUSH
13508: LD_VAR 0 8
13512: PUSH
13513: LD_VAR 0 7
13517: UNION
13518: DIFF
13519: PPUSH
13520: LD_INT 4
13522: PPUSH
13523: CALL 67031 0 2
13527: ST_TO_ADDR
// p := [ ] ;
13528: LD_ADDR_VAR 0 11
13532: PUSH
13533: EMPTY
13534: ST_TO_ADDR
// if sort then
13535: LD_VAR 0 9
13539: IFFALSE 13655
// for i = 1 to 6 - sci do
13541: LD_ADDR_VAR 0 3
13545: PUSH
13546: DOUBLE
13547: LD_INT 1
13549: DEC
13550: ST_TO_ADDR
13551: LD_INT 6
13553: PUSH
13554: LD_VAR 0 8
13558: MINUS
13559: PUSH
13560: FOR_TO
13561: IFFALSE 13653
// begin if i = sort then
13563: LD_VAR 0 3
13567: PUSH
13568: LD_VAR 0 9
13572: EQUAL
13573: IFFALSE 13577
// break ;
13575: GO 13653
// if GetClass ( i ) = 4 then
13577: LD_VAR 0 3
13581: PPUSH
13582: CALL_OW 257
13586: PUSH
13587: LD_INT 4
13589: EQUAL
13590: IFFALSE 13594
// continue ;
13592: GO 13560
// p := Insert ( p , p + 1 , sort [ i ] ) ;
13594: LD_ADDR_VAR 0 11
13598: PUSH
13599: LD_VAR 0 11
13603: PPUSH
13604: LD_VAR 0 11
13608: PUSH
13609: LD_INT 1
13611: PLUS
13612: PPUSH
13613: LD_VAR 0 9
13617: PUSH
13618: LD_VAR 0 3
13622: ARRAY
13623: PPUSH
13624: CALL_OW 2
13628: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
13629: LD_ADDR_VAR 0 4
13633: PUSH
13634: LD_VAR 0 4
13638: PUSH
13639: LD_VAR 0 9
13643: PUSH
13644: LD_VAR 0 3
13648: ARRAY
13649: DIFF
13650: ST_TO_ADDR
// end ;
13651: GO 13560
13653: POP
13654: POP
// if p then
13655: LD_VAR 0 11
13659: IFFALSE 13684
// result := Replace ( result , 4 , p ) ;
13661: LD_ADDR_VAR 0 2
13665: PUSH
13666: LD_VAR 0 2
13670: PPUSH
13671: LD_INT 4
13673: PPUSH
13674: LD_VAR 0 11
13678: PPUSH
13679: CALL_OW 1
13683: ST_TO_ADDR
// end ; if tmp and mech < 6 then
13684: LD_VAR 0 4
13688: PUSH
13689: LD_VAR 0 7
13693: PUSH
13694: LD_INT 6
13696: LESS
13697: AND
13698: IFFALSE 13886
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
13700: LD_ADDR_VAR 0 9
13704: PUSH
13705: LD_VAR 0 4
13709: PUSH
13710: LD_VAR 0 8
13714: PUSH
13715: LD_VAR 0 7
13719: UNION
13720: DIFF
13721: PPUSH
13722: LD_INT 3
13724: PPUSH
13725: CALL 67031 0 2
13729: ST_TO_ADDR
// p := [ ] ;
13730: LD_ADDR_VAR 0 11
13734: PUSH
13735: EMPTY
13736: ST_TO_ADDR
// if sort then
13737: LD_VAR 0 9
13741: IFFALSE 13857
// for i = 1 to 6 - mech do
13743: LD_ADDR_VAR 0 3
13747: PUSH
13748: DOUBLE
13749: LD_INT 1
13751: DEC
13752: ST_TO_ADDR
13753: LD_INT 6
13755: PUSH
13756: LD_VAR 0 7
13760: MINUS
13761: PUSH
13762: FOR_TO
13763: IFFALSE 13855
// begin if i = sort then
13765: LD_VAR 0 3
13769: PUSH
13770: LD_VAR 0 9
13774: EQUAL
13775: IFFALSE 13779
// break ;
13777: GO 13855
// if GetClass ( i ) = 3 then
13779: LD_VAR 0 3
13783: PPUSH
13784: CALL_OW 257
13788: PUSH
13789: LD_INT 3
13791: EQUAL
13792: IFFALSE 13796
// continue ;
13794: GO 13762
// p := Insert ( p , p + 1 , sort [ i ] ) ;
13796: LD_ADDR_VAR 0 11
13800: PUSH
13801: LD_VAR 0 11
13805: PPUSH
13806: LD_VAR 0 11
13810: PUSH
13811: LD_INT 1
13813: PLUS
13814: PPUSH
13815: LD_VAR 0 9
13819: PUSH
13820: LD_VAR 0 3
13824: ARRAY
13825: PPUSH
13826: CALL_OW 2
13830: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
13831: LD_ADDR_VAR 0 4
13835: PUSH
13836: LD_VAR 0 4
13840: PUSH
13841: LD_VAR 0 9
13845: PUSH
13846: LD_VAR 0 3
13850: ARRAY
13851: DIFF
13852: ST_TO_ADDR
// end ;
13853: GO 13762
13855: POP
13856: POP
// if p then
13857: LD_VAR 0 11
13861: IFFALSE 13886
// result := Replace ( result , 3 , p ) ;
13863: LD_ADDR_VAR 0 2
13867: PUSH
13868: LD_VAR 0 2
13872: PPUSH
13873: LD_INT 3
13875: PPUSH
13876: LD_VAR 0 11
13880: PPUSH
13881: CALL_OW 1
13885: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
13886: LD_VAR 0 4
13890: PUSH
13891: LD_INT 6
13893: GREATER
13894: PUSH
13895: LD_VAR 0 6
13899: PUSH
13900: LD_INT 6
13902: LESS
13903: AND
13904: IFFALSE 14098
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
13906: LD_ADDR_VAR 0 9
13910: PUSH
13911: LD_VAR 0 4
13915: PUSH
13916: LD_VAR 0 8
13920: PUSH
13921: LD_VAR 0 7
13925: UNION
13926: PUSH
13927: LD_VAR 0 6
13931: UNION
13932: DIFF
13933: PPUSH
13934: LD_INT 2
13936: PPUSH
13937: CALL 67031 0 2
13941: ST_TO_ADDR
// p := [ ] ;
13942: LD_ADDR_VAR 0 11
13946: PUSH
13947: EMPTY
13948: ST_TO_ADDR
// if sort then
13949: LD_VAR 0 9
13953: IFFALSE 14069
// for i = 1 to 6 - eng do
13955: LD_ADDR_VAR 0 3
13959: PUSH
13960: DOUBLE
13961: LD_INT 1
13963: DEC
13964: ST_TO_ADDR
13965: LD_INT 6
13967: PUSH
13968: LD_VAR 0 6
13972: MINUS
13973: PUSH
13974: FOR_TO
13975: IFFALSE 14067
// begin if i = sort then
13977: LD_VAR 0 3
13981: PUSH
13982: LD_VAR 0 9
13986: EQUAL
13987: IFFALSE 13991
// break ;
13989: GO 14067
// if GetClass ( i ) = 2 then
13991: LD_VAR 0 3
13995: PPUSH
13996: CALL_OW 257
14000: PUSH
14001: LD_INT 2
14003: EQUAL
14004: IFFALSE 14008
// continue ;
14006: GO 13974
// p := Insert ( p , p + 1 , sort [ i ] ) ;
14008: LD_ADDR_VAR 0 11
14012: PUSH
14013: LD_VAR 0 11
14017: PPUSH
14018: LD_VAR 0 11
14022: PUSH
14023: LD_INT 1
14025: PLUS
14026: PPUSH
14027: LD_VAR 0 9
14031: PUSH
14032: LD_VAR 0 3
14036: ARRAY
14037: PPUSH
14038: CALL_OW 2
14042: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
14043: LD_ADDR_VAR 0 4
14047: PUSH
14048: LD_VAR 0 4
14052: PUSH
14053: LD_VAR 0 9
14057: PUSH
14058: LD_VAR 0 3
14062: ARRAY
14063: DIFF
14064: ST_TO_ADDR
// end ;
14065: GO 13974
14067: POP
14068: POP
// if p then
14069: LD_VAR 0 11
14073: IFFALSE 14098
// result := Replace ( result , 2 , p ) ;
14075: LD_ADDR_VAR 0 2
14079: PUSH
14080: LD_VAR 0 2
14084: PPUSH
14085: LD_INT 2
14087: PPUSH
14088: LD_VAR 0 11
14092: PPUSH
14093: CALL_OW 1
14097: ST_TO_ADDR
// end ; exit ;
14098: GO 15486
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
14100: LD_EXP 79
14104: PUSH
14105: LD_EXP 78
14109: PUSH
14110: LD_VAR 0 1
14114: ARRAY
14115: ARRAY
14116: NOT
14117: PUSH
14118: LD_EXP 52
14122: PUSH
14123: LD_VAR 0 1
14127: ARRAY
14128: PPUSH
14129: LD_INT 30
14131: PUSH
14132: LD_INT 3
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: PPUSH
14139: CALL_OW 72
14143: AND
14144: PUSH
14145: LD_EXP 57
14149: PUSH
14150: LD_VAR 0 1
14154: ARRAY
14155: AND
14156: IFFALSE 14764
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
14158: LD_ADDR_EXP 94
14162: PUSH
14163: LD_EXP 94
14167: PPUSH
14168: LD_VAR 0 1
14172: PPUSH
14173: LD_INT 5
14175: PPUSH
14176: CALL_OW 1
14180: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
14181: LD_ADDR_VAR 0 2
14185: PUSH
14186: LD_INT 0
14188: PUSH
14189: LD_INT 0
14191: PUSH
14192: LD_INT 0
14194: PUSH
14195: LD_INT 0
14197: PUSH
14198: EMPTY
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: ST_TO_ADDR
// if sci > 1 then
14204: LD_VAR 0 8
14208: PUSH
14209: LD_INT 1
14211: GREATER
14212: IFFALSE 14240
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
14214: LD_ADDR_VAR 0 4
14218: PUSH
14219: LD_VAR 0 4
14223: PUSH
14224: LD_VAR 0 8
14228: PUSH
14229: LD_VAR 0 8
14233: PUSH
14234: LD_INT 1
14236: ARRAY
14237: DIFF
14238: DIFF
14239: ST_TO_ADDR
// if tmp and not sci then
14240: LD_VAR 0 4
14244: PUSH
14245: LD_VAR 0 8
14249: NOT
14250: AND
14251: IFFALSE 14320
// begin sort := SortBySkill ( tmp , 4 ) ;
14253: LD_ADDR_VAR 0 9
14257: PUSH
14258: LD_VAR 0 4
14262: PPUSH
14263: LD_INT 4
14265: PPUSH
14266: CALL 67031 0 2
14270: ST_TO_ADDR
// if sort then
14271: LD_VAR 0 9
14275: IFFALSE 14291
// p := sort [ 1 ] ;
14277: LD_ADDR_VAR 0 11
14281: PUSH
14282: LD_VAR 0 9
14286: PUSH
14287: LD_INT 1
14289: ARRAY
14290: ST_TO_ADDR
// if p then
14291: LD_VAR 0 11
14295: IFFALSE 14320
// result := Replace ( result , 4 , p ) ;
14297: LD_ADDR_VAR 0 2
14301: PUSH
14302: LD_VAR 0 2
14306: PPUSH
14307: LD_INT 4
14309: PPUSH
14310: LD_VAR 0 11
14314: PPUSH
14315: CALL_OW 1
14319: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
14320: LD_ADDR_VAR 0 4
14324: PUSH
14325: LD_VAR 0 4
14329: PUSH
14330: LD_VAR 0 7
14334: DIFF
14335: ST_TO_ADDR
// if tmp and mech < 6 then
14336: LD_VAR 0 4
14340: PUSH
14341: LD_VAR 0 7
14345: PUSH
14346: LD_INT 6
14348: LESS
14349: AND
14350: IFFALSE 14538
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
14352: LD_ADDR_VAR 0 9
14356: PUSH
14357: LD_VAR 0 4
14361: PUSH
14362: LD_VAR 0 8
14366: PUSH
14367: LD_VAR 0 7
14371: UNION
14372: DIFF
14373: PPUSH
14374: LD_INT 3
14376: PPUSH
14377: CALL 67031 0 2
14381: ST_TO_ADDR
// p := [ ] ;
14382: LD_ADDR_VAR 0 11
14386: PUSH
14387: EMPTY
14388: ST_TO_ADDR
// if sort then
14389: LD_VAR 0 9
14393: IFFALSE 14509
// for i = 1 to 6 - mech do
14395: LD_ADDR_VAR 0 3
14399: PUSH
14400: DOUBLE
14401: LD_INT 1
14403: DEC
14404: ST_TO_ADDR
14405: LD_INT 6
14407: PUSH
14408: LD_VAR 0 7
14412: MINUS
14413: PUSH
14414: FOR_TO
14415: IFFALSE 14507
// begin if i = sort then
14417: LD_VAR 0 3
14421: PUSH
14422: LD_VAR 0 9
14426: EQUAL
14427: IFFALSE 14431
// break ;
14429: GO 14507
// if GetClass ( i ) = 3 then
14431: LD_VAR 0 3
14435: PPUSH
14436: CALL_OW 257
14440: PUSH
14441: LD_INT 3
14443: EQUAL
14444: IFFALSE 14448
// continue ;
14446: GO 14414
// p := Insert ( p , p + 1 , sort [ i ] ) ;
14448: LD_ADDR_VAR 0 11
14452: PUSH
14453: LD_VAR 0 11
14457: PPUSH
14458: LD_VAR 0 11
14462: PUSH
14463: LD_INT 1
14465: PLUS
14466: PPUSH
14467: LD_VAR 0 9
14471: PUSH
14472: LD_VAR 0 3
14476: ARRAY
14477: PPUSH
14478: CALL_OW 2
14482: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
14483: LD_ADDR_VAR 0 4
14487: PUSH
14488: LD_VAR 0 4
14492: PUSH
14493: LD_VAR 0 9
14497: PUSH
14498: LD_VAR 0 3
14502: ARRAY
14503: DIFF
14504: ST_TO_ADDR
// end ;
14505: GO 14414
14507: POP
14508: POP
// if p then
14509: LD_VAR 0 11
14513: IFFALSE 14538
// result := Replace ( result , 3 , p ) ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_VAR 0 2
14524: PPUSH
14525: LD_INT 3
14527: PPUSH
14528: LD_VAR 0 11
14532: PPUSH
14533: CALL_OW 1
14537: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
14538: LD_ADDR_VAR 0 4
14542: PUSH
14543: LD_VAR 0 4
14547: PUSH
14548: LD_VAR 0 6
14552: DIFF
14553: ST_TO_ADDR
// if tmp and eng < 6 then
14554: LD_VAR 0 4
14558: PUSH
14559: LD_VAR 0 6
14563: PUSH
14564: LD_INT 6
14566: LESS
14567: AND
14568: IFFALSE 14762
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
14570: LD_ADDR_VAR 0 9
14574: PUSH
14575: LD_VAR 0 4
14579: PUSH
14580: LD_VAR 0 8
14584: PUSH
14585: LD_VAR 0 7
14589: UNION
14590: PUSH
14591: LD_VAR 0 6
14595: UNION
14596: DIFF
14597: PPUSH
14598: LD_INT 2
14600: PPUSH
14601: CALL 67031 0 2
14605: ST_TO_ADDR
// p := [ ] ;
14606: LD_ADDR_VAR 0 11
14610: PUSH
14611: EMPTY
14612: ST_TO_ADDR
// if sort then
14613: LD_VAR 0 9
14617: IFFALSE 14733
// for i = 1 to 6 - eng do
14619: LD_ADDR_VAR 0 3
14623: PUSH
14624: DOUBLE
14625: LD_INT 1
14627: DEC
14628: ST_TO_ADDR
14629: LD_INT 6
14631: PUSH
14632: LD_VAR 0 6
14636: MINUS
14637: PUSH
14638: FOR_TO
14639: IFFALSE 14731
// begin if i = sort then
14641: LD_VAR 0 3
14645: PUSH
14646: LD_VAR 0 9
14650: EQUAL
14651: IFFALSE 14655
// break ;
14653: GO 14731
// if GetClass ( i ) = 2 then
14655: LD_VAR 0 3
14659: PPUSH
14660: CALL_OW 257
14664: PUSH
14665: LD_INT 2
14667: EQUAL
14668: IFFALSE 14672
// continue ;
14670: GO 14638
// p := Insert ( p , p + 1 , sort [ i ] ) ;
14672: LD_ADDR_VAR 0 11
14676: PUSH
14677: LD_VAR 0 11
14681: PPUSH
14682: LD_VAR 0 11
14686: PUSH
14687: LD_INT 1
14689: PLUS
14690: PPUSH
14691: LD_VAR 0 9
14695: PUSH
14696: LD_VAR 0 3
14700: ARRAY
14701: PPUSH
14702: CALL_OW 2
14706: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
14707: LD_ADDR_VAR 0 4
14711: PUSH
14712: LD_VAR 0 4
14716: PUSH
14717: LD_VAR 0 9
14721: PUSH
14722: LD_VAR 0 3
14726: ARRAY
14727: DIFF
14728: ST_TO_ADDR
// end ;
14729: GO 14638
14731: POP
14732: POP
// if p then
14733: LD_VAR 0 11
14737: IFFALSE 14762
// result := Replace ( result , 2 , p ) ;
14739: LD_ADDR_VAR 0 2
14743: PUSH
14744: LD_VAR 0 2
14748: PPUSH
14749: LD_INT 2
14751: PPUSH
14752: LD_VAR 0 11
14756: PPUSH
14757: CALL_OW 1
14761: ST_TO_ADDR
// end ; exit ;
14762: GO 15486
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
14764: LD_EXP 79
14768: PUSH
14769: LD_EXP 78
14773: PUSH
14774: LD_VAR 0 1
14778: ARRAY
14779: ARRAY
14780: NOT
14781: PUSH
14782: LD_EXP 52
14786: PUSH
14787: LD_VAR 0 1
14791: ARRAY
14792: PPUSH
14793: LD_INT 30
14795: PUSH
14796: LD_INT 3
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PPUSH
14803: CALL_OW 72
14807: AND
14808: PUSH
14809: LD_EXP 57
14813: PUSH
14814: LD_VAR 0 1
14818: ARRAY
14819: NOT
14820: AND
14821: IFFALSE 15486
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
14823: LD_ADDR_EXP 94
14827: PUSH
14828: LD_EXP 94
14832: PPUSH
14833: LD_VAR 0 1
14837: PPUSH
14838: LD_INT 6
14840: PPUSH
14841: CALL_OW 1
14845: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
14846: LD_ADDR_VAR 0 2
14850: PUSH
14851: LD_INT 0
14853: PUSH
14854: LD_INT 0
14856: PUSH
14857: LD_INT 0
14859: PUSH
14860: LD_INT 0
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: ST_TO_ADDR
// if sci >= 1 then
14869: LD_VAR 0 8
14873: PUSH
14874: LD_INT 1
14876: GREATEREQUAL
14877: IFFALSE 14899
// tmp := tmp diff sci [ 1 ] ;
14879: LD_ADDR_VAR 0 4
14883: PUSH
14884: LD_VAR 0 4
14888: PUSH
14889: LD_VAR 0 8
14893: PUSH
14894: LD_INT 1
14896: ARRAY
14897: DIFF
14898: ST_TO_ADDR
// if tmp and not sci then
14899: LD_VAR 0 4
14903: PUSH
14904: LD_VAR 0 8
14908: NOT
14909: AND
14910: IFFALSE 14979
// begin sort := SortBySkill ( tmp , 4 ) ;
14912: LD_ADDR_VAR 0 9
14916: PUSH
14917: LD_VAR 0 4
14921: PPUSH
14922: LD_INT 4
14924: PPUSH
14925: CALL 67031 0 2
14929: ST_TO_ADDR
// if sort then
14930: LD_VAR 0 9
14934: IFFALSE 14950
// p := sort [ 1 ] ;
14936: LD_ADDR_VAR 0 11
14940: PUSH
14941: LD_VAR 0 9
14945: PUSH
14946: LD_INT 1
14948: ARRAY
14949: ST_TO_ADDR
// if p then
14950: LD_VAR 0 11
14954: IFFALSE 14979
// result := Replace ( result , 4 , p ) ;
14956: LD_ADDR_VAR 0 2
14960: PUSH
14961: LD_VAR 0 2
14965: PPUSH
14966: LD_INT 4
14968: PPUSH
14969: LD_VAR 0 11
14973: PPUSH
14974: CALL_OW 1
14978: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
14979: LD_ADDR_VAR 0 4
14983: PUSH
14984: LD_VAR 0 4
14988: PUSH
14989: LD_VAR 0 7
14993: DIFF
14994: ST_TO_ADDR
// if tmp and mech < 6 then
14995: LD_VAR 0 4
14999: PUSH
15000: LD_VAR 0 7
15004: PUSH
15005: LD_INT 6
15007: LESS
15008: AND
15009: IFFALSE 15191
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
15011: LD_ADDR_VAR 0 9
15015: PUSH
15016: LD_VAR 0 4
15020: PUSH
15021: LD_VAR 0 7
15025: DIFF
15026: PPUSH
15027: LD_INT 3
15029: PPUSH
15030: CALL 67031 0 2
15034: ST_TO_ADDR
// p := [ ] ;
15035: LD_ADDR_VAR 0 11
15039: PUSH
15040: EMPTY
15041: ST_TO_ADDR
// if sort then
15042: LD_VAR 0 9
15046: IFFALSE 15162
// for i = 1 to 6 - mech do
15048: LD_ADDR_VAR 0 3
15052: PUSH
15053: DOUBLE
15054: LD_INT 1
15056: DEC
15057: ST_TO_ADDR
15058: LD_INT 6
15060: PUSH
15061: LD_VAR 0 7
15065: MINUS
15066: PUSH
15067: FOR_TO
15068: IFFALSE 15160
// begin if i = sort then
15070: LD_VAR 0 3
15074: PUSH
15075: LD_VAR 0 9
15079: EQUAL
15080: IFFALSE 15084
// break ;
15082: GO 15160
// if GetClass ( i ) = 3 then
15084: LD_VAR 0 3
15088: PPUSH
15089: CALL_OW 257
15093: PUSH
15094: LD_INT 3
15096: EQUAL
15097: IFFALSE 15101
// continue ;
15099: GO 15067
// p := Insert ( p , p + 1 , sort [ i ] ) ;
15101: LD_ADDR_VAR 0 11
15105: PUSH
15106: LD_VAR 0 11
15110: PPUSH
15111: LD_VAR 0 11
15115: PUSH
15116: LD_INT 1
15118: PLUS
15119: PPUSH
15120: LD_VAR 0 9
15124: PUSH
15125: LD_VAR 0 3
15129: ARRAY
15130: PPUSH
15131: CALL_OW 2
15135: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
15136: LD_ADDR_VAR 0 4
15140: PUSH
15141: LD_VAR 0 4
15145: PUSH
15146: LD_VAR 0 9
15150: PUSH
15151: LD_VAR 0 3
15155: ARRAY
15156: DIFF
15157: ST_TO_ADDR
// end ;
15158: GO 15067
15160: POP
15161: POP
// if p then
15162: LD_VAR 0 11
15166: IFFALSE 15191
// result := Replace ( result , 3 , p ) ;
15168: LD_ADDR_VAR 0 2
15172: PUSH
15173: LD_VAR 0 2
15177: PPUSH
15178: LD_INT 3
15180: PPUSH
15181: LD_VAR 0 11
15185: PPUSH
15186: CALL_OW 1
15190: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
15191: LD_ADDR_VAR 0 4
15195: PUSH
15196: LD_VAR 0 4
15200: PUSH
15201: LD_VAR 0 6
15205: DIFF
15206: ST_TO_ADDR
// if tmp and eng < 4 then
15207: LD_VAR 0 4
15211: PUSH
15212: LD_VAR 0 6
15216: PUSH
15217: LD_INT 4
15219: LESS
15220: AND
15221: IFFALSE 15411
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
15223: LD_ADDR_VAR 0 9
15227: PUSH
15228: LD_VAR 0 4
15232: PUSH
15233: LD_VAR 0 7
15237: PUSH
15238: LD_VAR 0 6
15242: UNION
15243: DIFF
15244: PPUSH
15245: LD_INT 2
15247: PPUSH
15248: CALL 67031 0 2
15252: ST_TO_ADDR
// p := [ ] ;
15253: LD_ADDR_VAR 0 11
15257: PUSH
15258: EMPTY
15259: ST_TO_ADDR
// if sort then
15260: LD_VAR 0 9
15264: IFFALSE 15380
// for i = 1 to 4 - eng do
15266: LD_ADDR_VAR 0 3
15270: PUSH
15271: DOUBLE
15272: LD_INT 1
15274: DEC
15275: ST_TO_ADDR
15276: LD_INT 4
15278: PUSH
15279: LD_VAR 0 6
15283: MINUS
15284: PUSH
15285: FOR_TO
15286: IFFALSE 15378
// begin if i = sort then
15288: LD_VAR 0 3
15292: PUSH
15293: LD_VAR 0 9
15297: EQUAL
15298: IFFALSE 15302
// break ;
15300: GO 15378
// if GetClass ( i ) = 2 then
15302: LD_VAR 0 3
15306: PPUSH
15307: CALL_OW 257
15311: PUSH
15312: LD_INT 2
15314: EQUAL
15315: IFFALSE 15319
// continue ;
15317: GO 15285
// p := Insert ( p , p + 1 , sort [ i ] ) ;
15319: LD_ADDR_VAR 0 11
15323: PUSH
15324: LD_VAR 0 11
15328: PPUSH
15329: LD_VAR 0 11
15333: PUSH
15334: LD_INT 1
15336: PLUS
15337: PPUSH
15338: LD_VAR 0 9
15342: PUSH
15343: LD_VAR 0 3
15347: ARRAY
15348: PPUSH
15349: CALL_OW 2
15353: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
15354: LD_ADDR_VAR 0 4
15358: PUSH
15359: LD_VAR 0 4
15363: PUSH
15364: LD_VAR 0 9
15368: PUSH
15369: LD_VAR 0 3
15373: ARRAY
15374: DIFF
15375: ST_TO_ADDR
// end ;
15376: GO 15285
15378: POP
15379: POP
// if p then
15380: LD_VAR 0 11
15384: IFFALSE 15409
// result := Replace ( result , 2 , p ) ;
15386: LD_ADDR_VAR 0 2
15390: PUSH
15391: LD_VAR 0 2
15395: PPUSH
15396: LD_INT 2
15398: PPUSH
15399: LD_VAR 0 11
15403: PPUSH
15404: CALL_OW 1
15408: ST_TO_ADDR
// end else
15409: GO 15455
// for i = eng downto 5 do
15411: LD_ADDR_VAR 0 3
15415: PUSH
15416: DOUBLE
15417: LD_VAR 0 6
15421: INC
15422: ST_TO_ADDR
15423: LD_INT 5
15425: PUSH
15426: FOR_DOWNTO
15427: IFFALSE 15453
// tmp := tmp union eng [ i ] ;
15429: LD_ADDR_VAR 0 4
15433: PUSH
15434: LD_VAR 0 4
15438: PUSH
15439: LD_VAR 0 6
15443: PUSH
15444: LD_VAR 0 3
15448: ARRAY
15449: UNION
15450: ST_TO_ADDR
15451: GO 15426
15453: POP
15454: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
15455: LD_ADDR_VAR 0 2
15459: PUSH
15460: LD_VAR 0 2
15464: PPUSH
15465: LD_INT 1
15467: PPUSH
15468: LD_VAR 0 4
15472: PUSH
15473: LD_VAR 0 5
15477: DIFF
15478: PPUSH
15479: CALL_OW 1
15483: ST_TO_ADDR
// exit ;
15484: GO 15486
// end ; end ;
15486: LD_VAR 0 2
15490: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
15491: LD_INT 0
15493: PPUSH
15494: PPUSH
15495: PPUSH
// if not mc_bases then
15496: LD_EXP 52
15500: NOT
15501: IFFALSE 15505
// exit ;
15503: GO 15611
// for i = 1 to mc_bases do
15505: LD_ADDR_VAR 0 2
15509: PUSH
15510: DOUBLE
15511: LD_INT 1
15513: DEC
15514: ST_TO_ADDR
15515: LD_EXP 52
15519: PUSH
15520: FOR_TO
15521: IFFALSE 15602
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
15523: LD_ADDR_VAR 0 3
15527: PUSH
15528: LD_EXP 52
15532: PUSH
15533: LD_VAR 0 2
15537: ARRAY
15538: PPUSH
15539: LD_INT 21
15541: PUSH
15542: LD_INT 3
15544: PUSH
15545: EMPTY
15546: LIST
15547: LIST
15548: PUSH
15549: LD_INT 3
15551: PUSH
15552: LD_INT 24
15554: PUSH
15555: LD_INT 1000
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PPUSH
15570: CALL_OW 72
15574: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
15575: LD_ADDR_EXP 53
15579: PUSH
15580: LD_EXP 53
15584: PPUSH
15585: LD_VAR 0 2
15589: PPUSH
15590: LD_VAR 0 3
15594: PPUSH
15595: CALL_OW 1
15599: ST_TO_ADDR
// end ;
15600: GO 15520
15602: POP
15603: POP
// RaiseSailEvent ( 101 ) ;
15604: LD_INT 101
15606: PPUSH
15607: CALL_OW 427
// end ;
15611: LD_VAR 0 1
15615: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
15616: LD_INT 0
15618: PPUSH
15619: PPUSH
15620: PPUSH
15621: PPUSH
15622: PPUSH
15623: PPUSH
15624: PPUSH
// if not mc_bases then
15625: LD_EXP 52
15629: NOT
15630: IFFALSE 15634
// exit ;
15632: GO 16196
// for i = 1 to mc_bases do
15634: LD_ADDR_VAR 0 2
15638: PUSH
15639: DOUBLE
15640: LD_INT 1
15642: DEC
15643: ST_TO_ADDR
15644: LD_EXP 52
15648: PUSH
15649: FOR_TO
15650: IFFALSE 16187
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
15652: LD_ADDR_VAR 0 5
15656: PUSH
15657: LD_EXP 52
15661: PUSH
15662: LD_VAR 0 2
15666: ARRAY
15667: PUSH
15668: LD_EXP 81
15672: PUSH
15673: LD_VAR 0 2
15677: ARRAY
15678: UNION
15679: PPUSH
15680: LD_INT 21
15682: PUSH
15683: LD_INT 1
15685: PUSH
15686: EMPTY
15687: LIST
15688: LIST
15689: PUSH
15690: LD_INT 1
15692: PUSH
15693: LD_INT 3
15695: PUSH
15696: LD_INT 54
15698: PUSH
15699: EMPTY
15700: LIST
15701: PUSH
15702: EMPTY
15703: LIST
15704: LIST
15705: PUSH
15706: LD_INT 3
15708: PUSH
15709: LD_INT 24
15711: PUSH
15712: LD_INT 800
15714: PUSH
15715: EMPTY
15716: LIST
15717: LIST
15718: PUSH
15719: EMPTY
15720: LIST
15721: LIST
15722: PUSH
15723: EMPTY
15724: LIST
15725: LIST
15726: LIST
15727: PUSH
15728: EMPTY
15729: LIST
15730: LIST
15731: PPUSH
15732: CALL_OW 72
15736: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
15737: LD_ADDR_VAR 0 6
15741: PUSH
15742: LD_EXP 52
15746: PUSH
15747: LD_VAR 0 2
15751: ARRAY
15752: PPUSH
15753: LD_INT 21
15755: PUSH
15756: LD_INT 1
15758: PUSH
15759: EMPTY
15760: LIST
15761: LIST
15762: PUSH
15763: LD_INT 1
15765: PUSH
15766: LD_INT 3
15768: PUSH
15769: LD_INT 54
15771: PUSH
15772: EMPTY
15773: LIST
15774: PUSH
15775: EMPTY
15776: LIST
15777: LIST
15778: PUSH
15779: LD_INT 3
15781: PUSH
15782: LD_INT 24
15784: PUSH
15785: LD_INT 250
15787: PUSH
15788: EMPTY
15789: LIST
15790: LIST
15791: PUSH
15792: EMPTY
15793: LIST
15794: LIST
15795: PUSH
15796: EMPTY
15797: LIST
15798: LIST
15799: LIST
15800: PUSH
15801: EMPTY
15802: LIST
15803: LIST
15804: PPUSH
15805: CALL_OW 72
15809: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
15810: LD_ADDR_VAR 0 7
15814: PUSH
15815: LD_VAR 0 5
15819: PUSH
15820: LD_VAR 0 6
15824: DIFF
15825: ST_TO_ADDR
// if not need_heal_1 then
15826: LD_VAR 0 6
15830: NOT
15831: IFFALSE 15864
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
15833: LD_ADDR_EXP 55
15837: PUSH
15838: LD_EXP 55
15842: PPUSH
15843: LD_VAR 0 2
15847: PUSH
15848: LD_INT 1
15850: PUSH
15851: EMPTY
15852: LIST
15853: LIST
15854: PPUSH
15855: EMPTY
15856: PPUSH
15857: CALL 37482 0 3
15861: ST_TO_ADDR
15862: GO 15934
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
15864: LD_ADDR_EXP 55
15868: PUSH
15869: LD_EXP 55
15873: PPUSH
15874: LD_VAR 0 2
15878: PUSH
15879: LD_INT 1
15881: PUSH
15882: EMPTY
15883: LIST
15884: LIST
15885: PPUSH
15886: LD_EXP 55
15890: PUSH
15891: LD_VAR 0 2
15895: ARRAY
15896: PUSH
15897: LD_INT 1
15899: ARRAY
15900: PPUSH
15901: LD_INT 3
15903: PUSH
15904: LD_INT 24
15906: PUSH
15907: LD_INT 1000
15909: PUSH
15910: EMPTY
15911: LIST
15912: LIST
15913: PUSH
15914: EMPTY
15915: LIST
15916: LIST
15917: PPUSH
15918: CALL_OW 72
15922: PUSH
15923: LD_VAR 0 6
15927: UNION
15928: PPUSH
15929: CALL 37482 0 3
15933: ST_TO_ADDR
// if not need_heal_2 then
15934: LD_VAR 0 7
15938: NOT
15939: IFFALSE 15972
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
15941: LD_ADDR_EXP 55
15945: PUSH
15946: LD_EXP 55
15950: PPUSH
15951: LD_VAR 0 2
15955: PUSH
15956: LD_INT 2
15958: PUSH
15959: EMPTY
15960: LIST
15961: LIST
15962: PPUSH
15963: EMPTY
15964: PPUSH
15965: CALL 37482 0 3
15969: ST_TO_ADDR
15970: GO 16004
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
15972: LD_ADDR_EXP 55
15976: PUSH
15977: LD_EXP 55
15981: PPUSH
15982: LD_VAR 0 2
15986: PUSH
15987: LD_INT 2
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PPUSH
15994: LD_VAR 0 7
15998: PPUSH
15999: CALL 37482 0 3
16003: ST_TO_ADDR
// if need_heal_2 then
16004: LD_VAR 0 7
16008: IFFALSE 16169
// for j in need_heal_2 do
16010: LD_ADDR_VAR 0 3
16014: PUSH
16015: LD_VAR 0 7
16019: PUSH
16020: FOR_IN
16021: IFFALSE 16167
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
16023: LD_ADDR_VAR 0 5
16027: PUSH
16028: LD_EXP 52
16032: PUSH
16033: LD_VAR 0 2
16037: ARRAY
16038: PPUSH
16039: LD_INT 2
16041: PUSH
16042: LD_INT 30
16044: PUSH
16045: LD_INT 6
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: PUSH
16052: LD_INT 30
16054: PUSH
16055: LD_INT 7
16057: PUSH
16058: EMPTY
16059: LIST
16060: LIST
16061: PUSH
16062: LD_INT 30
16064: PUSH
16065: LD_INT 8
16067: PUSH
16068: EMPTY
16069: LIST
16070: LIST
16071: PUSH
16072: LD_INT 30
16074: PUSH
16075: LD_INT 0
16077: PUSH
16078: EMPTY
16079: LIST
16080: LIST
16081: PUSH
16082: LD_INT 30
16084: PUSH
16085: LD_INT 1
16087: PUSH
16088: EMPTY
16089: LIST
16090: LIST
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: LIST
16096: LIST
16097: LIST
16098: LIST
16099: PPUSH
16100: CALL_OW 72
16104: ST_TO_ADDR
// if tmp then
16105: LD_VAR 0 5
16109: IFFALSE 16165
// begin k := NearestUnitToUnit ( tmp , j ) ;
16111: LD_ADDR_VAR 0 4
16115: PUSH
16116: LD_VAR 0 5
16120: PPUSH
16121: LD_VAR 0 3
16125: PPUSH
16126: CALL_OW 74
16130: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
16131: LD_VAR 0 3
16135: PPUSH
16136: LD_VAR 0 4
16140: PPUSH
16141: CALL_OW 296
16145: PUSH
16146: LD_INT 5
16148: GREATER
16149: IFFALSE 16165
// ComMoveUnit ( j , k ) ;
16151: LD_VAR 0 3
16155: PPUSH
16156: LD_VAR 0 4
16160: PPUSH
16161: CALL_OW 112
// end ; end ;
16165: GO 16020
16167: POP
16168: POP
// if not need_heal_1 and not need_heal_2 then
16169: LD_VAR 0 6
16173: NOT
16174: PUSH
16175: LD_VAR 0 7
16179: NOT
16180: AND
16181: IFFALSE 16185
// continue ;
16183: GO 15649
// end ;
16185: GO 15649
16187: POP
16188: POP
// RaiseSailEvent ( 102 ) ;
16189: LD_INT 102
16191: PPUSH
16192: CALL_OW 427
// end ;
16196: LD_VAR 0 1
16200: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
16201: LD_INT 0
16203: PPUSH
16204: PPUSH
16205: PPUSH
16206: PPUSH
16207: PPUSH
16208: PPUSH
16209: PPUSH
16210: PPUSH
// if not mc_bases then
16211: LD_EXP 52
16215: NOT
16216: IFFALSE 16220
// exit ;
16218: GO 17055
// for i = 1 to mc_bases do
16220: LD_ADDR_VAR 0 2
16224: PUSH
16225: DOUBLE
16226: LD_INT 1
16228: DEC
16229: ST_TO_ADDR
16230: LD_EXP 52
16234: PUSH
16235: FOR_TO
16236: IFFALSE 17053
// begin if not mc_building_need_repair [ i ] then
16238: LD_EXP 53
16242: PUSH
16243: LD_VAR 0 2
16247: ARRAY
16248: NOT
16249: IFFALSE 16423
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
16251: LD_ADDR_VAR 0 6
16255: PUSH
16256: LD_EXP 71
16260: PUSH
16261: LD_VAR 0 2
16265: ARRAY
16266: PPUSH
16267: LD_INT 3
16269: PUSH
16270: LD_INT 24
16272: PUSH
16273: LD_INT 1000
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: PUSH
16284: LD_INT 2
16286: PUSH
16287: LD_INT 34
16289: PUSH
16290: LD_INT 13
16292: PUSH
16293: EMPTY
16294: LIST
16295: LIST
16296: PUSH
16297: LD_INT 34
16299: PUSH
16300: LD_INT 52
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: LIST
16311: PUSH
16312: EMPTY
16313: LIST
16314: LIST
16315: PPUSH
16316: CALL_OW 72
16320: ST_TO_ADDR
// if cranes then
16321: LD_VAR 0 6
16325: IFFALSE 16387
// for j in cranes do
16327: LD_ADDR_VAR 0 3
16331: PUSH
16332: LD_VAR 0 6
16336: PUSH
16337: FOR_IN
16338: IFFALSE 16385
// if not IsInArea ( j , mc_parking [ i ] ) then
16340: LD_VAR 0 3
16344: PPUSH
16345: LD_EXP 76
16349: PUSH
16350: LD_VAR 0 2
16354: ARRAY
16355: PPUSH
16356: CALL_OW 308
16360: NOT
16361: IFFALSE 16383
// ComMoveToArea ( j , mc_parking [ i ] ) ;
16363: LD_VAR 0 3
16367: PPUSH
16368: LD_EXP 76
16372: PUSH
16373: LD_VAR 0 2
16377: ARRAY
16378: PPUSH
16379: CALL_OW 113
16383: GO 16337
16385: POP
16386: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
16387: LD_ADDR_EXP 54
16391: PUSH
16392: LD_EXP 54
16396: PPUSH
16397: LD_VAR 0 2
16401: PPUSH
16402: EMPTY
16403: PPUSH
16404: CALL_OW 1
16408: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
16409: LD_VAR 0 2
16413: PPUSH
16414: LD_INT 101
16416: PPUSH
16417: CALL 11324 0 2
// continue ;
16421: GO 16235
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
16423: LD_ADDR_EXP 58
16427: PUSH
16428: LD_EXP 58
16432: PPUSH
16433: LD_VAR 0 2
16437: PPUSH
16438: EMPTY
16439: PPUSH
16440: CALL_OW 1
16444: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
16445: LD_VAR 0 2
16449: PPUSH
16450: LD_INT 103
16452: PPUSH
16453: CALL 11324 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
16457: LD_ADDR_VAR 0 5
16461: PUSH
16462: LD_EXP 52
16466: PUSH
16467: LD_VAR 0 2
16471: ARRAY
16472: PUSH
16473: LD_EXP 81
16477: PUSH
16478: LD_VAR 0 2
16482: ARRAY
16483: UNION
16484: PPUSH
16485: LD_INT 2
16487: PUSH
16488: LD_INT 25
16490: PUSH
16491: LD_INT 2
16493: PUSH
16494: EMPTY
16495: LIST
16496: LIST
16497: PUSH
16498: LD_INT 25
16500: PUSH
16501: LD_INT 16
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: LIST
16512: PUSH
16513: EMPTY
16514: LIST
16515: PPUSH
16516: CALL_OW 72
16520: PUSH
16521: LD_EXP 55
16525: PUSH
16526: LD_VAR 0 2
16530: ARRAY
16531: PUSH
16532: LD_INT 1
16534: ARRAY
16535: PUSH
16536: LD_EXP 55
16540: PUSH
16541: LD_VAR 0 2
16545: ARRAY
16546: PUSH
16547: LD_INT 2
16549: ARRAY
16550: UNION
16551: DIFF
16552: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
16553: LD_ADDR_VAR 0 6
16557: PUSH
16558: LD_EXP 71
16562: PUSH
16563: LD_VAR 0 2
16567: ARRAY
16568: PPUSH
16569: LD_INT 2
16571: PUSH
16572: LD_INT 34
16574: PUSH
16575: LD_INT 13
16577: PUSH
16578: EMPTY
16579: LIST
16580: LIST
16581: PUSH
16582: LD_INT 34
16584: PUSH
16585: LD_INT 52
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: PUSH
16592: EMPTY
16593: LIST
16594: LIST
16595: LIST
16596: PPUSH
16597: CALL_OW 72
16601: ST_TO_ADDR
// if cranes then
16602: LD_VAR 0 6
16606: IFFALSE 16742
// begin for j in cranes do
16608: LD_ADDR_VAR 0 3
16612: PUSH
16613: LD_VAR 0 6
16617: PUSH
16618: FOR_IN
16619: IFFALSE 16740
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
16621: LD_VAR 0 3
16625: PPUSH
16626: CALL_OW 256
16630: PUSH
16631: LD_INT 500
16633: GREATEREQUAL
16634: PUSH
16635: LD_VAR 0 3
16639: PPUSH
16640: CALL_OW 314
16644: NOT
16645: AND
16646: IFFALSE 16680
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
16648: LD_VAR 0 3
16652: PPUSH
16653: LD_EXP 53
16657: PUSH
16658: LD_VAR 0 2
16662: ARRAY
16663: PPUSH
16664: LD_VAR 0 3
16668: PPUSH
16669: CALL_OW 74
16673: PPUSH
16674: CALL_OW 130
16678: GO 16738
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
16680: LD_VAR 0 3
16684: PPUSH
16685: CALL_OW 256
16689: PUSH
16690: LD_INT 500
16692: LESS
16693: PUSH
16694: LD_VAR 0 3
16698: PPUSH
16699: LD_EXP 76
16703: PUSH
16704: LD_VAR 0 2
16708: ARRAY
16709: PPUSH
16710: CALL_OW 308
16714: NOT
16715: AND
16716: IFFALSE 16738
// ComMoveToArea ( j , mc_parking [ i ] ) ;
16718: LD_VAR 0 3
16722: PPUSH
16723: LD_EXP 76
16727: PUSH
16728: LD_VAR 0 2
16732: ARRAY
16733: PPUSH
16734: CALL_OW 113
16738: GO 16618
16740: POP
16741: POP
// end ; if tmp > 3 then
16742: LD_VAR 0 5
16746: PUSH
16747: LD_INT 3
16749: GREATER
16750: IFFALSE 16770
// tmp := ShrinkArray ( tmp , 4 ) ;
16752: LD_ADDR_VAR 0 5
16756: PUSH
16757: LD_VAR 0 5
16761: PPUSH
16762: LD_INT 4
16764: PPUSH
16765: CALL 68708 0 2
16769: ST_TO_ADDR
// if not tmp then
16770: LD_VAR 0 5
16774: NOT
16775: IFFALSE 16779
// continue ;
16777: GO 16235
// for j in tmp do
16779: LD_ADDR_VAR 0 3
16783: PUSH
16784: LD_VAR 0 5
16788: PUSH
16789: FOR_IN
16790: IFFALSE 17049
// begin if IsInUnit ( j ) then
16792: LD_VAR 0 3
16796: PPUSH
16797: CALL_OW 310
16801: IFFALSE 16812
// ComExitBuilding ( j ) ;
16803: LD_VAR 0 3
16807: PPUSH
16808: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
16812: LD_VAR 0 3
16816: PUSH
16817: LD_EXP 54
16821: PUSH
16822: LD_VAR 0 2
16826: ARRAY
16827: IN
16828: NOT
16829: IFFALSE 16887
// begin SetTag ( j , 101 ) ;
16831: LD_VAR 0 3
16835: PPUSH
16836: LD_INT 101
16838: PPUSH
16839: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
16843: LD_ADDR_EXP 54
16847: PUSH
16848: LD_EXP 54
16852: PPUSH
16853: LD_VAR 0 2
16857: PUSH
16858: LD_EXP 54
16862: PUSH
16863: LD_VAR 0 2
16867: ARRAY
16868: PUSH
16869: LD_INT 1
16871: PLUS
16872: PUSH
16873: EMPTY
16874: LIST
16875: LIST
16876: PPUSH
16877: LD_VAR 0 3
16881: PPUSH
16882: CALL 37482 0 3
16886: ST_TO_ADDR
// end ; wait ( 1 ) ;
16887: LD_INT 1
16889: PPUSH
16890: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
16894: LD_ADDR_VAR 0 7
16898: PUSH
16899: LD_EXP 53
16903: PUSH
16904: LD_VAR 0 2
16908: ARRAY
16909: ST_TO_ADDR
// if mc_scan [ i ] then
16910: LD_EXP 75
16914: PUSH
16915: LD_VAR 0 2
16919: ARRAY
16920: IFFALSE 16982
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
16922: LD_ADDR_VAR 0 7
16926: PUSH
16927: LD_EXP 53
16931: PUSH
16932: LD_VAR 0 2
16936: ARRAY
16937: PPUSH
16938: LD_INT 3
16940: PUSH
16941: LD_INT 30
16943: PUSH
16944: LD_INT 32
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PUSH
16951: LD_INT 30
16953: PUSH
16954: LD_INT 33
16956: PUSH
16957: EMPTY
16958: LIST
16959: LIST
16960: PUSH
16961: LD_INT 30
16963: PUSH
16964: LD_INT 31
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: PPUSH
16977: CALL_OW 72
16981: ST_TO_ADDR
// if not to_repair_tmp then
16982: LD_VAR 0 7
16986: NOT
16987: IFFALSE 16991
// continue ;
16989: GO 16789
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
16991: LD_ADDR_VAR 0 8
16995: PUSH
16996: LD_VAR 0 7
17000: PPUSH
17001: LD_VAR 0 3
17005: PPUSH
17006: CALL_OW 74
17010: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
17011: LD_VAR 0 8
17015: PPUSH
17016: LD_INT 16
17018: PPUSH
17019: CALL 40075 0 2
17023: PUSH
17024: LD_INT 4
17026: ARRAY
17027: PUSH
17028: LD_INT 5
17030: LESS
17031: IFFALSE 17047
// ComRepairBuilding ( j , to_repair ) ;
17033: LD_VAR 0 3
17037: PPUSH
17038: LD_VAR 0 8
17042: PPUSH
17043: CALL_OW 130
// end ;
17047: GO 16789
17049: POP
17050: POP
// end ;
17051: GO 16235
17053: POP
17054: POP
// end ;
17055: LD_VAR 0 1
17059: RET
// export function MC_Heal ; var i , j , tmp ; begin
17060: LD_INT 0
17062: PPUSH
17063: PPUSH
17064: PPUSH
17065: PPUSH
// if not mc_bases then
17066: LD_EXP 52
17070: NOT
17071: IFFALSE 17075
// exit ;
17073: GO 17477
// for i = 1 to mc_bases do
17075: LD_ADDR_VAR 0 2
17079: PUSH
17080: DOUBLE
17081: LD_INT 1
17083: DEC
17084: ST_TO_ADDR
17085: LD_EXP 52
17089: PUSH
17090: FOR_TO
17091: IFFALSE 17475
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
17093: LD_EXP 55
17097: PUSH
17098: LD_VAR 0 2
17102: ARRAY
17103: PUSH
17104: LD_INT 1
17106: ARRAY
17107: NOT
17108: PUSH
17109: LD_EXP 55
17113: PUSH
17114: LD_VAR 0 2
17118: ARRAY
17119: PUSH
17120: LD_INT 2
17122: ARRAY
17123: NOT
17124: AND
17125: IFFALSE 17163
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
17127: LD_ADDR_EXP 56
17131: PUSH
17132: LD_EXP 56
17136: PPUSH
17137: LD_VAR 0 2
17141: PPUSH
17142: EMPTY
17143: PPUSH
17144: CALL_OW 1
17148: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
17149: LD_VAR 0 2
17153: PPUSH
17154: LD_INT 102
17156: PPUSH
17157: CALL 11324 0 2
// continue ;
17161: GO 17090
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
17163: LD_ADDR_VAR 0 4
17167: PUSH
17168: LD_EXP 52
17172: PUSH
17173: LD_VAR 0 2
17177: ARRAY
17178: PPUSH
17179: LD_INT 25
17181: PUSH
17182: LD_INT 4
17184: PUSH
17185: EMPTY
17186: LIST
17187: LIST
17188: PPUSH
17189: CALL_OW 72
17193: ST_TO_ADDR
// if not tmp then
17194: LD_VAR 0 4
17198: NOT
17199: IFFALSE 17203
// continue ;
17201: GO 17090
// if mc_taming [ i ] then
17203: LD_EXP 83
17207: PUSH
17208: LD_VAR 0 2
17212: ARRAY
17213: IFFALSE 17237
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
17215: LD_ADDR_EXP 83
17219: PUSH
17220: LD_EXP 83
17224: PPUSH
17225: LD_VAR 0 2
17229: PPUSH
17230: EMPTY
17231: PPUSH
17232: CALL_OW 1
17236: ST_TO_ADDR
// for j in tmp do
17237: LD_ADDR_VAR 0 3
17241: PUSH
17242: LD_VAR 0 4
17246: PUSH
17247: FOR_IN
17248: IFFALSE 17471
// begin if IsInUnit ( j ) then
17250: LD_VAR 0 3
17254: PPUSH
17255: CALL_OW 310
17259: IFFALSE 17270
// ComExitBuilding ( j ) ;
17261: LD_VAR 0 3
17265: PPUSH
17266: CALL_OW 122
// if not j in mc_healers [ i ] then
17270: LD_VAR 0 3
17274: PUSH
17275: LD_EXP 56
17279: PUSH
17280: LD_VAR 0 2
17284: ARRAY
17285: IN
17286: NOT
17287: IFFALSE 17333
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
17289: LD_ADDR_EXP 56
17293: PUSH
17294: LD_EXP 56
17298: PPUSH
17299: LD_VAR 0 2
17303: PUSH
17304: LD_EXP 56
17308: PUSH
17309: LD_VAR 0 2
17313: ARRAY
17314: PUSH
17315: LD_INT 1
17317: PLUS
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PPUSH
17323: LD_VAR 0 3
17327: PPUSH
17328: CALL 37482 0 3
17332: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
17333: LD_VAR 0 3
17337: PPUSH
17338: CALL_OW 110
17342: PUSH
17343: LD_INT 102
17345: NONEQUAL
17346: IFFALSE 17360
// SetTag ( j , 102 ) ;
17348: LD_VAR 0 3
17352: PPUSH
17353: LD_INT 102
17355: PPUSH
17356: CALL_OW 109
// Wait ( 3 ) ;
17360: LD_INT 3
17362: PPUSH
17363: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
17367: LD_EXP 55
17371: PUSH
17372: LD_VAR 0 2
17376: ARRAY
17377: PUSH
17378: LD_INT 1
17380: ARRAY
17381: IFFALSE 17413
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
17383: LD_VAR 0 3
17387: PPUSH
17388: LD_EXP 55
17392: PUSH
17393: LD_VAR 0 2
17397: ARRAY
17398: PUSH
17399: LD_INT 1
17401: ARRAY
17402: PUSH
17403: LD_INT 1
17405: ARRAY
17406: PPUSH
17407: CALL_OW 128
17411: GO 17469
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
17413: LD_VAR 0 3
17417: PPUSH
17418: CALL_OW 314
17422: NOT
17423: PUSH
17424: LD_EXP 55
17428: PUSH
17429: LD_VAR 0 2
17433: ARRAY
17434: PUSH
17435: LD_INT 2
17437: ARRAY
17438: AND
17439: IFFALSE 17469
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
17441: LD_VAR 0 3
17445: PPUSH
17446: LD_EXP 55
17450: PUSH
17451: LD_VAR 0 2
17455: ARRAY
17456: PUSH
17457: LD_INT 2
17459: ARRAY
17460: PUSH
17461: LD_INT 1
17463: ARRAY
17464: PPUSH
17465: CALL_OW 128
// end ;
17469: GO 17247
17471: POP
17472: POP
// end ;
17473: GO 17090
17475: POP
17476: POP
// end ;
17477: LD_VAR 0 1
17481: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
17482: LD_INT 0
17484: PPUSH
17485: PPUSH
17486: PPUSH
17487: PPUSH
17488: PPUSH
// if not mc_bases then
17489: LD_EXP 52
17493: NOT
17494: IFFALSE 17498
// exit ;
17496: GO 18641
// for i = 1 to mc_bases do
17498: LD_ADDR_VAR 0 2
17502: PUSH
17503: DOUBLE
17504: LD_INT 1
17506: DEC
17507: ST_TO_ADDR
17508: LD_EXP 52
17512: PUSH
17513: FOR_TO
17514: IFFALSE 18639
// begin if mc_scan [ i ] then
17516: LD_EXP 75
17520: PUSH
17521: LD_VAR 0 2
17525: ARRAY
17526: IFFALSE 17530
// continue ;
17528: GO 17513
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
17530: LD_EXP 57
17534: PUSH
17535: LD_VAR 0 2
17539: ARRAY
17540: NOT
17541: PUSH
17542: LD_EXP 59
17546: PUSH
17547: LD_VAR 0 2
17551: ARRAY
17552: NOT
17553: AND
17554: PUSH
17555: LD_EXP 58
17559: PUSH
17560: LD_VAR 0 2
17564: ARRAY
17565: AND
17566: IFFALSE 17604
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
17568: LD_ADDR_EXP 58
17572: PUSH
17573: LD_EXP 58
17577: PPUSH
17578: LD_VAR 0 2
17582: PPUSH
17583: EMPTY
17584: PPUSH
17585: CALL_OW 1
17589: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
17590: LD_VAR 0 2
17594: PPUSH
17595: LD_INT 103
17597: PPUSH
17598: CALL 11324 0 2
// continue ;
17602: GO 17513
// end ; if mc_construct_list [ i ] then
17604: LD_EXP 59
17608: PUSH
17609: LD_VAR 0 2
17613: ARRAY
17614: IFFALSE 17834
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
17616: LD_ADDR_VAR 0 4
17620: PUSH
17621: LD_EXP 52
17625: PUSH
17626: LD_VAR 0 2
17630: ARRAY
17631: PPUSH
17632: LD_INT 25
17634: PUSH
17635: LD_INT 2
17637: PUSH
17638: EMPTY
17639: LIST
17640: LIST
17641: PPUSH
17642: CALL_OW 72
17646: PUSH
17647: LD_EXP 54
17651: PUSH
17652: LD_VAR 0 2
17656: ARRAY
17657: DIFF
17658: ST_TO_ADDR
// if not tmp then
17659: LD_VAR 0 4
17663: NOT
17664: IFFALSE 17668
// continue ;
17666: GO 17513
// for j in tmp do
17668: LD_ADDR_VAR 0 3
17672: PUSH
17673: LD_VAR 0 4
17677: PUSH
17678: FOR_IN
17679: IFFALSE 17830
// begin if not mc_builders [ i ] then
17681: LD_EXP 58
17685: PUSH
17686: LD_VAR 0 2
17690: ARRAY
17691: NOT
17692: IFFALSE 17750
// begin SetTag ( j , 103 ) ;
17694: LD_VAR 0 3
17698: PPUSH
17699: LD_INT 103
17701: PPUSH
17702: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
17706: LD_ADDR_EXP 58
17710: PUSH
17711: LD_EXP 58
17715: PPUSH
17716: LD_VAR 0 2
17720: PUSH
17721: LD_EXP 58
17725: PUSH
17726: LD_VAR 0 2
17730: ARRAY
17731: PUSH
17732: LD_INT 1
17734: PLUS
17735: PUSH
17736: EMPTY
17737: LIST
17738: LIST
17739: PPUSH
17740: LD_VAR 0 3
17744: PPUSH
17745: CALL 37482 0 3
17749: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
17750: LD_VAR 0 3
17754: PPUSH
17755: CALL_OW 310
17759: IFFALSE 17770
// ComExitBuilding ( j ) ;
17761: LD_VAR 0 3
17765: PPUSH
17766: CALL_OW 122
// wait ( 3 ) ;
17770: LD_INT 3
17772: PPUSH
17773: CALL_OW 67
// if not mc_construct_list [ i ] then
17777: LD_EXP 59
17781: PUSH
17782: LD_VAR 0 2
17786: ARRAY
17787: NOT
17788: IFFALSE 17792
// break ;
17790: GO 17830
// if not HasTask ( j ) then
17792: LD_VAR 0 3
17796: PPUSH
17797: CALL_OW 314
17801: NOT
17802: IFFALSE 17828
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
17804: LD_VAR 0 3
17808: PPUSH
17809: LD_EXP 59
17813: PUSH
17814: LD_VAR 0 2
17818: ARRAY
17819: PUSH
17820: LD_INT 1
17822: ARRAY
17823: PPUSH
17824: CALL 40333 0 2
// end ;
17828: GO 17678
17830: POP
17831: POP
// end else
17832: GO 18637
// if mc_build_list [ i ] then
17834: LD_EXP 57
17838: PUSH
17839: LD_VAR 0 2
17843: ARRAY
17844: IFFALSE 18637
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
17846: LD_ADDR_VAR 0 5
17850: PUSH
17851: LD_EXP 52
17855: PUSH
17856: LD_VAR 0 2
17860: ARRAY
17861: PPUSH
17862: LD_INT 2
17864: PUSH
17865: LD_INT 30
17867: PUSH
17868: LD_INT 0
17870: PUSH
17871: EMPTY
17872: LIST
17873: LIST
17874: PUSH
17875: LD_INT 30
17877: PUSH
17878: LD_INT 1
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: LIST
17889: PPUSH
17890: CALL_OW 72
17894: ST_TO_ADDR
// if depot then
17895: LD_VAR 0 5
17899: IFFALSE 17917
// depot := depot [ 1 ] else
17901: LD_ADDR_VAR 0 5
17905: PUSH
17906: LD_VAR 0 5
17910: PUSH
17911: LD_INT 1
17913: ARRAY
17914: ST_TO_ADDR
17915: GO 17925
// depot := 0 ;
17917: LD_ADDR_VAR 0 5
17921: PUSH
17922: LD_INT 0
17924: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
17925: LD_EXP 57
17929: PUSH
17930: LD_VAR 0 2
17934: ARRAY
17935: PUSH
17936: LD_INT 1
17938: ARRAY
17939: PUSH
17940: LD_INT 1
17942: ARRAY
17943: PPUSH
17944: CALL 40163 0 1
17948: PUSH
17949: LD_EXP 52
17953: PUSH
17954: LD_VAR 0 2
17958: ARRAY
17959: PPUSH
17960: LD_INT 2
17962: PUSH
17963: LD_INT 30
17965: PUSH
17966: LD_INT 2
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: PUSH
17973: LD_INT 30
17975: PUSH
17976: LD_INT 3
17978: PUSH
17979: EMPTY
17980: LIST
17981: LIST
17982: PUSH
17983: EMPTY
17984: LIST
17985: LIST
17986: LIST
17987: PPUSH
17988: CALL_OW 72
17992: NOT
17993: AND
17994: IFFALSE 18099
// begin for j = 1 to mc_build_list [ i ] do
17996: LD_ADDR_VAR 0 3
18000: PUSH
18001: DOUBLE
18002: LD_INT 1
18004: DEC
18005: ST_TO_ADDR
18006: LD_EXP 57
18010: PUSH
18011: LD_VAR 0 2
18015: ARRAY
18016: PUSH
18017: FOR_TO
18018: IFFALSE 18097
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
18020: LD_EXP 57
18024: PUSH
18025: LD_VAR 0 2
18029: ARRAY
18030: PUSH
18031: LD_VAR 0 3
18035: ARRAY
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PUSH
18041: LD_INT 2
18043: EQUAL
18044: IFFALSE 18095
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
18046: LD_ADDR_EXP 57
18050: PUSH
18051: LD_EXP 57
18055: PPUSH
18056: LD_VAR 0 2
18060: PPUSH
18061: LD_EXP 57
18065: PUSH
18066: LD_VAR 0 2
18070: ARRAY
18071: PPUSH
18072: LD_VAR 0 3
18076: PPUSH
18077: LD_INT 1
18079: PPUSH
18080: LD_INT 0
18082: PPUSH
18083: CALL 36900 0 4
18087: PPUSH
18088: CALL_OW 1
18092: ST_TO_ADDR
// break ;
18093: GO 18097
// end ;
18095: GO 18017
18097: POP
18098: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
18099: LD_EXP 57
18103: PUSH
18104: LD_VAR 0 2
18108: ARRAY
18109: PUSH
18110: LD_INT 1
18112: ARRAY
18113: PUSH
18114: LD_INT 1
18116: ARRAY
18117: PUSH
18118: LD_INT 0
18120: EQUAL
18121: PUSH
18122: LD_VAR 0 5
18126: PUSH
18127: LD_VAR 0 5
18131: PPUSH
18132: LD_EXP 57
18136: PUSH
18137: LD_VAR 0 2
18141: ARRAY
18142: PUSH
18143: LD_INT 1
18145: ARRAY
18146: PUSH
18147: LD_INT 1
18149: ARRAY
18150: PPUSH
18151: LD_EXP 57
18155: PUSH
18156: LD_VAR 0 2
18160: ARRAY
18161: PUSH
18162: LD_INT 1
18164: ARRAY
18165: PUSH
18166: LD_INT 2
18168: ARRAY
18169: PPUSH
18170: LD_EXP 57
18174: PUSH
18175: LD_VAR 0 2
18179: ARRAY
18180: PUSH
18181: LD_INT 1
18183: ARRAY
18184: PUSH
18185: LD_INT 3
18187: ARRAY
18188: PPUSH
18189: LD_EXP 57
18193: PUSH
18194: LD_VAR 0 2
18198: ARRAY
18199: PUSH
18200: LD_INT 1
18202: ARRAY
18203: PUSH
18204: LD_INT 4
18206: ARRAY
18207: PPUSH
18208: CALL 44897 0 5
18212: AND
18213: OR
18214: IFFALSE 18495
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
18216: LD_ADDR_VAR 0 4
18220: PUSH
18221: LD_EXP 52
18225: PUSH
18226: LD_VAR 0 2
18230: ARRAY
18231: PPUSH
18232: LD_INT 25
18234: PUSH
18235: LD_INT 2
18237: PUSH
18238: EMPTY
18239: LIST
18240: LIST
18241: PPUSH
18242: CALL_OW 72
18246: PUSH
18247: LD_EXP 54
18251: PUSH
18252: LD_VAR 0 2
18256: ARRAY
18257: DIFF
18258: ST_TO_ADDR
// if not tmp then
18259: LD_VAR 0 4
18263: NOT
18264: IFFALSE 18268
// continue ;
18266: GO 17513
// for j in tmp do
18268: LD_ADDR_VAR 0 3
18272: PUSH
18273: LD_VAR 0 4
18277: PUSH
18278: FOR_IN
18279: IFFALSE 18491
// begin if not mc_builders [ i ] then
18281: LD_EXP 58
18285: PUSH
18286: LD_VAR 0 2
18290: ARRAY
18291: NOT
18292: IFFALSE 18350
// begin SetTag ( j , 103 ) ;
18294: LD_VAR 0 3
18298: PPUSH
18299: LD_INT 103
18301: PPUSH
18302: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
18306: LD_ADDR_EXP 58
18310: PUSH
18311: LD_EXP 58
18315: PPUSH
18316: LD_VAR 0 2
18320: PUSH
18321: LD_EXP 58
18325: PUSH
18326: LD_VAR 0 2
18330: ARRAY
18331: PUSH
18332: LD_INT 1
18334: PLUS
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: PPUSH
18340: LD_VAR 0 3
18344: PPUSH
18345: CALL 37482 0 3
18349: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
18350: LD_VAR 0 3
18354: PPUSH
18355: CALL_OW 310
18359: IFFALSE 18370
// ComExitBuilding ( j ) ;
18361: LD_VAR 0 3
18365: PPUSH
18366: CALL_OW 122
// wait ( 3 ) ;
18370: LD_INT 3
18372: PPUSH
18373: CALL_OW 67
// if not mc_build_list [ i ] then
18377: LD_EXP 57
18381: PUSH
18382: LD_VAR 0 2
18386: ARRAY
18387: NOT
18388: IFFALSE 18392
// break ;
18390: GO 18491
// if not HasTask ( j ) then
18392: LD_VAR 0 3
18396: PPUSH
18397: CALL_OW 314
18401: NOT
18402: IFFALSE 18489
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
18404: LD_VAR 0 3
18408: PPUSH
18409: LD_EXP 57
18413: PUSH
18414: LD_VAR 0 2
18418: ARRAY
18419: PUSH
18420: LD_INT 1
18422: ARRAY
18423: PUSH
18424: LD_INT 1
18426: ARRAY
18427: PPUSH
18428: LD_EXP 57
18432: PUSH
18433: LD_VAR 0 2
18437: ARRAY
18438: PUSH
18439: LD_INT 1
18441: ARRAY
18442: PUSH
18443: LD_INT 2
18445: ARRAY
18446: PPUSH
18447: LD_EXP 57
18451: PUSH
18452: LD_VAR 0 2
18456: ARRAY
18457: PUSH
18458: LD_INT 1
18460: ARRAY
18461: PUSH
18462: LD_INT 3
18464: ARRAY
18465: PPUSH
18466: LD_EXP 57
18470: PUSH
18471: LD_VAR 0 2
18475: ARRAY
18476: PUSH
18477: LD_INT 1
18479: ARRAY
18480: PUSH
18481: LD_INT 4
18483: ARRAY
18484: PPUSH
18485: CALL_OW 145
// end ;
18489: GO 18278
18491: POP
18492: POP
// end else
18493: GO 18637
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
18495: LD_EXP 52
18499: PUSH
18500: LD_VAR 0 2
18504: ARRAY
18505: PPUSH
18506: LD_EXP 57
18510: PUSH
18511: LD_VAR 0 2
18515: ARRAY
18516: PUSH
18517: LD_INT 1
18519: ARRAY
18520: PUSH
18521: LD_INT 1
18523: ARRAY
18524: PPUSH
18525: LD_EXP 57
18529: PUSH
18530: LD_VAR 0 2
18534: ARRAY
18535: PUSH
18536: LD_INT 1
18538: ARRAY
18539: PUSH
18540: LD_INT 2
18542: ARRAY
18543: PPUSH
18544: LD_EXP 57
18548: PUSH
18549: LD_VAR 0 2
18553: ARRAY
18554: PUSH
18555: LD_INT 1
18557: ARRAY
18558: PUSH
18559: LD_INT 3
18561: ARRAY
18562: PPUSH
18563: LD_EXP 57
18567: PUSH
18568: LD_VAR 0 2
18572: ARRAY
18573: PUSH
18574: LD_INT 1
18576: ARRAY
18577: PUSH
18578: LD_INT 4
18580: ARRAY
18581: PPUSH
18582: CALL 44233 0 5
18586: NOT
18587: IFFALSE 18637
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
18589: LD_ADDR_EXP 57
18593: PUSH
18594: LD_EXP 57
18598: PPUSH
18599: LD_VAR 0 2
18603: PPUSH
18604: LD_EXP 57
18608: PUSH
18609: LD_VAR 0 2
18613: ARRAY
18614: PPUSH
18615: LD_INT 1
18617: PPUSH
18618: LD_INT 1
18620: NEG
18621: PPUSH
18622: LD_INT 0
18624: PPUSH
18625: CALL 36900 0 4
18629: PPUSH
18630: CALL_OW 1
18634: ST_TO_ADDR
// continue ;
18635: GO 17513
// end ; end ; end ;
18637: GO 17513
18639: POP
18640: POP
// end ;
18641: LD_VAR 0 1
18645: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
18646: LD_INT 0
18648: PPUSH
18649: PPUSH
18650: PPUSH
18651: PPUSH
18652: PPUSH
18653: PPUSH
// if not mc_bases then
18654: LD_EXP 52
18658: NOT
18659: IFFALSE 18663
// exit ;
18661: GO 19090
// for i = 1 to mc_bases do
18663: LD_ADDR_VAR 0 2
18667: PUSH
18668: DOUBLE
18669: LD_INT 1
18671: DEC
18672: ST_TO_ADDR
18673: LD_EXP 52
18677: PUSH
18678: FOR_TO
18679: IFFALSE 19088
// begin tmp := mc_build_upgrade [ i ] ;
18681: LD_ADDR_VAR 0 4
18685: PUSH
18686: LD_EXP 84
18690: PUSH
18691: LD_VAR 0 2
18695: ARRAY
18696: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
18697: LD_ADDR_VAR 0 6
18701: PUSH
18702: LD_EXP 85
18706: PUSH
18707: LD_VAR 0 2
18711: ARRAY
18712: PPUSH
18713: LD_INT 2
18715: PUSH
18716: LD_INT 30
18718: PUSH
18719: LD_INT 6
18721: PUSH
18722: EMPTY
18723: LIST
18724: LIST
18725: PUSH
18726: LD_INT 30
18728: PUSH
18729: LD_INT 7
18731: PUSH
18732: EMPTY
18733: LIST
18734: LIST
18735: PUSH
18736: EMPTY
18737: LIST
18738: LIST
18739: LIST
18740: PPUSH
18741: CALL_OW 72
18745: ST_TO_ADDR
// if not tmp and not lab then
18746: LD_VAR 0 4
18750: NOT
18751: PUSH
18752: LD_VAR 0 6
18756: NOT
18757: AND
18758: IFFALSE 18762
// continue ;
18760: GO 18678
// if tmp then
18762: LD_VAR 0 4
18766: IFFALSE 18886
// for j in tmp do
18768: LD_ADDR_VAR 0 3
18772: PUSH
18773: LD_VAR 0 4
18777: PUSH
18778: FOR_IN
18779: IFFALSE 18884
// begin if UpgradeCost ( j ) then
18781: LD_VAR 0 3
18785: PPUSH
18786: CALL 43893 0 1
18790: IFFALSE 18882
// begin ComUpgrade ( j ) ;
18792: LD_VAR 0 3
18796: PPUSH
18797: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
18801: LD_ADDR_EXP 84
18805: PUSH
18806: LD_EXP 84
18810: PPUSH
18811: LD_VAR 0 2
18815: PPUSH
18816: LD_EXP 84
18820: PUSH
18821: LD_VAR 0 2
18825: ARRAY
18826: PUSH
18827: LD_VAR 0 3
18831: DIFF
18832: PPUSH
18833: CALL_OW 1
18837: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
18838: LD_ADDR_EXP 59
18842: PUSH
18843: LD_EXP 59
18847: PPUSH
18848: LD_VAR 0 2
18852: PUSH
18853: LD_EXP 59
18857: PUSH
18858: LD_VAR 0 2
18862: ARRAY
18863: PUSH
18864: LD_INT 1
18866: PLUS
18867: PUSH
18868: EMPTY
18869: LIST
18870: LIST
18871: PPUSH
18872: LD_VAR 0 3
18876: PPUSH
18877: CALL 37482 0 3
18881: ST_TO_ADDR
// end ; end ;
18882: GO 18778
18884: POP
18885: POP
// if not lab or not mc_lab_upgrade [ i ] then
18886: LD_VAR 0 6
18890: NOT
18891: PUSH
18892: LD_EXP 86
18896: PUSH
18897: LD_VAR 0 2
18901: ARRAY
18902: NOT
18903: OR
18904: IFFALSE 18908
// continue ;
18906: GO 18678
// for j in lab do
18908: LD_ADDR_VAR 0 3
18912: PUSH
18913: LD_VAR 0 6
18917: PUSH
18918: FOR_IN
18919: IFFALSE 19084
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
18921: LD_VAR 0 3
18925: PPUSH
18926: CALL_OW 266
18930: PUSH
18931: LD_INT 6
18933: PUSH
18934: LD_INT 7
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: IN
18941: PUSH
18942: LD_VAR 0 3
18946: PPUSH
18947: CALL_OW 461
18951: PUSH
18952: LD_INT 1
18954: NONEQUAL
18955: AND
18956: IFFALSE 19082
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
18958: LD_VAR 0 3
18962: PPUSH
18963: LD_EXP 86
18967: PUSH
18968: LD_VAR 0 2
18972: ARRAY
18973: PUSH
18974: LD_INT 1
18976: ARRAY
18977: PPUSH
18978: CALL 44098 0 2
18982: IFFALSE 19082
// begin ComCancel ( j ) ;
18984: LD_VAR 0 3
18988: PPUSH
18989: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
18993: LD_VAR 0 3
18997: PPUSH
18998: LD_EXP 86
19002: PUSH
19003: LD_VAR 0 2
19007: ARRAY
19008: PUSH
19009: LD_INT 1
19011: ARRAY
19012: PPUSH
19013: CALL_OW 207
// if not j in mc_construct_list [ i ] then
19017: LD_VAR 0 3
19021: PUSH
19022: LD_EXP 59
19026: PUSH
19027: LD_VAR 0 2
19031: ARRAY
19032: IN
19033: NOT
19034: IFFALSE 19080
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
19036: LD_ADDR_EXP 59
19040: PUSH
19041: LD_EXP 59
19045: PPUSH
19046: LD_VAR 0 2
19050: PUSH
19051: LD_EXP 59
19055: PUSH
19056: LD_VAR 0 2
19060: ARRAY
19061: PUSH
19062: LD_INT 1
19064: PLUS
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PPUSH
19070: LD_VAR 0 3
19074: PPUSH
19075: CALL 37482 0 3
19079: ST_TO_ADDR
// break ;
19080: GO 19084
// end ; end ; end ;
19082: GO 18918
19084: POP
19085: POP
// end ;
19086: GO 18678
19088: POP
19089: POP
// end ;
19090: LD_VAR 0 1
19094: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
19095: LD_INT 0
19097: PPUSH
19098: PPUSH
19099: PPUSH
19100: PPUSH
19101: PPUSH
19102: PPUSH
19103: PPUSH
19104: PPUSH
19105: PPUSH
// if not mc_bases then
19106: LD_EXP 52
19110: NOT
19111: IFFALSE 19115
// exit ;
19113: GO 19520
// for i = 1 to mc_bases do
19115: LD_ADDR_VAR 0 2
19119: PUSH
19120: DOUBLE
19121: LD_INT 1
19123: DEC
19124: ST_TO_ADDR
19125: LD_EXP 52
19129: PUSH
19130: FOR_TO
19131: IFFALSE 19518
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
19133: LD_EXP 60
19137: PUSH
19138: LD_VAR 0 2
19142: ARRAY
19143: NOT
19144: PUSH
19145: LD_EXP 52
19149: PUSH
19150: LD_VAR 0 2
19154: ARRAY
19155: PPUSH
19156: LD_INT 30
19158: PUSH
19159: LD_INT 3
19161: PUSH
19162: EMPTY
19163: LIST
19164: LIST
19165: PPUSH
19166: CALL_OW 72
19170: NOT
19171: OR
19172: IFFALSE 19176
// continue ;
19174: GO 19130
// busy := false ;
19176: LD_ADDR_VAR 0 8
19180: PUSH
19181: LD_INT 0
19183: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
19184: LD_ADDR_VAR 0 4
19188: PUSH
19189: LD_EXP 52
19193: PUSH
19194: LD_VAR 0 2
19198: ARRAY
19199: PPUSH
19200: LD_INT 30
19202: PUSH
19203: LD_INT 3
19205: PUSH
19206: EMPTY
19207: LIST
19208: LIST
19209: PPUSH
19210: CALL_OW 72
19214: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
19215: LD_ADDR_VAR 0 6
19219: PUSH
19220: LD_EXP 60
19224: PUSH
19225: LD_VAR 0 2
19229: ARRAY
19230: PPUSH
19231: LD_INT 2
19233: PUSH
19234: LD_INT 30
19236: PUSH
19237: LD_INT 32
19239: PUSH
19240: EMPTY
19241: LIST
19242: LIST
19243: PUSH
19244: LD_INT 30
19246: PUSH
19247: LD_INT 33
19249: PUSH
19250: EMPTY
19251: LIST
19252: LIST
19253: PUSH
19254: EMPTY
19255: LIST
19256: LIST
19257: LIST
19258: PPUSH
19259: CALL_OW 72
19263: ST_TO_ADDR
// if not t then
19264: LD_VAR 0 6
19268: NOT
19269: IFFALSE 19273
// continue ;
19271: GO 19130
// for j in tmp do
19273: LD_ADDR_VAR 0 3
19277: PUSH
19278: LD_VAR 0 4
19282: PUSH
19283: FOR_IN
19284: IFFALSE 19314
// if not BuildingStatus ( j ) = bs_idle then
19286: LD_VAR 0 3
19290: PPUSH
19291: CALL_OW 461
19295: PUSH
19296: LD_INT 2
19298: EQUAL
19299: NOT
19300: IFFALSE 19312
// begin busy := true ;
19302: LD_ADDR_VAR 0 8
19306: PUSH
19307: LD_INT 1
19309: ST_TO_ADDR
// break ;
19310: GO 19314
// end ;
19312: GO 19283
19314: POP
19315: POP
// if busy then
19316: LD_VAR 0 8
19320: IFFALSE 19324
// continue ;
19322: GO 19130
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
19324: LD_ADDR_VAR 0 7
19328: PUSH
19329: LD_VAR 0 6
19333: PPUSH
19334: LD_INT 35
19336: PUSH
19337: LD_INT 0
19339: PUSH
19340: EMPTY
19341: LIST
19342: LIST
19343: PPUSH
19344: CALL_OW 72
19348: ST_TO_ADDR
// if tw then
19349: LD_VAR 0 7
19353: IFFALSE 19430
// begin tw := tw [ 1 ] ;
19355: LD_ADDR_VAR 0 7
19359: PUSH
19360: LD_VAR 0 7
19364: PUSH
19365: LD_INT 1
19367: ARRAY
19368: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
19369: LD_ADDR_VAR 0 9
19373: PUSH
19374: LD_VAR 0 7
19378: PPUSH
19379: LD_EXP 77
19383: PUSH
19384: LD_VAR 0 2
19388: ARRAY
19389: PPUSH
19390: CALL 42452 0 2
19394: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
19395: LD_EXP 91
19399: PUSH
19400: LD_VAR 0 2
19404: ARRAY
19405: IFFALSE 19428
// if not weapon in mc_allowed_tower_weapons [ i ] then
19407: LD_VAR 0 9
19411: PUSH
19412: LD_EXP 91
19416: PUSH
19417: LD_VAR 0 2
19421: ARRAY
19422: IN
19423: NOT
19424: IFFALSE 19428
// continue ;
19426: GO 19130
// end else
19428: GO 19493
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
19430: LD_ADDR_VAR 0 5
19434: PUSH
19435: LD_EXP 60
19439: PUSH
19440: LD_VAR 0 2
19444: ARRAY
19445: PPUSH
19446: LD_VAR 0 4
19450: PPUSH
19451: CALL 67954 0 2
19455: ST_TO_ADDR
// if not tmp2 then
19456: LD_VAR 0 5
19460: NOT
19461: IFFALSE 19465
// continue ;
19463: GO 19130
// tw := tmp2 [ 1 ] ;
19465: LD_ADDR_VAR 0 7
19469: PUSH
19470: LD_VAR 0 5
19474: PUSH
19475: LD_INT 1
19477: ARRAY
19478: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
19479: LD_ADDR_VAR 0 9
19483: PUSH
19484: LD_VAR 0 5
19488: PUSH
19489: LD_INT 2
19491: ARRAY
19492: ST_TO_ADDR
// end ; if not weapon then
19493: LD_VAR 0 9
19497: NOT
19498: IFFALSE 19502
// continue ;
19500: GO 19130
// ComPlaceWeapon ( tw , weapon ) ;
19502: LD_VAR 0 7
19506: PPUSH
19507: LD_VAR 0 9
19511: PPUSH
19512: CALL_OW 148
// end ;
19516: GO 19130
19518: POP
19519: POP
// end ;
19520: LD_VAR 0 1
19524: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
19525: LD_INT 0
19527: PPUSH
19528: PPUSH
19529: PPUSH
19530: PPUSH
19531: PPUSH
19532: PPUSH
// if not mc_bases then
19533: LD_EXP 52
19537: NOT
19538: IFFALSE 19542
// exit ;
19540: GO 20318
// for i = 1 to mc_bases do
19542: LD_ADDR_VAR 0 2
19546: PUSH
19547: DOUBLE
19548: LD_INT 1
19550: DEC
19551: ST_TO_ADDR
19552: LD_EXP 52
19556: PUSH
19557: FOR_TO
19558: IFFALSE 20316
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
19560: LD_EXP 65
19564: PUSH
19565: LD_VAR 0 2
19569: ARRAY
19570: NOT
19571: PUSH
19572: LD_EXP 65
19576: PUSH
19577: LD_VAR 0 2
19581: ARRAY
19582: PUSH
19583: LD_EXP 66
19587: PUSH
19588: LD_VAR 0 2
19592: ARRAY
19593: EQUAL
19594: OR
19595: PUSH
19596: LD_EXP 75
19600: PUSH
19601: LD_VAR 0 2
19605: ARRAY
19606: OR
19607: IFFALSE 19611
// continue ;
19609: GO 19557
// if mc_miners [ i ] then
19611: LD_EXP 66
19615: PUSH
19616: LD_VAR 0 2
19620: ARRAY
19621: IFFALSE 20003
// begin for j = mc_miners [ i ] downto 1 do
19623: LD_ADDR_VAR 0 3
19627: PUSH
19628: DOUBLE
19629: LD_EXP 66
19633: PUSH
19634: LD_VAR 0 2
19638: ARRAY
19639: INC
19640: ST_TO_ADDR
19641: LD_INT 1
19643: PUSH
19644: FOR_DOWNTO
19645: IFFALSE 20001
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
19647: LD_EXP 66
19651: PUSH
19652: LD_VAR 0 2
19656: ARRAY
19657: PUSH
19658: LD_VAR 0 3
19662: ARRAY
19663: PPUSH
19664: CALL_OW 301
19668: PUSH
19669: LD_EXP 66
19673: PUSH
19674: LD_VAR 0 2
19678: ARRAY
19679: PUSH
19680: LD_VAR 0 3
19684: ARRAY
19685: PPUSH
19686: CALL_OW 257
19690: PUSH
19691: LD_INT 1
19693: NONEQUAL
19694: OR
19695: IFFALSE 19758
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
19697: LD_ADDR_VAR 0 5
19701: PUSH
19702: LD_EXP 66
19706: PUSH
19707: LD_VAR 0 2
19711: ARRAY
19712: PUSH
19713: LD_EXP 66
19717: PUSH
19718: LD_VAR 0 2
19722: ARRAY
19723: PUSH
19724: LD_VAR 0 3
19728: ARRAY
19729: DIFF
19730: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
19731: LD_ADDR_EXP 66
19735: PUSH
19736: LD_EXP 66
19740: PPUSH
19741: LD_VAR 0 2
19745: PPUSH
19746: LD_VAR 0 5
19750: PPUSH
19751: CALL_OW 1
19755: ST_TO_ADDR
// continue ;
19756: GO 19644
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
19758: LD_EXP 66
19762: PUSH
19763: LD_VAR 0 2
19767: ARRAY
19768: PUSH
19769: LD_VAR 0 3
19773: ARRAY
19774: PPUSH
19775: CALL_OW 257
19779: PUSH
19780: LD_INT 1
19782: EQUAL
19783: PUSH
19784: LD_EXP 66
19788: PUSH
19789: LD_VAR 0 2
19793: ARRAY
19794: PUSH
19795: LD_VAR 0 3
19799: ARRAY
19800: PPUSH
19801: CALL_OW 459
19805: NOT
19806: AND
19807: PUSH
19808: LD_EXP 66
19812: PUSH
19813: LD_VAR 0 2
19817: ARRAY
19818: PUSH
19819: LD_VAR 0 3
19823: ARRAY
19824: PPUSH
19825: CALL_OW 314
19829: NOT
19830: AND
19831: IFFALSE 19999
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
19833: LD_EXP 66
19837: PUSH
19838: LD_VAR 0 2
19842: ARRAY
19843: PUSH
19844: LD_VAR 0 3
19848: ARRAY
19849: PPUSH
19850: CALL_OW 310
19854: IFFALSE 19877
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
19856: LD_EXP 66
19860: PUSH
19861: LD_VAR 0 2
19865: ARRAY
19866: PUSH
19867: LD_VAR 0 3
19871: ARRAY
19872: PPUSH
19873: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
19877: LD_EXP 66
19881: PUSH
19882: LD_VAR 0 2
19886: ARRAY
19887: PUSH
19888: LD_VAR 0 3
19892: ARRAY
19893: PPUSH
19894: CALL_OW 314
19898: NOT
19899: IFFALSE 19999
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
19901: LD_EXP 66
19905: PUSH
19906: LD_VAR 0 2
19910: ARRAY
19911: PUSH
19912: LD_VAR 0 3
19916: ARRAY
19917: PPUSH
19918: LD_EXP 65
19922: PUSH
19923: LD_VAR 0 2
19927: ARRAY
19928: PUSH
19929: LD_VAR 0 3
19933: PUSH
19934: LD_EXP 65
19938: PUSH
19939: LD_VAR 0 2
19943: ARRAY
19944: MOD
19945: PUSH
19946: LD_INT 1
19948: PLUS
19949: ARRAY
19950: PUSH
19951: LD_INT 1
19953: ARRAY
19954: PPUSH
19955: LD_EXP 65
19959: PUSH
19960: LD_VAR 0 2
19964: ARRAY
19965: PUSH
19966: LD_VAR 0 3
19970: PUSH
19971: LD_EXP 65
19975: PUSH
19976: LD_VAR 0 2
19980: ARRAY
19981: MOD
19982: PUSH
19983: LD_INT 1
19985: PLUS
19986: ARRAY
19987: PUSH
19988: LD_INT 2
19990: ARRAY
19991: PPUSH
19992: LD_INT 0
19994: PPUSH
19995: CALL_OW 193
// end ; end ;
19999: GO 19644
20001: POP
20002: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
20003: LD_ADDR_VAR 0 5
20007: PUSH
20008: LD_EXP 52
20012: PUSH
20013: LD_VAR 0 2
20017: ARRAY
20018: PPUSH
20019: LD_INT 2
20021: PUSH
20022: LD_INT 30
20024: PUSH
20025: LD_INT 4
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: LD_INT 30
20034: PUSH
20035: LD_INT 5
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: LD_INT 30
20044: PUSH
20045: LD_INT 32
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: PUSH
20052: EMPTY
20053: LIST
20054: LIST
20055: LIST
20056: LIST
20057: PPUSH
20058: CALL_OW 72
20062: ST_TO_ADDR
// if not tmp then
20063: LD_VAR 0 5
20067: NOT
20068: IFFALSE 20072
// continue ;
20070: GO 19557
// list := [ ] ;
20072: LD_ADDR_VAR 0 6
20076: PUSH
20077: EMPTY
20078: ST_TO_ADDR
// for j in tmp do
20079: LD_ADDR_VAR 0 3
20083: PUSH
20084: LD_VAR 0 5
20088: PUSH
20089: FOR_IN
20090: IFFALSE 20159
// begin for k in UnitsInside ( j ) do
20092: LD_ADDR_VAR 0 4
20096: PUSH
20097: LD_VAR 0 3
20101: PPUSH
20102: CALL_OW 313
20106: PUSH
20107: FOR_IN
20108: IFFALSE 20155
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
20110: LD_VAR 0 4
20114: PPUSH
20115: CALL_OW 257
20119: PUSH
20120: LD_INT 1
20122: EQUAL
20123: PUSH
20124: LD_VAR 0 4
20128: PPUSH
20129: CALL_OW 459
20133: NOT
20134: AND
20135: IFFALSE 20153
// list := list ^ k ;
20137: LD_ADDR_VAR 0 6
20141: PUSH
20142: LD_VAR 0 6
20146: PUSH
20147: LD_VAR 0 4
20151: ADD
20152: ST_TO_ADDR
20153: GO 20107
20155: POP
20156: POP
// end ;
20157: GO 20089
20159: POP
20160: POP
// list := list diff mc_miners [ i ] ;
20161: LD_ADDR_VAR 0 6
20165: PUSH
20166: LD_VAR 0 6
20170: PUSH
20171: LD_EXP 66
20175: PUSH
20176: LD_VAR 0 2
20180: ARRAY
20181: DIFF
20182: ST_TO_ADDR
// if not list then
20183: LD_VAR 0 6
20187: NOT
20188: IFFALSE 20192
// continue ;
20190: GO 19557
// k := mc_mines [ i ] - mc_miners [ i ] ;
20192: LD_ADDR_VAR 0 4
20196: PUSH
20197: LD_EXP 65
20201: PUSH
20202: LD_VAR 0 2
20206: ARRAY
20207: PUSH
20208: LD_EXP 66
20212: PUSH
20213: LD_VAR 0 2
20217: ARRAY
20218: MINUS
20219: ST_TO_ADDR
// if k > list then
20220: LD_VAR 0 4
20224: PUSH
20225: LD_VAR 0 6
20229: GREATER
20230: IFFALSE 20242
// k := list ;
20232: LD_ADDR_VAR 0 4
20236: PUSH
20237: LD_VAR 0 6
20241: ST_TO_ADDR
// for j = 1 to k do
20242: LD_ADDR_VAR 0 3
20246: PUSH
20247: DOUBLE
20248: LD_INT 1
20250: DEC
20251: ST_TO_ADDR
20252: LD_VAR 0 4
20256: PUSH
20257: FOR_TO
20258: IFFALSE 20312
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
20260: LD_ADDR_EXP 66
20264: PUSH
20265: LD_EXP 66
20269: PPUSH
20270: LD_VAR 0 2
20274: PUSH
20275: LD_EXP 66
20279: PUSH
20280: LD_VAR 0 2
20284: ARRAY
20285: PUSH
20286: LD_INT 1
20288: PLUS
20289: PUSH
20290: EMPTY
20291: LIST
20292: LIST
20293: PPUSH
20294: LD_VAR 0 6
20298: PUSH
20299: LD_VAR 0 3
20303: ARRAY
20304: PPUSH
20305: CALL 37482 0 3
20309: ST_TO_ADDR
20310: GO 20257
20312: POP
20313: POP
// end ;
20314: GO 19557
20316: POP
20317: POP
// end ;
20318: LD_VAR 0 1
20322: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
20323: LD_INT 0
20325: PPUSH
20326: PPUSH
20327: PPUSH
20328: PPUSH
20329: PPUSH
20330: PPUSH
20331: PPUSH
20332: PPUSH
20333: PPUSH
20334: PPUSH
// if not mc_bases then
20335: LD_EXP 52
20339: NOT
20340: IFFALSE 20344
// exit ;
20342: GO 22094
// for i = 1 to mc_bases do
20344: LD_ADDR_VAR 0 2
20348: PUSH
20349: DOUBLE
20350: LD_INT 1
20352: DEC
20353: ST_TO_ADDR
20354: LD_EXP 52
20358: PUSH
20359: FOR_TO
20360: IFFALSE 22092
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
20362: LD_EXP 52
20366: PUSH
20367: LD_VAR 0 2
20371: ARRAY
20372: NOT
20373: PUSH
20374: LD_EXP 59
20378: PUSH
20379: LD_VAR 0 2
20383: ARRAY
20384: OR
20385: IFFALSE 20389
// continue ;
20387: GO 20359
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
20389: LD_EXP 68
20393: PUSH
20394: LD_VAR 0 2
20398: ARRAY
20399: NOT
20400: PUSH
20401: LD_EXP 69
20405: PUSH
20406: LD_VAR 0 2
20410: ARRAY
20411: AND
20412: IFFALSE 20450
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20414: LD_ADDR_EXP 69
20418: PUSH
20419: LD_EXP 69
20423: PPUSH
20424: LD_VAR 0 2
20428: PPUSH
20429: EMPTY
20430: PPUSH
20431: CALL_OW 1
20435: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
20436: LD_VAR 0 2
20440: PPUSH
20441: LD_INT 107
20443: PPUSH
20444: CALL 11324 0 2
// continue ;
20448: GO 20359
// end ; target := [ ] ;
20450: LD_ADDR_VAR 0 6
20454: PUSH
20455: EMPTY
20456: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
20457: LD_ADDR_VAR 0 3
20461: PUSH
20462: DOUBLE
20463: LD_EXP 68
20467: PUSH
20468: LD_VAR 0 2
20472: ARRAY
20473: INC
20474: ST_TO_ADDR
20475: LD_INT 1
20477: PUSH
20478: FOR_DOWNTO
20479: IFFALSE 20739
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
20481: LD_EXP 68
20485: PUSH
20486: LD_VAR 0 2
20490: ARRAY
20491: PUSH
20492: LD_VAR 0 3
20496: ARRAY
20497: PUSH
20498: LD_INT 2
20500: ARRAY
20501: PPUSH
20502: LD_EXP 68
20506: PUSH
20507: LD_VAR 0 2
20511: ARRAY
20512: PUSH
20513: LD_VAR 0 3
20517: ARRAY
20518: PUSH
20519: LD_INT 3
20521: ARRAY
20522: PPUSH
20523: CALL_OW 488
20527: PUSH
20528: LD_EXP 68
20532: PUSH
20533: LD_VAR 0 2
20537: ARRAY
20538: PUSH
20539: LD_VAR 0 3
20543: ARRAY
20544: PUSH
20545: LD_INT 2
20547: ARRAY
20548: PPUSH
20549: LD_EXP 68
20553: PUSH
20554: LD_VAR 0 2
20558: ARRAY
20559: PUSH
20560: LD_VAR 0 3
20564: ARRAY
20565: PUSH
20566: LD_INT 3
20568: ARRAY
20569: PPUSH
20570: CALL_OW 284
20574: PUSH
20575: LD_INT 0
20577: EQUAL
20578: AND
20579: IFFALSE 20634
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
20581: LD_ADDR_VAR 0 5
20585: PUSH
20586: LD_EXP 68
20590: PUSH
20591: LD_VAR 0 2
20595: ARRAY
20596: PPUSH
20597: LD_VAR 0 3
20601: PPUSH
20602: CALL_OW 3
20606: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
20607: LD_ADDR_EXP 68
20611: PUSH
20612: LD_EXP 68
20616: PPUSH
20617: LD_VAR 0 2
20621: PPUSH
20622: LD_VAR 0 5
20626: PPUSH
20627: CALL_OW 1
20631: ST_TO_ADDR
// continue ;
20632: GO 20478
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
20634: LD_EXP 52
20638: PUSH
20639: LD_VAR 0 2
20643: ARRAY
20644: PUSH
20645: LD_INT 1
20647: ARRAY
20648: PPUSH
20649: CALL_OW 255
20653: PPUSH
20654: LD_EXP 68
20658: PUSH
20659: LD_VAR 0 2
20663: ARRAY
20664: PUSH
20665: LD_VAR 0 3
20669: ARRAY
20670: PUSH
20671: LD_INT 2
20673: ARRAY
20674: PPUSH
20675: LD_EXP 68
20679: PUSH
20680: LD_VAR 0 2
20684: ARRAY
20685: PUSH
20686: LD_VAR 0 3
20690: ARRAY
20691: PUSH
20692: LD_INT 3
20694: ARRAY
20695: PPUSH
20696: LD_INT 30
20698: PPUSH
20699: CALL 38378 0 4
20703: PUSH
20704: LD_INT 4
20706: ARRAY
20707: PUSH
20708: LD_INT 0
20710: EQUAL
20711: IFFALSE 20737
// begin target := mc_crates [ i ] [ j ] ;
20713: LD_ADDR_VAR 0 6
20717: PUSH
20718: LD_EXP 68
20722: PUSH
20723: LD_VAR 0 2
20727: ARRAY
20728: PUSH
20729: LD_VAR 0 3
20733: ARRAY
20734: ST_TO_ADDR
// break ;
20735: GO 20739
// end ; end ;
20737: GO 20478
20739: POP
20740: POP
// if not target then
20741: LD_VAR 0 6
20745: NOT
20746: IFFALSE 20750
// continue ;
20748: GO 20359
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
20750: LD_ADDR_VAR 0 7
20754: PUSH
20755: LD_EXP 71
20759: PUSH
20760: LD_VAR 0 2
20764: ARRAY
20765: PPUSH
20766: LD_INT 2
20768: PUSH
20769: LD_INT 3
20771: PUSH
20772: LD_INT 58
20774: PUSH
20775: EMPTY
20776: LIST
20777: PUSH
20778: EMPTY
20779: LIST
20780: LIST
20781: PUSH
20782: LD_INT 61
20784: PUSH
20785: EMPTY
20786: LIST
20787: PUSH
20788: LD_INT 33
20790: PUSH
20791: LD_INT 5
20793: PUSH
20794: EMPTY
20795: LIST
20796: LIST
20797: PUSH
20798: LD_INT 33
20800: PUSH
20801: LD_INT 3
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: PUSH
20815: LD_INT 2
20817: PUSH
20818: LD_INT 34
20820: PUSH
20821: LD_INT 32
20823: PUSH
20824: EMPTY
20825: LIST
20826: LIST
20827: PUSH
20828: LD_INT 34
20830: PUSH
20831: LD_INT 51
20833: PUSH
20834: EMPTY
20835: LIST
20836: LIST
20837: PUSH
20838: LD_INT 34
20840: PUSH
20841: LD_INT 12
20843: PUSH
20844: EMPTY
20845: LIST
20846: LIST
20847: PUSH
20848: EMPTY
20849: LIST
20850: LIST
20851: LIST
20852: LIST
20853: PUSH
20854: EMPTY
20855: LIST
20856: LIST
20857: PPUSH
20858: CALL_OW 72
20862: ST_TO_ADDR
// if not cargo then
20863: LD_VAR 0 7
20867: NOT
20868: IFFALSE 21511
// begin if mc_crates_collector [ i ] < 5 then
20870: LD_EXP 69
20874: PUSH
20875: LD_VAR 0 2
20879: ARRAY
20880: PUSH
20881: LD_INT 5
20883: LESS
20884: IFFALSE 21250
// begin if mc_ape [ i ] then
20886: LD_EXP 81
20890: PUSH
20891: LD_VAR 0 2
20895: ARRAY
20896: IFFALSE 20943
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
20898: LD_ADDR_VAR 0 5
20902: PUSH
20903: LD_EXP 81
20907: PUSH
20908: LD_VAR 0 2
20912: ARRAY
20913: PPUSH
20914: LD_INT 25
20916: PUSH
20917: LD_INT 16
20919: PUSH
20920: EMPTY
20921: LIST
20922: LIST
20923: PUSH
20924: LD_INT 24
20926: PUSH
20927: LD_INT 750
20929: PUSH
20930: EMPTY
20931: LIST
20932: LIST
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: PPUSH
20938: CALL_OW 72
20942: ST_TO_ADDR
// if not tmp then
20943: LD_VAR 0 5
20947: NOT
20948: IFFALSE 20995
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
20950: LD_ADDR_VAR 0 5
20954: PUSH
20955: LD_EXP 52
20959: PUSH
20960: LD_VAR 0 2
20964: ARRAY
20965: PPUSH
20966: LD_INT 25
20968: PUSH
20969: LD_INT 2
20971: PUSH
20972: EMPTY
20973: LIST
20974: LIST
20975: PUSH
20976: LD_INT 24
20978: PUSH
20979: LD_INT 750
20981: PUSH
20982: EMPTY
20983: LIST
20984: LIST
20985: PUSH
20986: EMPTY
20987: LIST
20988: LIST
20989: PPUSH
20990: CALL_OW 72
20994: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
20995: LD_EXP 81
20999: PUSH
21000: LD_VAR 0 2
21004: ARRAY
21005: PUSH
21006: LD_EXP 52
21010: PUSH
21011: LD_VAR 0 2
21015: ARRAY
21016: PPUSH
21017: LD_INT 25
21019: PUSH
21020: LD_INT 2
21022: PUSH
21023: EMPTY
21024: LIST
21025: LIST
21026: PUSH
21027: LD_INT 24
21029: PUSH
21030: LD_INT 750
21032: PUSH
21033: EMPTY
21034: LIST
21035: LIST
21036: PUSH
21037: EMPTY
21038: LIST
21039: LIST
21040: PPUSH
21041: CALL_OW 72
21045: AND
21046: PUSH
21047: LD_VAR 0 5
21051: PUSH
21052: LD_INT 5
21054: LESS
21055: AND
21056: IFFALSE 21138
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
21058: LD_ADDR_VAR 0 3
21062: PUSH
21063: LD_EXP 52
21067: PUSH
21068: LD_VAR 0 2
21072: ARRAY
21073: PPUSH
21074: LD_INT 25
21076: PUSH
21077: LD_INT 2
21079: PUSH
21080: EMPTY
21081: LIST
21082: LIST
21083: PUSH
21084: LD_INT 24
21086: PUSH
21087: LD_INT 750
21089: PUSH
21090: EMPTY
21091: LIST
21092: LIST
21093: PUSH
21094: EMPTY
21095: LIST
21096: LIST
21097: PPUSH
21098: CALL_OW 72
21102: PUSH
21103: FOR_IN
21104: IFFALSE 21136
// begin tmp := tmp union j ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_VAR 0 5
21115: PUSH
21116: LD_VAR 0 3
21120: UNION
21121: ST_TO_ADDR
// if tmp >= 5 then
21122: LD_VAR 0 5
21126: PUSH
21127: LD_INT 5
21129: GREATEREQUAL
21130: IFFALSE 21134
// break ;
21132: GO 21136
// end ;
21134: GO 21103
21136: POP
21137: POP
// end ; if not tmp then
21138: LD_VAR 0 5
21142: NOT
21143: IFFALSE 21147
// continue ;
21145: GO 20359
// for j in tmp do
21147: LD_ADDR_VAR 0 3
21151: PUSH
21152: LD_VAR 0 5
21156: PUSH
21157: FOR_IN
21158: IFFALSE 21248
// if not GetTag ( j ) then
21160: LD_VAR 0 3
21164: PPUSH
21165: CALL_OW 110
21169: NOT
21170: IFFALSE 21246
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
21172: LD_ADDR_EXP 69
21176: PUSH
21177: LD_EXP 69
21181: PPUSH
21182: LD_VAR 0 2
21186: PUSH
21187: LD_EXP 69
21191: PUSH
21192: LD_VAR 0 2
21196: ARRAY
21197: PUSH
21198: LD_INT 1
21200: PLUS
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: PPUSH
21206: LD_VAR 0 3
21210: PPUSH
21211: CALL 37482 0 3
21215: ST_TO_ADDR
// SetTag ( j , 107 ) ;
21216: LD_VAR 0 3
21220: PPUSH
21221: LD_INT 107
21223: PPUSH
21224: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
21228: LD_EXP 69
21232: PUSH
21233: LD_VAR 0 2
21237: ARRAY
21238: PUSH
21239: LD_INT 5
21241: GREATEREQUAL
21242: IFFALSE 21246
// break ;
21244: GO 21248
// end ;
21246: GO 21157
21248: POP
21249: POP
// end ; if mc_crates_collector [ i ] and target then
21250: LD_EXP 69
21254: PUSH
21255: LD_VAR 0 2
21259: ARRAY
21260: PUSH
21261: LD_VAR 0 6
21265: AND
21266: IFFALSE 21509
// begin if mc_crates_collector [ i ] < target [ 1 ] then
21268: LD_EXP 69
21272: PUSH
21273: LD_VAR 0 2
21277: ARRAY
21278: PUSH
21279: LD_VAR 0 6
21283: PUSH
21284: LD_INT 1
21286: ARRAY
21287: LESS
21288: IFFALSE 21308
// tmp := mc_crates_collector [ i ] else
21290: LD_ADDR_VAR 0 5
21294: PUSH
21295: LD_EXP 69
21299: PUSH
21300: LD_VAR 0 2
21304: ARRAY
21305: ST_TO_ADDR
21306: GO 21322
// tmp := target [ 1 ] ;
21308: LD_ADDR_VAR 0 5
21312: PUSH
21313: LD_VAR 0 6
21317: PUSH
21318: LD_INT 1
21320: ARRAY
21321: ST_TO_ADDR
// k := 0 ;
21322: LD_ADDR_VAR 0 4
21326: PUSH
21327: LD_INT 0
21329: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
21330: LD_ADDR_VAR 0 3
21334: PUSH
21335: LD_EXP 69
21339: PUSH
21340: LD_VAR 0 2
21344: ARRAY
21345: PUSH
21346: FOR_IN
21347: IFFALSE 21507
// begin k := k + 1 ;
21349: LD_ADDR_VAR 0 4
21353: PUSH
21354: LD_VAR 0 4
21358: PUSH
21359: LD_INT 1
21361: PLUS
21362: ST_TO_ADDR
// if k > tmp then
21363: LD_VAR 0 4
21367: PUSH
21368: LD_VAR 0 5
21372: GREATER
21373: IFFALSE 21377
// break ;
21375: GO 21507
// if not GetClass ( j ) in [ 2 , 16 ] then
21377: LD_VAR 0 3
21381: PPUSH
21382: CALL_OW 257
21386: PUSH
21387: LD_INT 2
21389: PUSH
21390: LD_INT 16
21392: PUSH
21393: EMPTY
21394: LIST
21395: LIST
21396: IN
21397: NOT
21398: IFFALSE 21451
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
21400: LD_ADDR_EXP 69
21404: PUSH
21405: LD_EXP 69
21409: PPUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: LD_EXP 69
21419: PUSH
21420: LD_VAR 0 2
21424: ARRAY
21425: PUSH
21426: LD_VAR 0 3
21430: DIFF
21431: PPUSH
21432: CALL_OW 1
21436: ST_TO_ADDR
// SetTag ( j , 0 ) ;
21437: LD_VAR 0 3
21441: PPUSH
21442: LD_INT 0
21444: PPUSH
21445: CALL_OW 109
// continue ;
21449: GO 21346
// end ; if IsInUnit ( j ) then
21451: LD_VAR 0 3
21455: PPUSH
21456: CALL_OW 310
21460: IFFALSE 21471
// ComExitBuilding ( j ) ;
21462: LD_VAR 0 3
21466: PPUSH
21467: CALL_OW 122
// wait ( 3 ) ;
21471: LD_INT 3
21473: PPUSH
21474: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
21478: LD_VAR 0 3
21482: PPUSH
21483: LD_VAR 0 6
21487: PUSH
21488: LD_INT 2
21490: ARRAY
21491: PPUSH
21492: LD_VAR 0 6
21496: PUSH
21497: LD_INT 3
21499: ARRAY
21500: PPUSH
21501: CALL_OW 117
// end ;
21505: GO 21346
21507: POP
21508: POP
// end ; end else
21509: GO 22090
// begin for j in cargo do
21511: LD_ADDR_VAR 0 3
21515: PUSH
21516: LD_VAR 0 7
21520: PUSH
21521: FOR_IN
21522: IFFALSE 22088
// begin if GetTag ( j ) <> 0 then
21524: LD_VAR 0 3
21528: PPUSH
21529: CALL_OW 110
21533: PUSH
21534: LD_INT 0
21536: NONEQUAL
21537: IFFALSE 21541
// continue ;
21539: GO 21521
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
21541: LD_VAR 0 3
21545: PPUSH
21546: CALL_OW 256
21550: PUSH
21551: LD_INT 1000
21553: LESS
21554: PUSH
21555: LD_VAR 0 3
21559: PPUSH
21560: LD_EXP 76
21564: PUSH
21565: LD_VAR 0 2
21569: ARRAY
21570: PPUSH
21571: CALL_OW 308
21575: NOT
21576: AND
21577: IFFALSE 21599
// ComMoveToArea ( j , mc_parking [ i ] ) ;
21579: LD_VAR 0 3
21583: PPUSH
21584: LD_EXP 76
21588: PUSH
21589: LD_VAR 0 2
21593: ARRAY
21594: PPUSH
21595: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
21599: LD_VAR 0 3
21603: PPUSH
21604: CALL_OW 256
21608: PUSH
21609: LD_INT 1000
21611: LESS
21612: PUSH
21613: LD_VAR 0 3
21617: PPUSH
21618: LD_EXP 76
21622: PUSH
21623: LD_VAR 0 2
21627: ARRAY
21628: PPUSH
21629: CALL_OW 308
21633: AND
21634: IFFALSE 21638
// continue ;
21636: GO 21521
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
21638: LD_VAR 0 3
21642: PPUSH
21643: CALL_OW 262
21647: PUSH
21648: LD_INT 2
21650: EQUAL
21651: PUSH
21652: LD_VAR 0 3
21656: PPUSH
21657: CALL_OW 261
21661: PUSH
21662: LD_INT 15
21664: LESS
21665: AND
21666: IFFALSE 21670
// continue ;
21668: GO 21521
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
21670: LD_VAR 0 3
21674: PPUSH
21675: CALL_OW 262
21679: PUSH
21680: LD_INT 1
21682: EQUAL
21683: PUSH
21684: LD_VAR 0 3
21688: PPUSH
21689: CALL_OW 261
21693: PUSH
21694: LD_INT 10
21696: LESS
21697: AND
21698: IFFALSE 22027
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
21700: LD_ADDR_VAR 0 8
21704: PUSH
21705: LD_EXP 52
21709: PUSH
21710: LD_VAR 0 2
21714: ARRAY
21715: PPUSH
21716: LD_INT 2
21718: PUSH
21719: LD_INT 30
21721: PUSH
21722: LD_INT 0
21724: PUSH
21725: EMPTY
21726: LIST
21727: LIST
21728: PUSH
21729: LD_INT 30
21731: PUSH
21732: LD_INT 1
21734: PUSH
21735: EMPTY
21736: LIST
21737: LIST
21738: PUSH
21739: EMPTY
21740: LIST
21741: LIST
21742: LIST
21743: PPUSH
21744: CALL_OW 72
21748: ST_TO_ADDR
// if not depot then
21749: LD_VAR 0 8
21753: NOT
21754: IFFALSE 21758
// continue ;
21756: GO 21521
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
21758: LD_VAR 0 3
21762: PPUSH
21763: LD_VAR 0 8
21767: PPUSH
21768: LD_VAR 0 3
21772: PPUSH
21773: CALL_OW 74
21777: PPUSH
21778: CALL_OW 296
21782: PUSH
21783: LD_INT 6
21785: LESS
21786: IFFALSE 21802
// SetFuel ( j , 100 ) else
21788: LD_VAR 0 3
21792: PPUSH
21793: LD_INT 100
21795: PPUSH
21796: CALL_OW 240
21800: GO 22027
// if GetFuel ( j ) = 0 then
21802: LD_VAR 0 3
21806: PPUSH
21807: CALL_OW 261
21811: PUSH
21812: LD_INT 0
21814: EQUAL
21815: IFFALSE 22027
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
21817: LD_ADDR_EXP 71
21821: PUSH
21822: LD_EXP 71
21826: PPUSH
21827: LD_VAR 0 2
21831: PPUSH
21832: LD_EXP 71
21836: PUSH
21837: LD_VAR 0 2
21841: ARRAY
21842: PUSH
21843: LD_VAR 0 3
21847: DIFF
21848: PPUSH
21849: CALL_OW 1
21853: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
21854: LD_VAR 0 3
21858: PPUSH
21859: CALL_OW 263
21863: PUSH
21864: LD_INT 1
21866: EQUAL
21867: IFFALSE 21883
// ComExitVehicle ( IsInUnit ( j ) ) ;
21869: LD_VAR 0 3
21873: PPUSH
21874: CALL_OW 310
21878: PPUSH
21879: CALL_OW 121
// if GetControl ( j ) = control_remote then
21883: LD_VAR 0 3
21887: PPUSH
21888: CALL_OW 263
21892: PUSH
21893: LD_INT 2
21895: EQUAL
21896: IFFALSE 21907
// ComUnlink ( j ) ;
21898: LD_VAR 0 3
21902: PPUSH
21903: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
21907: LD_ADDR_VAR 0 9
21911: PUSH
21912: LD_VAR 0 2
21916: PPUSH
21917: LD_INT 3
21919: PPUSH
21920: CALL 31380 0 2
21924: ST_TO_ADDR
// if fac then
21925: LD_VAR 0 9
21929: IFFALSE 22025
// begin for k in fac do
21931: LD_ADDR_VAR 0 4
21935: PUSH
21936: LD_VAR 0 9
21940: PUSH
21941: FOR_IN
21942: IFFALSE 22023
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
21944: LD_ADDR_VAR 0 10
21948: PUSH
21949: LD_VAR 0 9
21953: PPUSH
21954: LD_VAR 0 3
21958: PPUSH
21959: CALL_OW 265
21963: PPUSH
21964: LD_VAR 0 3
21968: PPUSH
21969: CALL_OW 262
21973: PPUSH
21974: LD_VAR 0 3
21978: PPUSH
21979: CALL_OW 263
21983: PPUSH
21984: LD_VAR 0 3
21988: PPUSH
21989: CALL_OW 264
21993: PPUSH
21994: CALL 35014 0 5
21998: ST_TO_ADDR
// if components then
21999: LD_VAR 0 10
22003: IFFALSE 22021
// begin MC_InsertProduceList ( i , components ) ;
22005: LD_VAR 0 2
22009: PPUSH
22010: LD_VAR 0 10
22014: PPUSH
22015: CALL 30925 0 2
// break ;
22019: GO 22023
// end ; end ;
22021: GO 21941
22023: POP
22024: POP
// end ; continue ;
22025: GO 21521
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
22027: LD_VAR 0 3
22031: PPUSH
22032: LD_INT 1
22034: PPUSH
22035: CALL_OW 289
22039: PUSH
22040: LD_INT 100
22042: LESS
22043: PUSH
22044: LD_VAR 0 3
22048: PPUSH
22049: CALL_OW 314
22053: NOT
22054: AND
22055: IFFALSE 22084
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
22057: LD_VAR 0 3
22061: PPUSH
22062: LD_VAR 0 6
22066: PUSH
22067: LD_INT 2
22069: ARRAY
22070: PPUSH
22071: LD_VAR 0 6
22075: PUSH
22076: LD_INT 3
22078: ARRAY
22079: PPUSH
22080: CALL_OW 117
// break ;
22084: GO 22088
// end ;
22086: GO 21521
22088: POP
22089: POP
// end ; end ;
22090: GO 20359
22092: POP
22093: POP
// end ;
22094: LD_VAR 0 1
22098: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
22099: LD_INT 0
22101: PPUSH
22102: PPUSH
22103: PPUSH
22104: PPUSH
// if not mc_bases then
22105: LD_EXP 52
22109: NOT
22110: IFFALSE 22114
// exit ;
22112: GO 22275
// for i = 1 to mc_bases do
22114: LD_ADDR_VAR 0 2
22118: PUSH
22119: DOUBLE
22120: LD_INT 1
22122: DEC
22123: ST_TO_ADDR
22124: LD_EXP 52
22128: PUSH
22129: FOR_TO
22130: IFFALSE 22273
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
22132: LD_ADDR_VAR 0 4
22136: PUSH
22137: LD_EXP 71
22141: PUSH
22142: LD_VAR 0 2
22146: ARRAY
22147: PUSH
22148: LD_EXP 74
22152: PUSH
22153: LD_VAR 0 2
22157: ARRAY
22158: UNION
22159: PPUSH
22160: LD_INT 33
22162: PUSH
22163: LD_INT 2
22165: PUSH
22166: EMPTY
22167: LIST
22168: LIST
22169: PPUSH
22170: CALL_OW 72
22174: ST_TO_ADDR
// if tmp then
22175: LD_VAR 0 4
22179: IFFALSE 22271
// for j in tmp do
22181: LD_ADDR_VAR 0 3
22185: PUSH
22186: LD_VAR 0 4
22190: PUSH
22191: FOR_IN
22192: IFFALSE 22269
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
22194: LD_VAR 0 3
22198: PPUSH
22199: CALL_OW 312
22203: NOT
22204: PUSH
22205: LD_VAR 0 3
22209: PPUSH
22210: CALL_OW 256
22214: PUSH
22215: LD_INT 250
22217: GREATEREQUAL
22218: AND
22219: IFFALSE 22232
// Connect ( j ) else
22221: LD_VAR 0 3
22225: PPUSH
22226: CALL 40415 0 1
22230: GO 22267
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
22232: LD_VAR 0 3
22236: PPUSH
22237: CALL_OW 256
22241: PUSH
22242: LD_INT 250
22244: LESS
22245: PUSH
22246: LD_VAR 0 3
22250: PPUSH
22251: CALL_OW 312
22255: AND
22256: IFFALSE 22267
// ComUnlink ( j ) ;
22258: LD_VAR 0 3
22262: PPUSH
22263: CALL_OW 136
22267: GO 22191
22269: POP
22270: POP
// end ;
22271: GO 22129
22273: POP
22274: POP
// end ;
22275: LD_VAR 0 1
22279: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
22280: LD_INT 0
22282: PPUSH
22283: PPUSH
22284: PPUSH
22285: PPUSH
22286: PPUSH
// if not mc_bases then
22287: LD_EXP 52
22291: NOT
22292: IFFALSE 22296
// exit ;
22294: GO 22741
// for i = 1 to mc_bases do
22296: LD_ADDR_VAR 0 2
22300: PUSH
22301: DOUBLE
22302: LD_INT 1
22304: DEC
22305: ST_TO_ADDR
22306: LD_EXP 52
22310: PUSH
22311: FOR_TO
22312: IFFALSE 22739
// begin if not mc_produce [ i ] then
22314: LD_EXP 73
22318: PUSH
22319: LD_VAR 0 2
22323: ARRAY
22324: NOT
22325: IFFALSE 22329
// continue ;
22327: GO 22311
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
22329: LD_ADDR_VAR 0 5
22333: PUSH
22334: LD_EXP 52
22338: PUSH
22339: LD_VAR 0 2
22343: ARRAY
22344: PPUSH
22345: LD_INT 30
22347: PUSH
22348: LD_INT 3
22350: PUSH
22351: EMPTY
22352: LIST
22353: LIST
22354: PPUSH
22355: CALL_OW 72
22359: ST_TO_ADDR
// if not fac then
22360: LD_VAR 0 5
22364: NOT
22365: IFFALSE 22369
// continue ;
22367: GO 22311
// for j in fac do
22369: LD_ADDR_VAR 0 3
22373: PUSH
22374: LD_VAR 0 5
22378: PUSH
22379: FOR_IN
22380: IFFALSE 22735
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
22382: LD_VAR 0 3
22386: PPUSH
22387: CALL_OW 461
22391: PUSH
22392: LD_INT 2
22394: NONEQUAL
22395: PUSH
22396: LD_VAR 0 3
22400: PPUSH
22401: LD_INT 15
22403: PPUSH
22404: CALL 40075 0 2
22408: PUSH
22409: LD_INT 4
22411: ARRAY
22412: OR
22413: IFFALSE 22417
// continue ;
22415: GO 22379
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
22417: LD_VAR 0 3
22421: PPUSH
22422: LD_EXP 73
22426: PUSH
22427: LD_VAR 0 2
22431: ARRAY
22432: PUSH
22433: LD_INT 1
22435: ARRAY
22436: PUSH
22437: LD_INT 1
22439: ARRAY
22440: PPUSH
22441: LD_EXP 73
22445: PUSH
22446: LD_VAR 0 2
22450: ARRAY
22451: PUSH
22452: LD_INT 1
22454: ARRAY
22455: PUSH
22456: LD_INT 2
22458: ARRAY
22459: PPUSH
22460: LD_EXP 73
22464: PUSH
22465: LD_VAR 0 2
22469: ARRAY
22470: PUSH
22471: LD_INT 1
22473: ARRAY
22474: PUSH
22475: LD_INT 3
22477: ARRAY
22478: PPUSH
22479: LD_EXP 73
22483: PUSH
22484: LD_VAR 0 2
22488: ARRAY
22489: PUSH
22490: LD_INT 1
22492: ARRAY
22493: PUSH
22494: LD_INT 4
22496: ARRAY
22497: PPUSH
22498: CALL_OW 448
22502: PUSH
22503: LD_VAR 0 3
22507: PPUSH
22508: LD_EXP 73
22512: PUSH
22513: LD_VAR 0 2
22517: ARRAY
22518: PUSH
22519: LD_INT 1
22521: ARRAY
22522: PUSH
22523: LD_INT 1
22525: ARRAY
22526: PUSH
22527: LD_EXP 73
22531: PUSH
22532: LD_VAR 0 2
22536: ARRAY
22537: PUSH
22538: LD_INT 1
22540: ARRAY
22541: PUSH
22542: LD_INT 2
22544: ARRAY
22545: PUSH
22546: LD_EXP 73
22550: PUSH
22551: LD_VAR 0 2
22555: ARRAY
22556: PUSH
22557: LD_INT 1
22559: ARRAY
22560: PUSH
22561: LD_INT 3
22563: ARRAY
22564: PUSH
22565: LD_EXP 73
22569: PUSH
22570: LD_VAR 0 2
22574: ARRAY
22575: PUSH
22576: LD_INT 1
22578: ARRAY
22579: PUSH
22580: LD_INT 4
22582: ARRAY
22583: PUSH
22584: EMPTY
22585: LIST
22586: LIST
22587: LIST
22588: LIST
22589: PPUSH
22590: CALL 43746 0 2
22594: AND
22595: IFFALSE 22733
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
22597: LD_VAR 0 3
22601: PPUSH
22602: LD_EXP 73
22606: PUSH
22607: LD_VAR 0 2
22611: ARRAY
22612: PUSH
22613: LD_INT 1
22615: ARRAY
22616: PUSH
22617: LD_INT 1
22619: ARRAY
22620: PPUSH
22621: LD_EXP 73
22625: PUSH
22626: LD_VAR 0 2
22630: ARRAY
22631: PUSH
22632: LD_INT 1
22634: ARRAY
22635: PUSH
22636: LD_INT 2
22638: ARRAY
22639: PPUSH
22640: LD_EXP 73
22644: PUSH
22645: LD_VAR 0 2
22649: ARRAY
22650: PUSH
22651: LD_INT 1
22653: ARRAY
22654: PUSH
22655: LD_INT 3
22657: ARRAY
22658: PPUSH
22659: LD_EXP 73
22663: PUSH
22664: LD_VAR 0 2
22668: ARRAY
22669: PUSH
22670: LD_INT 1
22672: ARRAY
22673: PUSH
22674: LD_INT 4
22676: ARRAY
22677: PPUSH
22678: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
22682: LD_ADDR_VAR 0 4
22686: PUSH
22687: LD_EXP 73
22691: PUSH
22692: LD_VAR 0 2
22696: ARRAY
22697: PPUSH
22698: LD_INT 1
22700: PPUSH
22701: CALL_OW 3
22705: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
22706: LD_ADDR_EXP 73
22710: PUSH
22711: LD_EXP 73
22715: PPUSH
22716: LD_VAR 0 2
22720: PPUSH
22721: LD_VAR 0 4
22725: PPUSH
22726: CALL_OW 1
22730: ST_TO_ADDR
// break ;
22731: GO 22735
// end ; end ;
22733: GO 22379
22735: POP
22736: POP
// end ;
22737: GO 22311
22739: POP
22740: POP
// end ;
22741: LD_VAR 0 1
22745: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
22746: LD_INT 0
22748: PPUSH
22749: PPUSH
22750: PPUSH
// if not mc_bases then
22751: LD_EXP 52
22755: NOT
22756: IFFALSE 22760
// exit ;
22758: GO 22849
// for i = 1 to mc_bases do
22760: LD_ADDR_VAR 0 2
22764: PUSH
22765: DOUBLE
22766: LD_INT 1
22768: DEC
22769: ST_TO_ADDR
22770: LD_EXP 52
22774: PUSH
22775: FOR_TO
22776: IFFALSE 22847
// begin if mc_attack [ i ] then
22778: LD_EXP 72
22782: PUSH
22783: LD_VAR 0 2
22787: ARRAY
22788: IFFALSE 22845
// begin tmp := mc_attack [ i ] [ 1 ] ;
22790: LD_ADDR_VAR 0 3
22794: PUSH
22795: LD_EXP 72
22799: PUSH
22800: LD_VAR 0 2
22804: ARRAY
22805: PUSH
22806: LD_INT 1
22808: ARRAY
22809: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22810: LD_ADDR_EXP 72
22814: PUSH
22815: LD_EXP 72
22819: PPUSH
22820: LD_VAR 0 2
22824: PPUSH
22825: EMPTY
22826: PPUSH
22827: CALL_OW 1
22831: ST_TO_ADDR
// Attack ( tmp ) ;
22832: LD_VAR 0 3
22836: PPUSH
22837: CALL 73617 0 1
// exit ;
22841: POP
22842: POP
22843: GO 22849
// end ; end ;
22845: GO 22775
22847: POP
22848: POP
// end ;
22849: LD_VAR 0 1
22853: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
22854: LD_INT 0
22856: PPUSH
22857: PPUSH
22858: PPUSH
22859: PPUSH
22860: PPUSH
22861: PPUSH
22862: PPUSH
// if not mc_bases then
22863: LD_EXP 52
22867: NOT
22868: IFFALSE 22872
// exit ;
22870: GO 23454
// for i = 1 to mc_bases do
22872: LD_ADDR_VAR 0 2
22876: PUSH
22877: DOUBLE
22878: LD_INT 1
22880: DEC
22881: ST_TO_ADDR
22882: LD_EXP 52
22886: PUSH
22887: FOR_TO
22888: IFFALSE 23452
// begin if not mc_bases [ i ] then
22890: LD_EXP 52
22894: PUSH
22895: LD_VAR 0 2
22899: ARRAY
22900: NOT
22901: IFFALSE 22905
// continue ;
22903: GO 22887
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
22905: LD_ADDR_VAR 0 7
22909: PUSH
22910: LD_EXP 52
22914: PUSH
22915: LD_VAR 0 2
22919: ARRAY
22920: PUSH
22921: LD_INT 1
22923: ARRAY
22924: PPUSH
22925: CALL 34318 0 1
22929: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
22930: LD_ADDR_EXP 75
22934: PUSH
22935: LD_EXP 75
22939: PPUSH
22940: LD_VAR 0 2
22944: PPUSH
22945: LD_EXP 52
22949: PUSH
22950: LD_VAR 0 2
22954: ARRAY
22955: PUSH
22956: LD_INT 1
22958: ARRAY
22959: PPUSH
22960: CALL_OW 255
22964: PPUSH
22965: LD_EXP 77
22969: PUSH
22970: LD_VAR 0 2
22974: ARRAY
22975: PPUSH
22976: CALL 34283 0 2
22980: PPUSH
22981: CALL_OW 1
22985: ST_TO_ADDR
// if not mc_scan [ i ] then
22986: LD_EXP 75
22990: PUSH
22991: LD_VAR 0 2
22995: ARRAY
22996: NOT
22997: IFFALSE 23152
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22999: LD_ADDR_VAR 0 4
23003: PUSH
23004: LD_EXP 52
23008: PUSH
23009: LD_VAR 0 2
23013: ARRAY
23014: PPUSH
23015: LD_INT 2
23017: PUSH
23018: LD_INT 25
23020: PUSH
23021: LD_INT 5
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_INT 25
23030: PUSH
23031: LD_INT 8
23033: PUSH
23034: EMPTY
23035: LIST
23036: LIST
23037: PUSH
23038: LD_INT 25
23040: PUSH
23041: LD_INT 9
23043: PUSH
23044: EMPTY
23045: LIST
23046: LIST
23047: PUSH
23048: EMPTY
23049: LIST
23050: LIST
23051: LIST
23052: LIST
23053: PPUSH
23054: CALL_OW 72
23058: ST_TO_ADDR
// if not tmp then
23059: LD_VAR 0 4
23063: NOT
23064: IFFALSE 23068
// continue ;
23066: GO 22887
// for j in tmp do
23068: LD_ADDR_VAR 0 3
23072: PUSH
23073: LD_VAR 0 4
23077: PUSH
23078: FOR_IN
23079: IFFALSE 23150
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
23081: LD_VAR 0 3
23085: PPUSH
23086: CALL_OW 310
23090: PPUSH
23091: CALL_OW 266
23095: PUSH
23096: LD_INT 5
23098: EQUAL
23099: PUSH
23100: LD_VAR 0 3
23104: PPUSH
23105: CALL_OW 257
23109: PUSH
23110: LD_INT 1
23112: EQUAL
23113: AND
23114: PUSH
23115: LD_VAR 0 3
23119: PPUSH
23120: CALL_OW 459
23124: NOT
23125: AND
23126: PUSH
23127: LD_VAR 0 7
23131: AND
23132: IFFALSE 23148
// ComChangeProfession ( j , class ) ;
23134: LD_VAR 0 3
23138: PPUSH
23139: LD_VAR 0 7
23143: PPUSH
23144: CALL_OW 123
23148: GO 23078
23150: POP
23151: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
23152: LD_EXP 75
23156: PUSH
23157: LD_VAR 0 2
23161: ARRAY
23162: PUSH
23163: LD_EXP 74
23167: PUSH
23168: LD_VAR 0 2
23172: ARRAY
23173: NOT
23174: AND
23175: PUSH
23176: LD_EXP 52
23180: PUSH
23181: LD_VAR 0 2
23185: ARRAY
23186: PPUSH
23187: LD_INT 30
23189: PUSH
23190: LD_INT 32
23192: PUSH
23193: EMPTY
23194: LIST
23195: LIST
23196: PPUSH
23197: CALL_OW 72
23201: NOT
23202: AND
23203: PUSH
23204: LD_EXP 52
23208: PUSH
23209: LD_VAR 0 2
23213: ARRAY
23214: PPUSH
23215: LD_INT 2
23217: PUSH
23218: LD_INT 30
23220: PUSH
23221: LD_INT 4
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: PUSH
23228: LD_INT 30
23230: PUSH
23231: LD_INT 5
23233: PUSH
23234: EMPTY
23235: LIST
23236: LIST
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: LIST
23242: PPUSH
23243: CALL_OW 72
23247: NOT
23248: AND
23249: IFFALSE 23381
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23251: LD_ADDR_VAR 0 4
23255: PUSH
23256: LD_EXP 52
23260: PUSH
23261: LD_VAR 0 2
23265: ARRAY
23266: PPUSH
23267: LD_INT 2
23269: PUSH
23270: LD_INT 25
23272: PUSH
23273: LD_INT 1
23275: PUSH
23276: EMPTY
23277: LIST
23278: LIST
23279: PUSH
23280: LD_INT 25
23282: PUSH
23283: LD_INT 5
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: PUSH
23290: LD_INT 25
23292: PUSH
23293: LD_INT 8
23295: PUSH
23296: EMPTY
23297: LIST
23298: LIST
23299: PUSH
23300: LD_INT 25
23302: PUSH
23303: LD_INT 9
23305: PUSH
23306: EMPTY
23307: LIST
23308: LIST
23309: PUSH
23310: EMPTY
23311: LIST
23312: LIST
23313: LIST
23314: LIST
23315: LIST
23316: PPUSH
23317: CALL_OW 72
23321: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
23322: LD_ADDR_VAR 0 4
23326: PUSH
23327: LD_VAR 0 4
23331: PUSH
23332: LD_VAR 0 4
23336: PPUSH
23337: LD_INT 18
23339: PPUSH
23340: CALL 66043 0 2
23344: DIFF
23345: ST_TO_ADDR
// if tmp then
23346: LD_VAR 0 4
23350: IFFALSE 23381
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
23352: LD_VAR 0 2
23356: PPUSH
23357: LD_VAR 0 4
23361: PPUSH
23362: LD_EXP 77
23366: PUSH
23367: LD_VAR 0 2
23371: ARRAY
23372: PPUSH
23373: CALL 78326 0 3
// exit ;
23377: POP
23378: POP
23379: GO 23454
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
23381: LD_EXP 75
23385: PUSH
23386: LD_VAR 0 2
23390: ARRAY
23391: PUSH
23392: LD_EXP 74
23396: PUSH
23397: LD_VAR 0 2
23401: ARRAY
23402: AND
23403: IFFALSE 23450
// begin tmp := mc_defender [ i ] ;
23405: LD_ADDR_VAR 0 4
23409: PUSH
23410: LD_EXP 74
23414: PUSH
23415: LD_VAR 0 2
23419: ARRAY
23420: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
23421: LD_VAR 0 2
23425: PPUSH
23426: LD_VAR 0 4
23430: PPUSH
23431: LD_EXP 75
23435: PUSH
23436: LD_VAR 0 2
23440: ARRAY
23441: PPUSH
23442: CALL 78887 0 3
// exit ;
23446: POP
23447: POP
23448: GO 23454
// end ; end ;
23450: GO 22887
23452: POP
23453: POP
// end ;
23454: LD_VAR 0 1
23458: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
23459: LD_INT 0
23461: PPUSH
23462: PPUSH
23463: PPUSH
23464: PPUSH
23465: PPUSH
23466: PPUSH
23467: PPUSH
23468: PPUSH
23469: PPUSH
23470: PPUSH
23471: PPUSH
// if not mc_bases then
23472: LD_EXP 52
23476: NOT
23477: IFFALSE 23481
// exit ;
23479: GO 24568
// for i = 1 to mc_bases do
23481: LD_ADDR_VAR 0 2
23485: PUSH
23486: DOUBLE
23487: LD_INT 1
23489: DEC
23490: ST_TO_ADDR
23491: LD_EXP 52
23495: PUSH
23496: FOR_TO
23497: IFFALSE 24566
// begin tmp := mc_lab [ i ] ;
23499: LD_ADDR_VAR 0 6
23503: PUSH
23504: LD_EXP 85
23508: PUSH
23509: LD_VAR 0 2
23513: ARRAY
23514: ST_TO_ADDR
// if not tmp then
23515: LD_VAR 0 6
23519: NOT
23520: IFFALSE 23524
// continue ;
23522: GO 23496
// idle_lab := 0 ;
23524: LD_ADDR_VAR 0 11
23528: PUSH
23529: LD_INT 0
23531: ST_TO_ADDR
// for j in tmp do
23532: LD_ADDR_VAR 0 3
23536: PUSH
23537: LD_VAR 0 6
23541: PUSH
23542: FOR_IN
23543: IFFALSE 24562
// begin researching := false ;
23545: LD_ADDR_VAR 0 10
23549: PUSH
23550: LD_INT 0
23552: ST_TO_ADDR
// side := GetSide ( j ) ;
23553: LD_ADDR_VAR 0 4
23557: PUSH
23558: LD_VAR 0 3
23562: PPUSH
23563: CALL_OW 255
23567: ST_TO_ADDR
// if not mc_tech [ side ] then
23568: LD_EXP 79
23572: PUSH
23573: LD_VAR 0 4
23577: ARRAY
23578: NOT
23579: IFFALSE 23583
// continue ;
23581: GO 23542
// if BuildingStatus ( j ) = bs_idle then
23583: LD_VAR 0 3
23587: PPUSH
23588: CALL_OW 461
23592: PUSH
23593: LD_INT 2
23595: EQUAL
23596: IFFALSE 23784
// begin if idle_lab and UnitsInside ( j ) < 6 then
23598: LD_VAR 0 11
23602: PUSH
23603: LD_VAR 0 3
23607: PPUSH
23608: CALL_OW 313
23612: PUSH
23613: LD_INT 6
23615: LESS
23616: AND
23617: IFFALSE 23688
// begin tmp2 := UnitsInside ( idle_lab ) ;
23619: LD_ADDR_VAR 0 9
23623: PUSH
23624: LD_VAR 0 11
23628: PPUSH
23629: CALL_OW 313
23633: ST_TO_ADDR
// if tmp2 then
23634: LD_VAR 0 9
23638: IFFALSE 23680
// for x in tmp2 do
23640: LD_ADDR_VAR 0 7
23644: PUSH
23645: LD_VAR 0 9
23649: PUSH
23650: FOR_IN
23651: IFFALSE 23678
// begin ComExitBuilding ( x ) ;
23653: LD_VAR 0 7
23657: PPUSH
23658: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
23662: LD_VAR 0 7
23666: PPUSH
23667: LD_VAR 0 3
23671: PPUSH
23672: CALL_OW 180
// end ;
23676: GO 23650
23678: POP
23679: POP
// idle_lab := 0 ;
23680: LD_ADDR_VAR 0 11
23684: PUSH
23685: LD_INT 0
23687: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
23688: LD_ADDR_VAR 0 5
23692: PUSH
23693: LD_EXP 79
23697: PUSH
23698: LD_VAR 0 4
23702: ARRAY
23703: PUSH
23704: FOR_IN
23705: IFFALSE 23765
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
23707: LD_VAR 0 3
23711: PPUSH
23712: LD_VAR 0 5
23716: PPUSH
23717: CALL_OW 430
23721: PUSH
23722: LD_VAR 0 4
23726: PPUSH
23727: LD_VAR 0 5
23731: PPUSH
23732: CALL 33388 0 2
23736: AND
23737: IFFALSE 23763
// begin researching := true ;
23739: LD_ADDR_VAR 0 10
23743: PUSH
23744: LD_INT 1
23746: ST_TO_ADDR
// ComResearch ( j , t ) ;
23747: LD_VAR 0 3
23751: PPUSH
23752: LD_VAR 0 5
23756: PPUSH
23757: CALL_OW 124
// break ;
23761: GO 23765
// end ;
23763: GO 23704
23765: POP
23766: POP
// if not researching then
23767: LD_VAR 0 10
23771: NOT
23772: IFFALSE 23784
// idle_lab := j ;
23774: LD_ADDR_VAR 0 11
23778: PUSH
23779: LD_VAR 0 3
23783: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
23784: LD_VAR 0 3
23788: PPUSH
23789: CALL_OW 461
23793: PUSH
23794: LD_INT 10
23796: EQUAL
23797: IFFALSE 24385
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
23799: LD_EXP 81
23803: PUSH
23804: LD_VAR 0 2
23808: ARRAY
23809: NOT
23810: PUSH
23811: LD_EXP 82
23815: PUSH
23816: LD_VAR 0 2
23820: ARRAY
23821: NOT
23822: AND
23823: PUSH
23824: LD_EXP 79
23828: PUSH
23829: LD_VAR 0 4
23833: ARRAY
23834: PUSH
23835: LD_INT 1
23837: GREATER
23838: AND
23839: IFFALSE 23970
// begin ComCancel ( j ) ;
23841: LD_VAR 0 3
23845: PPUSH
23846: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
23850: LD_ADDR_EXP 79
23854: PUSH
23855: LD_EXP 79
23859: PPUSH
23860: LD_VAR 0 4
23864: PPUSH
23865: LD_EXP 79
23869: PUSH
23870: LD_VAR 0 4
23874: ARRAY
23875: PPUSH
23876: LD_EXP 79
23880: PUSH
23881: LD_VAR 0 4
23885: ARRAY
23886: PUSH
23887: LD_INT 1
23889: MINUS
23890: PPUSH
23891: LD_EXP 79
23895: PUSH
23896: LD_VAR 0 4
23900: ARRAY
23901: PPUSH
23902: LD_INT 0
23904: PPUSH
23905: CALL 36900 0 4
23909: PPUSH
23910: CALL_OW 1
23914: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
23915: LD_ADDR_EXP 79
23919: PUSH
23920: LD_EXP 79
23924: PPUSH
23925: LD_VAR 0 4
23929: PPUSH
23930: LD_EXP 79
23934: PUSH
23935: LD_VAR 0 4
23939: ARRAY
23940: PPUSH
23941: LD_EXP 79
23945: PUSH
23946: LD_VAR 0 4
23950: ARRAY
23951: PPUSH
23952: LD_INT 1
23954: PPUSH
23955: LD_INT 0
23957: PPUSH
23958: CALL 36900 0 4
23962: PPUSH
23963: CALL_OW 1
23967: ST_TO_ADDR
// continue ;
23968: GO 23542
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
23970: LD_EXP 81
23974: PUSH
23975: LD_VAR 0 2
23979: ARRAY
23980: PUSH
23981: LD_EXP 82
23985: PUSH
23986: LD_VAR 0 2
23990: ARRAY
23991: NOT
23992: AND
23993: IFFALSE 24120
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
23995: LD_ADDR_EXP 82
23999: PUSH
24000: LD_EXP 82
24004: PPUSH
24005: LD_VAR 0 2
24009: PUSH
24010: LD_EXP 82
24014: PUSH
24015: LD_VAR 0 2
24019: ARRAY
24020: PUSH
24021: LD_INT 1
24023: PLUS
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PPUSH
24029: LD_EXP 81
24033: PUSH
24034: LD_VAR 0 2
24038: ARRAY
24039: PUSH
24040: LD_INT 1
24042: ARRAY
24043: PPUSH
24044: CALL 37482 0 3
24048: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
24049: LD_EXP 81
24053: PUSH
24054: LD_VAR 0 2
24058: ARRAY
24059: PUSH
24060: LD_INT 1
24062: ARRAY
24063: PPUSH
24064: LD_INT 112
24066: PPUSH
24067: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
24071: LD_ADDR_VAR 0 9
24075: PUSH
24076: LD_EXP 81
24080: PUSH
24081: LD_VAR 0 2
24085: ARRAY
24086: PPUSH
24087: LD_INT 1
24089: PPUSH
24090: CALL_OW 3
24094: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
24095: LD_ADDR_EXP 81
24099: PUSH
24100: LD_EXP 81
24104: PPUSH
24105: LD_VAR 0 2
24109: PPUSH
24110: LD_VAR 0 9
24114: PPUSH
24115: CALL_OW 1
24119: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
24120: LD_EXP 81
24124: PUSH
24125: LD_VAR 0 2
24129: ARRAY
24130: PUSH
24131: LD_EXP 82
24135: PUSH
24136: LD_VAR 0 2
24140: ARRAY
24141: AND
24142: PUSH
24143: LD_EXP 82
24147: PUSH
24148: LD_VAR 0 2
24152: ARRAY
24153: PUSH
24154: LD_INT 1
24156: ARRAY
24157: PPUSH
24158: CALL_OW 310
24162: NOT
24163: AND
24164: PUSH
24165: LD_VAR 0 3
24169: PPUSH
24170: CALL_OW 313
24174: PUSH
24175: LD_INT 6
24177: EQUAL
24178: AND
24179: IFFALSE 24235
// begin tmp2 := UnitsInside ( j ) ;
24181: LD_ADDR_VAR 0 9
24185: PUSH
24186: LD_VAR 0 3
24190: PPUSH
24191: CALL_OW 313
24195: ST_TO_ADDR
// if tmp2 = 6 then
24196: LD_VAR 0 9
24200: PUSH
24201: LD_INT 6
24203: EQUAL
24204: IFFALSE 24235
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
24206: LD_VAR 0 9
24210: PUSH
24211: LD_INT 1
24213: ARRAY
24214: PPUSH
24215: LD_INT 112
24217: PPUSH
24218: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
24222: LD_VAR 0 9
24226: PUSH
24227: LD_INT 1
24229: ARRAY
24230: PPUSH
24231: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
24235: LD_EXP 82
24239: PUSH
24240: LD_VAR 0 2
24244: ARRAY
24245: PUSH
24246: LD_EXP 82
24250: PUSH
24251: LD_VAR 0 2
24255: ARRAY
24256: PUSH
24257: LD_INT 1
24259: ARRAY
24260: PPUSH
24261: CALL_OW 314
24265: NOT
24266: AND
24267: PUSH
24268: LD_EXP 82
24272: PUSH
24273: LD_VAR 0 2
24277: ARRAY
24278: PUSH
24279: LD_INT 1
24281: ARRAY
24282: PPUSH
24283: CALL_OW 310
24287: NOT
24288: AND
24289: IFFALSE 24315
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
24291: LD_EXP 82
24295: PUSH
24296: LD_VAR 0 2
24300: ARRAY
24301: PUSH
24302: LD_INT 1
24304: ARRAY
24305: PPUSH
24306: LD_VAR 0 3
24310: PPUSH
24311: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
24315: LD_EXP 82
24319: PUSH
24320: LD_VAR 0 2
24324: ARRAY
24325: PUSH
24326: LD_INT 1
24328: ARRAY
24329: PPUSH
24330: CALL_OW 310
24334: PUSH
24335: LD_EXP 82
24339: PUSH
24340: LD_VAR 0 2
24344: ARRAY
24345: PUSH
24346: LD_INT 1
24348: ARRAY
24349: PPUSH
24350: CALL_OW 310
24354: PPUSH
24355: CALL_OW 461
24359: PUSH
24360: LD_INT 3
24362: NONEQUAL
24363: AND
24364: IFFALSE 24385
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
24366: LD_EXP 82
24370: PUSH
24371: LD_VAR 0 2
24375: ARRAY
24376: PUSH
24377: LD_INT 1
24379: ARRAY
24380: PPUSH
24381: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
24385: LD_VAR 0 3
24389: PPUSH
24390: CALL_OW 461
24394: PUSH
24395: LD_INT 6
24397: EQUAL
24398: PUSH
24399: LD_VAR 0 6
24403: PUSH
24404: LD_INT 1
24406: GREATER
24407: AND
24408: IFFALSE 24560
// begin sci := [ ] ;
24410: LD_ADDR_VAR 0 8
24414: PUSH
24415: EMPTY
24416: ST_TO_ADDR
// for x in ( tmp diff j ) do
24417: LD_ADDR_VAR 0 7
24421: PUSH
24422: LD_VAR 0 6
24426: PUSH
24427: LD_VAR 0 3
24431: DIFF
24432: PUSH
24433: FOR_IN
24434: IFFALSE 24486
// begin if sci = 6 then
24436: LD_VAR 0 8
24440: PUSH
24441: LD_INT 6
24443: EQUAL
24444: IFFALSE 24448
// break ;
24446: GO 24486
// if BuildingStatus ( x ) = bs_idle then
24448: LD_VAR 0 7
24452: PPUSH
24453: CALL_OW 461
24457: PUSH
24458: LD_INT 2
24460: EQUAL
24461: IFFALSE 24484
// sci := sci ^ UnitsInside ( x ) ;
24463: LD_ADDR_VAR 0 8
24467: PUSH
24468: LD_VAR 0 8
24472: PUSH
24473: LD_VAR 0 7
24477: PPUSH
24478: CALL_OW 313
24482: ADD
24483: ST_TO_ADDR
// end ;
24484: GO 24433
24486: POP
24487: POP
// if not sci then
24488: LD_VAR 0 8
24492: NOT
24493: IFFALSE 24497
// continue ;
24495: GO 23542
// for x in sci do
24497: LD_ADDR_VAR 0 7
24501: PUSH
24502: LD_VAR 0 8
24506: PUSH
24507: FOR_IN
24508: IFFALSE 24558
// if IsInUnit ( x ) and not HasTask ( x ) then
24510: LD_VAR 0 7
24514: PPUSH
24515: CALL_OW 310
24519: PUSH
24520: LD_VAR 0 7
24524: PPUSH
24525: CALL_OW 314
24529: NOT
24530: AND
24531: IFFALSE 24556
// begin ComExitBuilding ( x ) ;
24533: LD_VAR 0 7
24537: PPUSH
24538: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
24542: LD_VAR 0 7
24546: PPUSH
24547: LD_VAR 0 3
24551: PPUSH
24552: CALL_OW 180
// end ;
24556: GO 24507
24558: POP
24559: POP
// end ; end ;
24560: GO 23542
24562: POP
24563: POP
// end ;
24564: GO 23496
24566: POP
24567: POP
// end ;
24568: LD_VAR 0 1
24572: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
24573: LD_INT 0
24575: PPUSH
24576: PPUSH
// if not mc_bases then
24577: LD_EXP 52
24581: NOT
24582: IFFALSE 24586
// exit ;
24584: GO 24667
// for i = 1 to mc_bases do
24586: LD_ADDR_VAR 0 2
24590: PUSH
24591: DOUBLE
24592: LD_INT 1
24594: DEC
24595: ST_TO_ADDR
24596: LD_EXP 52
24600: PUSH
24601: FOR_TO
24602: IFFALSE 24665
// if mc_mines [ i ] and mc_miners [ i ] then
24604: LD_EXP 65
24608: PUSH
24609: LD_VAR 0 2
24613: ARRAY
24614: PUSH
24615: LD_EXP 66
24619: PUSH
24620: LD_VAR 0 2
24624: ARRAY
24625: AND
24626: IFFALSE 24663
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
24628: LD_EXP 66
24632: PUSH
24633: LD_VAR 0 2
24637: ARRAY
24638: PUSH
24639: LD_INT 1
24641: ARRAY
24642: PPUSH
24643: CALL_OW 255
24647: PPUSH
24648: LD_EXP 65
24652: PUSH
24653: LD_VAR 0 2
24657: ARRAY
24658: PPUSH
24659: CALL 34471 0 2
24663: GO 24601
24665: POP
24666: POP
// end ;
24667: LD_VAR 0 1
24671: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
24672: LD_INT 0
24674: PPUSH
24675: PPUSH
24676: PPUSH
24677: PPUSH
24678: PPUSH
24679: PPUSH
24680: PPUSH
24681: PPUSH
// if not mc_bases or not mc_parking then
24682: LD_EXP 52
24686: NOT
24687: PUSH
24688: LD_EXP 76
24692: NOT
24693: OR
24694: IFFALSE 24698
// exit ;
24696: GO 25397
// for i = 1 to mc_bases do
24698: LD_ADDR_VAR 0 2
24702: PUSH
24703: DOUBLE
24704: LD_INT 1
24706: DEC
24707: ST_TO_ADDR
24708: LD_EXP 52
24712: PUSH
24713: FOR_TO
24714: IFFALSE 25395
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
24716: LD_EXP 52
24720: PUSH
24721: LD_VAR 0 2
24725: ARRAY
24726: NOT
24727: PUSH
24728: LD_EXP 76
24732: PUSH
24733: LD_VAR 0 2
24737: ARRAY
24738: NOT
24739: OR
24740: IFFALSE 24744
// continue ;
24742: GO 24713
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
24744: LD_ADDR_VAR 0 5
24748: PUSH
24749: LD_EXP 52
24753: PUSH
24754: LD_VAR 0 2
24758: ARRAY
24759: PUSH
24760: LD_INT 1
24762: ARRAY
24763: PPUSH
24764: CALL_OW 255
24768: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
24769: LD_ADDR_VAR 0 6
24773: PUSH
24774: LD_EXP 52
24778: PUSH
24779: LD_VAR 0 2
24783: ARRAY
24784: PPUSH
24785: LD_INT 30
24787: PUSH
24788: LD_INT 3
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PPUSH
24795: CALL_OW 72
24799: ST_TO_ADDR
// if not fac then
24800: LD_VAR 0 6
24804: NOT
24805: IFFALSE 24856
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
24807: LD_ADDR_VAR 0 6
24811: PUSH
24812: LD_EXP 52
24816: PUSH
24817: LD_VAR 0 2
24821: ARRAY
24822: PPUSH
24823: LD_INT 2
24825: PUSH
24826: LD_INT 30
24828: PUSH
24829: LD_INT 0
24831: PUSH
24832: EMPTY
24833: LIST
24834: LIST
24835: PUSH
24836: LD_INT 30
24838: PUSH
24839: LD_INT 1
24841: PUSH
24842: EMPTY
24843: LIST
24844: LIST
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: LIST
24850: PPUSH
24851: CALL_OW 72
24855: ST_TO_ADDR
// if not fac then
24856: LD_VAR 0 6
24860: NOT
24861: IFFALSE 24865
// continue ;
24863: GO 24713
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
24865: LD_ADDR_VAR 0 7
24869: PUSH
24870: LD_EXP 76
24874: PUSH
24875: LD_VAR 0 2
24879: ARRAY
24880: PPUSH
24881: LD_INT 22
24883: PUSH
24884: LD_VAR 0 5
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PUSH
24893: LD_INT 21
24895: PUSH
24896: LD_INT 2
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: PUSH
24903: LD_INT 3
24905: PUSH
24906: LD_INT 24
24908: PUSH
24909: LD_INT 1000
24911: PUSH
24912: EMPTY
24913: LIST
24914: LIST
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: EMPTY
24921: LIST
24922: LIST
24923: LIST
24924: PPUSH
24925: CALL_OW 70
24929: ST_TO_ADDR
// for j in fac do
24930: LD_ADDR_VAR 0 3
24934: PUSH
24935: LD_VAR 0 6
24939: PUSH
24940: FOR_IN
24941: IFFALSE 25022
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
24943: LD_ADDR_VAR 0 7
24947: PUSH
24948: LD_VAR 0 7
24952: PUSH
24953: LD_INT 22
24955: PUSH
24956: LD_VAR 0 5
24960: PUSH
24961: EMPTY
24962: LIST
24963: LIST
24964: PUSH
24965: LD_INT 91
24967: PUSH
24968: LD_VAR 0 3
24972: PUSH
24973: LD_INT 15
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: LIST
24980: PUSH
24981: LD_INT 21
24983: PUSH
24984: LD_INT 2
24986: PUSH
24987: EMPTY
24988: LIST
24989: LIST
24990: PUSH
24991: LD_INT 3
24993: PUSH
24994: LD_INT 24
24996: PUSH
24997: LD_INT 1000
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: PUSH
25004: EMPTY
25005: LIST
25006: LIST
25007: PUSH
25008: EMPTY
25009: LIST
25010: LIST
25011: LIST
25012: LIST
25013: PPUSH
25014: CALL_OW 69
25018: UNION
25019: ST_TO_ADDR
25020: GO 24940
25022: POP
25023: POP
// if not vehs then
25024: LD_VAR 0 7
25028: NOT
25029: IFFALSE 25055
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
25031: LD_ADDR_EXP 64
25035: PUSH
25036: LD_EXP 64
25040: PPUSH
25041: LD_VAR 0 2
25045: PPUSH
25046: EMPTY
25047: PPUSH
25048: CALL_OW 1
25052: ST_TO_ADDR
// continue ;
25053: GO 24713
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
25055: LD_ADDR_VAR 0 8
25059: PUSH
25060: LD_EXP 52
25064: PUSH
25065: LD_VAR 0 2
25069: ARRAY
25070: PPUSH
25071: LD_INT 30
25073: PUSH
25074: LD_INT 3
25076: PUSH
25077: EMPTY
25078: LIST
25079: LIST
25080: PPUSH
25081: CALL_OW 72
25085: ST_TO_ADDR
// if tmp then
25086: LD_VAR 0 8
25090: IFFALSE 25193
// begin for j in tmp do
25092: LD_ADDR_VAR 0 3
25096: PUSH
25097: LD_VAR 0 8
25101: PUSH
25102: FOR_IN
25103: IFFALSE 25191
// for k in UnitsInside ( j ) do
25105: LD_ADDR_VAR 0 4
25109: PUSH
25110: LD_VAR 0 3
25114: PPUSH
25115: CALL_OW 313
25119: PUSH
25120: FOR_IN
25121: IFFALSE 25187
// if k then
25123: LD_VAR 0 4
25127: IFFALSE 25185
// if not k in mc_repair_vehicle [ i ] then
25129: LD_VAR 0 4
25133: PUSH
25134: LD_EXP 64
25138: PUSH
25139: LD_VAR 0 2
25143: ARRAY
25144: IN
25145: NOT
25146: IFFALSE 25185
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
25148: LD_ADDR_EXP 64
25152: PUSH
25153: LD_EXP 64
25157: PPUSH
25158: LD_VAR 0 2
25162: PPUSH
25163: LD_EXP 64
25167: PUSH
25168: LD_VAR 0 2
25172: ARRAY
25173: PUSH
25174: LD_VAR 0 4
25178: UNION
25179: PPUSH
25180: CALL_OW 1
25184: ST_TO_ADDR
25185: GO 25120
25187: POP
25188: POP
25189: GO 25102
25191: POP
25192: POP
// end ; if not mc_repair_vehicle [ i ] then
25193: LD_EXP 64
25197: PUSH
25198: LD_VAR 0 2
25202: ARRAY
25203: NOT
25204: IFFALSE 25208
// continue ;
25206: GO 24713
// for j in mc_repair_vehicle [ i ] do
25208: LD_ADDR_VAR 0 3
25212: PUSH
25213: LD_EXP 64
25217: PUSH
25218: LD_VAR 0 2
25222: ARRAY
25223: PUSH
25224: FOR_IN
25225: IFFALSE 25391
// begin if GetClass ( j ) <> 3 then
25227: LD_VAR 0 3
25231: PPUSH
25232: CALL_OW 257
25236: PUSH
25237: LD_INT 3
25239: NONEQUAL
25240: IFFALSE 25281
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
25242: LD_ADDR_EXP 64
25246: PUSH
25247: LD_EXP 64
25251: PPUSH
25252: LD_VAR 0 2
25256: PPUSH
25257: LD_EXP 64
25261: PUSH
25262: LD_VAR 0 2
25266: ARRAY
25267: PUSH
25268: LD_VAR 0 3
25272: DIFF
25273: PPUSH
25274: CALL_OW 1
25278: ST_TO_ADDR
// continue ;
25279: GO 25224
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
25281: LD_VAR 0 3
25285: PPUSH
25286: CALL_OW 311
25290: NOT
25291: PUSH
25292: LD_VAR 0 3
25296: PUSH
25297: LD_EXP 55
25301: PUSH
25302: LD_VAR 0 2
25306: ARRAY
25307: PUSH
25308: LD_INT 1
25310: ARRAY
25311: IN
25312: NOT
25313: AND
25314: PUSH
25315: LD_VAR 0 3
25319: PUSH
25320: LD_EXP 55
25324: PUSH
25325: LD_VAR 0 2
25329: ARRAY
25330: PUSH
25331: LD_INT 2
25333: ARRAY
25334: IN
25335: NOT
25336: AND
25337: IFFALSE 25389
// begin if IsInUnit ( j ) then
25339: LD_VAR 0 3
25343: PPUSH
25344: CALL_OW 310
25348: IFFALSE 25359
// ComExitBuilding ( j ) ;
25350: LD_VAR 0 3
25354: PPUSH
25355: CALL_OW 122
// if not HasTask ( j ) then
25359: LD_VAR 0 3
25363: PPUSH
25364: CALL_OW 314
25368: NOT
25369: IFFALSE 25389
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
25371: LD_VAR 0 3
25375: PPUSH
25376: LD_VAR 0 7
25380: PUSH
25381: LD_INT 1
25383: ARRAY
25384: PPUSH
25385: CALL_OW 189
// end ; end ;
25389: GO 25224
25391: POP
25392: POP
// end ;
25393: GO 24713
25395: POP
25396: POP
// end ;
25397: LD_VAR 0 1
25401: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
25402: LD_INT 0
25404: PPUSH
25405: PPUSH
25406: PPUSH
25407: PPUSH
25408: PPUSH
25409: PPUSH
25410: PPUSH
25411: PPUSH
25412: PPUSH
25413: PPUSH
25414: PPUSH
// if not mc_bases then
25415: LD_EXP 52
25419: NOT
25420: IFFALSE 25424
// exit ;
25422: GO 26226
// for i = 1 to mc_bases do
25424: LD_ADDR_VAR 0 2
25428: PUSH
25429: DOUBLE
25430: LD_INT 1
25432: DEC
25433: ST_TO_ADDR
25434: LD_EXP 52
25438: PUSH
25439: FOR_TO
25440: IFFALSE 26224
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
25442: LD_EXP 80
25446: PUSH
25447: LD_VAR 0 2
25451: ARRAY
25452: NOT
25453: PUSH
25454: LD_EXP 55
25458: PUSH
25459: LD_VAR 0 2
25463: ARRAY
25464: PUSH
25465: LD_INT 1
25467: ARRAY
25468: OR
25469: PUSH
25470: LD_EXP 55
25474: PUSH
25475: LD_VAR 0 2
25479: ARRAY
25480: PUSH
25481: LD_INT 2
25483: ARRAY
25484: OR
25485: PUSH
25486: LD_EXP 78
25490: PUSH
25491: LD_VAR 0 2
25495: ARRAY
25496: PPUSH
25497: LD_INT 1
25499: PPUSH
25500: CALL_OW 325
25504: NOT
25505: OR
25506: PUSH
25507: LD_EXP 75
25511: PUSH
25512: LD_VAR 0 2
25516: ARRAY
25517: OR
25518: IFFALSE 25522
// continue ;
25520: GO 25439
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
25522: LD_ADDR_VAR 0 8
25526: PUSH
25527: LD_EXP 52
25531: PUSH
25532: LD_VAR 0 2
25536: ARRAY
25537: PPUSH
25538: LD_INT 25
25540: PUSH
25541: LD_INT 4
25543: PUSH
25544: EMPTY
25545: LIST
25546: LIST
25547: PUSH
25548: LD_INT 50
25550: PUSH
25551: EMPTY
25552: LIST
25553: PUSH
25554: LD_INT 3
25556: PUSH
25557: LD_INT 60
25559: PUSH
25560: EMPTY
25561: LIST
25562: PUSH
25563: EMPTY
25564: LIST
25565: LIST
25566: PUSH
25567: EMPTY
25568: LIST
25569: LIST
25570: LIST
25571: PPUSH
25572: CALL_OW 72
25576: PUSH
25577: LD_EXP 56
25581: PUSH
25582: LD_VAR 0 2
25586: ARRAY
25587: DIFF
25588: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
25589: LD_ADDR_VAR 0 9
25593: PUSH
25594: LD_EXP 52
25598: PUSH
25599: LD_VAR 0 2
25603: ARRAY
25604: PPUSH
25605: LD_INT 2
25607: PUSH
25608: LD_INT 30
25610: PUSH
25611: LD_INT 0
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: PUSH
25618: LD_INT 30
25620: PUSH
25621: LD_INT 1
25623: PUSH
25624: EMPTY
25625: LIST
25626: LIST
25627: PUSH
25628: EMPTY
25629: LIST
25630: LIST
25631: LIST
25632: PPUSH
25633: CALL_OW 72
25637: ST_TO_ADDR
// if not tmp or not dep then
25638: LD_VAR 0 8
25642: NOT
25643: PUSH
25644: LD_VAR 0 9
25648: NOT
25649: OR
25650: IFFALSE 25654
// continue ;
25652: GO 25439
// side := GetSide ( tmp [ 1 ] ) ;
25654: LD_ADDR_VAR 0 11
25658: PUSH
25659: LD_VAR 0 8
25663: PUSH
25664: LD_INT 1
25666: ARRAY
25667: PPUSH
25668: CALL_OW 255
25672: ST_TO_ADDR
// dep := dep [ 1 ] ;
25673: LD_ADDR_VAR 0 9
25677: PUSH
25678: LD_VAR 0 9
25682: PUSH
25683: LD_INT 1
25685: ARRAY
25686: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
25687: LD_ADDR_VAR 0 7
25691: PUSH
25692: LD_EXP 80
25696: PUSH
25697: LD_VAR 0 2
25701: ARRAY
25702: PPUSH
25703: LD_INT 22
25705: PUSH
25706: LD_INT 0
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: PUSH
25713: LD_INT 25
25715: PUSH
25716: LD_INT 12
25718: PUSH
25719: EMPTY
25720: LIST
25721: LIST
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: PPUSH
25727: CALL_OW 70
25731: PUSH
25732: LD_INT 22
25734: PUSH
25735: LD_INT 0
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: LD_INT 25
25744: PUSH
25745: LD_INT 12
25747: PUSH
25748: EMPTY
25749: LIST
25750: LIST
25751: PUSH
25752: LD_INT 91
25754: PUSH
25755: LD_VAR 0 9
25759: PUSH
25760: LD_INT 20
25762: PUSH
25763: EMPTY
25764: LIST
25765: LIST
25766: LIST
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: LIST
25772: PPUSH
25773: CALL_OW 69
25777: UNION
25778: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
25779: LD_ADDR_VAR 0 10
25783: PUSH
25784: LD_EXP 80
25788: PUSH
25789: LD_VAR 0 2
25793: ARRAY
25794: PPUSH
25795: LD_INT 81
25797: PUSH
25798: LD_VAR 0 11
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: PPUSH
25807: CALL_OW 70
25811: ST_TO_ADDR
// if not apes or danger_at_area then
25812: LD_VAR 0 7
25816: NOT
25817: PUSH
25818: LD_VAR 0 10
25822: OR
25823: IFFALSE 25873
// begin if mc_taming [ i ] then
25825: LD_EXP 83
25829: PUSH
25830: LD_VAR 0 2
25834: ARRAY
25835: IFFALSE 25871
// begin MC_Reset ( i , 121 ) ;
25837: LD_VAR 0 2
25841: PPUSH
25842: LD_INT 121
25844: PPUSH
25845: CALL 11324 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25849: LD_ADDR_EXP 83
25853: PUSH
25854: LD_EXP 83
25858: PPUSH
25859: LD_VAR 0 2
25863: PPUSH
25864: EMPTY
25865: PPUSH
25866: CALL_OW 1
25870: ST_TO_ADDR
// end ; continue ;
25871: GO 25439
// end ; for j in tmp do
25873: LD_ADDR_VAR 0 3
25877: PUSH
25878: LD_VAR 0 8
25882: PUSH
25883: FOR_IN
25884: IFFALSE 26220
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
25886: LD_VAR 0 3
25890: PUSH
25891: LD_EXP 83
25895: PUSH
25896: LD_VAR 0 2
25900: ARRAY
25901: IN
25902: NOT
25903: PUSH
25904: LD_EXP 83
25908: PUSH
25909: LD_VAR 0 2
25913: ARRAY
25914: PUSH
25915: LD_INT 3
25917: LESS
25918: AND
25919: IFFALSE 25977
// begin SetTag ( j , 121 ) ;
25921: LD_VAR 0 3
25925: PPUSH
25926: LD_INT 121
25928: PPUSH
25929: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
25933: LD_ADDR_EXP 83
25937: PUSH
25938: LD_EXP 83
25942: PPUSH
25943: LD_VAR 0 2
25947: PUSH
25948: LD_EXP 83
25952: PUSH
25953: LD_VAR 0 2
25957: ARRAY
25958: PUSH
25959: LD_INT 1
25961: PLUS
25962: PUSH
25963: EMPTY
25964: LIST
25965: LIST
25966: PPUSH
25967: LD_VAR 0 3
25971: PPUSH
25972: CALL 37482 0 3
25976: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
25977: LD_VAR 0 3
25981: PUSH
25982: LD_EXP 83
25986: PUSH
25987: LD_VAR 0 2
25991: ARRAY
25992: IN
25993: IFFALSE 26218
// begin if GetClass ( j ) <> 4 then
25995: LD_VAR 0 3
25999: PPUSH
26000: CALL_OW 257
26004: PUSH
26005: LD_INT 4
26007: NONEQUAL
26008: IFFALSE 26061
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
26010: LD_ADDR_EXP 83
26014: PUSH
26015: LD_EXP 83
26019: PPUSH
26020: LD_VAR 0 2
26024: PPUSH
26025: LD_EXP 83
26029: PUSH
26030: LD_VAR 0 2
26034: ARRAY
26035: PUSH
26036: LD_VAR 0 3
26040: DIFF
26041: PPUSH
26042: CALL_OW 1
26046: ST_TO_ADDR
// SetTag ( j , 0 ) ;
26047: LD_VAR 0 3
26051: PPUSH
26052: LD_INT 0
26054: PPUSH
26055: CALL_OW 109
// continue ;
26059: GO 25883
// end ; if IsInUnit ( j ) then
26061: LD_VAR 0 3
26065: PPUSH
26066: CALL_OW 310
26070: IFFALSE 26081
// ComExitBuilding ( j ) ;
26072: LD_VAR 0 3
26076: PPUSH
26077: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
26081: LD_ADDR_VAR 0 6
26085: PUSH
26086: LD_VAR 0 7
26090: PPUSH
26091: LD_VAR 0 3
26095: PPUSH
26096: CALL_OW 74
26100: ST_TO_ADDR
// if not ape then
26101: LD_VAR 0 6
26105: NOT
26106: IFFALSE 26110
// break ;
26108: GO 26220
// x := GetX ( ape ) ;
26110: LD_ADDR_VAR 0 4
26114: PUSH
26115: LD_VAR 0 6
26119: PPUSH
26120: CALL_OW 250
26124: ST_TO_ADDR
// y := GetY ( ape ) ;
26125: LD_ADDR_VAR 0 5
26129: PUSH
26130: LD_VAR 0 6
26134: PPUSH
26135: CALL_OW 251
26139: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
26140: LD_VAR 0 4
26144: PPUSH
26145: LD_VAR 0 5
26149: PPUSH
26150: CALL_OW 488
26154: NOT
26155: PUSH
26156: LD_VAR 0 11
26160: PPUSH
26161: LD_VAR 0 4
26165: PPUSH
26166: LD_VAR 0 5
26170: PPUSH
26171: LD_INT 20
26173: PPUSH
26174: CALL 38378 0 4
26178: PUSH
26179: LD_INT 4
26181: ARRAY
26182: OR
26183: IFFALSE 26187
// break ;
26185: GO 26220
// if not HasTask ( j ) then
26187: LD_VAR 0 3
26191: PPUSH
26192: CALL_OW 314
26196: NOT
26197: IFFALSE 26218
// ComTameXY ( j , x , y ) ;
26199: LD_VAR 0 3
26203: PPUSH
26204: LD_VAR 0 4
26208: PPUSH
26209: LD_VAR 0 5
26213: PPUSH
26214: CALL_OW 131
// end ; end ;
26218: GO 25883
26220: POP
26221: POP
// end ;
26222: GO 25439
26224: POP
26225: POP
// end ;
26226: LD_VAR 0 1
26230: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
26231: LD_INT 0
26233: PPUSH
26234: PPUSH
26235: PPUSH
26236: PPUSH
26237: PPUSH
26238: PPUSH
26239: PPUSH
26240: PPUSH
// if not mc_bases then
26241: LD_EXP 52
26245: NOT
26246: IFFALSE 26250
// exit ;
26248: GO 26876
// for i = 1 to mc_bases do
26250: LD_ADDR_VAR 0 2
26254: PUSH
26255: DOUBLE
26256: LD_INT 1
26258: DEC
26259: ST_TO_ADDR
26260: LD_EXP 52
26264: PUSH
26265: FOR_TO
26266: IFFALSE 26874
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
26268: LD_EXP 81
26272: PUSH
26273: LD_VAR 0 2
26277: ARRAY
26278: NOT
26279: PUSH
26280: LD_EXP 81
26284: PUSH
26285: LD_VAR 0 2
26289: ARRAY
26290: PPUSH
26291: LD_INT 25
26293: PUSH
26294: LD_INT 12
26296: PUSH
26297: EMPTY
26298: LIST
26299: LIST
26300: PPUSH
26301: CALL_OW 72
26305: NOT
26306: OR
26307: IFFALSE 26311
// continue ;
26309: GO 26265
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
26311: LD_ADDR_VAR 0 5
26315: PUSH
26316: LD_EXP 81
26320: PUSH
26321: LD_VAR 0 2
26325: ARRAY
26326: PUSH
26327: LD_INT 1
26329: ARRAY
26330: PPUSH
26331: CALL_OW 255
26335: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
26336: LD_VAR 0 5
26340: PPUSH
26341: LD_INT 2
26343: PPUSH
26344: CALL_OW 325
26348: IFFALSE 26601
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
26350: LD_ADDR_VAR 0 4
26354: PUSH
26355: LD_EXP 81
26359: PUSH
26360: LD_VAR 0 2
26364: ARRAY
26365: PPUSH
26366: LD_INT 25
26368: PUSH
26369: LD_INT 16
26371: PUSH
26372: EMPTY
26373: LIST
26374: LIST
26375: PPUSH
26376: CALL_OW 72
26380: ST_TO_ADDR
// if tmp < 6 then
26381: LD_VAR 0 4
26385: PUSH
26386: LD_INT 6
26388: LESS
26389: IFFALSE 26601
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26391: LD_ADDR_VAR 0 6
26395: PUSH
26396: LD_EXP 52
26400: PUSH
26401: LD_VAR 0 2
26405: ARRAY
26406: PPUSH
26407: LD_INT 2
26409: PUSH
26410: LD_INT 30
26412: PUSH
26413: LD_INT 0
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: PUSH
26420: LD_INT 30
26422: PUSH
26423: LD_INT 1
26425: PUSH
26426: EMPTY
26427: LIST
26428: LIST
26429: PUSH
26430: EMPTY
26431: LIST
26432: LIST
26433: LIST
26434: PPUSH
26435: CALL_OW 72
26439: ST_TO_ADDR
// if depot then
26440: LD_VAR 0 6
26444: IFFALSE 26601
// begin selected := 0 ;
26446: LD_ADDR_VAR 0 7
26450: PUSH
26451: LD_INT 0
26453: ST_TO_ADDR
// for j in depot do
26454: LD_ADDR_VAR 0 3
26458: PUSH
26459: LD_VAR 0 6
26463: PUSH
26464: FOR_IN
26465: IFFALSE 26496
// begin if UnitsInside ( j ) < 6 then
26467: LD_VAR 0 3
26471: PPUSH
26472: CALL_OW 313
26476: PUSH
26477: LD_INT 6
26479: LESS
26480: IFFALSE 26494
// begin selected := j ;
26482: LD_ADDR_VAR 0 7
26486: PUSH
26487: LD_VAR 0 3
26491: ST_TO_ADDR
// break ;
26492: GO 26496
// end ; end ;
26494: GO 26464
26496: POP
26497: POP
// if selected then
26498: LD_VAR 0 7
26502: IFFALSE 26601
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
26504: LD_ADDR_VAR 0 3
26508: PUSH
26509: LD_EXP 81
26513: PUSH
26514: LD_VAR 0 2
26518: ARRAY
26519: PPUSH
26520: LD_INT 25
26522: PUSH
26523: LD_INT 12
26525: PUSH
26526: EMPTY
26527: LIST
26528: LIST
26529: PPUSH
26530: CALL_OW 72
26534: PUSH
26535: FOR_IN
26536: IFFALSE 26599
// if not HasTask ( j ) then
26538: LD_VAR 0 3
26542: PPUSH
26543: CALL_OW 314
26547: NOT
26548: IFFALSE 26597
// begin if not IsInUnit ( j ) then
26550: LD_VAR 0 3
26554: PPUSH
26555: CALL_OW 310
26559: NOT
26560: IFFALSE 26576
// ComEnterUnit ( j , selected ) ;
26562: LD_VAR 0 3
26566: PPUSH
26567: LD_VAR 0 7
26571: PPUSH
26572: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
26576: LD_VAR 0 3
26580: PPUSH
26581: LD_INT 16
26583: PPUSH
26584: CALL_OW 183
// AddComExitBuilding ( j ) ;
26588: LD_VAR 0 3
26592: PPUSH
26593: CALL_OW 182
// end ;
26597: GO 26535
26599: POP
26600: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
26601: LD_VAR 0 5
26605: PPUSH
26606: LD_INT 11
26608: PPUSH
26609: CALL_OW 325
26613: IFFALSE 26872
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
26615: LD_ADDR_VAR 0 4
26619: PUSH
26620: LD_EXP 81
26624: PUSH
26625: LD_VAR 0 2
26629: ARRAY
26630: PPUSH
26631: LD_INT 25
26633: PUSH
26634: LD_INT 16
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: PPUSH
26641: CALL_OW 72
26645: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
26646: LD_VAR 0 4
26650: PUSH
26651: LD_INT 6
26653: GREATEREQUAL
26654: PUSH
26655: LD_VAR 0 5
26659: PPUSH
26660: LD_INT 2
26662: PPUSH
26663: CALL_OW 325
26667: NOT
26668: OR
26669: IFFALSE 26872
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26671: LD_ADDR_VAR 0 8
26675: PUSH
26676: LD_EXP 52
26680: PUSH
26681: LD_VAR 0 2
26685: ARRAY
26686: PPUSH
26687: LD_INT 2
26689: PUSH
26690: LD_INT 30
26692: PUSH
26693: LD_INT 4
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PUSH
26700: LD_INT 30
26702: PUSH
26703: LD_INT 5
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PUSH
26710: EMPTY
26711: LIST
26712: LIST
26713: LIST
26714: PPUSH
26715: CALL_OW 72
26719: ST_TO_ADDR
// if barracks then
26720: LD_VAR 0 8
26724: IFFALSE 26872
// begin selected := 0 ;
26726: LD_ADDR_VAR 0 7
26730: PUSH
26731: LD_INT 0
26733: ST_TO_ADDR
// for j in barracks do
26734: LD_ADDR_VAR 0 3
26738: PUSH
26739: LD_VAR 0 8
26743: PUSH
26744: FOR_IN
26745: IFFALSE 26776
// begin if UnitsInside ( j ) < 6 then
26747: LD_VAR 0 3
26751: PPUSH
26752: CALL_OW 313
26756: PUSH
26757: LD_INT 6
26759: LESS
26760: IFFALSE 26774
// begin selected := j ;
26762: LD_ADDR_VAR 0 7
26766: PUSH
26767: LD_VAR 0 3
26771: ST_TO_ADDR
// break ;
26772: GO 26776
// end ; end ;
26774: GO 26744
26776: POP
26777: POP
// if selected then
26778: LD_VAR 0 7
26782: IFFALSE 26872
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
26784: LD_ADDR_VAR 0 3
26788: PUSH
26789: LD_EXP 81
26793: PUSH
26794: LD_VAR 0 2
26798: ARRAY
26799: PPUSH
26800: LD_INT 25
26802: PUSH
26803: LD_INT 12
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: PPUSH
26810: CALL_OW 72
26814: PUSH
26815: FOR_IN
26816: IFFALSE 26870
// if not IsInUnit ( j ) and not HasTask ( j ) then
26818: LD_VAR 0 3
26822: PPUSH
26823: CALL_OW 310
26827: NOT
26828: PUSH
26829: LD_VAR 0 3
26833: PPUSH
26834: CALL_OW 314
26838: NOT
26839: AND
26840: IFFALSE 26868
// begin ComEnterUnit ( j , selected ) ;
26842: LD_VAR 0 3
26846: PPUSH
26847: LD_VAR 0 7
26851: PPUSH
26852: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
26856: LD_VAR 0 3
26860: PPUSH
26861: LD_INT 15
26863: PPUSH
26864: CALL_OW 183
// end ;
26868: GO 26815
26870: POP
26871: POP
// end ; end ; end ; end ; end ;
26872: GO 26265
26874: POP
26875: POP
// end ;
26876: LD_VAR 0 1
26880: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
26881: LD_INT 0
26883: PPUSH
26884: PPUSH
26885: PPUSH
26886: PPUSH
// if not mc_bases then
26887: LD_EXP 52
26891: NOT
26892: IFFALSE 26896
// exit ;
26894: GO 27074
// for i = 1 to mc_bases do
26896: LD_ADDR_VAR 0 2
26900: PUSH
26901: DOUBLE
26902: LD_INT 1
26904: DEC
26905: ST_TO_ADDR
26906: LD_EXP 52
26910: PUSH
26911: FOR_TO
26912: IFFALSE 27072
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
26914: LD_ADDR_VAR 0 4
26918: PUSH
26919: LD_EXP 52
26923: PUSH
26924: LD_VAR 0 2
26928: ARRAY
26929: PPUSH
26930: LD_INT 25
26932: PUSH
26933: LD_INT 9
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PPUSH
26940: CALL_OW 72
26944: ST_TO_ADDR
// if not tmp then
26945: LD_VAR 0 4
26949: NOT
26950: IFFALSE 26954
// continue ;
26952: GO 26911
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
26954: LD_EXP 78
26958: PUSH
26959: LD_VAR 0 2
26963: ARRAY
26964: PPUSH
26965: LD_INT 29
26967: PPUSH
26968: CALL_OW 325
26972: NOT
26973: PUSH
26974: LD_EXP 78
26978: PUSH
26979: LD_VAR 0 2
26983: ARRAY
26984: PPUSH
26985: LD_INT 28
26987: PPUSH
26988: CALL_OW 325
26992: NOT
26993: AND
26994: IFFALSE 26998
// continue ;
26996: GO 26911
// for j in tmp do
26998: LD_ADDR_VAR 0 3
27002: PUSH
27003: LD_VAR 0 4
27007: PUSH
27008: FOR_IN
27009: IFFALSE 27068
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
27011: LD_VAR 0 3
27015: PUSH
27016: LD_EXP 55
27020: PUSH
27021: LD_VAR 0 2
27025: ARRAY
27026: PUSH
27027: LD_INT 1
27029: ARRAY
27030: IN
27031: NOT
27032: PUSH
27033: LD_VAR 0 3
27037: PUSH
27038: LD_EXP 55
27042: PUSH
27043: LD_VAR 0 2
27047: ARRAY
27048: PUSH
27049: LD_INT 2
27051: ARRAY
27052: IN
27053: NOT
27054: AND
27055: IFFALSE 27066
// ComSpaceTimeShoot ( j ) ;
27057: LD_VAR 0 3
27061: PPUSH
27062: CALL 33479 0 1
27066: GO 27008
27068: POP
27069: POP
// end ;
27070: GO 26911
27072: POP
27073: POP
// end ;
27074: LD_VAR 0 1
27078: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
27079: LD_INT 0
27081: PPUSH
27082: PPUSH
27083: PPUSH
27084: PPUSH
27085: PPUSH
27086: PPUSH
27087: PPUSH
27088: PPUSH
27089: PPUSH
// if not mc_bases then
27090: LD_EXP 52
27094: NOT
27095: IFFALSE 27099
// exit ;
27097: GO 27721
// for i = 1 to mc_bases do
27099: LD_ADDR_VAR 0 2
27103: PUSH
27104: DOUBLE
27105: LD_INT 1
27107: DEC
27108: ST_TO_ADDR
27109: LD_EXP 52
27113: PUSH
27114: FOR_TO
27115: IFFALSE 27719
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
27117: LD_EXP 87
27121: PUSH
27122: LD_VAR 0 2
27126: ARRAY
27127: NOT
27128: PUSH
27129: LD_INT 38
27131: PPUSH
27132: LD_EXP 78
27136: PUSH
27137: LD_VAR 0 2
27141: ARRAY
27142: PPUSH
27143: CALL_OW 321
27147: PUSH
27148: LD_INT 2
27150: NONEQUAL
27151: OR
27152: IFFALSE 27156
// continue ;
27154: GO 27114
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
27156: LD_ADDR_VAR 0 8
27160: PUSH
27161: LD_EXP 52
27165: PUSH
27166: LD_VAR 0 2
27170: ARRAY
27171: PPUSH
27172: LD_INT 30
27174: PUSH
27175: LD_INT 34
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: PPUSH
27182: CALL_OW 72
27186: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
27187: LD_ADDR_VAR 0 9
27191: PUSH
27192: LD_EXP 52
27196: PUSH
27197: LD_VAR 0 2
27201: ARRAY
27202: PPUSH
27203: LD_INT 25
27205: PUSH
27206: LD_INT 4
27208: PUSH
27209: EMPTY
27210: LIST
27211: LIST
27212: PPUSH
27213: CALL_OW 72
27217: PPUSH
27218: LD_INT 0
27220: PPUSH
27221: CALL 66043 0 2
27225: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
27226: LD_VAR 0 9
27230: NOT
27231: PUSH
27232: LD_VAR 0 8
27236: NOT
27237: OR
27238: PUSH
27239: LD_EXP 52
27243: PUSH
27244: LD_VAR 0 2
27248: ARRAY
27249: PPUSH
27250: LD_INT 124
27252: PPUSH
27253: CALL 66043 0 2
27257: OR
27258: IFFALSE 27262
// continue ;
27260: GO 27114
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
27262: LD_EXP 88
27266: PUSH
27267: LD_VAR 0 2
27271: ARRAY
27272: PUSH
27273: LD_EXP 87
27277: PUSH
27278: LD_VAR 0 2
27282: ARRAY
27283: LESS
27284: PUSH
27285: LD_EXP 88
27289: PUSH
27290: LD_VAR 0 2
27294: ARRAY
27295: PUSH
27296: LD_VAR 0 8
27300: LESS
27301: AND
27302: IFFALSE 27717
// begin tmp := sci [ 1 ] ;
27304: LD_ADDR_VAR 0 7
27308: PUSH
27309: LD_VAR 0 9
27313: PUSH
27314: LD_INT 1
27316: ARRAY
27317: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
27318: LD_VAR 0 7
27322: PPUSH
27323: LD_INT 124
27325: PPUSH
27326: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
27330: LD_ADDR_VAR 0 3
27334: PUSH
27335: DOUBLE
27336: LD_EXP 87
27340: PUSH
27341: LD_VAR 0 2
27345: ARRAY
27346: INC
27347: ST_TO_ADDR
27348: LD_EXP 87
27352: PUSH
27353: LD_VAR 0 2
27357: ARRAY
27358: PUSH
27359: FOR_DOWNTO
27360: IFFALSE 27703
// begin if IsInUnit ( tmp ) then
27362: LD_VAR 0 7
27366: PPUSH
27367: CALL_OW 310
27371: IFFALSE 27382
// ComExitBuilding ( tmp ) ;
27373: LD_VAR 0 7
27377: PPUSH
27378: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
27382: LD_INT 35
27384: PPUSH
27385: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
27389: LD_VAR 0 7
27393: PPUSH
27394: CALL_OW 310
27398: NOT
27399: PUSH
27400: LD_VAR 0 7
27404: PPUSH
27405: CALL_OW 314
27409: NOT
27410: AND
27411: IFFALSE 27382
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
27413: LD_ADDR_VAR 0 6
27417: PUSH
27418: LD_VAR 0 7
27422: PPUSH
27423: CALL_OW 250
27427: PUSH
27428: LD_VAR 0 7
27432: PPUSH
27433: CALL_OW 251
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
27442: LD_INT 35
27444: PPUSH
27445: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
27449: LD_ADDR_VAR 0 4
27453: PUSH
27454: LD_EXP 87
27458: PUSH
27459: LD_VAR 0 2
27463: ARRAY
27464: PUSH
27465: LD_VAR 0 3
27469: ARRAY
27470: PUSH
27471: LD_INT 1
27473: ARRAY
27474: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
27475: LD_ADDR_VAR 0 5
27479: PUSH
27480: LD_EXP 87
27484: PUSH
27485: LD_VAR 0 2
27489: ARRAY
27490: PUSH
27491: LD_VAR 0 3
27495: ARRAY
27496: PUSH
27497: LD_INT 2
27499: ARRAY
27500: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
27501: LD_VAR 0 7
27505: PPUSH
27506: LD_INT 10
27508: PPUSH
27509: CALL 40075 0 2
27513: PUSH
27514: LD_INT 4
27516: ARRAY
27517: IFFALSE 27555
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
27519: LD_VAR 0 7
27523: PPUSH
27524: LD_VAR 0 6
27528: PUSH
27529: LD_INT 1
27531: ARRAY
27532: PPUSH
27533: LD_VAR 0 6
27537: PUSH
27538: LD_INT 2
27540: ARRAY
27541: PPUSH
27542: CALL_OW 111
// wait ( 0 0$10 ) ;
27546: LD_INT 350
27548: PPUSH
27549: CALL_OW 67
// end else
27553: GO 27581
// begin ComMoveXY ( tmp , x , y ) ;
27555: LD_VAR 0 7
27559: PPUSH
27560: LD_VAR 0 4
27564: PPUSH
27565: LD_VAR 0 5
27569: PPUSH
27570: CALL_OW 111
// wait ( 0 0$3 ) ;
27574: LD_INT 105
27576: PPUSH
27577: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
27581: LD_VAR 0 7
27585: PPUSH
27586: LD_VAR 0 4
27590: PPUSH
27591: LD_VAR 0 5
27595: PPUSH
27596: CALL_OW 307
27600: IFFALSE 27442
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
27602: LD_VAR 0 7
27606: PPUSH
27607: LD_VAR 0 4
27611: PPUSH
27612: LD_VAR 0 5
27616: PPUSH
27617: LD_VAR 0 8
27621: PUSH
27622: LD_VAR 0 3
27626: ARRAY
27627: PPUSH
27628: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
27632: LD_INT 35
27634: PPUSH
27635: CALL_OW 67
// until not HasTask ( tmp ) ;
27639: LD_VAR 0 7
27643: PPUSH
27644: CALL_OW 314
27648: NOT
27649: IFFALSE 27632
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
27651: LD_ADDR_EXP 88
27655: PUSH
27656: LD_EXP 88
27660: PPUSH
27661: LD_VAR 0 2
27665: PUSH
27666: LD_EXP 88
27670: PUSH
27671: LD_VAR 0 2
27675: ARRAY
27676: PUSH
27677: LD_INT 1
27679: PLUS
27680: PUSH
27681: EMPTY
27682: LIST
27683: LIST
27684: PPUSH
27685: LD_VAR 0 8
27689: PUSH
27690: LD_VAR 0 3
27694: ARRAY
27695: PPUSH
27696: CALL 37482 0 3
27700: ST_TO_ADDR
// end ;
27701: GO 27359
27703: POP
27704: POP
// MC_Reset ( i , 124 ) ;
27705: LD_VAR 0 2
27709: PPUSH
27710: LD_INT 124
27712: PPUSH
27713: CALL 11324 0 2
// end ; end ;
27717: GO 27114
27719: POP
27720: POP
// end ;
27721: LD_VAR 0 1
27725: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
27726: LD_INT 0
27728: PPUSH
27729: PPUSH
27730: PPUSH
// if not mc_bases then
27731: LD_EXP 52
27735: NOT
27736: IFFALSE 27740
// exit ;
27738: GO 28346
// for i = 1 to mc_bases do
27740: LD_ADDR_VAR 0 2
27744: PUSH
27745: DOUBLE
27746: LD_INT 1
27748: DEC
27749: ST_TO_ADDR
27750: LD_EXP 52
27754: PUSH
27755: FOR_TO
27756: IFFALSE 28344
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27758: LD_ADDR_VAR 0 3
27762: PUSH
27763: LD_EXP 52
27767: PUSH
27768: LD_VAR 0 2
27772: ARRAY
27773: PPUSH
27774: LD_INT 25
27776: PUSH
27777: LD_INT 4
27779: PUSH
27780: EMPTY
27781: LIST
27782: LIST
27783: PPUSH
27784: CALL_OW 72
27788: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
27789: LD_VAR 0 3
27793: NOT
27794: PUSH
27795: LD_EXP 89
27799: PUSH
27800: LD_VAR 0 2
27804: ARRAY
27805: NOT
27806: OR
27807: PUSH
27808: LD_EXP 52
27812: PUSH
27813: LD_VAR 0 2
27817: ARRAY
27818: PPUSH
27819: LD_INT 2
27821: PUSH
27822: LD_INT 30
27824: PUSH
27825: LD_INT 0
27827: PUSH
27828: EMPTY
27829: LIST
27830: LIST
27831: PUSH
27832: LD_INT 30
27834: PUSH
27835: LD_INT 1
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: PUSH
27842: EMPTY
27843: LIST
27844: LIST
27845: LIST
27846: PPUSH
27847: CALL_OW 72
27851: NOT
27852: OR
27853: IFFALSE 27903
// begin if mc_deposits_finder [ i ] then
27855: LD_EXP 90
27859: PUSH
27860: LD_VAR 0 2
27864: ARRAY
27865: IFFALSE 27901
// begin MC_Reset ( i , 125 ) ;
27867: LD_VAR 0 2
27871: PPUSH
27872: LD_INT 125
27874: PPUSH
27875: CALL 11324 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
27879: LD_ADDR_EXP 90
27883: PUSH
27884: LD_EXP 90
27888: PPUSH
27889: LD_VAR 0 2
27893: PPUSH
27894: EMPTY
27895: PPUSH
27896: CALL_OW 1
27900: ST_TO_ADDR
// end ; continue ;
27901: GO 27755
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
27903: LD_EXP 89
27907: PUSH
27908: LD_VAR 0 2
27912: ARRAY
27913: PUSH
27914: LD_INT 1
27916: ARRAY
27917: PUSH
27918: LD_INT 3
27920: ARRAY
27921: PUSH
27922: LD_INT 1
27924: EQUAL
27925: PUSH
27926: LD_INT 20
27928: PPUSH
27929: LD_EXP 78
27933: PUSH
27934: LD_VAR 0 2
27938: ARRAY
27939: PPUSH
27940: CALL_OW 321
27944: PUSH
27945: LD_INT 2
27947: NONEQUAL
27948: AND
27949: IFFALSE 27999
// begin if mc_deposits_finder [ i ] then
27951: LD_EXP 90
27955: PUSH
27956: LD_VAR 0 2
27960: ARRAY
27961: IFFALSE 27997
// begin MC_Reset ( i , 125 ) ;
27963: LD_VAR 0 2
27967: PPUSH
27968: LD_INT 125
27970: PPUSH
27971: CALL 11324 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
27975: LD_ADDR_EXP 90
27979: PUSH
27980: LD_EXP 90
27984: PPUSH
27985: LD_VAR 0 2
27989: PPUSH
27990: EMPTY
27991: PPUSH
27992: CALL_OW 1
27996: ST_TO_ADDR
// end ; continue ;
27997: GO 27755
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
27999: LD_EXP 89
28003: PUSH
28004: LD_VAR 0 2
28008: ARRAY
28009: PUSH
28010: LD_INT 1
28012: ARRAY
28013: PUSH
28014: LD_INT 1
28016: ARRAY
28017: PPUSH
28018: LD_EXP 89
28022: PUSH
28023: LD_VAR 0 2
28027: ARRAY
28028: PUSH
28029: LD_INT 1
28031: ARRAY
28032: PUSH
28033: LD_INT 2
28035: ARRAY
28036: PPUSH
28037: LD_EXP 78
28041: PUSH
28042: LD_VAR 0 2
28046: ARRAY
28047: PPUSH
28048: CALL_OW 440
28052: IFFALSE 28095
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
28054: LD_ADDR_EXP 89
28058: PUSH
28059: LD_EXP 89
28063: PPUSH
28064: LD_VAR 0 2
28068: PPUSH
28069: LD_EXP 89
28073: PUSH
28074: LD_VAR 0 2
28078: ARRAY
28079: PPUSH
28080: LD_INT 1
28082: PPUSH
28083: CALL_OW 3
28087: PPUSH
28088: CALL_OW 1
28092: ST_TO_ADDR
28093: GO 28342
// begin if not mc_deposits_finder [ i ] then
28095: LD_EXP 90
28099: PUSH
28100: LD_VAR 0 2
28104: ARRAY
28105: NOT
28106: IFFALSE 28158
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
28108: LD_ADDR_EXP 90
28112: PUSH
28113: LD_EXP 90
28117: PPUSH
28118: LD_VAR 0 2
28122: PPUSH
28123: LD_VAR 0 3
28127: PUSH
28128: LD_INT 1
28130: ARRAY
28131: PUSH
28132: EMPTY
28133: LIST
28134: PPUSH
28135: CALL_OW 1
28139: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
28140: LD_VAR 0 3
28144: PUSH
28145: LD_INT 1
28147: ARRAY
28148: PPUSH
28149: LD_INT 125
28151: PPUSH
28152: CALL_OW 109
// end else
28156: GO 28342
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
28158: LD_EXP 90
28162: PUSH
28163: LD_VAR 0 2
28167: ARRAY
28168: PUSH
28169: LD_INT 1
28171: ARRAY
28172: PPUSH
28173: CALL_OW 310
28177: IFFALSE 28200
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
28179: LD_EXP 90
28183: PUSH
28184: LD_VAR 0 2
28188: ARRAY
28189: PUSH
28190: LD_INT 1
28192: ARRAY
28193: PPUSH
28194: CALL_OW 122
28198: GO 28342
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
28200: LD_EXP 90
28204: PUSH
28205: LD_VAR 0 2
28209: ARRAY
28210: PUSH
28211: LD_INT 1
28213: ARRAY
28214: PPUSH
28215: CALL_OW 314
28219: NOT
28220: PUSH
28221: LD_EXP 90
28225: PUSH
28226: LD_VAR 0 2
28230: ARRAY
28231: PUSH
28232: LD_INT 1
28234: ARRAY
28235: PPUSH
28236: LD_EXP 89
28240: PUSH
28241: LD_VAR 0 2
28245: ARRAY
28246: PUSH
28247: LD_INT 1
28249: ARRAY
28250: PUSH
28251: LD_INT 1
28253: ARRAY
28254: PPUSH
28255: LD_EXP 89
28259: PUSH
28260: LD_VAR 0 2
28264: ARRAY
28265: PUSH
28266: LD_INT 1
28268: ARRAY
28269: PUSH
28270: LD_INT 2
28272: ARRAY
28273: PPUSH
28274: CALL_OW 297
28278: PUSH
28279: LD_INT 6
28281: GREATER
28282: AND
28283: IFFALSE 28342
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
28285: LD_EXP 90
28289: PUSH
28290: LD_VAR 0 2
28294: ARRAY
28295: PUSH
28296: LD_INT 1
28298: ARRAY
28299: PPUSH
28300: LD_EXP 89
28304: PUSH
28305: LD_VAR 0 2
28309: ARRAY
28310: PUSH
28311: LD_INT 1
28313: ARRAY
28314: PUSH
28315: LD_INT 1
28317: ARRAY
28318: PPUSH
28319: LD_EXP 89
28323: PUSH
28324: LD_VAR 0 2
28328: ARRAY
28329: PUSH
28330: LD_INT 1
28332: ARRAY
28333: PUSH
28334: LD_INT 2
28336: ARRAY
28337: PPUSH
28338: CALL_OW 111
// end ; end ; end ;
28342: GO 27755
28344: POP
28345: POP
// end ;
28346: LD_VAR 0 1
28350: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
28351: LD_INT 0
28353: PPUSH
28354: PPUSH
28355: PPUSH
28356: PPUSH
28357: PPUSH
28358: PPUSH
28359: PPUSH
28360: PPUSH
28361: PPUSH
28362: PPUSH
28363: PPUSH
// if not mc_bases then
28364: LD_EXP 52
28368: NOT
28369: IFFALSE 28373
// exit ;
28371: GO 29313
// for i = 1 to mc_bases do
28373: LD_ADDR_VAR 0 2
28377: PUSH
28378: DOUBLE
28379: LD_INT 1
28381: DEC
28382: ST_TO_ADDR
28383: LD_EXP 52
28387: PUSH
28388: FOR_TO
28389: IFFALSE 29311
// begin if not mc_bases [ i ] or mc_scan [ i ] then
28391: LD_EXP 52
28395: PUSH
28396: LD_VAR 0 2
28400: ARRAY
28401: NOT
28402: PUSH
28403: LD_EXP 75
28407: PUSH
28408: LD_VAR 0 2
28412: ARRAY
28413: OR
28414: IFFALSE 28418
// continue ;
28416: GO 28388
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
28418: LD_ADDR_VAR 0 7
28422: PUSH
28423: LD_EXP 52
28427: PUSH
28428: LD_VAR 0 2
28432: ARRAY
28433: PUSH
28434: LD_INT 1
28436: ARRAY
28437: PPUSH
28438: CALL_OW 248
28442: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
28443: LD_VAR 0 7
28447: PUSH
28448: LD_INT 3
28450: EQUAL
28451: PUSH
28452: LD_EXP 71
28456: PUSH
28457: LD_VAR 0 2
28461: ARRAY
28462: PUSH
28463: LD_EXP 74
28467: PUSH
28468: LD_VAR 0 2
28472: ARRAY
28473: UNION
28474: PPUSH
28475: LD_INT 33
28477: PUSH
28478: LD_INT 2
28480: PUSH
28481: EMPTY
28482: LIST
28483: LIST
28484: PPUSH
28485: CALL_OW 72
28489: NOT
28490: OR
28491: IFFALSE 28495
// continue ;
28493: GO 28388
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
28495: LD_ADDR_VAR 0 9
28499: PUSH
28500: LD_EXP 52
28504: PUSH
28505: LD_VAR 0 2
28509: ARRAY
28510: PPUSH
28511: LD_INT 30
28513: PUSH
28514: LD_INT 36
28516: PUSH
28517: EMPTY
28518: LIST
28519: LIST
28520: PPUSH
28521: CALL_OW 72
28525: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
28526: LD_ADDR_VAR 0 10
28530: PUSH
28531: LD_EXP 71
28535: PUSH
28536: LD_VAR 0 2
28540: ARRAY
28541: PPUSH
28542: LD_INT 34
28544: PUSH
28545: LD_INT 31
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PPUSH
28552: CALL_OW 72
28556: ST_TO_ADDR
// if not cts and not mcts then
28557: LD_VAR 0 9
28561: NOT
28562: PUSH
28563: LD_VAR 0 10
28567: NOT
28568: AND
28569: IFFALSE 28573
// continue ;
28571: GO 28388
// x := cts ;
28573: LD_ADDR_VAR 0 11
28577: PUSH
28578: LD_VAR 0 9
28582: ST_TO_ADDR
// if not x then
28583: LD_VAR 0 11
28587: NOT
28588: IFFALSE 28600
// x := mcts ;
28590: LD_ADDR_VAR 0 11
28594: PUSH
28595: LD_VAR 0 10
28599: ST_TO_ADDR
// if not x then
28600: LD_VAR 0 11
28604: NOT
28605: IFFALSE 28609
// continue ;
28607: GO 28388
// if mc_remote_driver [ i ] then
28609: LD_EXP 92
28613: PUSH
28614: LD_VAR 0 2
28618: ARRAY
28619: IFFALSE 29006
// for j in mc_remote_driver [ i ] do
28621: LD_ADDR_VAR 0 3
28625: PUSH
28626: LD_EXP 92
28630: PUSH
28631: LD_VAR 0 2
28635: ARRAY
28636: PUSH
28637: FOR_IN
28638: IFFALSE 29004
// begin if GetClass ( j ) <> 3 then
28640: LD_VAR 0 3
28644: PPUSH
28645: CALL_OW 257
28649: PUSH
28650: LD_INT 3
28652: NONEQUAL
28653: IFFALSE 28706
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
28655: LD_ADDR_EXP 92
28659: PUSH
28660: LD_EXP 92
28664: PPUSH
28665: LD_VAR 0 2
28669: PPUSH
28670: LD_EXP 92
28674: PUSH
28675: LD_VAR 0 2
28679: ARRAY
28680: PUSH
28681: LD_VAR 0 3
28685: DIFF
28686: PPUSH
28687: CALL_OW 1
28691: ST_TO_ADDR
// SetTag ( j , 0 ) ;
28692: LD_VAR 0 3
28696: PPUSH
28697: LD_INT 0
28699: PPUSH
28700: CALL_OW 109
// continue ;
28704: GO 28637
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
28706: LD_EXP 71
28710: PUSH
28711: LD_VAR 0 2
28715: ARRAY
28716: PPUSH
28717: LD_INT 34
28719: PUSH
28720: LD_INT 31
28722: PUSH
28723: EMPTY
28724: LIST
28725: LIST
28726: PUSH
28727: LD_INT 58
28729: PUSH
28730: EMPTY
28731: LIST
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: PPUSH
28737: CALL_OW 72
28741: PUSH
28742: LD_VAR 0 3
28746: PPUSH
28747: CALL 66131 0 1
28751: NOT
28752: AND
28753: IFFALSE 28824
// begin if IsInUnit ( j ) then
28755: LD_VAR 0 3
28759: PPUSH
28760: CALL_OW 310
28764: IFFALSE 28775
// ComExitBuilding ( j ) ;
28766: LD_VAR 0 3
28770: PPUSH
28771: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
28775: LD_VAR 0 3
28779: PPUSH
28780: LD_EXP 71
28784: PUSH
28785: LD_VAR 0 2
28789: ARRAY
28790: PPUSH
28791: LD_INT 34
28793: PUSH
28794: LD_INT 31
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: PUSH
28801: LD_INT 58
28803: PUSH
28804: EMPTY
28805: LIST
28806: PUSH
28807: EMPTY
28808: LIST
28809: LIST
28810: PPUSH
28811: CALL_OW 72
28815: PUSH
28816: LD_INT 1
28818: ARRAY
28819: PPUSH
28820: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
28824: LD_VAR 0 3
28828: PPUSH
28829: CALL_OW 310
28833: NOT
28834: PUSH
28835: LD_VAR 0 3
28839: PPUSH
28840: CALL_OW 310
28844: PPUSH
28845: CALL_OW 266
28849: PUSH
28850: LD_INT 36
28852: NONEQUAL
28853: PUSH
28854: LD_VAR 0 3
28858: PPUSH
28859: CALL 66131 0 1
28863: NOT
28864: AND
28865: OR
28866: IFFALSE 29002
// begin if IsInUnit ( j ) then
28868: LD_VAR 0 3
28872: PPUSH
28873: CALL_OW 310
28877: IFFALSE 28888
// ComExitBuilding ( j ) ;
28879: LD_VAR 0 3
28883: PPUSH
28884: CALL_OW 122
// ct := 0 ;
28888: LD_ADDR_VAR 0 8
28892: PUSH
28893: LD_INT 0
28895: ST_TO_ADDR
// for k in x do
28896: LD_ADDR_VAR 0 4
28900: PUSH
28901: LD_VAR 0 11
28905: PUSH
28906: FOR_IN
28907: IFFALSE 28980
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
28909: LD_VAR 0 4
28913: PPUSH
28914: CALL_OW 264
28918: PUSH
28919: LD_INT 31
28921: EQUAL
28922: PUSH
28923: LD_VAR 0 4
28927: PPUSH
28928: CALL_OW 311
28932: NOT
28933: AND
28934: PUSH
28935: LD_VAR 0 4
28939: PPUSH
28940: CALL_OW 266
28944: PUSH
28945: LD_INT 36
28947: EQUAL
28948: PUSH
28949: LD_VAR 0 4
28953: PPUSH
28954: CALL_OW 313
28958: PUSH
28959: LD_INT 3
28961: LESS
28962: AND
28963: OR
28964: IFFALSE 28978
// begin ct := k ;
28966: LD_ADDR_VAR 0 8
28970: PUSH
28971: LD_VAR 0 4
28975: ST_TO_ADDR
// break ;
28976: GO 28980
// end ;
28978: GO 28906
28980: POP
28981: POP
// if ct then
28982: LD_VAR 0 8
28986: IFFALSE 29002
// ComEnterUnit ( j , ct ) ;
28988: LD_VAR 0 3
28992: PPUSH
28993: LD_VAR 0 8
28997: PPUSH
28998: CALL_OW 120
// end ; end ;
29002: GO 28637
29004: POP
29005: POP
// places := 0 ;
29006: LD_ADDR_VAR 0 5
29010: PUSH
29011: LD_INT 0
29013: ST_TO_ADDR
// for j = 1 to x do
29014: LD_ADDR_VAR 0 3
29018: PUSH
29019: DOUBLE
29020: LD_INT 1
29022: DEC
29023: ST_TO_ADDR
29024: LD_VAR 0 11
29028: PUSH
29029: FOR_TO
29030: IFFALSE 29106
// if GetWeapon ( x [ j ] ) = ar_control_tower then
29032: LD_VAR 0 11
29036: PUSH
29037: LD_VAR 0 3
29041: ARRAY
29042: PPUSH
29043: CALL_OW 264
29047: PUSH
29048: LD_INT 31
29050: EQUAL
29051: IFFALSE 29069
// places := places + 1 else
29053: LD_ADDR_VAR 0 5
29057: PUSH
29058: LD_VAR 0 5
29062: PUSH
29063: LD_INT 1
29065: PLUS
29066: ST_TO_ADDR
29067: GO 29104
// if GetBType ( x [ j ] ) = b_control_tower then
29069: LD_VAR 0 11
29073: PUSH
29074: LD_VAR 0 3
29078: ARRAY
29079: PPUSH
29080: CALL_OW 266
29084: PUSH
29085: LD_INT 36
29087: EQUAL
29088: IFFALSE 29104
// places := places + 3 ;
29090: LD_ADDR_VAR 0 5
29094: PUSH
29095: LD_VAR 0 5
29099: PUSH
29100: LD_INT 3
29102: PLUS
29103: ST_TO_ADDR
29104: GO 29029
29106: POP
29107: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
29108: LD_VAR 0 5
29112: PUSH
29113: LD_INT 0
29115: EQUAL
29116: PUSH
29117: LD_VAR 0 5
29121: PUSH
29122: LD_EXP 92
29126: PUSH
29127: LD_VAR 0 2
29131: ARRAY
29132: LESSEQUAL
29133: OR
29134: IFFALSE 29138
// continue ;
29136: GO 28388
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
29138: LD_ADDR_VAR 0 6
29142: PUSH
29143: LD_EXP 52
29147: PUSH
29148: LD_VAR 0 2
29152: ARRAY
29153: PPUSH
29154: LD_INT 25
29156: PUSH
29157: LD_INT 3
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PPUSH
29164: CALL_OW 72
29168: PUSH
29169: LD_EXP 92
29173: PUSH
29174: LD_VAR 0 2
29178: ARRAY
29179: DIFF
29180: PPUSH
29181: LD_INT 3
29183: PPUSH
29184: CALL 67031 0 2
29188: ST_TO_ADDR
// for j in tmp do
29189: LD_ADDR_VAR 0 3
29193: PUSH
29194: LD_VAR 0 6
29198: PUSH
29199: FOR_IN
29200: IFFALSE 29235
// if GetTag ( j ) > 0 then
29202: LD_VAR 0 3
29206: PPUSH
29207: CALL_OW 110
29211: PUSH
29212: LD_INT 0
29214: GREATER
29215: IFFALSE 29233
// tmp := tmp diff j ;
29217: LD_ADDR_VAR 0 6
29221: PUSH
29222: LD_VAR 0 6
29226: PUSH
29227: LD_VAR 0 3
29231: DIFF
29232: ST_TO_ADDR
29233: GO 29199
29235: POP
29236: POP
// if not tmp then
29237: LD_VAR 0 6
29241: NOT
29242: IFFALSE 29246
// continue ;
29244: GO 28388
// if places then
29246: LD_VAR 0 5
29250: IFFALSE 29309
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
29252: LD_ADDR_EXP 92
29256: PUSH
29257: LD_EXP 92
29261: PPUSH
29262: LD_VAR 0 2
29266: PPUSH
29267: LD_EXP 92
29271: PUSH
29272: LD_VAR 0 2
29276: ARRAY
29277: PUSH
29278: LD_VAR 0 6
29282: PUSH
29283: LD_INT 1
29285: ARRAY
29286: UNION
29287: PPUSH
29288: CALL_OW 1
29292: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
29293: LD_VAR 0 6
29297: PUSH
29298: LD_INT 1
29300: ARRAY
29301: PPUSH
29302: LD_INT 126
29304: PPUSH
29305: CALL_OW 109
// end ; end ;
29309: GO 28388
29311: POP
29312: POP
// end ;
29313: LD_VAR 0 1
29317: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
29318: LD_INT 0
29320: PPUSH
29321: PPUSH
29322: PPUSH
29323: PPUSH
29324: PPUSH
29325: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
29326: LD_VAR 0 1
29330: NOT
29331: PUSH
29332: LD_VAR 0 2
29336: NOT
29337: OR
29338: PUSH
29339: LD_VAR 0 3
29343: NOT
29344: OR
29345: PUSH
29346: LD_VAR 0 4
29350: PUSH
29351: LD_INT 1
29353: PUSH
29354: LD_INT 2
29356: PUSH
29357: LD_INT 3
29359: PUSH
29360: LD_INT 4
29362: PUSH
29363: LD_INT 5
29365: PUSH
29366: LD_INT 8
29368: PUSH
29369: LD_INT 9
29371: PUSH
29372: LD_INT 15
29374: PUSH
29375: LD_INT 16
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: LIST
29382: LIST
29383: LIST
29384: LIST
29385: LIST
29386: LIST
29387: LIST
29388: IN
29389: NOT
29390: OR
29391: IFFALSE 29395
// exit ;
29393: GO 30295
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
29395: LD_ADDR_VAR 0 2
29399: PUSH
29400: LD_VAR 0 2
29404: PPUSH
29405: LD_INT 21
29407: PUSH
29408: LD_INT 3
29410: PUSH
29411: EMPTY
29412: LIST
29413: LIST
29414: PUSH
29415: LD_INT 24
29417: PUSH
29418: LD_INT 250
29420: PUSH
29421: EMPTY
29422: LIST
29423: LIST
29424: PUSH
29425: EMPTY
29426: LIST
29427: LIST
29428: PPUSH
29429: CALL_OW 72
29433: ST_TO_ADDR
// case class of 1 , 15 :
29434: LD_VAR 0 4
29438: PUSH
29439: LD_INT 1
29441: DOUBLE
29442: EQUAL
29443: IFTRUE 29453
29445: LD_INT 15
29447: DOUBLE
29448: EQUAL
29449: IFTRUE 29453
29451: GO 29538
29453: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
29454: LD_ADDR_VAR 0 8
29458: PUSH
29459: LD_VAR 0 2
29463: PPUSH
29464: LD_INT 2
29466: PUSH
29467: LD_INT 30
29469: PUSH
29470: LD_INT 32
29472: PUSH
29473: EMPTY
29474: LIST
29475: LIST
29476: PUSH
29477: LD_INT 30
29479: PUSH
29480: LD_INT 31
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: LIST
29491: PPUSH
29492: CALL_OW 72
29496: PUSH
29497: LD_VAR 0 2
29501: PPUSH
29502: LD_INT 2
29504: PUSH
29505: LD_INT 30
29507: PUSH
29508: LD_INT 4
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 30
29517: PUSH
29518: LD_INT 5
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: LIST
29529: PPUSH
29530: CALL_OW 72
29534: ADD
29535: ST_TO_ADDR
29536: GO 29784
29538: LD_INT 2
29540: DOUBLE
29541: EQUAL
29542: IFTRUE 29552
29544: LD_INT 16
29546: DOUBLE
29547: EQUAL
29548: IFTRUE 29552
29550: GO 29598
29552: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
29553: LD_ADDR_VAR 0 8
29557: PUSH
29558: LD_VAR 0 2
29562: PPUSH
29563: LD_INT 2
29565: PUSH
29566: LD_INT 30
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 30
29578: PUSH
29579: LD_INT 1
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: LIST
29590: PPUSH
29591: CALL_OW 72
29595: ST_TO_ADDR
29596: GO 29784
29598: LD_INT 3
29600: DOUBLE
29601: EQUAL
29602: IFTRUE 29606
29604: GO 29652
29606: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
29607: LD_ADDR_VAR 0 8
29611: PUSH
29612: LD_VAR 0 2
29616: PPUSH
29617: LD_INT 2
29619: PUSH
29620: LD_INT 30
29622: PUSH
29623: LD_INT 2
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 30
29632: PUSH
29633: LD_INT 3
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: LIST
29644: PPUSH
29645: CALL_OW 72
29649: ST_TO_ADDR
29650: GO 29784
29652: LD_INT 4
29654: DOUBLE
29655: EQUAL
29656: IFTRUE 29660
29658: GO 29717
29660: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
29661: LD_ADDR_VAR 0 8
29665: PUSH
29666: LD_VAR 0 2
29670: PPUSH
29671: LD_INT 2
29673: PUSH
29674: LD_INT 30
29676: PUSH
29677: LD_INT 6
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 30
29686: PUSH
29687: LD_INT 7
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 30
29696: PUSH
29697: LD_INT 8
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: LIST
29708: LIST
29709: PPUSH
29710: CALL_OW 72
29714: ST_TO_ADDR
29715: GO 29784
29717: LD_INT 5
29719: DOUBLE
29720: EQUAL
29721: IFTRUE 29737
29723: LD_INT 8
29725: DOUBLE
29726: EQUAL
29727: IFTRUE 29737
29729: LD_INT 9
29731: DOUBLE
29732: EQUAL
29733: IFTRUE 29737
29735: GO 29783
29737: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
29738: LD_ADDR_VAR 0 8
29742: PUSH
29743: LD_VAR 0 2
29747: PPUSH
29748: LD_INT 2
29750: PUSH
29751: LD_INT 30
29753: PUSH
29754: LD_INT 4
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 30
29763: PUSH
29764: LD_INT 5
29766: PUSH
29767: EMPTY
29768: LIST
29769: LIST
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: LIST
29775: PPUSH
29776: CALL_OW 72
29780: ST_TO_ADDR
29781: GO 29784
29783: POP
// if not tmp then
29784: LD_VAR 0 8
29788: NOT
29789: IFFALSE 29793
// exit ;
29791: GO 30295
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
29793: LD_VAR 0 4
29797: PUSH
29798: LD_INT 1
29800: PUSH
29801: LD_INT 15
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: IN
29808: PUSH
29809: LD_EXP 61
29813: PUSH
29814: LD_VAR 0 1
29818: ARRAY
29819: AND
29820: IFFALSE 29976
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
29822: LD_ADDR_VAR 0 9
29826: PUSH
29827: LD_EXP 61
29831: PUSH
29832: LD_VAR 0 1
29836: ARRAY
29837: PUSH
29838: LD_INT 1
29840: ARRAY
29841: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
29842: LD_VAR 0 9
29846: PUSH
29847: LD_EXP 62
29851: PUSH
29852: LD_VAR 0 1
29856: ARRAY
29857: IN
29858: NOT
29859: IFFALSE 29974
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
29861: LD_ADDR_EXP 62
29865: PUSH
29866: LD_EXP 62
29870: PPUSH
29871: LD_VAR 0 1
29875: PUSH
29876: LD_EXP 62
29880: PUSH
29881: LD_VAR 0 1
29885: ARRAY
29886: PUSH
29887: LD_INT 1
29889: PLUS
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: PPUSH
29895: LD_VAR 0 9
29899: PPUSH
29900: CALL 37482 0 3
29904: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
29905: LD_ADDR_EXP 61
29909: PUSH
29910: LD_EXP 61
29914: PPUSH
29915: LD_VAR 0 1
29919: PPUSH
29920: LD_EXP 61
29924: PUSH
29925: LD_VAR 0 1
29929: ARRAY
29930: PUSH
29931: LD_VAR 0 9
29935: DIFF
29936: PPUSH
29937: CALL_OW 1
29941: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
29942: LD_VAR 0 3
29946: PPUSH
29947: LD_EXP 62
29951: PUSH
29952: LD_VAR 0 1
29956: ARRAY
29957: PUSH
29958: LD_EXP 62
29962: PUSH
29963: LD_VAR 0 1
29967: ARRAY
29968: ARRAY
29969: PPUSH
29970: CALL_OW 120
// end ; exit ;
29974: GO 30295
// end ; if tmp > 1 then
29976: LD_VAR 0 8
29980: PUSH
29981: LD_INT 1
29983: GREATER
29984: IFFALSE 30088
// for i = 2 to tmp do
29986: LD_ADDR_VAR 0 6
29990: PUSH
29991: DOUBLE
29992: LD_INT 2
29994: DEC
29995: ST_TO_ADDR
29996: LD_VAR 0 8
30000: PUSH
30001: FOR_TO
30002: IFFALSE 30086
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
30004: LD_VAR 0 8
30008: PUSH
30009: LD_VAR 0 6
30013: ARRAY
30014: PPUSH
30015: CALL_OW 461
30019: PUSH
30020: LD_INT 6
30022: EQUAL
30023: IFFALSE 30084
// begin x := tmp [ i ] ;
30025: LD_ADDR_VAR 0 9
30029: PUSH
30030: LD_VAR 0 8
30034: PUSH
30035: LD_VAR 0 6
30039: ARRAY
30040: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
30041: LD_ADDR_VAR 0 8
30045: PUSH
30046: LD_VAR 0 8
30050: PPUSH
30051: LD_VAR 0 6
30055: PPUSH
30056: CALL_OW 3
30060: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
30061: LD_ADDR_VAR 0 8
30065: PUSH
30066: LD_VAR 0 8
30070: PPUSH
30071: LD_INT 1
30073: PPUSH
30074: LD_VAR 0 9
30078: PPUSH
30079: CALL_OW 2
30083: ST_TO_ADDR
// end ;
30084: GO 30001
30086: POP
30087: POP
// for i in tmp do
30088: LD_ADDR_VAR 0 6
30092: PUSH
30093: LD_VAR 0 8
30097: PUSH
30098: FOR_IN
30099: IFFALSE 30168
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
30101: LD_VAR 0 6
30105: PPUSH
30106: CALL_OW 313
30110: PUSH
30111: LD_INT 6
30113: LESS
30114: PUSH
30115: LD_VAR 0 6
30119: PPUSH
30120: CALL_OW 266
30124: PUSH
30125: LD_INT 31
30127: PUSH
30128: LD_INT 32
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: IN
30135: NOT
30136: AND
30137: PUSH
30138: LD_VAR 0 6
30142: PPUSH
30143: CALL_OW 313
30147: PUSH
30148: LD_INT 0
30150: EQUAL
30151: OR
30152: IFFALSE 30166
// begin j := i ;
30154: LD_ADDR_VAR 0 7
30158: PUSH
30159: LD_VAR 0 6
30163: ST_TO_ADDR
// break ;
30164: GO 30168
// end ; end ;
30166: GO 30098
30168: POP
30169: POP
// if j then
30170: LD_VAR 0 7
30174: IFFALSE 30192
// ComEnterUnit ( unit , j ) else
30176: LD_VAR 0 3
30180: PPUSH
30181: LD_VAR 0 7
30185: PPUSH
30186: CALL_OW 120
30190: GO 30295
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30192: LD_ADDR_VAR 0 10
30196: PUSH
30197: LD_VAR 0 2
30201: PPUSH
30202: LD_INT 2
30204: PUSH
30205: LD_INT 30
30207: PUSH
30208: LD_INT 0
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 30
30217: PUSH
30218: LD_INT 1
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: LIST
30229: PPUSH
30230: CALL_OW 72
30234: ST_TO_ADDR
// if depot then
30235: LD_VAR 0 10
30239: IFFALSE 30295
// begin depot := NearestUnitToUnit ( depot , unit ) ;
30241: LD_ADDR_VAR 0 10
30245: PUSH
30246: LD_VAR 0 10
30250: PPUSH
30251: LD_VAR 0 3
30255: PPUSH
30256: CALL_OW 74
30260: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
30261: LD_VAR 0 3
30265: PPUSH
30266: LD_VAR 0 10
30270: PPUSH
30271: CALL_OW 296
30275: PUSH
30276: LD_INT 10
30278: GREATER
30279: IFFALSE 30295
// ComStandNearbyBuilding ( unit , depot ) ;
30281: LD_VAR 0 3
30285: PPUSH
30286: LD_VAR 0 10
30290: PPUSH
30291: CALL 34096 0 2
// end ; end ; end ;
30295: LD_VAR 0 5
30299: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
30300: LD_INT 0
30302: PPUSH
30303: PPUSH
30304: PPUSH
30305: PPUSH
// if not mc_bases then
30306: LD_EXP 52
30310: NOT
30311: IFFALSE 30315
// exit ;
30313: GO 30554
// for i = 1 to mc_bases do
30315: LD_ADDR_VAR 0 2
30319: PUSH
30320: DOUBLE
30321: LD_INT 1
30323: DEC
30324: ST_TO_ADDR
30325: LD_EXP 52
30329: PUSH
30330: FOR_TO
30331: IFFALSE 30552
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
30333: LD_ADDR_VAR 0 4
30337: PUSH
30338: LD_EXP 52
30342: PUSH
30343: LD_VAR 0 2
30347: ARRAY
30348: PPUSH
30349: LD_INT 21
30351: PUSH
30352: LD_INT 1
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PPUSH
30359: CALL_OW 72
30363: PUSH
30364: LD_EXP 81
30368: PUSH
30369: LD_VAR 0 2
30373: ARRAY
30374: UNION
30375: ST_TO_ADDR
// if not tmp then
30376: LD_VAR 0 4
30380: NOT
30381: IFFALSE 30385
// continue ;
30383: GO 30330
// for j in tmp do
30385: LD_ADDR_VAR 0 3
30389: PUSH
30390: LD_VAR 0 4
30394: PUSH
30395: FOR_IN
30396: IFFALSE 30548
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
30398: LD_VAR 0 3
30402: PPUSH
30403: CALL_OW 110
30407: NOT
30408: PUSH
30409: LD_VAR 0 3
30413: PPUSH
30414: CALL_OW 314
30418: NOT
30419: AND
30420: PUSH
30421: LD_VAR 0 3
30425: PPUSH
30426: CALL_OW 311
30430: NOT
30431: AND
30432: PUSH
30433: LD_VAR 0 3
30437: PPUSH
30438: CALL_OW 310
30442: NOT
30443: AND
30444: PUSH
30445: LD_VAR 0 3
30449: PUSH
30450: LD_EXP 55
30454: PUSH
30455: LD_VAR 0 2
30459: ARRAY
30460: PUSH
30461: LD_INT 1
30463: ARRAY
30464: IN
30465: NOT
30466: AND
30467: PUSH
30468: LD_VAR 0 3
30472: PUSH
30473: LD_EXP 55
30477: PUSH
30478: LD_VAR 0 2
30482: ARRAY
30483: PUSH
30484: LD_INT 2
30486: ARRAY
30487: IN
30488: NOT
30489: AND
30490: PUSH
30491: LD_VAR 0 3
30495: PUSH
30496: LD_EXP 64
30500: PUSH
30501: LD_VAR 0 2
30505: ARRAY
30506: IN
30507: NOT
30508: AND
30509: IFFALSE 30546
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
30511: LD_VAR 0 2
30515: PPUSH
30516: LD_EXP 52
30520: PUSH
30521: LD_VAR 0 2
30525: ARRAY
30526: PPUSH
30527: LD_VAR 0 3
30531: PPUSH
30532: LD_VAR 0 3
30536: PPUSH
30537: CALL_OW 257
30541: PPUSH
30542: CALL 29318 0 4
// end ;
30546: GO 30395
30548: POP
30549: POP
// end ;
30550: GO 30330
30552: POP
30553: POP
// end ;
30554: LD_VAR 0 1
30558: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
30559: LD_INT 0
30561: PPUSH
30562: PPUSH
30563: PPUSH
30564: PPUSH
30565: PPUSH
30566: PPUSH
// if not mc_bases [ base ] then
30567: LD_EXP 52
30571: PUSH
30572: LD_VAR 0 1
30576: ARRAY
30577: NOT
30578: IFFALSE 30582
// exit ;
30580: GO 30764
// tmp := [ ] ;
30582: LD_ADDR_VAR 0 6
30586: PUSH
30587: EMPTY
30588: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
30589: LD_ADDR_VAR 0 7
30593: PUSH
30594: LD_VAR 0 3
30598: PPUSH
30599: LD_INT 0
30601: PPUSH
30602: CALL_OW 517
30606: ST_TO_ADDR
// if not list then
30607: LD_VAR 0 7
30611: NOT
30612: IFFALSE 30616
// exit ;
30614: GO 30764
// for i = 1 to amount do
30616: LD_ADDR_VAR 0 5
30620: PUSH
30621: DOUBLE
30622: LD_INT 1
30624: DEC
30625: ST_TO_ADDR
30626: LD_VAR 0 2
30630: PUSH
30631: FOR_TO
30632: IFFALSE 30712
// begin x := rand ( 1 , list [ 1 ] ) ;
30634: LD_ADDR_VAR 0 8
30638: PUSH
30639: LD_INT 1
30641: PPUSH
30642: LD_VAR 0 7
30646: PUSH
30647: LD_INT 1
30649: ARRAY
30650: PPUSH
30651: CALL_OW 12
30655: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
30656: LD_ADDR_VAR 0 6
30660: PUSH
30661: LD_VAR 0 6
30665: PPUSH
30666: LD_VAR 0 5
30670: PPUSH
30671: LD_VAR 0 7
30675: PUSH
30676: LD_INT 1
30678: ARRAY
30679: PUSH
30680: LD_VAR 0 8
30684: ARRAY
30685: PUSH
30686: LD_VAR 0 7
30690: PUSH
30691: LD_INT 2
30693: ARRAY
30694: PUSH
30695: LD_VAR 0 8
30699: ARRAY
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PPUSH
30705: CALL_OW 1
30709: ST_TO_ADDR
// end ;
30710: GO 30631
30712: POP
30713: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
30714: LD_ADDR_EXP 65
30718: PUSH
30719: LD_EXP 65
30723: PPUSH
30724: LD_VAR 0 1
30728: PPUSH
30729: LD_VAR 0 6
30733: PPUSH
30734: CALL_OW 1
30738: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
30739: LD_ADDR_EXP 67
30743: PUSH
30744: LD_EXP 67
30748: PPUSH
30749: LD_VAR 0 1
30753: PPUSH
30754: LD_VAR 0 3
30758: PPUSH
30759: CALL_OW 1
30763: ST_TO_ADDR
// end ;
30764: LD_VAR 0 4
30768: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
30769: LD_INT 0
30771: PPUSH
// if not mc_bases [ base ] then
30772: LD_EXP 52
30776: PUSH
30777: LD_VAR 0 1
30781: ARRAY
30782: NOT
30783: IFFALSE 30787
// exit ;
30785: GO 30812
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
30787: LD_ADDR_EXP 57
30791: PUSH
30792: LD_EXP 57
30796: PPUSH
30797: LD_VAR 0 1
30801: PPUSH
30802: LD_VAR 0 2
30806: PPUSH
30807: CALL_OW 1
30811: ST_TO_ADDR
// end ;
30812: LD_VAR 0 3
30816: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
30817: LD_INT 0
30819: PPUSH
// if not mc_bases [ base ] then
30820: LD_EXP 52
30824: PUSH
30825: LD_VAR 0 1
30829: ARRAY
30830: NOT
30831: IFFALSE 30835
// exit ;
30833: GO 30872
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
30835: LD_ADDR_EXP 57
30839: PUSH
30840: LD_EXP 57
30844: PPUSH
30845: LD_VAR 0 1
30849: PPUSH
30850: LD_EXP 57
30854: PUSH
30855: LD_VAR 0 1
30859: ARRAY
30860: PUSH
30861: LD_VAR 0 2
30865: UNION
30866: PPUSH
30867: CALL_OW 1
30871: ST_TO_ADDR
// end ;
30872: LD_VAR 0 3
30876: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
30877: LD_INT 0
30879: PPUSH
// if not mc_bases [ base ] then
30880: LD_EXP 52
30884: PUSH
30885: LD_VAR 0 1
30889: ARRAY
30890: NOT
30891: IFFALSE 30895
// exit ;
30893: GO 30920
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
30895: LD_ADDR_EXP 73
30899: PUSH
30900: LD_EXP 73
30904: PPUSH
30905: LD_VAR 0 1
30909: PPUSH
30910: LD_VAR 0 2
30914: PPUSH
30915: CALL_OW 1
30919: ST_TO_ADDR
// end ;
30920: LD_VAR 0 3
30924: RET
// export function MC_InsertProduceList ( base , components ) ; begin
30925: LD_INT 0
30927: PPUSH
// if not mc_bases [ base ] then
30928: LD_EXP 52
30932: PUSH
30933: LD_VAR 0 1
30937: ARRAY
30938: NOT
30939: IFFALSE 30943
// exit ;
30941: GO 30980
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
30943: LD_ADDR_EXP 73
30947: PUSH
30948: LD_EXP 73
30952: PPUSH
30953: LD_VAR 0 1
30957: PPUSH
30958: LD_EXP 73
30962: PUSH
30963: LD_VAR 0 1
30967: ARRAY
30968: PUSH
30969: LD_VAR 0 2
30973: ADD
30974: PPUSH
30975: CALL_OW 1
30979: ST_TO_ADDR
// end ;
30980: LD_VAR 0 3
30984: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
30985: LD_INT 0
30987: PPUSH
// if not mc_bases [ base ] then
30988: LD_EXP 52
30992: PUSH
30993: LD_VAR 0 1
30997: ARRAY
30998: NOT
30999: IFFALSE 31003
// exit ;
31001: GO 31057
// mc_defender := Replace ( mc_defender , base , deflist ) ;
31003: LD_ADDR_EXP 74
31007: PUSH
31008: LD_EXP 74
31012: PPUSH
31013: LD_VAR 0 1
31017: PPUSH
31018: LD_VAR 0 2
31022: PPUSH
31023: CALL_OW 1
31027: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
31028: LD_ADDR_EXP 63
31032: PUSH
31033: LD_EXP 63
31037: PPUSH
31038: LD_VAR 0 1
31042: PPUSH
31043: LD_VAR 0 2
31047: PUSH
31048: LD_INT 0
31050: PLUS
31051: PPUSH
31052: CALL_OW 1
31056: ST_TO_ADDR
// end ;
31057: LD_VAR 0 3
31061: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
31062: LD_INT 0
31064: PPUSH
// if not mc_bases [ base ] then
31065: LD_EXP 52
31069: PUSH
31070: LD_VAR 0 1
31074: ARRAY
31075: NOT
31076: IFFALSE 31080
// exit ;
31078: GO 31105
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
31080: LD_ADDR_EXP 63
31084: PUSH
31085: LD_EXP 63
31089: PPUSH
31090: LD_VAR 0 1
31094: PPUSH
31095: LD_VAR 0 2
31099: PPUSH
31100: CALL_OW 1
31104: ST_TO_ADDR
// end ;
31105: LD_VAR 0 3
31109: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
31110: LD_INT 0
31112: PPUSH
31113: PPUSH
31114: PPUSH
31115: PPUSH
// if not mc_bases [ base ] then
31116: LD_EXP 52
31120: PUSH
31121: LD_VAR 0 1
31125: ARRAY
31126: NOT
31127: IFFALSE 31131
// exit ;
31129: GO 31196
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
31131: LD_ADDR_EXP 72
31135: PUSH
31136: LD_EXP 72
31140: PPUSH
31141: LD_VAR 0 1
31145: PUSH
31146: LD_EXP 72
31150: PUSH
31151: LD_VAR 0 1
31155: ARRAY
31156: PUSH
31157: LD_INT 1
31159: PLUS
31160: PUSH
31161: EMPTY
31162: LIST
31163: LIST
31164: PPUSH
31165: LD_VAR 0 1
31169: PUSH
31170: LD_VAR 0 2
31174: PUSH
31175: LD_VAR 0 3
31179: PUSH
31180: LD_VAR 0 4
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: LIST
31189: LIST
31190: PPUSH
31191: CALL 37482 0 3
31195: ST_TO_ADDR
// end ;
31196: LD_VAR 0 5
31200: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
31201: LD_INT 0
31203: PPUSH
// if not mc_bases [ base ] then
31204: LD_EXP 52
31208: PUSH
31209: LD_VAR 0 1
31213: ARRAY
31214: NOT
31215: IFFALSE 31219
// exit ;
31217: GO 31244
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
31219: LD_ADDR_EXP 89
31223: PUSH
31224: LD_EXP 89
31228: PPUSH
31229: LD_VAR 0 1
31233: PPUSH
31234: LD_VAR 0 2
31238: PPUSH
31239: CALL_OW 1
31243: ST_TO_ADDR
// end ;
31244: LD_VAR 0 3
31248: RET
// export function MC_GetMinesField ( base ) ; begin
31249: LD_INT 0
31251: PPUSH
// result := mc_mines [ base ] ;
31252: LD_ADDR_VAR 0 2
31256: PUSH
31257: LD_EXP 65
31261: PUSH
31262: LD_VAR 0 1
31266: ARRAY
31267: ST_TO_ADDR
// end ;
31268: LD_VAR 0 2
31272: RET
// export function MC_GetProduceList ( base ) ; begin
31273: LD_INT 0
31275: PPUSH
// result := mc_produce [ base ] ;
31276: LD_ADDR_VAR 0 2
31280: PUSH
31281: LD_EXP 73
31285: PUSH
31286: LD_VAR 0 1
31290: ARRAY
31291: ST_TO_ADDR
// end ;
31292: LD_VAR 0 2
31296: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
31297: LD_INT 0
31299: PPUSH
31300: PPUSH
// if not mc_bases then
31301: LD_EXP 52
31305: NOT
31306: IFFALSE 31310
// exit ;
31308: GO 31375
// if mc_bases [ base ] then
31310: LD_EXP 52
31314: PUSH
31315: LD_VAR 0 1
31319: ARRAY
31320: IFFALSE 31375
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
31322: LD_ADDR_VAR 0 3
31326: PUSH
31327: LD_EXP 52
31331: PUSH
31332: LD_VAR 0 1
31336: ARRAY
31337: PPUSH
31338: LD_INT 30
31340: PUSH
31341: LD_VAR 0 2
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PPUSH
31350: CALL_OW 72
31354: ST_TO_ADDR
// if result then
31355: LD_VAR 0 3
31359: IFFALSE 31375
// result := result [ 1 ] ;
31361: LD_ADDR_VAR 0 3
31365: PUSH
31366: LD_VAR 0 3
31370: PUSH
31371: LD_INT 1
31373: ARRAY
31374: ST_TO_ADDR
// end ; end ;
31375: LD_VAR 0 3
31379: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
31380: LD_INT 0
31382: PPUSH
31383: PPUSH
// if not mc_bases then
31384: LD_EXP 52
31388: NOT
31389: IFFALSE 31393
// exit ;
31391: GO 31438
// if mc_bases [ base ] then
31393: LD_EXP 52
31397: PUSH
31398: LD_VAR 0 1
31402: ARRAY
31403: IFFALSE 31438
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
31405: LD_ADDR_VAR 0 3
31409: PUSH
31410: LD_EXP 52
31414: PUSH
31415: LD_VAR 0 1
31419: ARRAY
31420: PPUSH
31421: LD_INT 30
31423: PUSH
31424: LD_VAR 0 2
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PPUSH
31433: CALL_OW 72
31437: ST_TO_ADDR
// end ;
31438: LD_VAR 0 3
31442: RET
// export function MC_SetTame ( base , area ) ; begin
31443: LD_INT 0
31445: PPUSH
// if not mc_bases or not base then
31446: LD_EXP 52
31450: NOT
31451: PUSH
31452: LD_VAR 0 1
31456: NOT
31457: OR
31458: IFFALSE 31462
// exit ;
31460: GO 31487
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
31462: LD_ADDR_EXP 80
31466: PUSH
31467: LD_EXP 80
31471: PPUSH
31472: LD_VAR 0 1
31476: PPUSH
31477: LD_VAR 0 2
31481: PPUSH
31482: CALL_OW 1
31486: ST_TO_ADDR
// end ;
31487: LD_VAR 0 3
31491: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
31492: LD_INT 0
31494: PPUSH
31495: PPUSH
// if not mc_bases or not base then
31496: LD_EXP 52
31500: NOT
31501: PUSH
31502: LD_VAR 0 1
31506: NOT
31507: OR
31508: IFFALSE 31512
// exit ;
31510: GO 31614
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
31512: LD_ADDR_VAR 0 4
31516: PUSH
31517: LD_EXP 52
31521: PUSH
31522: LD_VAR 0 1
31526: ARRAY
31527: PPUSH
31528: LD_INT 30
31530: PUSH
31531: LD_VAR 0 2
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PPUSH
31540: CALL_OW 72
31544: ST_TO_ADDR
// if not tmp then
31545: LD_VAR 0 4
31549: NOT
31550: IFFALSE 31554
// exit ;
31552: GO 31614
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
31554: LD_ADDR_EXP 84
31558: PUSH
31559: LD_EXP 84
31563: PPUSH
31564: LD_VAR 0 1
31568: PPUSH
31569: LD_EXP 84
31573: PUSH
31574: LD_VAR 0 1
31578: ARRAY
31579: PPUSH
31580: LD_EXP 84
31584: PUSH
31585: LD_VAR 0 1
31589: ARRAY
31590: PUSH
31591: LD_INT 1
31593: PLUS
31594: PPUSH
31595: LD_VAR 0 4
31599: PUSH
31600: LD_INT 1
31602: ARRAY
31603: PPUSH
31604: CALL_OW 2
31608: PPUSH
31609: CALL_OW 1
31613: ST_TO_ADDR
// end ;
31614: LD_VAR 0 3
31618: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
31619: LD_INT 0
31621: PPUSH
31622: PPUSH
// if not mc_bases or not base or not kinds then
31623: LD_EXP 52
31627: NOT
31628: PUSH
31629: LD_VAR 0 1
31633: NOT
31634: OR
31635: PUSH
31636: LD_VAR 0 2
31640: NOT
31641: OR
31642: IFFALSE 31646
// exit ;
31644: GO 31707
// for i in kinds do
31646: LD_ADDR_VAR 0 4
31650: PUSH
31651: LD_VAR 0 2
31655: PUSH
31656: FOR_IN
31657: IFFALSE 31705
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
31659: LD_ADDR_EXP 86
31663: PUSH
31664: LD_EXP 86
31668: PPUSH
31669: LD_VAR 0 1
31673: PUSH
31674: LD_EXP 86
31678: PUSH
31679: LD_VAR 0 1
31683: ARRAY
31684: PUSH
31685: LD_INT 1
31687: PLUS
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PPUSH
31693: LD_VAR 0 4
31697: PPUSH
31698: CALL 37482 0 3
31702: ST_TO_ADDR
31703: GO 31656
31705: POP
31706: POP
// end ;
31707: LD_VAR 0 3
31711: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
31712: LD_INT 0
31714: PPUSH
// if not mc_bases or not base or not areas then
31715: LD_EXP 52
31719: NOT
31720: PUSH
31721: LD_VAR 0 1
31725: NOT
31726: OR
31727: PUSH
31728: LD_VAR 0 2
31732: NOT
31733: OR
31734: IFFALSE 31738
// exit ;
31736: GO 31763
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
31738: LD_ADDR_EXP 70
31742: PUSH
31743: LD_EXP 70
31747: PPUSH
31748: LD_VAR 0 1
31752: PPUSH
31753: LD_VAR 0 2
31757: PPUSH
31758: CALL_OW 1
31762: ST_TO_ADDR
// end ;
31763: LD_VAR 0 3
31767: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
31768: LD_INT 0
31770: PPUSH
// if not mc_bases or not base or not teleports_exit then
31771: LD_EXP 52
31775: NOT
31776: PUSH
31777: LD_VAR 0 1
31781: NOT
31782: OR
31783: PUSH
31784: LD_VAR 0 2
31788: NOT
31789: OR
31790: IFFALSE 31794
// exit ;
31792: GO 31819
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
31794: LD_ADDR_EXP 87
31798: PUSH
31799: LD_EXP 87
31803: PPUSH
31804: LD_VAR 0 1
31808: PPUSH
31809: LD_VAR 0 2
31813: PPUSH
31814: CALL_OW 1
31818: ST_TO_ADDR
// end ;
31819: LD_VAR 0 3
31823: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
31824: LD_INT 0
31826: PPUSH
31827: PPUSH
31828: PPUSH
// if not mc_bases or not base or not ext_list then
31829: LD_EXP 52
31833: NOT
31834: PUSH
31835: LD_VAR 0 1
31839: NOT
31840: OR
31841: PUSH
31842: LD_VAR 0 5
31846: NOT
31847: OR
31848: IFFALSE 31852
// exit ;
31850: GO 32025
// tmp := GetFacExtXYD ( x , y , d ) ;
31852: LD_ADDR_VAR 0 8
31856: PUSH
31857: LD_VAR 0 2
31861: PPUSH
31862: LD_VAR 0 3
31866: PPUSH
31867: LD_VAR 0 4
31871: PPUSH
31872: CALL 66161 0 3
31876: ST_TO_ADDR
// if not tmp then
31877: LD_VAR 0 8
31881: NOT
31882: IFFALSE 31886
// exit ;
31884: GO 32025
// for i in tmp do
31886: LD_ADDR_VAR 0 7
31890: PUSH
31891: LD_VAR 0 8
31895: PUSH
31896: FOR_IN
31897: IFFALSE 32023
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
31899: LD_ADDR_EXP 57
31903: PUSH
31904: LD_EXP 57
31908: PPUSH
31909: LD_VAR 0 1
31913: PPUSH
31914: LD_EXP 57
31918: PUSH
31919: LD_VAR 0 1
31923: ARRAY
31924: PPUSH
31925: LD_EXP 57
31929: PUSH
31930: LD_VAR 0 1
31934: ARRAY
31935: PUSH
31936: LD_INT 1
31938: PLUS
31939: PPUSH
31940: LD_VAR 0 5
31944: PUSH
31945: LD_INT 1
31947: ARRAY
31948: PUSH
31949: LD_VAR 0 7
31953: PUSH
31954: LD_INT 1
31956: ARRAY
31957: PUSH
31958: LD_VAR 0 7
31962: PUSH
31963: LD_INT 2
31965: ARRAY
31966: PUSH
31967: LD_VAR 0 7
31971: PUSH
31972: LD_INT 3
31974: ARRAY
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: LIST
31980: LIST
31981: PPUSH
31982: CALL_OW 2
31986: PPUSH
31987: CALL_OW 1
31991: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
31992: LD_ADDR_VAR 0 5
31996: PUSH
31997: LD_VAR 0 5
32001: PPUSH
32002: LD_INT 1
32004: PPUSH
32005: CALL_OW 3
32009: ST_TO_ADDR
// if not ext_list then
32010: LD_VAR 0 5
32014: NOT
32015: IFFALSE 32021
// exit ;
32017: POP
32018: POP
32019: GO 32025
// end ;
32021: GO 31896
32023: POP
32024: POP
// end ;
32025: LD_VAR 0 6
32029: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
32030: LD_INT 0
32032: PPUSH
// if not mc_bases or not base or not weapon_list then
32033: LD_EXP 52
32037: NOT
32038: PUSH
32039: LD_VAR 0 1
32043: NOT
32044: OR
32045: PUSH
32046: LD_VAR 0 2
32050: NOT
32051: OR
32052: IFFALSE 32056
// exit ;
32054: GO 32081
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
32056: LD_ADDR_EXP 91
32060: PUSH
32061: LD_EXP 91
32065: PPUSH
32066: LD_VAR 0 1
32070: PPUSH
32071: LD_VAR 0 2
32075: PPUSH
32076: CALL_OW 1
32080: ST_TO_ADDR
// end ;
32081: LD_VAR 0 3
32085: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
32086: LD_INT 0
32088: PPUSH
// if not mc_bases or not base or not tech_list then
32089: LD_EXP 52
32093: NOT
32094: PUSH
32095: LD_VAR 0 1
32099: NOT
32100: OR
32101: PUSH
32102: LD_VAR 0 2
32106: NOT
32107: OR
32108: IFFALSE 32112
// exit ;
32110: GO 32137
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
32112: LD_ADDR_EXP 79
32116: PUSH
32117: LD_EXP 79
32121: PPUSH
32122: LD_VAR 0 1
32126: PPUSH
32127: LD_VAR 0 2
32131: PPUSH
32132: CALL_OW 1
32136: ST_TO_ADDR
// end ;
32137: LD_VAR 0 3
32141: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
32142: LD_INT 0
32144: PPUSH
// if not mc_bases or not parking_area or not base then
32145: LD_EXP 52
32149: NOT
32150: PUSH
32151: LD_VAR 0 2
32155: NOT
32156: OR
32157: PUSH
32158: LD_VAR 0 1
32162: NOT
32163: OR
32164: IFFALSE 32168
// exit ;
32166: GO 32193
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
32168: LD_ADDR_EXP 76
32172: PUSH
32173: LD_EXP 76
32177: PPUSH
32178: LD_VAR 0 1
32182: PPUSH
32183: LD_VAR 0 2
32187: PPUSH
32188: CALL_OW 1
32192: ST_TO_ADDR
// end ;
32193: LD_VAR 0 3
32197: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
32198: LD_INT 0
32200: PPUSH
// if not mc_bases or not base or not scan_area then
32201: LD_EXP 52
32205: NOT
32206: PUSH
32207: LD_VAR 0 1
32211: NOT
32212: OR
32213: PUSH
32214: LD_VAR 0 2
32218: NOT
32219: OR
32220: IFFALSE 32224
// exit ;
32222: GO 32249
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
32224: LD_ADDR_EXP 77
32228: PUSH
32229: LD_EXP 77
32233: PPUSH
32234: LD_VAR 0 1
32238: PPUSH
32239: LD_VAR 0 2
32243: PPUSH
32244: CALL_OW 1
32248: ST_TO_ADDR
// end ;
32249: LD_VAR 0 3
32253: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
32254: LD_INT 0
32256: PPUSH
32257: PPUSH
// if not mc_bases or not base then
32258: LD_EXP 52
32262: NOT
32263: PUSH
32264: LD_VAR 0 1
32268: NOT
32269: OR
32270: IFFALSE 32274
// exit ;
32272: GO 32338
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
32274: LD_ADDR_VAR 0 3
32278: PUSH
32279: LD_INT 1
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: LD_INT 3
32287: PUSH
32288: LD_INT 4
32290: PUSH
32291: LD_INT 11
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
32301: LD_ADDR_EXP 79
32305: PUSH
32306: LD_EXP 79
32310: PPUSH
32311: LD_VAR 0 1
32315: PPUSH
32316: LD_EXP 79
32320: PUSH
32321: LD_VAR 0 1
32325: ARRAY
32326: PUSH
32327: LD_VAR 0 3
32331: DIFF
32332: PPUSH
32333: CALL_OW 1
32337: ST_TO_ADDR
// end ;
32338: LD_VAR 0 2
32342: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
32343: LD_INT 0
32345: PPUSH
// result := mc_vehicles [ base ] ;
32346: LD_ADDR_VAR 0 3
32350: PUSH
32351: LD_EXP 71
32355: PUSH
32356: LD_VAR 0 1
32360: ARRAY
32361: ST_TO_ADDR
// if onlyCombat then
32362: LD_VAR 0 2
32366: IFFALSE 32531
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
32368: LD_ADDR_VAR 0 3
32372: PUSH
32373: LD_VAR 0 3
32377: PUSH
32378: LD_VAR 0 3
32382: PPUSH
32383: LD_INT 2
32385: PUSH
32386: LD_INT 34
32388: PUSH
32389: LD_INT 12
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 34
32398: PUSH
32399: LD_INT 51
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 34
32408: PUSH
32409: LD_EXP 96
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 34
32420: PUSH
32421: LD_INT 32
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 34
32430: PUSH
32431: LD_INT 13
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 34
32440: PUSH
32441: LD_INT 52
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 34
32450: PUSH
32451: LD_INT 14
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 34
32460: PUSH
32461: LD_INT 53
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 34
32470: PUSH
32471: LD_EXP 95
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 34
32482: PUSH
32483: LD_INT 31
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 34
32492: PUSH
32493: LD_INT 48
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 34
32502: PUSH
32503: LD_INT 8
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: PPUSH
32525: CALL_OW 72
32529: DIFF
32530: ST_TO_ADDR
// end ; end_of_file
32531: LD_VAR 0 3
32535: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
32536: LD_INT 0
32538: PPUSH
32539: PPUSH
// if exist_mode then
32540: LD_VAR 0 2
32544: IFFALSE 32569
// unit := CreateCharacter ( prefix & ident ) else
32546: LD_ADDR_VAR 0 5
32550: PUSH
32551: LD_VAR 0 3
32555: PUSH
32556: LD_VAR 0 1
32560: STR
32561: PPUSH
32562: CALL_OW 34
32566: ST_TO_ADDR
32567: GO 32584
// unit := NewCharacter ( ident ) ;
32569: LD_ADDR_VAR 0 5
32573: PUSH
32574: LD_VAR 0 1
32578: PPUSH
32579: CALL_OW 25
32583: ST_TO_ADDR
// result := unit ;
32584: LD_ADDR_VAR 0 4
32588: PUSH
32589: LD_VAR 0 5
32593: ST_TO_ADDR
// end ;
32594: LD_VAR 0 4
32598: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
32599: LD_INT 0
32601: PPUSH
32602: PPUSH
// if not side or not nation then
32603: LD_VAR 0 1
32607: NOT
32608: PUSH
32609: LD_VAR 0 2
32613: NOT
32614: OR
32615: IFFALSE 32619
// exit ;
32617: GO 33383
// case nation of nation_american :
32619: LD_VAR 0 2
32623: PUSH
32624: LD_INT 1
32626: DOUBLE
32627: EQUAL
32628: IFTRUE 32632
32630: GO 32846
32632: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
32633: LD_ADDR_VAR 0 4
32637: PUSH
32638: LD_INT 35
32640: PUSH
32641: LD_INT 45
32643: PUSH
32644: LD_INT 46
32646: PUSH
32647: LD_INT 47
32649: PUSH
32650: LD_INT 82
32652: PUSH
32653: LD_INT 83
32655: PUSH
32656: LD_INT 84
32658: PUSH
32659: LD_INT 85
32661: PUSH
32662: LD_INT 86
32664: PUSH
32665: LD_INT 1
32667: PUSH
32668: LD_INT 2
32670: PUSH
32671: LD_INT 6
32673: PUSH
32674: LD_INT 15
32676: PUSH
32677: LD_INT 16
32679: PUSH
32680: LD_INT 7
32682: PUSH
32683: LD_INT 12
32685: PUSH
32686: LD_INT 13
32688: PUSH
32689: LD_INT 10
32691: PUSH
32692: LD_INT 14
32694: PUSH
32695: LD_INT 20
32697: PUSH
32698: LD_INT 21
32700: PUSH
32701: LD_INT 22
32703: PUSH
32704: LD_INT 25
32706: PUSH
32707: LD_INT 32
32709: PUSH
32710: LD_INT 27
32712: PUSH
32713: LD_INT 36
32715: PUSH
32716: LD_INT 69
32718: PUSH
32719: LD_INT 39
32721: PUSH
32722: LD_INT 34
32724: PUSH
32725: LD_INT 40
32727: PUSH
32728: LD_INT 48
32730: PUSH
32731: LD_INT 49
32733: PUSH
32734: LD_INT 50
32736: PUSH
32737: LD_INT 51
32739: PUSH
32740: LD_INT 52
32742: PUSH
32743: LD_INT 53
32745: PUSH
32746: LD_INT 54
32748: PUSH
32749: LD_INT 55
32751: PUSH
32752: LD_INT 56
32754: PUSH
32755: LD_INT 57
32757: PUSH
32758: LD_INT 58
32760: PUSH
32761: LD_INT 59
32763: PUSH
32764: LD_INT 60
32766: PUSH
32767: LD_INT 61
32769: PUSH
32770: LD_INT 62
32772: PUSH
32773: LD_INT 80
32775: PUSH
32776: LD_INT 82
32778: PUSH
32779: LD_INT 83
32781: PUSH
32782: LD_INT 84
32784: PUSH
32785: LD_INT 85
32787: PUSH
32788: LD_INT 86
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: LIST
32795: LIST
32796: LIST
32797: LIST
32798: LIST
32799: LIST
32800: LIST
32801: LIST
32802: LIST
32803: LIST
32804: LIST
32805: LIST
32806: LIST
32807: LIST
32808: LIST
32809: LIST
32810: LIST
32811: LIST
32812: LIST
32813: LIST
32814: LIST
32815: LIST
32816: LIST
32817: LIST
32818: LIST
32819: LIST
32820: LIST
32821: LIST
32822: LIST
32823: LIST
32824: LIST
32825: LIST
32826: LIST
32827: LIST
32828: LIST
32829: LIST
32830: LIST
32831: LIST
32832: LIST
32833: LIST
32834: LIST
32835: LIST
32836: LIST
32837: LIST
32838: LIST
32839: LIST
32840: LIST
32841: LIST
32842: LIST
32843: ST_TO_ADDR
32844: GO 33307
32846: LD_INT 2
32848: DOUBLE
32849: EQUAL
32850: IFTRUE 32854
32852: GO 33076
32854: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
32855: LD_ADDR_VAR 0 4
32859: PUSH
32860: LD_INT 35
32862: PUSH
32863: LD_INT 45
32865: PUSH
32866: LD_INT 46
32868: PUSH
32869: LD_INT 47
32871: PUSH
32872: LD_INT 82
32874: PUSH
32875: LD_INT 83
32877: PUSH
32878: LD_INT 84
32880: PUSH
32881: LD_INT 85
32883: PUSH
32884: LD_INT 87
32886: PUSH
32887: LD_INT 70
32889: PUSH
32890: LD_INT 1
32892: PUSH
32893: LD_INT 11
32895: PUSH
32896: LD_INT 3
32898: PUSH
32899: LD_INT 4
32901: PUSH
32902: LD_INT 5
32904: PUSH
32905: LD_INT 6
32907: PUSH
32908: LD_INT 15
32910: PUSH
32911: LD_INT 18
32913: PUSH
32914: LD_INT 7
32916: PUSH
32917: LD_INT 17
32919: PUSH
32920: LD_INT 8
32922: PUSH
32923: LD_INT 20
32925: PUSH
32926: LD_INT 21
32928: PUSH
32929: LD_INT 22
32931: PUSH
32932: LD_INT 72
32934: PUSH
32935: LD_INT 26
32937: PUSH
32938: LD_INT 69
32940: PUSH
32941: LD_INT 39
32943: PUSH
32944: LD_INT 40
32946: PUSH
32947: LD_INT 41
32949: PUSH
32950: LD_INT 42
32952: PUSH
32953: LD_INT 43
32955: PUSH
32956: LD_INT 48
32958: PUSH
32959: LD_INT 49
32961: PUSH
32962: LD_INT 50
32964: PUSH
32965: LD_INT 51
32967: PUSH
32968: LD_INT 52
32970: PUSH
32971: LD_INT 53
32973: PUSH
32974: LD_INT 54
32976: PUSH
32977: LD_INT 55
32979: PUSH
32980: LD_INT 56
32982: PUSH
32983: LD_INT 60
32985: PUSH
32986: LD_INT 61
32988: PUSH
32989: LD_INT 62
32991: PUSH
32992: LD_INT 66
32994: PUSH
32995: LD_INT 67
32997: PUSH
32998: LD_INT 68
33000: PUSH
33001: LD_INT 81
33003: PUSH
33004: LD_INT 82
33006: PUSH
33007: LD_INT 83
33009: PUSH
33010: LD_INT 84
33012: PUSH
33013: LD_INT 85
33015: PUSH
33016: LD_INT 87
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: LIST
33023: LIST
33024: LIST
33025: LIST
33026: LIST
33027: LIST
33028: LIST
33029: LIST
33030: LIST
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: LIST
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: LIST
33069: LIST
33070: LIST
33071: LIST
33072: LIST
33073: ST_TO_ADDR
33074: GO 33307
33076: LD_INT 3
33078: DOUBLE
33079: EQUAL
33080: IFTRUE 33084
33082: GO 33306
33084: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
33085: LD_ADDR_VAR 0 4
33089: PUSH
33090: LD_INT 46
33092: PUSH
33093: LD_INT 47
33095: PUSH
33096: LD_INT 1
33098: PUSH
33099: LD_INT 2
33101: PUSH
33102: LD_INT 82
33104: PUSH
33105: LD_INT 83
33107: PUSH
33108: LD_INT 84
33110: PUSH
33111: LD_INT 85
33113: PUSH
33114: LD_INT 86
33116: PUSH
33117: LD_INT 11
33119: PUSH
33120: LD_INT 9
33122: PUSH
33123: LD_INT 20
33125: PUSH
33126: LD_INT 19
33128: PUSH
33129: LD_INT 21
33131: PUSH
33132: LD_INT 24
33134: PUSH
33135: LD_INT 22
33137: PUSH
33138: LD_INT 25
33140: PUSH
33141: LD_INT 28
33143: PUSH
33144: LD_INT 29
33146: PUSH
33147: LD_INT 30
33149: PUSH
33150: LD_INT 31
33152: PUSH
33153: LD_INT 37
33155: PUSH
33156: LD_INT 38
33158: PUSH
33159: LD_INT 32
33161: PUSH
33162: LD_INT 27
33164: PUSH
33165: LD_INT 33
33167: PUSH
33168: LD_INT 69
33170: PUSH
33171: LD_INT 39
33173: PUSH
33174: LD_INT 34
33176: PUSH
33177: LD_INT 40
33179: PUSH
33180: LD_INT 71
33182: PUSH
33183: LD_INT 23
33185: PUSH
33186: LD_INT 44
33188: PUSH
33189: LD_INT 48
33191: PUSH
33192: LD_INT 49
33194: PUSH
33195: LD_INT 50
33197: PUSH
33198: LD_INT 51
33200: PUSH
33201: LD_INT 52
33203: PUSH
33204: LD_INT 53
33206: PUSH
33207: LD_INT 54
33209: PUSH
33210: LD_INT 55
33212: PUSH
33213: LD_INT 56
33215: PUSH
33216: LD_INT 57
33218: PUSH
33219: LD_INT 58
33221: PUSH
33222: LD_INT 59
33224: PUSH
33225: LD_INT 63
33227: PUSH
33228: LD_INT 64
33230: PUSH
33231: LD_INT 65
33233: PUSH
33234: LD_INT 82
33236: PUSH
33237: LD_INT 83
33239: PUSH
33240: LD_INT 84
33242: PUSH
33243: LD_INT 85
33245: PUSH
33246: LD_INT 86
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: LIST
33253: LIST
33254: LIST
33255: LIST
33256: LIST
33257: LIST
33258: LIST
33259: LIST
33260: LIST
33261: LIST
33262: LIST
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: LIST
33269: LIST
33270: LIST
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: LIST
33278: LIST
33279: LIST
33280: LIST
33281: LIST
33282: LIST
33283: LIST
33284: LIST
33285: LIST
33286: LIST
33287: LIST
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: LIST
33293: LIST
33294: LIST
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: LIST
33301: LIST
33302: LIST
33303: ST_TO_ADDR
33304: GO 33307
33306: POP
// if state > - 1 and state < 3 then
33307: LD_VAR 0 3
33311: PUSH
33312: LD_INT 1
33314: NEG
33315: GREATER
33316: PUSH
33317: LD_VAR 0 3
33321: PUSH
33322: LD_INT 3
33324: LESS
33325: AND
33326: IFFALSE 33383
// for i in result do
33328: LD_ADDR_VAR 0 5
33332: PUSH
33333: LD_VAR 0 4
33337: PUSH
33338: FOR_IN
33339: IFFALSE 33381
// if GetTech ( i , side ) <> state then
33341: LD_VAR 0 5
33345: PPUSH
33346: LD_VAR 0 1
33350: PPUSH
33351: CALL_OW 321
33355: PUSH
33356: LD_VAR 0 3
33360: NONEQUAL
33361: IFFALSE 33379
// result := result diff i ;
33363: LD_ADDR_VAR 0 4
33367: PUSH
33368: LD_VAR 0 4
33372: PUSH
33373: LD_VAR 0 5
33377: DIFF
33378: ST_TO_ADDR
33379: GO 33338
33381: POP
33382: POP
// end ;
33383: LD_VAR 0 4
33387: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
33388: LD_INT 0
33390: PPUSH
33391: PPUSH
33392: PPUSH
// result := true ;
33393: LD_ADDR_VAR 0 3
33397: PUSH
33398: LD_INT 1
33400: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
33401: LD_ADDR_VAR 0 5
33405: PUSH
33406: LD_VAR 0 2
33410: PPUSH
33411: CALL_OW 480
33415: ST_TO_ADDR
// if not tmp then
33416: LD_VAR 0 5
33420: NOT
33421: IFFALSE 33425
// exit ;
33423: GO 33474
// for i in tmp do
33425: LD_ADDR_VAR 0 4
33429: PUSH
33430: LD_VAR 0 5
33434: PUSH
33435: FOR_IN
33436: IFFALSE 33472
// if GetTech ( i , side ) <> state_researched then
33438: LD_VAR 0 4
33442: PPUSH
33443: LD_VAR 0 1
33447: PPUSH
33448: CALL_OW 321
33452: PUSH
33453: LD_INT 2
33455: NONEQUAL
33456: IFFALSE 33470
// begin result := false ;
33458: LD_ADDR_VAR 0 3
33462: PUSH
33463: LD_INT 0
33465: ST_TO_ADDR
// exit ;
33466: POP
33467: POP
33468: GO 33474
// end ;
33470: GO 33435
33472: POP
33473: POP
// end ;
33474: LD_VAR 0 3
33478: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
33479: LD_INT 0
33481: PPUSH
33482: PPUSH
33483: PPUSH
33484: PPUSH
33485: PPUSH
33486: PPUSH
33487: PPUSH
33488: PPUSH
33489: PPUSH
33490: PPUSH
33491: PPUSH
33492: PPUSH
33493: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
33494: LD_VAR 0 1
33498: NOT
33499: PUSH
33500: LD_VAR 0 1
33504: PPUSH
33505: CALL_OW 257
33509: PUSH
33510: LD_INT 9
33512: NONEQUAL
33513: OR
33514: IFFALSE 33518
// exit ;
33516: GO 34091
// side := GetSide ( unit ) ;
33518: LD_ADDR_VAR 0 9
33522: PUSH
33523: LD_VAR 0 1
33527: PPUSH
33528: CALL_OW 255
33532: ST_TO_ADDR
// tech_space := tech_spacanom ;
33533: LD_ADDR_VAR 0 12
33537: PUSH
33538: LD_INT 29
33540: ST_TO_ADDR
// tech_time := tech_taurad ;
33541: LD_ADDR_VAR 0 13
33545: PUSH
33546: LD_INT 28
33548: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
33549: LD_ADDR_VAR 0 11
33553: PUSH
33554: LD_VAR 0 1
33558: PPUSH
33559: CALL_OW 310
33563: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
33564: LD_VAR 0 11
33568: PPUSH
33569: CALL_OW 247
33573: PUSH
33574: LD_INT 2
33576: EQUAL
33577: IFFALSE 33581
// exit ;
33579: GO 34091
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
33581: LD_ADDR_VAR 0 8
33585: PUSH
33586: LD_INT 81
33588: PUSH
33589: LD_VAR 0 9
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 3
33600: PUSH
33601: LD_INT 21
33603: PUSH
33604: LD_INT 3
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: EMPTY
33612: LIST
33613: LIST
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PPUSH
33619: CALL_OW 69
33623: ST_TO_ADDR
// if not tmp then
33624: LD_VAR 0 8
33628: NOT
33629: IFFALSE 33633
// exit ;
33631: GO 34091
// if in_unit then
33633: LD_VAR 0 11
33637: IFFALSE 33661
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
33639: LD_ADDR_VAR 0 10
33643: PUSH
33644: LD_VAR 0 8
33648: PPUSH
33649: LD_VAR 0 11
33653: PPUSH
33654: CALL_OW 74
33658: ST_TO_ADDR
33659: GO 33681
// enemy := NearestUnitToUnit ( tmp , unit ) ;
33661: LD_ADDR_VAR 0 10
33665: PUSH
33666: LD_VAR 0 8
33670: PPUSH
33671: LD_VAR 0 1
33675: PPUSH
33676: CALL_OW 74
33680: ST_TO_ADDR
// if not enemy then
33681: LD_VAR 0 10
33685: NOT
33686: IFFALSE 33690
// exit ;
33688: GO 34091
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
33690: LD_VAR 0 11
33694: PUSH
33695: LD_VAR 0 11
33699: PPUSH
33700: LD_VAR 0 10
33704: PPUSH
33705: CALL_OW 296
33709: PUSH
33710: LD_INT 13
33712: GREATER
33713: AND
33714: PUSH
33715: LD_VAR 0 1
33719: PPUSH
33720: LD_VAR 0 10
33724: PPUSH
33725: CALL_OW 296
33729: PUSH
33730: LD_INT 12
33732: GREATER
33733: OR
33734: IFFALSE 33738
// exit ;
33736: GO 34091
// missile := [ 1 ] ;
33738: LD_ADDR_VAR 0 14
33742: PUSH
33743: LD_INT 1
33745: PUSH
33746: EMPTY
33747: LIST
33748: ST_TO_ADDR
// if Researched ( side , tech_space ) then
33749: LD_VAR 0 9
33753: PPUSH
33754: LD_VAR 0 12
33758: PPUSH
33759: CALL_OW 325
33763: IFFALSE 33792
// missile := Insert ( missile , missile + 1 , 2 ) ;
33765: LD_ADDR_VAR 0 14
33769: PUSH
33770: LD_VAR 0 14
33774: PPUSH
33775: LD_VAR 0 14
33779: PUSH
33780: LD_INT 1
33782: PLUS
33783: PPUSH
33784: LD_INT 2
33786: PPUSH
33787: CALL_OW 2
33791: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
33792: LD_VAR 0 9
33796: PPUSH
33797: LD_VAR 0 13
33801: PPUSH
33802: CALL_OW 325
33806: PUSH
33807: LD_VAR 0 10
33811: PPUSH
33812: CALL_OW 255
33816: PPUSH
33817: LD_VAR 0 13
33821: PPUSH
33822: CALL_OW 325
33826: NOT
33827: AND
33828: IFFALSE 33857
// missile := Insert ( missile , missile + 1 , 3 ) ;
33830: LD_ADDR_VAR 0 14
33834: PUSH
33835: LD_VAR 0 14
33839: PPUSH
33840: LD_VAR 0 14
33844: PUSH
33845: LD_INT 1
33847: PLUS
33848: PPUSH
33849: LD_INT 3
33851: PPUSH
33852: CALL_OW 2
33856: ST_TO_ADDR
// if missile < 2 then
33857: LD_VAR 0 14
33861: PUSH
33862: LD_INT 2
33864: LESS
33865: IFFALSE 33869
// exit ;
33867: GO 34091
// x := GetX ( enemy ) ;
33869: LD_ADDR_VAR 0 4
33873: PUSH
33874: LD_VAR 0 10
33878: PPUSH
33879: CALL_OW 250
33883: ST_TO_ADDR
// y := GetY ( enemy ) ;
33884: LD_ADDR_VAR 0 5
33888: PUSH
33889: LD_VAR 0 10
33893: PPUSH
33894: CALL_OW 251
33898: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
33899: LD_ADDR_VAR 0 6
33903: PUSH
33904: LD_VAR 0 4
33908: PUSH
33909: LD_INT 1
33911: NEG
33912: PPUSH
33913: LD_INT 1
33915: PPUSH
33916: CALL_OW 12
33920: PLUS
33921: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
33922: LD_ADDR_VAR 0 7
33926: PUSH
33927: LD_VAR 0 5
33931: PUSH
33932: LD_INT 1
33934: NEG
33935: PPUSH
33936: LD_INT 1
33938: PPUSH
33939: CALL_OW 12
33943: PLUS
33944: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
33945: LD_VAR 0 6
33949: PPUSH
33950: LD_VAR 0 7
33954: PPUSH
33955: CALL_OW 488
33959: NOT
33960: IFFALSE 33982
// begin _x := x ;
33962: LD_ADDR_VAR 0 6
33966: PUSH
33967: LD_VAR 0 4
33971: ST_TO_ADDR
// _y := y ;
33972: LD_ADDR_VAR 0 7
33976: PUSH
33977: LD_VAR 0 5
33981: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
33982: LD_ADDR_VAR 0 3
33986: PUSH
33987: LD_INT 1
33989: PPUSH
33990: LD_VAR 0 14
33994: PPUSH
33995: CALL_OW 12
33999: ST_TO_ADDR
// case i of 1 :
34000: LD_VAR 0 3
34004: PUSH
34005: LD_INT 1
34007: DOUBLE
34008: EQUAL
34009: IFTRUE 34013
34011: GO 34030
34013: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
34014: LD_VAR 0 1
34018: PPUSH
34019: LD_VAR 0 10
34023: PPUSH
34024: CALL_OW 115
34028: GO 34091
34030: LD_INT 2
34032: DOUBLE
34033: EQUAL
34034: IFTRUE 34038
34036: GO 34060
34038: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
34039: LD_VAR 0 1
34043: PPUSH
34044: LD_VAR 0 6
34048: PPUSH
34049: LD_VAR 0 7
34053: PPUSH
34054: CALL_OW 153
34058: GO 34091
34060: LD_INT 3
34062: DOUBLE
34063: EQUAL
34064: IFTRUE 34068
34066: GO 34090
34068: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
34069: LD_VAR 0 1
34073: PPUSH
34074: LD_VAR 0 6
34078: PPUSH
34079: LD_VAR 0 7
34083: PPUSH
34084: CALL_OW 154
34088: GO 34091
34090: POP
// end ;
34091: LD_VAR 0 2
34095: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
34096: LD_INT 0
34098: PPUSH
34099: PPUSH
34100: PPUSH
34101: PPUSH
34102: PPUSH
34103: PPUSH
// if not unit or not building then
34104: LD_VAR 0 1
34108: NOT
34109: PUSH
34110: LD_VAR 0 2
34114: NOT
34115: OR
34116: IFFALSE 34120
// exit ;
34118: GO 34278
// x := GetX ( building ) ;
34120: LD_ADDR_VAR 0 5
34124: PUSH
34125: LD_VAR 0 2
34129: PPUSH
34130: CALL_OW 250
34134: ST_TO_ADDR
// y := GetY ( building ) ;
34135: LD_ADDR_VAR 0 6
34139: PUSH
34140: LD_VAR 0 2
34144: PPUSH
34145: CALL_OW 251
34149: ST_TO_ADDR
// for i = 0 to 5 do
34150: LD_ADDR_VAR 0 4
34154: PUSH
34155: DOUBLE
34156: LD_INT 0
34158: DEC
34159: ST_TO_ADDR
34160: LD_INT 5
34162: PUSH
34163: FOR_TO
34164: IFFALSE 34276
// begin _x := ShiftX ( x , i , 3 ) ;
34166: LD_ADDR_VAR 0 7
34170: PUSH
34171: LD_VAR 0 5
34175: PPUSH
34176: LD_VAR 0 4
34180: PPUSH
34181: LD_INT 3
34183: PPUSH
34184: CALL_OW 272
34188: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
34189: LD_ADDR_VAR 0 8
34193: PUSH
34194: LD_VAR 0 6
34198: PPUSH
34199: LD_VAR 0 4
34203: PPUSH
34204: LD_INT 3
34206: PPUSH
34207: CALL_OW 273
34211: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
34212: LD_VAR 0 7
34216: PPUSH
34217: LD_VAR 0 8
34221: PPUSH
34222: CALL_OW 488
34226: NOT
34227: IFFALSE 34231
// continue ;
34229: GO 34163
// if HexInfo ( _x , _y ) = 0 then
34231: LD_VAR 0 7
34235: PPUSH
34236: LD_VAR 0 8
34240: PPUSH
34241: CALL_OW 428
34245: PUSH
34246: LD_INT 0
34248: EQUAL
34249: IFFALSE 34274
// begin ComMoveXY ( unit , _x , _y ) ;
34251: LD_VAR 0 1
34255: PPUSH
34256: LD_VAR 0 7
34260: PPUSH
34261: LD_VAR 0 8
34265: PPUSH
34266: CALL_OW 111
// exit ;
34270: POP
34271: POP
34272: GO 34278
// end ; end ;
34274: GO 34163
34276: POP
34277: POP
// end ;
34278: LD_VAR 0 3
34282: RET
// export function ScanBase ( side , base_area ) ; begin
34283: LD_INT 0
34285: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
34286: LD_ADDR_VAR 0 3
34290: PUSH
34291: LD_VAR 0 2
34295: PPUSH
34296: LD_INT 81
34298: PUSH
34299: LD_VAR 0 1
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PPUSH
34308: CALL_OW 70
34312: ST_TO_ADDR
// end ;
34313: LD_VAR 0 3
34317: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
34318: LD_INT 0
34320: PPUSH
34321: PPUSH
34322: PPUSH
34323: PPUSH
// result := false ;
34324: LD_ADDR_VAR 0 2
34328: PUSH
34329: LD_INT 0
34331: ST_TO_ADDR
// side := GetSide ( unit ) ;
34332: LD_ADDR_VAR 0 3
34336: PUSH
34337: LD_VAR 0 1
34341: PPUSH
34342: CALL_OW 255
34346: ST_TO_ADDR
// nat := GetNation ( unit ) ;
34347: LD_ADDR_VAR 0 4
34351: PUSH
34352: LD_VAR 0 1
34356: PPUSH
34357: CALL_OW 248
34361: ST_TO_ADDR
// case nat of 1 :
34362: LD_VAR 0 4
34366: PUSH
34367: LD_INT 1
34369: DOUBLE
34370: EQUAL
34371: IFTRUE 34375
34373: GO 34386
34375: POP
// tech := tech_lassight ; 2 :
34376: LD_ADDR_VAR 0 5
34380: PUSH
34381: LD_INT 12
34383: ST_TO_ADDR
34384: GO 34425
34386: LD_INT 2
34388: DOUBLE
34389: EQUAL
34390: IFTRUE 34394
34392: GO 34405
34394: POP
// tech := tech_mortar ; 3 :
34395: LD_ADDR_VAR 0 5
34399: PUSH
34400: LD_INT 41
34402: ST_TO_ADDR
34403: GO 34425
34405: LD_INT 3
34407: DOUBLE
34408: EQUAL
34409: IFTRUE 34413
34411: GO 34424
34413: POP
// tech := tech_bazooka ; end ;
34414: LD_ADDR_VAR 0 5
34418: PUSH
34419: LD_INT 44
34421: ST_TO_ADDR
34422: GO 34425
34424: POP
// if Researched ( side , tech ) then
34425: LD_VAR 0 3
34429: PPUSH
34430: LD_VAR 0 5
34434: PPUSH
34435: CALL_OW 325
34439: IFFALSE 34466
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
34441: LD_ADDR_VAR 0 2
34445: PUSH
34446: LD_INT 5
34448: PUSH
34449: LD_INT 8
34451: PUSH
34452: LD_INT 9
34454: PUSH
34455: EMPTY
34456: LIST
34457: LIST
34458: LIST
34459: PUSH
34460: LD_VAR 0 4
34464: ARRAY
34465: ST_TO_ADDR
// end ;
34466: LD_VAR 0 2
34470: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
34471: LD_INT 0
34473: PPUSH
34474: PPUSH
34475: PPUSH
// if not mines then
34476: LD_VAR 0 2
34480: NOT
34481: IFFALSE 34485
// exit ;
34483: GO 34629
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
34485: LD_ADDR_VAR 0 5
34489: PUSH
34490: LD_INT 81
34492: PUSH
34493: LD_VAR 0 1
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 3
34504: PUSH
34505: LD_INT 21
34507: PUSH
34508: LD_INT 3
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PPUSH
34523: CALL_OW 69
34527: ST_TO_ADDR
// for i in mines do
34528: LD_ADDR_VAR 0 4
34532: PUSH
34533: LD_VAR 0 2
34537: PUSH
34538: FOR_IN
34539: IFFALSE 34627
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
34541: LD_VAR 0 4
34545: PUSH
34546: LD_INT 1
34548: ARRAY
34549: PPUSH
34550: LD_VAR 0 4
34554: PUSH
34555: LD_INT 2
34557: ARRAY
34558: PPUSH
34559: CALL_OW 458
34563: NOT
34564: IFFALSE 34568
// continue ;
34566: GO 34538
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
34568: LD_VAR 0 4
34572: PUSH
34573: LD_INT 1
34575: ARRAY
34576: PPUSH
34577: LD_VAR 0 4
34581: PUSH
34582: LD_INT 2
34584: ARRAY
34585: PPUSH
34586: CALL_OW 428
34590: PUSH
34591: LD_VAR 0 5
34595: IN
34596: IFFALSE 34625
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
34598: LD_VAR 0 4
34602: PUSH
34603: LD_INT 1
34605: ARRAY
34606: PPUSH
34607: LD_VAR 0 4
34611: PUSH
34612: LD_INT 2
34614: ARRAY
34615: PPUSH
34616: LD_VAR 0 1
34620: PPUSH
34621: CALL_OW 456
// end ;
34625: GO 34538
34627: POP
34628: POP
// end ;
34629: LD_VAR 0 3
34633: RET
// export function Count ( array ) ; var i ; begin
34634: LD_INT 0
34636: PPUSH
34637: PPUSH
// result := 0 ;
34638: LD_ADDR_VAR 0 2
34642: PUSH
34643: LD_INT 0
34645: ST_TO_ADDR
// for i in array do
34646: LD_ADDR_VAR 0 3
34650: PUSH
34651: LD_VAR 0 1
34655: PUSH
34656: FOR_IN
34657: IFFALSE 34681
// if i then
34659: LD_VAR 0 3
34663: IFFALSE 34679
// result := result + 1 ;
34665: LD_ADDR_VAR 0 2
34669: PUSH
34670: LD_VAR 0 2
34674: PUSH
34675: LD_INT 1
34677: PLUS
34678: ST_TO_ADDR
34679: GO 34656
34681: POP
34682: POP
// end ;
34683: LD_VAR 0 2
34687: RET
// export function IsEmpty ( building ) ; begin
34688: LD_INT 0
34690: PPUSH
// if not building then
34691: LD_VAR 0 1
34695: NOT
34696: IFFALSE 34700
// exit ;
34698: GO 34743
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
34700: LD_ADDR_VAR 0 2
34704: PUSH
34705: LD_VAR 0 1
34709: PUSH
34710: LD_INT 22
34712: PUSH
34713: LD_VAR 0 1
34717: PPUSH
34718: CALL_OW 255
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: LD_INT 58
34729: PUSH
34730: EMPTY
34731: LIST
34732: PUSH
34733: EMPTY
34734: LIST
34735: LIST
34736: PPUSH
34737: CALL_OW 69
34741: IN
34742: ST_TO_ADDR
// end ;
34743: LD_VAR 0 2
34747: RET
// export function IsNotFull ( building ) ; begin
34748: LD_INT 0
34750: PPUSH
// if not building then
34751: LD_VAR 0 1
34755: NOT
34756: IFFALSE 34760
// exit ;
34758: GO 34779
// result := UnitsInside ( building ) < 6 ;
34760: LD_ADDR_VAR 0 2
34764: PUSH
34765: LD_VAR 0 1
34769: PPUSH
34770: CALL_OW 313
34774: PUSH
34775: LD_INT 6
34777: LESS
34778: ST_TO_ADDR
// end ;
34779: LD_VAR 0 2
34783: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
34784: LD_INT 0
34786: PPUSH
34787: PPUSH
34788: PPUSH
34789: PPUSH
// tmp := [ ] ;
34790: LD_ADDR_VAR 0 3
34794: PUSH
34795: EMPTY
34796: ST_TO_ADDR
// list := [ ] ;
34797: LD_ADDR_VAR 0 5
34801: PUSH
34802: EMPTY
34803: ST_TO_ADDR
// for i = 16 to 25 do
34804: LD_ADDR_VAR 0 4
34808: PUSH
34809: DOUBLE
34810: LD_INT 16
34812: DEC
34813: ST_TO_ADDR
34814: LD_INT 25
34816: PUSH
34817: FOR_TO
34818: IFFALSE 34891
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
34820: LD_ADDR_VAR 0 3
34824: PUSH
34825: LD_VAR 0 3
34829: PUSH
34830: LD_INT 22
34832: PUSH
34833: LD_VAR 0 1
34837: PPUSH
34838: CALL_OW 255
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 91
34849: PUSH
34850: LD_VAR 0 1
34854: PUSH
34855: LD_INT 6
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 30
34865: PUSH
34866: LD_VAR 0 4
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: LIST
34879: PUSH
34880: EMPTY
34881: LIST
34882: PPUSH
34883: CALL_OW 69
34887: ADD
34888: ST_TO_ADDR
34889: GO 34817
34891: POP
34892: POP
// for i = 1 to tmp do
34893: LD_ADDR_VAR 0 4
34897: PUSH
34898: DOUBLE
34899: LD_INT 1
34901: DEC
34902: ST_TO_ADDR
34903: LD_VAR 0 3
34907: PUSH
34908: FOR_TO
34909: IFFALSE 34997
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
34911: LD_ADDR_VAR 0 5
34915: PUSH
34916: LD_VAR 0 5
34920: PUSH
34921: LD_VAR 0 3
34925: PUSH
34926: LD_VAR 0 4
34930: ARRAY
34931: PPUSH
34932: CALL_OW 266
34936: PUSH
34937: LD_VAR 0 3
34941: PUSH
34942: LD_VAR 0 4
34946: ARRAY
34947: PPUSH
34948: CALL_OW 250
34952: PUSH
34953: LD_VAR 0 3
34957: PUSH
34958: LD_VAR 0 4
34962: ARRAY
34963: PPUSH
34964: CALL_OW 251
34968: PUSH
34969: LD_VAR 0 3
34973: PUSH
34974: LD_VAR 0 4
34978: ARRAY
34979: PPUSH
34980: CALL_OW 254
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: PUSH
34991: EMPTY
34992: LIST
34993: ADD
34994: ST_TO_ADDR
34995: GO 34908
34997: POP
34998: POP
// result := list ;
34999: LD_ADDR_VAR 0 2
35003: PUSH
35004: LD_VAR 0 5
35008: ST_TO_ADDR
// end ;
35009: LD_VAR 0 2
35013: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
35014: LD_INT 0
35016: PPUSH
35017: PPUSH
35018: PPUSH
35019: PPUSH
35020: PPUSH
35021: PPUSH
35022: PPUSH
// if not factory then
35023: LD_VAR 0 1
35027: NOT
35028: IFFALSE 35032
// exit ;
35030: GO 35625
// if control = control_apeman then
35032: LD_VAR 0 4
35036: PUSH
35037: LD_INT 5
35039: EQUAL
35040: IFFALSE 35149
// begin tmp := UnitsInside ( factory ) ;
35042: LD_ADDR_VAR 0 8
35046: PUSH
35047: LD_VAR 0 1
35051: PPUSH
35052: CALL_OW 313
35056: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
35057: LD_VAR 0 8
35061: PPUSH
35062: LD_INT 25
35064: PUSH
35065: LD_INT 12
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PPUSH
35072: CALL_OW 72
35076: NOT
35077: IFFALSE 35087
// control := control_manual ;
35079: LD_ADDR_VAR 0 4
35083: PUSH
35084: LD_INT 1
35086: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
35087: LD_ADDR_VAR 0 8
35091: PUSH
35092: LD_VAR 0 1
35096: PPUSH
35097: CALL 34784 0 1
35101: ST_TO_ADDR
// if tmp then
35102: LD_VAR 0 8
35106: IFFALSE 35149
// begin for i in tmp do
35108: LD_ADDR_VAR 0 7
35112: PUSH
35113: LD_VAR 0 8
35117: PUSH
35118: FOR_IN
35119: IFFALSE 35147
// if i [ 1 ] = b_ext_radio then
35121: LD_VAR 0 7
35125: PUSH
35126: LD_INT 1
35128: ARRAY
35129: PUSH
35130: LD_INT 22
35132: EQUAL
35133: IFFALSE 35145
// begin control := control_remote ;
35135: LD_ADDR_VAR 0 4
35139: PUSH
35140: LD_INT 2
35142: ST_TO_ADDR
// break ;
35143: GO 35147
// end ;
35145: GO 35118
35147: POP
35148: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
35149: LD_VAR 0 1
35153: PPUSH
35154: LD_VAR 0 2
35158: PPUSH
35159: LD_VAR 0 3
35163: PPUSH
35164: LD_VAR 0 4
35168: PPUSH
35169: LD_VAR 0 5
35173: PPUSH
35174: CALL_OW 448
35178: IFFALSE 35213
// begin result := [ chassis , engine , control , weapon ] ;
35180: LD_ADDR_VAR 0 6
35184: PUSH
35185: LD_VAR 0 2
35189: PUSH
35190: LD_VAR 0 3
35194: PUSH
35195: LD_VAR 0 4
35199: PUSH
35200: LD_VAR 0 5
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: LIST
35209: LIST
35210: ST_TO_ADDR
// exit ;
35211: GO 35625
// end ; _chassis := AvailableChassisList ( factory ) ;
35213: LD_ADDR_VAR 0 9
35217: PUSH
35218: LD_VAR 0 1
35222: PPUSH
35223: CALL_OW 475
35227: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
35228: LD_ADDR_VAR 0 11
35232: PUSH
35233: LD_VAR 0 1
35237: PPUSH
35238: CALL_OW 476
35242: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
35243: LD_ADDR_VAR 0 12
35247: PUSH
35248: LD_VAR 0 1
35252: PPUSH
35253: CALL_OW 477
35257: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
35258: LD_ADDR_VAR 0 10
35262: PUSH
35263: LD_VAR 0 1
35267: PPUSH
35268: CALL_OW 478
35272: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
35273: LD_VAR 0 9
35277: NOT
35278: PUSH
35279: LD_VAR 0 11
35283: NOT
35284: OR
35285: PUSH
35286: LD_VAR 0 12
35290: NOT
35291: OR
35292: PUSH
35293: LD_VAR 0 10
35297: NOT
35298: OR
35299: IFFALSE 35334
// begin result := [ chassis , engine , control , weapon ] ;
35301: LD_ADDR_VAR 0 6
35305: PUSH
35306: LD_VAR 0 2
35310: PUSH
35311: LD_VAR 0 3
35315: PUSH
35316: LD_VAR 0 4
35320: PUSH
35321: LD_VAR 0 5
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: LIST
35330: LIST
35331: ST_TO_ADDR
// exit ;
35332: GO 35625
// end ; if not chassis in _chassis then
35334: LD_VAR 0 2
35338: PUSH
35339: LD_VAR 0 9
35343: IN
35344: NOT
35345: IFFALSE 35371
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
35347: LD_ADDR_VAR 0 2
35351: PUSH
35352: LD_VAR 0 9
35356: PUSH
35357: LD_INT 1
35359: PPUSH
35360: LD_VAR 0 9
35364: PPUSH
35365: CALL_OW 12
35369: ARRAY
35370: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
35371: LD_VAR 0 2
35375: PPUSH
35376: LD_VAR 0 3
35380: PPUSH
35381: CALL 35630 0 2
35385: NOT
35386: IFFALSE 35445
// repeat engine := _engine [ 1 ] ;
35388: LD_ADDR_VAR 0 3
35392: PUSH
35393: LD_VAR 0 11
35397: PUSH
35398: LD_INT 1
35400: ARRAY
35401: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
35402: LD_ADDR_VAR 0 11
35406: PUSH
35407: LD_VAR 0 11
35411: PPUSH
35412: LD_INT 1
35414: PPUSH
35415: CALL_OW 3
35419: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
35420: LD_VAR 0 2
35424: PPUSH
35425: LD_VAR 0 3
35429: PPUSH
35430: CALL 35630 0 2
35434: PUSH
35435: LD_VAR 0 11
35439: PUSH
35440: EMPTY
35441: EQUAL
35442: OR
35443: IFFALSE 35388
// if not control in _control then
35445: LD_VAR 0 4
35449: PUSH
35450: LD_VAR 0 12
35454: IN
35455: NOT
35456: IFFALSE 35482
// control := _control [ rand ( 1 , _control ) ] ;
35458: LD_ADDR_VAR 0 4
35462: PUSH
35463: LD_VAR 0 12
35467: PUSH
35468: LD_INT 1
35470: PPUSH
35471: LD_VAR 0 12
35475: PPUSH
35476: CALL_OW 12
35480: ARRAY
35481: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
35482: LD_VAR 0 2
35486: PPUSH
35487: LD_VAR 0 5
35491: PPUSH
35492: CALL 35850 0 2
35496: NOT
35497: IFFALSE 35556
// repeat weapon := _weapon [ 1 ] ;
35499: LD_ADDR_VAR 0 5
35503: PUSH
35504: LD_VAR 0 10
35508: PUSH
35509: LD_INT 1
35511: ARRAY
35512: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
35513: LD_ADDR_VAR 0 10
35517: PUSH
35518: LD_VAR 0 10
35522: PPUSH
35523: LD_INT 1
35525: PPUSH
35526: CALL_OW 3
35530: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
35531: LD_VAR 0 2
35535: PPUSH
35536: LD_VAR 0 5
35540: PPUSH
35541: CALL 35850 0 2
35545: PUSH
35546: LD_VAR 0 10
35550: PUSH
35551: EMPTY
35552: EQUAL
35553: OR
35554: IFFALSE 35499
// result := [ ] ;
35556: LD_ADDR_VAR 0 6
35560: PUSH
35561: EMPTY
35562: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
35563: LD_VAR 0 1
35567: PPUSH
35568: LD_VAR 0 2
35572: PPUSH
35573: LD_VAR 0 3
35577: PPUSH
35578: LD_VAR 0 4
35582: PPUSH
35583: LD_VAR 0 5
35587: PPUSH
35588: CALL_OW 448
35592: IFFALSE 35625
// result := [ chassis , engine , control , weapon ] ;
35594: LD_ADDR_VAR 0 6
35598: PUSH
35599: LD_VAR 0 2
35603: PUSH
35604: LD_VAR 0 3
35608: PUSH
35609: LD_VAR 0 4
35613: PUSH
35614: LD_VAR 0 5
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: LIST
35623: LIST
35624: ST_TO_ADDR
// end ;
35625: LD_VAR 0 6
35629: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
35630: LD_INT 0
35632: PPUSH
// if not chassis or not engine then
35633: LD_VAR 0 1
35637: NOT
35638: PUSH
35639: LD_VAR 0 2
35643: NOT
35644: OR
35645: IFFALSE 35649
// exit ;
35647: GO 35845
// case engine of engine_solar :
35649: LD_VAR 0 2
35653: PUSH
35654: LD_INT 2
35656: DOUBLE
35657: EQUAL
35658: IFTRUE 35662
35660: GO 35700
35662: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
35663: LD_ADDR_VAR 0 3
35667: PUSH
35668: LD_INT 11
35670: PUSH
35671: LD_INT 12
35673: PUSH
35674: LD_INT 13
35676: PUSH
35677: LD_INT 14
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: LD_INT 2
35685: PUSH
35686: LD_INT 3
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: LIST
35693: LIST
35694: LIST
35695: LIST
35696: LIST
35697: ST_TO_ADDR
35698: GO 35829
35700: LD_INT 1
35702: DOUBLE
35703: EQUAL
35704: IFTRUE 35708
35706: GO 35770
35708: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
35709: LD_ADDR_VAR 0 3
35713: PUSH
35714: LD_INT 11
35716: PUSH
35717: LD_INT 12
35719: PUSH
35720: LD_INT 13
35722: PUSH
35723: LD_INT 14
35725: PUSH
35726: LD_INT 1
35728: PUSH
35729: LD_INT 2
35731: PUSH
35732: LD_INT 3
35734: PUSH
35735: LD_INT 4
35737: PUSH
35738: LD_INT 5
35740: PUSH
35741: LD_INT 21
35743: PUSH
35744: LD_INT 23
35746: PUSH
35747: LD_INT 22
35749: PUSH
35750: LD_INT 24
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: ST_TO_ADDR
35768: GO 35829
35770: LD_INT 3
35772: DOUBLE
35773: EQUAL
35774: IFTRUE 35778
35776: GO 35828
35778: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
35779: LD_ADDR_VAR 0 3
35783: PUSH
35784: LD_INT 13
35786: PUSH
35787: LD_INT 14
35789: PUSH
35790: LD_INT 2
35792: PUSH
35793: LD_INT 3
35795: PUSH
35796: LD_INT 4
35798: PUSH
35799: LD_INT 5
35801: PUSH
35802: LD_INT 21
35804: PUSH
35805: LD_INT 22
35807: PUSH
35808: LD_INT 23
35810: PUSH
35811: LD_INT 24
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: ST_TO_ADDR
35826: GO 35829
35828: POP
// result := ( chassis in result ) ;
35829: LD_ADDR_VAR 0 3
35833: PUSH
35834: LD_VAR 0 1
35838: PUSH
35839: LD_VAR 0 3
35843: IN
35844: ST_TO_ADDR
// end ;
35845: LD_VAR 0 3
35849: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
35850: LD_INT 0
35852: PPUSH
// if not chassis or not weapon then
35853: LD_VAR 0 1
35857: NOT
35858: PUSH
35859: LD_VAR 0 2
35863: NOT
35864: OR
35865: IFFALSE 35869
// exit ;
35867: GO 36895
// case weapon of us_machine_gun :
35869: LD_VAR 0 2
35873: PUSH
35874: LD_INT 2
35876: DOUBLE
35877: EQUAL
35878: IFTRUE 35882
35880: GO 35912
35882: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
35883: LD_ADDR_VAR 0 3
35887: PUSH
35888: LD_INT 1
35890: PUSH
35891: LD_INT 2
35893: PUSH
35894: LD_INT 3
35896: PUSH
35897: LD_INT 4
35899: PUSH
35900: LD_INT 5
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: LIST
35909: ST_TO_ADDR
35910: GO 36879
35912: LD_INT 3
35914: DOUBLE
35915: EQUAL
35916: IFTRUE 35920
35918: GO 35950
35920: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
35921: LD_ADDR_VAR 0 3
35925: PUSH
35926: LD_INT 1
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: LD_INT 3
35934: PUSH
35935: LD_INT 4
35937: PUSH
35938: LD_INT 5
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: LIST
35945: LIST
35946: LIST
35947: ST_TO_ADDR
35948: GO 36879
35950: LD_INT 11
35952: DOUBLE
35953: EQUAL
35954: IFTRUE 35958
35956: GO 35988
35958: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
35959: LD_ADDR_VAR 0 3
35963: PUSH
35964: LD_INT 1
35966: PUSH
35967: LD_INT 2
35969: PUSH
35970: LD_INT 3
35972: PUSH
35973: LD_INT 4
35975: PUSH
35976: LD_INT 5
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: ST_TO_ADDR
35986: GO 36879
35988: LD_INT 4
35990: DOUBLE
35991: EQUAL
35992: IFTRUE 35996
35994: GO 36022
35996: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
35997: LD_ADDR_VAR 0 3
36001: PUSH
36002: LD_INT 2
36004: PUSH
36005: LD_INT 3
36007: PUSH
36008: LD_INT 4
36010: PUSH
36011: LD_INT 5
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: LIST
36018: LIST
36019: ST_TO_ADDR
36020: GO 36879
36022: LD_INT 5
36024: DOUBLE
36025: EQUAL
36026: IFTRUE 36030
36028: GO 36056
36030: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
36031: LD_ADDR_VAR 0 3
36035: PUSH
36036: LD_INT 2
36038: PUSH
36039: LD_INT 3
36041: PUSH
36042: LD_INT 4
36044: PUSH
36045: LD_INT 5
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: LIST
36052: LIST
36053: ST_TO_ADDR
36054: GO 36879
36056: LD_INT 9
36058: DOUBLE
36059: EQUAL
36060: IFTRUE 36064
36062: GO 36090
36064: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
36065: LD_ADDR_VAR 0 3
36069: PUSH
36070: LD_INT 2
36072: PUSH
36073: LD_INT 3
36075: PUSH
36076: LD_INT 4
36078: PUSH
36079: LD_INT 5
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: ST_TO_ADDR
36088: GO 36879
36090: LD_INT 7
36092: DOUBLE
36093: EQUAL
36094: IFTRUE 36098
36096: GO 36124
36098: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
36099: LD_ADDR_VAR 0 3
36103: PUSH
36104: LD_INT 2
36106: PUSH
36107: LD_INT 3
36109: PUSH
36110: LD_INT 4
36112: PUSH
36113: LD_INT 5
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: ST_TO_ADDR
36122: GO 36879
36124: LD_INT 12
36126: DOUBLE
36127: EQUAL
36128: IFTRUE 36132
36130: GO 36158
36132: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
36133: LD_ADDR_VAR 0 3
36137: PUSH
36138: LD_INT 2
36140: PUSH
36141: LD_INT 3
36143: PUSH
36144: LD_INT 4
36146: PUSH
36147: LD_INT 5
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: ST_TO_ADDR
36156: GO 36879
36158: LD_INT 13
36160: DOUBLE
36161: EQUAL
36162: IFTRUE 36166
36164: GO 36192
36166: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
36167: LD_ADDR_VAR 0 3
36171: PUSH
36172: LD_INT 2
36174: PUSH
36175: LD_INT 3
36177: PUSH
36178: LD_INT 4
36180: PUSH
36181: LD_INT 5
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: ST_TO_ADDR
36190: GO 36879
36192: LD_INT 14
36194: DOUBLE
36195: EQUAL
36196: IFTRUE 36200
36198: GO 36218
36200: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
36201: LD_ADDR_VAR 0 3
36205: PUSH
36206: LD_INT 4
36208: PUSH
36209: LD_INT 5
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: ST_TO_ADDR
36216: GO 36879
36218: LD_INT 6
36220: DOUBLE
36221: EQUAL
36222: IFTRUE 36226
36224: GO 36244
36226: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
36227: LD_ADDR_VAR 0 3
36231: PUSH
36232: LD_INT 4
36234: PUSH
36235: LD_INT 5
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: ST_TO_ADDR
36242: GO 36879
36244: LD_INT 10
36246: DOUBLE
36247: EQUAL
36248: IFTRUE 36252
36250: GO 36270
36252: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
36253: LD_ADDR_VAR 0 3
36257: PUSH
36258: LD_INT 4
36260: PUSH
36261: LD_INT 5
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: ST_TO_ADDR
36268: GO 36879
36270: LD_INT 22
36272: DOUBLE
36273: EQUAL
36274: IFTRUE 36278
36276: GO 36304
36278: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
36279: LD_ADDR_VAR 0 3
36283: PUSH
36284: LD_INT 11
36286: PUSH
36287: LD_INT 12
36289: PUSH
36290: LD_INT 13
36292: PUSH
36293: LD_INT 14
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: LIST
36300: LIST
36301: ST_TO_ADDR
36302: GO 36879
36304: LD_INT 23
36306: DOUBLE
36307: EQUAL
36308: IFTRUE 36312
36310: GO 36338
36312: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
36313: LD_ADDR_VAR 0 3
36317: PUSH
36318: LD_INT 11
36320: PUSH
36321: LD_INT 12
36323: PUSH
36324: LD_INT 13
36326: PUSH
36327: LD_INT 14
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: ST_TO_ADDR
36336: GO 36879
36338: LD_INT 24
36340: DOUBLE
36341: EQUAL
36342: IFTRUE 36346
36344: GO 36372
36346: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
36347: LD_ADDR_VAR 0 3
36351: PUSH
36352: LD_INT 11
36354: PUSH
36355: LD_INT 12
36357: PUSH
36358: LD_INT 13
36360: PUSH
36361: LD_INT 14
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: LIST
36368: LIST
36369: ST_TO_ADDR
36370: GO 36879
36372: LD_INT 30
36374: DOUBLE
36375: EQUAL
36376: IFTRUE 36380
36378: GO 36406
36380: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
36381: LD_ADDR_VAR 0 3
36385: PUSH
36386: LD_INT 11
36388: PUSH
36389: LD_INT 12
36391: PUSH
36392: LD_INT 13
36394: PUSH
36395: LD_INT 14
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: ST_TO_ADDR
36404: GO 36879
36406: LD_INT 25
36408: DOUBLE
36409: EQUAL
36410: IFTRUE 36414
36412: GO 36432
36414: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
36415: LD_ADDR_VAR 0 3
36419: PUSH
36420: LD_INT 13
36422: PUSH
36423: LD_INT 14
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: ST_TO_ADDR
36430: GO 36879
36432: LD_INT 27
36434: DOUBLE
36435: EQUAL
36436: IFTRUE 36440
36438: GO 36458
36440: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
36441: LD_ADDR_VAR 0 3
36445: PUSH
36446: LD_INT 13
36448: PUSH
36449: LD_INT 14
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: ST_TO_ADDR
36456: GO 36879
36458: LD_INT 28
36460: DOUBLE
36461: EQUAL
36462: IFTRUE 36466
36464: GO 36484
36466: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
36467: LD_ADDR_VAR 0 3
36471: PUSH
36472: LD_INT 13
36474: PUSH
36475: LD_INT 14
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: ST_TO_ADDR
36482: GO 36879
36484: LD_INT 29
36486: DOUBLE
36487: EQUAL
36488: IFTRUE 36492
36490: GO 36510
36492: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
36493: LD_ADDR_VAR 0 3
36497: PUSH
36498: LD_INT 13
36500: PUSH
36501: LD_INT 14
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: ST_TO_ADDR
36508: GO 36879
36510: LD_INT 31
36512: DOUBLE
36513: EQUAL
36514: IFTRUE 36518
36516: GO 36536
36518: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
36519: LD_ADDR_VAR 0 3
36523: PUSH
36524: LD_INT 13
36526: PUSH
36527: LD_INT 14
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: ST_TO_ADDR
36534: GO 36879
36536: LD_INT 26
36538: DOUBLE
36539: EQUAL
36540: IFTRUE 36544
36542: GO 36562
36544: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
36545: LD_ADDR_VAR 0 3
36549: PUSH
36550: LD_INT 13
36552: PUSH
36553: LD_INT 14
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: ST_TO_ADDR
36560: GO 36879
36562: LD_INT 42
36564: DOUBLE
36565: EQUAL
36566: IFTRUE 36570
36568: GO 36596
36570: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
36571: LD_ADDR_VAR 0 3
36575: PUSH
36576: LD_INT 21
36578: PUSH
36579: LD_INT 22
36581: PUSH
36582: LD_INT 23
36584: PUSH
36585: LD_INT 24
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: ST_TO_ADDR
36594: GO 36879
36596: LD_INT 43
36598: DOUBLE
36599: EQUAL
36600: IFTRUE 36604
36602: GO 36630
36604: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
36605: LD_ADDR_VAR 0 3
36609: PUSH
36610: LD_INT 21
36612: PUSH
36613: LD_INT 22
36615: PUSH
36616: LD_INT 23
36618: PUSH
36619: LD_INT 24
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: ST_TO_ADDR
36628: GO 36879
36630: LD_INT 44
36632: DOUBLE
36633: EQUAL
36634: IFTRUE 36638
36636: GO 36664
36638: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
36639: LD_ADDR_VAR 0 3
36643: PUSH
36644: LD_INT 21
36646: PUSH
36647: LD_INT 22
36649: PUSH
36650: LD_INT 23
36652: PUSH
36653: LD_INT 24
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: ST_TO_ADDR
36662: GO 36879
36664: LD_INT 45
36666: DOUBLE
36667: EQUAL
36668: IFTRUE 36672
36670: GO 36698
36672: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
36673: LD_ADDR_VAR 0 3
36677: PUSH
36678: LD_INT 21
36680: PUSH
36681: LD_INT 22
36683: PUSH
36684: LD_INT 23
36686: PUSH
36687: LD_INT 24
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: ST_TO_ADDR
36696: GO 36879
36698: LD_INT 49
36700: DOUBLE
36701: EQUAL
36702: IFTRUE 36706
36704: GO 36732
36706: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
36707: LD_ADDR_VAR 0 3
36711: PUSH
36712: LD_INT 21
36714: PUSH
36715: LD_INT 22
36717: PUSH
36718: LD_INT 23
36720: PUSH
36721: LD_INT 24
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: LIST
36728: LIST
36729: ST_TO_ADDR
36730: GO 36879
36732: LD_INT 51
36734: DOUBLE
36735: EQUAL
36736: IFTRUE 36740
36738: GO 36766
36740: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
36741: LD_ADDR_VAR 0 3
36745: PUSH
36746: LD_INT 21
36748: PUSH
36749: LD_INT 22
36751: PUSH
36752: LD_INT 23
36754: PUSH
36755: LD_INT 24
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: LIST
36762: LIST
36763: ST_TO_ADDR
36764: GO 36879
36766: LD_INT 52
36768: DOUBLE
36769: EQUAL
36770: IFTRUE 36774
36772: GO 36800
36774: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
36775: LD_ADDR_VAR 0 3
36779: PUSH
36780: LD_INT 21
36782: PUSH
36783: LD_INT 22
36785: PUSH
36786: LD_INT 23
36788: PUSH
36789: LD_INT 24
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: ST_TO_ADDR
36798: GO 36879
36800: LD_INT 53
36802: DOUBLE
36803: EQUAL
36804: IFTRUE 36808
36806: GO 36826
36808: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
36809: LD_ADDR_VAR 0 3
36813: PUSH
36814: LD_INT 23
36816: PUSH
36817: LD_INT 24
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: ST_TO_ADDR
36824: GO 36879
36826: LD_INT 46
36828: DOUBLE
36829: EQUAL
36830: IFTRUE 36834
36832: GO 36852
36834: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
36835: LD_ADDR_VAR 0 3
36839: PUSH
36840: LD_INT 23
36842: PUSH
36843: LD_INT 24
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: ST_TO_ADDR
36850: GO 36879
36852: LD_INT 47
36854: DOUBLE
36855: EQUAL
36856: IFTRUE 36860
36858: GO 36878
36860: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
36861: LD_ADDR_VAR 0 3
36865: PUSH
36866: LD_INT 23
36868: PUSH
36869: LD_INT 24
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: ST_TO_ADDR
36876: GO 36879
36878: POP
// result := ( chassis in result ) ;
36879: LD_ADDR_VAR 0 3
36883: PUSH
36884: LD_VAR 0 1
36888: PUSH
36889: LD_VAR 0 3
36893: IN
36894: ST_TO_ADDR
// end ;
36895: LD_VAR 0 3
36899: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
36900: LD_INT 0
36902: PPUSH
36903: PPUSH
36904: PPUSH
36905: PPUSH
36906: PPUSH
36907: PPUSH
36908: PPUSH
// result := array ;
36909: LD_ADDR_VAR 0 5
36913: PUSH
36914: LD_VAR 0 1
36918: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
36919: LD_VAR 0 1
36923: NOT
36924: PUSH
36925: LD_VAR 0 2
36929: NOT
36930: OR
36931: PUSH
36932: LD_VAR 0 3
36936: NOT
36937: OR
36938: PUSH
36939: LD_VAR 0 2
36943: PUSH
36944: LD_VAR 0 1
36948: GREATER
36949: OR
36950: PUSH
36951: LD_VAR 0 3
36955: PUSH
36956: LD_VAR 0 1
36960: GREATER
36961: OR
36962: IFFALSE 36966
// exit ;
36964: GO 37262
// if direction then
36966: LD_VAR 0 4
36970: IFFALSE 37034
// begin d := 1 ;
36972: LD_ADDR_VAR 0 9
36976: PUSH
36977: LD_INT 1
36979: ST_TO_ADDR
// if i_from > i_to then
36980: LD_VAR 0 2
36984: PUSH
36985: LD_VAR 0 3
36989: GREATER
36990: IFFALSE 37016
// length := ( array - i_from ) + i_to else
36992: LD_ADDR_VAR 0 11
36996: PUSH
36997: LD_VAR 0 1
37001: PUSH
37002: LD_VAR 0 2
37006: MINUS
37007: PUSH
37008: LD_VAR 0 3
37012: PLUS
37013: ST_TO_ADDR
37014: GO 37032
// length := i_to - i_from ;
37016: LD_ADDR_VAR 0 11
37020: PUSH
37021: LD_VAR 0 3
37025: PUSH
37026: LD_VAR 0 2
37030: MINUS
37031: ST_TO_ADDR
// end else
37032: GO 37095
// begin d := - 1 ;
37034: LD_ADDR_VAR 0 9
37038: PUSH
37039: LD_INT 1
37041: NEG
37042: ST_TO_ADDR
// if i_from > i_to then
37043: LD_VAR 0 2
37047: PUSH
37048: LD_VAR 0 3
37052: GREATER
37053: IFFALSE 37073
// length := i_from - i_to else
37055: LD_ADDR_VAR 0 11
37059: PUSH
37060: LD_VAR 0 2
37064: PUSH
37065: LD_VAR 0 3
37069: MINUS
37070: ST_TO_ADDR
37071: GO 37095
// length := ( array - i_to ) + i_from ;
37073: LD_ADDR_VAR 0 11
37077: PUSH
37078: LD_VAR 0 1
37082: PUSH
37083: LD_VAR 0 3
37087: MINUS
37088: PUSH
37089: LD_VAR 0 2
37093: PLUS
37094: ST_TO_ADDR
// end ; if not length then
37095: LD_VAR 0 11
37099: NOT
37100: IFFALSE 37104
// exit ;
37102: GO 37262
// tmp := array ;
37104: LD_ADDR_VAR 0 10
37108: PUSH
37109: LD_VAR 0 1
37113: ST_TO_ADDR
// for i = 1 to length do
37114: LD_ADDR_VAR 0 6
37118: PUSH
37119: DOUBLE
37120: LD_INT 1
37122: DEC
37123: ST_TO_ADDR
37124: LD_VAR 0 11
37128: PUSH
37129: FOR_TO
37130: IFFALSE 37250
// begin for j = 1 to array do
37132: LD_ADDR_VAR 0 7
37136: PUSH
37137: DOUBLE
37138: LD_INT 1
37140: DEC
37141: ST_TO_ADDR
37142: LD_VAR 0 1
37146: PUSH
37147: FOR_TO
37148: IFFALSE 37236
// begin k := j + d ;
37150: LD_ADDR_VAR 0 8
37154: PUSH
37155: LD_VAR 0 7
37159: PUSH
37160: LD_VAR 0 9
37164: PLUS
37165: ST_TO_ADDR
// if k > array then
37166: LD_VAR 0 8
37170: PUSH
37171: LD_VAR 0 1
37175: GREATER
37176: IFFALSE 37186
// k := 1 ;
37178: LD_ADDR_VAR 0 8
37182: PUSH
37183: LD_INT 1
37185: ST_TO_ADDR
// if not k then
37186: LD_VAR 0 8
37190: NOT
37191: IFFALSE 37203
// k := array ;
37193: LD_ADDR_VAR 0 8
37197: PUSH
37198: LD_VAR 0 1
37202: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
37203: LD_ADDR_VAR 0 10
37207: PUSH
37208: LD_VAR 0 10
37212: PPUSH
37213: LD_VAR 0 8
37217: PPUSH
37218: LD_VAR 0 1
37222: PUSH
37223: LD_VAR 0 7
37227: ARRAY
37228: PPUSH
37229: CALL_OW 1
37233: ST_TO_ADDR
// end ;
37234: GO 37147
37236: POP
37237: POP
// array := tmp ;
37238: LD_ADDR_VAR 0 1
37242: PUSH
37243: LD_VAR 0 10
37247: ST_TO_ADDR
// end ;
37248: GO 37129
37250: POP
37251: POP
// result := array ;
37252: LD_ADDR_VAR 0 5
37256: PUSH
37257: LD_VAR 0 1
37261: ST_TO_ADDR
// end ;
37262: LD_VAR 0 5
37266: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
37267: LD_INT 0
37269: PPUSH
37270: PPUSH
// result := 0 ;
37271: LD_ADDR_VAR 0 3
37275: PUSH
37276: LD_INT 0
37278: ST_TO_ADDR
// if not array or not value in array then
37279: LD_VAR 0 1
37283: NOT
37284: PUSH
37285: LD_VAR 0 2
37289: PUSH
37290: LD_VAR 0 1
37294: IN
37295: NOT
37296: OR
37297: IFFALSE 37301
// exit ;
37299: GO 37355
// for i = 1 to array do
37301: LD_ADDR_VAR 0 4
37305: PUSH
37306: DOUBLE
37307: LD_INT 1
37309: DEC
37310: ST_TO_ADDR
37311: LD_VAR 0 1
37315: PUSH
37316: FOR_TO
37317: IFFALSE 37353
// if value = array [ i ] then
37319: LD_VAR 0 2
37323: PUSH
37324: LD_VAR 0 1
37328: PUSH
37329: LD_VAR 0 4
37333: ARRAY
37334: EQUAL
37335: IFFALSE 37351
// begin result := i ;
37337: LD_ADDR_VAR 0 3
37341: PUSH
37342: LD_VAR 0 4
37346: ST_TO_ADDR
// exit ;
37347: POP
37348: POP
37349: GO 37355
// end ;
37351: GO 37316
37353: POP
37354: POP
// end ;
37355: LD_VAR 0 3
37359: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
37360: LD_INT 0
37362: PPUSH
// vc_chassis := chassis ;
37363: LD_ADDR_OWVAR 37
37367: PUSH
37368: LD_VAR 0 1
37372: ST_TO_ADDR
// vc_engine := engine ;
37373: LD_ADDR_OWVAR 39
37377: PUSH
37378: LD_VAR 0 2
37382: ST_TO_ADDR
// vc_control := control ;
37383: LD_ADDR_OWVAR 38
37387: PUSH
37388: LD_VAR 0 3
37392: ST_TO_ADDR
// vc_weapon := weapon ;
37393: LD_ADDR_OWVAR 40
37397: PUSH
37398: LD_VAR 0 4
37402: ST_TO_ADDR
// vc_fuel_battery := fuel ;
37403: LD_ADDR_OWVAR 41
37407: PUSH
37408: LD_VAR 0 5
37412: ST_TO_ADDR
// end ;
37413: LD_VAR 0 6
37417: RET
// export function WantPlant ( unit ) ; var task ; begin
37418: LD_INT 0
37420: PPUSH
37421: PPUSH
// result := false ;
37422: LD_ADDR_VAR 0 2
37426: PUSH
37427: LD_INT 0
37429: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
37430: LD_ADDR_VAR 0 3
37434: PUSH
37435: LD_VAR 0 1
37439: PPUSH
37440: CALL_OW 437
37444: ST_TO_ADDR
// if task then
37445: LD_VAR 0 3
37449: IFFALSE 37477
// if task [ 1 ] [ 1 ] = p then
37451: LD_VAR 0 3
37455: PUSH
37456: LD_INT 1
37458: ARRAY
37459: PUSH
37460: LD_INT 1
37462: ARRAY
37463: PUSH
37464: LD_STRING p
37466: EQUAL
37467: IFFALSE 37477
// result := true ;
37469: LD_ADDR_VAR 0 2
37473: PUSH
37474: LD_INT 1
37476: ST_TO_ADDR
// end ;
37477: LD_VAR 0 2
37481: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
37482: LD_INT 0
37484: PPUSH
37485: PPUSH
37486: PPUSH
37487: PPUSH
// if pos < 1 then
37488: LD_VAR 0 2
37492: PUSH
37493: LD_INT 1
37495: LESS
37496: IFFALSE 37500
// exit ;
37498: GO 37803
// if pos = 1 then
37500: LD_VAR 0 2
37504: PUSH
37505: LD_INT 1
37507: EQUAL
37508: IFFALSE 37541
// result := Replace ( arr , pos [ 1 ] , value ) else
37510: LD_ADDR_VAR 0 4
37514: PUSH
37515: LD_VAR 0 1
37519: PPUSH
37520: LD_VAR 0 2
37524: PUSH
37525: LD_INT 1
37527: ARRAY
37528: PPUSH
37529: LD_VAR 0 3
37533: PPUSH
37534: CALL_OW 1
37538: ST_TO_ADDR
37539: GO 37803
// begin tmp := arr ;
37541: LD_ADDR_VAR 0 6
37545: PUSH
37546: LD_VAR 0 1
37550: ST_TO_ADDR
// s_arr := [ tmp ] ;
37551: LD_ADDR_VAR 0 7
37555: PUSH
37556: LD_VAR 0 6
37560: PUSH
37561: EMPTY
37562: LIST
37563: ST_TO_ADDR
// for i = 1 to pos - 1 do
37564: LD_ADDR_VAR 0 5
37568: PUSH
37569: DOUBLE
37570: LD_INT 1
37572: DEC
37573: ST_TO_ADDR
37574: LD_VAR 0 2
37578: PUSH
37579: LD_INT 1
37581: MINUS
37582: PUSH
37583: FOR_TO
37584: IFFALSE 37629
// begin tmp := tmp [ pos [ i ] ] ;
37586: LD_ADDR_VAR 0 6
37590: PUSH
37591: LD_VAR 0 6
37595: PUSH
37596: LD_VAR 0 2
37600: PUSH
37601: LD_VAR 0 5
37605: ARRAY
37606: ARRAY
37607: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
37608: LD_ADDR_VAR 0 7
37612: PUSH
37613: LD_VAR 0 7
37617: PUSH
37618: LD_VAR 0 6
37622: PUSH
37623: EMPTY
37624: LIST
37625: ADD
37626: ST_TO_ADDR
// end ;
37627: GO 37583
37629: POP
37630: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
37631: LD_ADDR_VAR 0 6
37635: PUSH
37636: LD_VAR 0 6
37640: PPUSH
37641: LD_VAR 0 2
37645: PUSH
37646: LD_VAR 0 2
37650: ARRAY
37651: PPUSH
37652: LD_VAR 0 3
37656: PPUSH
37657: CALL_OW 1
37661: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
37662: LD_ADDR_VAR 0 7
37666: PUSH
37667: LD_VAR 0 7
37671: PPUSH
37672: LD_VAR 0 7
37676: PPUSH
37677: LD_VAR 0 6
37681: PPUSH
37682: CALL_OW 1
37686: ST_TO_ADDR
// for i = s_arr downto 2 do
37687: LD_ADDR_VAR 0 5
37691: PUSH
37692: DOUBLE
37693: LD_VAR 0 7
37697: INC
37698: ST_TO_ADDR
37699: LD_INT 2
37701: PUSH
37702: FOR_DOWNTO
37703: IFFALSE 37787
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
37705: LD_ADDR_VAR 0 6
37709: PUSH
37710: LD_VAR 0 7
37714: PUSH
37715: LD_VAR 0 5
37719: PUSH
37720: LD_INT 1
37722: MINUS
37723: ARRAY
37724: PPUSH
37725: LD_VAR 0 2
37729: PUSH
37730: LD_VAR 0 5
37734: PUSH
37735: LD_INT 1
37737: MINUS
37738: ARRAY
37739: PPUSH
37740: LD_VAR 0 7
37744: PUSH
37745: LD_VAR 0 5
37749: ARRAY
37750: PPUSH
37751: CALL_OW 1
37755: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
37756: LD_ADDR_VAR 0 7
37760: PUSH
37761: LD_VAR 0 7
37765: PPUSH
37766: LD_VAR 0 5
37770: PUSH
37771: LD_INT 1
37773: MINUS
37774: PPUSH
37775: LD_VAR 0 6
37779: PPUSH
37780: CALL_OW 1
37784: ST_TO_ADDR
// end ;
37785: GO 37702
37787: POP
37788: POP
// result := s_arr [ 1 ] ;
37789: LD_ADDR_VAR 0 4
37793: PUSH
37794: LD_VAR 0 7
37798: PUSH
37799: LD_INT 1
37801: ARRAY
37802: ST_TO_ADDR
// end ; end ;
37803: LD_VAR 0 4
37807: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
37808: LD_INT 0
37810: PPUSH
37811: PPUSH
// if not list then
37812: LD_VAR 0 1
37816: NOT
37817: IFFALSE 37821
// exit ;
37819: GO 37912
// i := list [ pos1 ] ;
37821: LD_ADDR_VAR 0 5
37825: PUSH
37826: LD_VAR 0 1
37830: PUSH
37831: LD_VAR 0 2
37835: ARRAY
37836: ST_TO_ADDR
// if not i then
37837: LD_VAR 0 5
37841: NOT
37842: IFFALSE 37846
// exit ;
37844: GO 37912
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
37846: LD_ADDR_VAR 0 1
37850: PUSH
37851: LD_VAR 0 1
37855: PPUSH
37856: LD_VAR 0 2
37860: PPUSH
37861: LD_VAR 0 1
37865: PUSH
37866: LD_VAR 0 3
37870: ARRAY
37871: PPUSH
37872: CALL_OW 1
37876: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
37877: LD_ADDR_VAR 0 1
37881: PUSH
37882: LD_VAR 0 1
37886: PPUSH
37887: LD_VAR 0 3
37891: PPUSH
37892: LD_VAR 0 5
37896: PPUSH
37897: CALL_OW 1
37901: ST_TO_ADDR
// result := list ;
37902: LD_ADDR_VAR 0 4
37906: PUSH
37907: LD_VAR 0 1
37911: ST_TO_ADDR
// end ;
37912: LD_VAR 0 4
37916: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
37917: LD_INT 0
37919: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
37920: LD_ADDR_VAR 0 5
37924: PUSH
37925: LD_VAR 0 1
37929: PPUSH
37930: CALL_OW 250
37934: PPUSH
37935: LD_VAR 0 1
37939: PPUSH
37940: CALL_OW 251
37944: PPUSH
37945: LD_VAR 0 2
37949: PPUSH
37950: LD_VAR 0 3
37954: PPUSH
37955: LD_VAR 0 4
37959: PPUSH
37960: CALL 37970 0 5
37964: ST_TO_ADDR
// end ;
37965: LD_VAR 0 5
37969: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
37970: LD_INT 0
37972: PPUSH
37973: PPUSH
37974: PPUSH
37975: PPUSH
// if not list then
37976: LD_VAR 0 3
37980: NOT
37981: IFFALSE 37985
// exit ;
37983: GO 38373
// result := [ ] ;
37985: LD_ADDR_VAR 0 6
37989: PUSH
37990: EMPTY
37991: ST_TO_ADDR
// for i in list do
37992: LD_ADDR_VAR 0 7
37996: PUSH
37997: LD_VAR 0 3
38001: PUSH
38002: FOR_IN
38003: IFFALSE 38205
// begin tmp := GetDistUnitXY ( i , x , y ) ;
38005: LD_ADDR_VAR 0 9
38009: PUSH
38010: LD_VAR 0 7
38014: PPUSH
38015: LD_VAR 0 1
38019: PPUSH
38020: LD_VAR 0 2
38024: PPUSH
38025: CALL_OW 297
38029: ST_TO_ADDR
// if not result then
38030: LD_VAR 0 6
38034: NOT
38035: IFFALSE 38061
// result := [ [ i , tmp ] ] else
38037: LD_ADDR_VAR 0 6
38041: PUSH
38042: LD_VAR 0 7
38046: PUSH
38047: LD_VAR 0 9
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: EMPTY
38057: LIST
38058: ST_TO_ADDR
38059: GO 38203
// begin if result [ result ] [ 2 ] < tmp then
38061: LD_VAR 0 6
38065: PUSH
38066: LD_VAR 0 6
38070: ARRAY
38071: PUSH
38072: LD_INT 2
38074: ARRAY
38075: PUSH
38076: LD_VAR 0 9
38080: LESS
38081: IFFALSE 38123
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
38083: LD_ADDR_VAR 0 6
38087: PUSH
38088: LD_VAR 0 6
38092: PPUSH
38093: LD_VAR 0 6
38097: PUSH
38098: LD_INT 1
38100: PLUS
38101: PPUSH
38102: LD_VAR 0 7
38106: PUSH
38107: LD_VAR 0 9
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PPUSH
38116: CALL_OW 2
38120: ST_TO_ADDR
38121: GO 38203
// for j = 1 to result do
38123: LD_ADDR_VAR 0 8
38127: PUSH
38128: DOUBLE
38129: LD_INT 1
38131: DEC
38132: ST_TO_ADDR
38133: LD_VAR 0 6
38137: PUSH
38138: FOR_TO
38139: IFFALSE 38201
// begin if tmp < result [ j ] [ 2 ] then
38141: LD_VAR 0 9
38145: PUSH
38146: LD_VAR 0 6
38150: PUSH
38151: LD_VAR 0 8
38155: ARRAY
38156: PUSH
38157: LD_INT 2
38159: ARRAY
38160: LESS
38161: IFFALSE 38199
// begin result := Insert ( result , j , [ i , tmp ] ) ;
38163: LD_ADDR_VAR 0 6
38167: PUSH
38168: LD_VAR 0 6
38172: PPUSH
38173: LD_VAR 0 8
38177: PPUSH
38178: LD_VAR 0 7
38182: PUSH
38183: LD_VAR 0 9
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PPUSH
38192: CALL_OW 2
38196: ST_TO_ADDR
// break ;
38197: GO 38201
// end ; end ;
38199: GO 38138
38201: POP
38202: POP
// end ; end ;
38203: GO 38002
38205: POP
38206: POP
// if result and not asc then
38207: LD_VAR 0 6
38211: PUSH
38212: LD_VAR 0 4
38216: NOT
38217: AND
38218: IFFALSE 38293
// begin tmp := result ;
38220: LD_ADDR_VAR 0 9
38224: PUSH
38225: LD_VAR 0 6
38229: ST_TO_ADDR
// for i = tmp downto 1 do
38230: LD_ADDR_VAR 0 7
38234: PUSH
38235: DOUBLE
38236: LD_VAR 0 9
38240: INC
38241: ST_TO_ADDR
38242: LD_INT 1
38244: PUSH
38245: FOR_DOWNTO
38246: IFFALSE 38291
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
38248: LD_ADDR_VAR 0 6
38252: PUSH
38253: LD_VAR 0 6
38257: PPUSH
38258: LD_VAR 0 9
38262: PUSH
38263: LD_VAR 0 7
38267: MINUS
38268: PUSH
38269: LD_INT 1
38271: PLUS
38272: PPUSH
38273: LD_VAR 0 9
38277: PUSH
38278: LD_VAR 0 7
38282: ARRAY
38283: PPUSH
38284: CALL_OW 1
38288: ST_TO_ADDR
38289: GO 38245
38291: POP
38292: POP
// end ; tmp := [ ] ;
38293: LD_ADDR_VAR 0 9
38297: PUSH
38298: EMPTY
38299: ST_TO_ADDR
// if mode then
38300: LD_VAR 0 5
38304: IFFALSE 38373
// begin for i = 1 to result do
38306: LD_ADDR_VAR 0 7
38310: PUSH
38311: DOUBLE
38312: LD_INT 1
38314: DEC
38315: ST_TO_ADDR
38316: LD_VAR 0 6
38320: PUSH
38321: FOR_TO
38322: IFFALSE 38361
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
38324: LD_ADDR_VAR 0 9
38328: PUSH
38329: LD_VAR 0 9
38333: PPUSH
38334: LD_VAR 0 7
38338: PPUSH
38339: LD_VAR 0 6
38343: PUSH
38344: LD_VAR 0 7
38348: ARRAY
38349: PUSH
38350: LD_INT 1
38352: ARRAY
38353: PPUSH
38354: CALL_OW 1
38358: ST_TO_ADDR
38359: GO 38321
38361: POP
38362: POP
// result := tmp ;
38363: LD_ADDR_VAR 0 6
38367: PUSH
38368: LD_VAR 0 9
38372: ST_TO_ADDR
// end ; end ;
38373: LD_VAR 0 6
38377: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
38378: LD_INT 0
38380: PPUSH
38381: PPUSH
38382: PPUSH
38383: PPUSH
38384: PPUSH
38385: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
38386: LD_ADDR_VAR 0 5
38390: PUSH
38391: LD_INT 0
38393: PUSH
38394: LD_INT 0
38396: PUSH
38397: LD_INT 0
38399: PUSH
38400: EMPTY
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: ST_TO_ADDR
// if not x or not y then
38408: LD_VAR 0 2
38412: NOT
38413: PUSH
38414: LD_VAR 0 3
38418: NOT
38419: OR
38420: IFFALSE 38424
// exit ;
38422: GO 40070
// if not range then
38424: LD_VAR 0 4
38428: NOT
38429: IFFALSE 38439
// range := 10 ;
38431: LD_ADDR_VAR 0 4
38435: PUSH
38436: LD_INT 10
38438: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
38439: LD_ADDR_VAR 0 8
38443: PUSH
38444: LD_INT 81
38446: PUSH
38447: LD_VAR 0 1
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 92
38458: PUSH
38459: LD_VAR 0 2
38463: PUSH
38464: LD_VAR 0 3
38468: PUSH
38469: LD_VAR 0 4
38473: PUSH
38474: EMPTY
38475: LIST
38476: LIST
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 3
38482: PUSH
38483: LD_INT 21
38485: PUSH
38486: LD_INT 3
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: LIST
38501: PPUSH
38502: CALL_OW 69
38506: ST_TO_ADDR
// if not tmp then
38507: LD_VAR 0 8
38511: NOT
38512: IFFALSE 38516
// exit ;
38514: GO 40070
// for i in tmp do
38516: LD_ADDR_VAR 0 6
38520: PUSH
38521: LD_VAR 0 8
38525: PUSH
38526: FOR_IN
38527: IFFALSE 40045
// begin points := [ 0 , 0 , 0 ] ;
38529: LD_ADDR_VAR 0 9
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: LD_INT 0
38539: PUSH
38540: LD_INT 0
38542: PUSH
38543: EMPTY
38544: LIST
38545: LIST
38546: LIST
38547: ST_TO_ADDR
// bpoints := 1 ;
38548: LD_ADDR_VAR 0 10
38552: PUSH
38553: LD_INT 1
38555: ST_TO_ADDR
// case GetType ( i ) of unit_human :
38556: LD_VAR 0 6
38560: PPUSH
38561: CALL_OW 247
38565: PUSH
38566: LD_INT 1
38568: DOUBLE
38569: EQUAL
38570: IFTRUE 38574
38572: GO 39152
38574: POP
// begin if GetClass ( i ) = 1 then
38575: LD_VAR 0 6
38579: PPUSH
38580: CALL_OW 257
38584: PUSH
38585: LD_INT 1
38587: EQUAL
38588: IFFALSE 38609
// points := [ 10 , 5 , 3 ] ;
38590: LD_ADDR_VAR 0 9
38594: PUSH
38595: LD_INT 10
38597: PUSH
38598: LD_INT 5
38600: PUSH
38601: LD_INT 3
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: LIST
38608: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
38609: LD_VAR 0 6
38613: PPUSH
38614: CALL_OW 257
38618: PUSH
38619: LD_INT 2
38621: PUSH
38622: LD_INT 3
38624: PUSH
38625: LD_INT 4
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: LIST
38632: IN
38633: IFFALSE 38654
// points := [ 3 , 2 , 1 ] ;
38635: LD_ADDR_VAR 0 9
38639: PUSH
38640: LD_INT 3
38642: PUSH
38643: LD_INT 2
38645: PUSH
38646: LD_INT 1
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: LIST
38653: ST_TO_ADDR
// if GetClass ( i ) = 5 then
38654: LD_VAR 0 6
38658: PPUSH
38659: CALL_OW 257
38663: PUSH
38664: LD_INT 5
38666: EQUAL
38667: IFFALSE 38688
// points := [ 130 , 5 , 2 ] ;
38669: LD_ADDR_VAR 0 9
38673: PUSH
38674: LD_INT 130
38676: PUSH
38677: LD_INT 5
38679: PUSH
38680: LD_INT 2
38682: PUSH
38683: EMPTY
38684: LIST
38685: LIST
38686: LIST
38687: ST_TO_ADDR
// if GetClass ( i ) = 8 then
38688: LD_VAR 0 6
38692: PPUSH
38693: CALL_OW 257
38697: PUSH
38698: LD_INT 8
38700: EQUAL
38701: IFFALSE 38722
// points := [ 35 , 35 , 30 ] ;
38703: LD_ADDR_VAR 0 9
38707: PUSH
38708: LD_INT 35
38710: PUSH
38711: LD_INT 35
38713: PUSH
38714: LD_INT 30
38716: PUSH
38717: EMPTY
38718: LIST
38719: LIST
38720: LIST
38721: ST_TO_ADDR
// if GetClass ( i ) = 9 then
38722: LD_VAR 0 6
38726: PPUSH
38727: CALL_OW 257
38731: PUSH
38732: LD_INT 9
38734: EQUAL
38735: IFFALSE 38756
// points := [ 20 , 55 , 40 ] ;
38737: LD_ADDR_VAR 0 9
38741: PUSH
38742: LD_INT 20
38744: PUSH
38745: LD_INT 55
38747: PUSH
38748: LD_INT 40
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: LIST
38755: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
38756: LD_VAR 0 6
38760: PPUSH
38761: CALL_OW 257
38765: PUSH
38766: LD_INT 12
38768: PUSH
38769: LD_INT 16
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: IN
38776: IFFALSE 38797
// points := [ 5 , 3 , 2 ] ;
38778: LD_ADDR_VAR 0 9
38782: PUSH
38783: LD_INT 5
38785: PUSH
38786: LD_INT 3
38788: PUSH
38789: LD_INT 2
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: LIST
38796: ST_TO_ADDR
// if GetClass ( i ) = 17 then
38797: LD_VAR 0 6
38801: PPUSH
38802: CALL_OW 257
38806: PUSH
38807: LD_INT 17
38809: EQUAL
38810: IFFALSE 38831
// points := [ 100 , 50 , 75 ] ;
38812: LD_ADDR_VAR 0 9
38816: PUSH
38817: LD_INT 100
38819: PUSH
38820: LD_INT 50
38822: PUSH
38823: LD_INT 75
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: LIST
38830: ST_TO_ADDR
// if GetClass ( i ) = 15 then
38831: LD_VAR 0 6
38835: PPUSH
38836: CALL_OW 257
38840: PUSH
38841: LD_INT 15
38843: EQUAL
38844: IFFALSE 38865
// points := [ 10 , 5 , 3 ] ;
38846: LD_ADDR_VAR 0 9
38850: PUSH
38851: LD_INT 10
38853: PUSH
38854: LD_INT 5
38856: PUSH
38857: LD_INT 3
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: LIST
38864: ST_TO_ADDR
// if GetClass ( i ) = 14 then
38865: LD_VAR 0 6
38869: PPUSH
38870: CALL_OW 257
38874: PUSH
38875: LD_INT 14
38877: EQUAL
38878: IFFALSE 38899
// points := [ 10 , 0 , 0 ] ;
38880: LD_ADDR_VAR 0 9
38884: PUSH
38885: LD_INT 10
38887: PUSH
38888: LD_INT 0
38890: PUSH
38891: LD_INT 0
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: LIST
38898: ST_TO_ADDR
// if GetClass ( i ) = 11 then
38899: LD_VAR 0 6
38903: PPUSH
38904: CALL_OW 257
38908: PUSH
38909: LD_INT 11
38911: EQUAL
38912: IFFALSE 38933
// points := [ 30 , 10 , 5 ] ;
38914: LD_ADDR_VAR 0 9
38918: PUSH
38919: LD_INT 30
38921: PUSH
38922: LD_INT 10
38924: PUSH
38925: LD_INT 5
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: LIST
38932: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
38933: LD_VAR 0 1
38937: PPUSH
38938: LD_INT 5
38940: PPUSH
38941: CALL_OW 321
38945: PUSH
38946: LD_INT 2
38948: EQUAL
38949: IFFALSE 38966
// bpoints := bpoints * 1.8 ;
38951: LD_ADDR_VAR 0 10
38955: PUSH
38956: LD_VAR 0 10
38960: PUSH
38961: LD_REAL  1.80000000000000E+0000
38964: MUL
38965: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
38966: LD_VAR 0 6
38970: PPUSH
38971: CALL_OW 257
38975: PUSH
38976: LD_INT 1
38978: PUSH
38979: LD_INT 2
38981: PUSH
38982: LD_INT 3
38984: PUSH
38985: LD_INT 4
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: LIST
38992: LIST
38993: IN
38994: PUSH
38995: LD_VAR 0 1
38999: PPUSH
39000: LD_INT 51
39002: PPUSH
39003: CALL_OW 321
39007: PUSH
39008: LD_INT 2
39010: EQUAL
39011: AND
39012: IFFALSE 39029
// bpoints := bpoints * 1.2 ;
39014: LD_ADDR_VAR 0 10
39018: PUSH
39019: LD_VAR 0 10
39023: PUSH
39024: LD_REAL  1.20000000000000E+0000
39027: MUL
39028: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
39029: LD_VAR 0 6
39033: PPUSH
39034: CALL_OW 257
39038: PUSH
39039: LD_INT 5
39041: PUSH
39042: LD_INT 7
39044: PUSH
39045: LD_INT 9
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: LIST
39052: IN
39053: PUSH
39054: LD_VAR 0 1
39058: PPUSH
39059: LD_INT 52
39061: PPUSH
39062: CALL_OW 321
39066: PUSH
39067: LD_INT 2
39069: EQUAL
39070: AND
39071: IFFALSE 39088
// bpoints := bpoints * 1.5 ;
39073: LD_ADDR_VAR 0 10
39077: PUSH
39078: LD_VAR 0 10
39082: PUSH
39083: LD_REAL  1.50000000000000E+0000
39086: MUL
39087: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
39088: LD_VAR 0 1
39092: PPUSH
39093: LD_INT 66
39095: PPUSH
39096: CALL_OW 321
39100: PUSH
39101: LD_INT 2
39103: EQUAL
39104: IFFALSE 39121
// bpoints := bpoints * 1.1 ;
39106: LD_ADDR_VAR 0 10
39110: PUSH
39111: LD_VAR 0 10
39115: PUSH
39116: LD_REAL  1.10000000000000E+0000
39119: MUL
39120: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
39121: LD_ADDR_VAR 0 10
39125: PUSH
39126: LD_VAR 0 10
39130: PUSH
39131: LD_VAR 0 6
39135: PPUSH
39136: LD_INT 1
39138: PPUSH
39139: CALL_OW 259
39143: PUSH
39144: LD_REAL  1.15000000000000E+0000
39147: MUL
39148: MUL
39149: ST_TO_ADDR
// end ; unit_vehicle :
39150: GO 39974
39152: LD_INT 2
39154: DOUBLE
39155: EQUAL
39156: IFTRUE 39160
39158: GO 39962
39160: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
39161: LD_VAR 0 6
39165: PPUSH
39166: CALL_OW 264
39170: PUSH
39171: LD_INT 2
39173: PUSH
39174: LD_INT 42
39176: PUSH
39177: LD_INT 24
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: LIST
39184: IN
39185: IFFALSE 39206
// points := [ 25 , 5 , 3 ] ;
39187: LD_ADDR_VAR 0 9
39191: PUSH
39192: LD_INT 25
39194: PUSH
39195: LD_INT 5
39197: PUSH
39198: LD_INT 3
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: LIST
39205: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
39206: LD_VAR 0 6
39210: PPUSH
39211: CALL_OW 264
39215: PUSH
39216: LD_INT 4
39218: PUSH
39219: LD_INT 43
39221: PUSH
39222: LD_INT 25
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: LIST
39229: IN
39230: IFFALSE 39251
// points := [ 40 , 15 , 5 ] ;
39232: LD_ADDR_VAR 0 9
39236: PUSH
39237: LD_INT 40
39239: PUSH
39240: LD_INT 15
39242: PUSH
39243: LD_INT 5
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: LIST
39250: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
39251: LD_VAR 0 6
39255: PPUSH
39256: CALL_OW 264
39260: PUSH
39261: LD_INT 3
39263: PUSH
39264: LD_INT 23
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: IN
39271: IFFALSE 39292
// points := [ 7 , 25 , 8 ] ;
39273: LD_ADDR_VAR 0 9
39277: PUSH
39278: LD_INT 7
39280: PUSH
39281: LD_INT 25
39283: PUSH
39284: LD_INT 8
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: LIST
39291: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
39292: LD_VAR 0 6
39296: PPUSH
39297: CALL_OW 264
39301: PUSH
39302: LD_INT 5
39304: PUSH
39305: LD_INT 27
39307: PUSH
39308: LD_INT 44
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: LIST
39315: IN
39316: IFFALSE 39337
// points := [ 14 , 50 , 16 ] ;
39318: LD_ADDR_VAR 0 9
39322: PUSH
39323: LD_INT 14
39325: PUSH
39326: LD_INT 50
39328: PUSH
39329: LD_INT 16
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: LIST
39336: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
39337: LD_VAR 0 6
39341: PPUSH
39342: CALL_OW 264
39346: PUSH
39347: LD_INT 6
39349: PUSH
39350: LD_INT 46
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: IN
39357: IFFALSE 39378
// points := [ 32 , 120 , 70 ] ;
39359: LD_ADDR_VAR 0 9
39363: PUSH
39364: LD_INT 32
39366: PUSH
39367: LD_INT 120
39369: PUSH
39370: LD_INT 70
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: LIST
39377: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
39378: LD_VAR 0 6
39382: PPUSH
39383: CALL_OW 264
39387: PUSH
39388: LD_INT 7
39390: PUSH
39391: LD_INT 28
39393: PUSH
39394: LD_INT 45
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: LIST
39401: IN
39402: IFFALSE 39423
// points := [ 35 , 20 , 45 ] ;
39404: LD_ADDR_VAR 0 9
39408: PUSH
39409: LD_INT 35
39411: PUSH
39412: LD_INT 20
39414: PUSH
39415: LD_INT 45
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: LIST
39422: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
39423: LD_VAR 0 6
39427: PPUSH
39428: CALL_OW 264
39432: PUSH
39433: LD_INT 47
39435: PUSH
39436: EMPTY
39437: LIST
39438: IN
39439: IFFALSE 39460
// points := [ 67 , 45 , 75 ] ;
39441: LD_ADDR_VAR 0 9
39445: PUSH
39446: LD_INT 67
39448: PUSH
39449: LD_INT 45
39451: PUSH
39452: LD_INT 75
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: LIST
39459: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
39460: LD_VAR 0 6
39464: PPUSH
39465: CALL_OW 264
39469: PUSH
39470: LD_INT 26
39472: PUSH
39473: EMPTY
39474: LIST
39475: IN
39476: IFFALSE 39497
// points := [ 120 , 30 , 80 ] ;
39478: LD_ADDR_VAR 0 9
39482: PUSH
39483: LD_INT 120
39485: PUSH
39486: LD_INT 30
39488: PUSH
39489: LD_INT 80
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: LIST
39496: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
39497: LD_VAR 0 6
39501: PPUSH
39502: CALL_OW 264
39506: PUSH
39507: LD_INT 22
39509: PUSH
39510: EMPTY
39511: LIST
39512: IN
39513: IFFALSE 39534
// points := [ 40 , 1 , 1 ] ;
39515: LD_ADDR_VAR 0 9
39519: PUSH
39520: LD_INT 40
39522: PUSH
39523: LD_INT 1
39525: PUSH
39526: LD_INT 1
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: LIST
39533: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
39534: LD_VAR 0 6
39538: PPUSH
39539: CALL_OW 264
39543: PUSH
39544: LD_INT 29
39546: PUSH
39547: EMPTY
39548: LIST
39549: IN
39550: IFFALSE 39571
// points := [ 70 , 200 , 400 ] ;
39552: LD_ADDR_VAR 0 9
39556: PUSH
39557: LD_INT 70
39559: PUSH
39560: LD_INT 200
39562: PUSH
39563: LD_INT 400
39565: PUSH
39566: EMPTY
39567: LIST
39568: LIST
39569: LIST
39570: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
39571: LD_VAR 0 6
39575: PPUSH
39576: CALL_OW 264
39580: PUSH
39581: LD_INT 14
39583: PUSH
39584: LD_INT 53
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: IN
39591: IFFALSE 39612
// points := [ 40 , 10 , 20 ] ;
39593: LD_ADDR_VAR 0 9
39597: PUSH
39598: LD_INT 40
39600: PUSH
39601: LD_INT 10
39603: PUSH
39604: LD_INT 20
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: LIST
39611: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
39612: LD_VAR 0 6
39616: PPUSH
39617: CALL_OW 264
39621: PUSH
39622: LD_INT 9
39624: PUSH
39625: EMPTY
39626: LIST
39627: IN
39628: IFFALSE 39649
// points := [ 5 , 70 , 20 ] ;
39630: LD_ADDR_VAR 0 9
39634: PUSH
39635: LD_INT 5
39637: PUSH
39638: LD_INT 70
39640: PUSH
39641: LD_INT 20
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: LIST
39648: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
39649: LD_VAR 0 6
39653: PPUSH
39654: CALL_OW 264
39658: PUSH
39659: LD_INT 10
39661: PUSH
39662: EMPTY
39663: LIST
39664: IN
39665: IFFALSE 39686
// points := [ 35 , 110 , 70 ] ;
39667: LD_ADDR_VAR 0 9
39671: PUSH
39672: LD_INT 35
39674: PUSH
39675: LD_INT 110
39677: PUSH
39678: LD_INT 70
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: LIST
39685: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
39686: LD_VAR 0 6
39690: PPUSH
39691: CALL_OW 265
39695: PUSH
39696: LD_INT 25
39698: EQUAL
39699: IFFALSE 39720
// points := [ 80 , 65 , 100 ] ;
39701: LD_ADDR_VAR 0 9
39705: PUSH
39706: LD_INT 80
39708: PUSH
39709: LD_INT 65
39711: PUSH
39712: LD_INT 100
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: LIST
39719: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
39720: LD_VAR 0 6
39724: PPUSH
39725: CALL_OW 263
39729: PUSH
39730: LD_INT 1
39732: EQUAL
39733: IFFALSE 39768
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
39735: LD_ADDR_VAR 0 10
39739: PUSH
39740: LD_VAR 0 10
39744: PUSH
39745: LD_VAR 0 6
39749: PPUSH
39750: CALL_OW 311
39754: PPUSH
39755: LD_INT 3
39757: PPUSH
39758: CALL_OW 259
39762: PUSH
39763: LD_INT 4
39765: MUL
39766: MUL
39767: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
39768: LD_VAR 0 6
39772: PPUSH
39773: CALL_OW 263
39777: PUSH
39778: LD_INT 2
39780: EQUAL
39781: IFFALSE 39832
// begin j := IsControledBy ( i ) ;
39783: LD_ADDR_VAR 0 7
39787: PUSH
39788: LD_VAR 0 6
39792: PPUSH
39793: CALL_OW 312
39797: ST_TO_ADDR
// if j then
39798: LD_VAR 0 7
39802: IFFALSE 39832
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
39804: LD_ADDR_VAR 0 10
39808: PUSH
39809: LD_VAR 0 10
39813: PUSH
39814: LD_VAR 0 7
39818: PPUSH
39819: LD_INT 3
39821: PPUSH
39822: CALL_OW 259
39826: PUSH
39827: LD_INT 3
39829: MUL
39830: MUL
39831: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
39832: LD_VAR 0 6
39836: PPUSH
39837: CALL_OW 264
39841: PUSH
39842: LD_INT 5
39844: PUSH
39845: LD_INT 6
39847: PUSH
39848: LD_INT 46
39850: PUSH
39851: LD_INT 44
39853: PUSH
39854: LD_INT 47
39856: PUSH
39857: LD_INT 45
39859: PUSH
39860: LD_INT 28
39862: PUSH
39863: LD_INT 7
39865: PUSH
39866: LD_INT 27
39868: PUSH
39869: LD_INT 29
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: IN
39884: PUSH
39885: LD_VAR 0 1
39889: PPUSH
39890: LD_INT 52
39892: PPUSH
39893: CALL_OW 321
39897: PUSH
39898: LD_INT 2
39900: EQUAL
39901: AND
39902: IFFALSE 39919
// bpoints := bpoints * 1.2 ;
39904: LD_ADDR_VAR 0 10
39908: PUSH
39909: LD_VAR 0 10
39913: PUSH
39914: LD_REAL  1.20000000000000E+0000
39917: MUL
39918: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
39919: LD_VAR 0 6
39923: PPUSH
39924: CALL_OW 264
39928: PUSH
39929: LD_INT 6
39931: PUSH
39932: LD_INT 46
39934: PUSH
39935: LD_INT 47
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: LIST
39942: IN
39943: IFFALSE 39960
// bpoints := bpoints * 1.2 ;
39945: LD_ADDR_VAR 0 10
39949: PUSH
39950: LD_VAR 0 10
39954: PUSH
39955: LD_REAL  1.20000000000000E+0000
39958: MUL
39959: ST_TO_ADDR
// end ; unit_building :
39960: GO 39974
39962: LD_INT 3
39964: DOUBLE
39965: EQUAL
39966: IFTRUE 39970
39968: GO 39973
39970: POP
// ; end ;
39971: GO 39974
39973: POP
// for j = 1 to 3 do
39974: LD_ADDR_VAR 0 7
39978: PUSH
39979: DOUBLE
39980: LD_INT 1
39982: DEC
39983: ST_TO_ADDR
39984: LD_INT 3
39986: PUSH
39987: FOR_TO
39988: IFFALSE 40041
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
39990: LD_ADDR_VAR 0 5
39994: PUSH
39995: LD_VAR 0 5
39999: PPUSH
40000: LD_VAR 0 7
40004: PPUSH
40005: LD_VAR 0 5
40009: PUSH
40010: LD_VAR 0 7
40014: ARRAY
40015: PUSH
40016: LD_VAR 0 9
40020: PUSH
40021: LD_VAR 0 7
40025: ARRAY
40026: PUSH
40027: LD_VAR 0 10
40031: MUL
40032: PLUS
40033: PPUSH
40034: CALL_OW 1
40038: ST_TO_ADDR
40039: GO 39987
40041: POP
40042: POP
// end ;
40043: GO 38526
40045: POP
40046: POP
// result := Replace ( result , 4 , tmp ) ;
40047: LD_ADDR_VAR 0 5
40051: PUSH
40052: LD_VAR 0 5
40056: PPUSH
40057: LD_INT 4
40059: PPUSH
40060: LD_VAR 0 8
40064: PPUSH
40065: CALL_OW 1
40069: ST_TO_ADDR
// end ;
40070: LD_VAR 0 5
40074: RET
// export function DangerAtRange ( unit , range ) ; begin
40075: LD_INT 0
40077: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
40078: LD_ADDR_VAR 0 3
40082: PUSH
40083: LD_VAR 0 1
40087: PPUSH
40088: CALL_OW 255
40092: PPUSH
40093: LD_VAR 0 1
40097: PPUSH
40098: CALL_OW 250
40102: PPUSH
40103: LD_VAR 0 1
40107: PPUSH
40108: CALL_OW 251
40112: PPUSH
40113: LD_VAR 0 2
40117: PPUSH
40118: CALL 38378 0 4
40122: ST_TO_ADDR
// end ;
40123: LD_VAR 0 3
40127: RET
// export function DangerInArea ( side , area ) ; begin
40128: LD_INT 0
40130: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
40131: LD_ADDR_VAR 0 3
40135: PUSH
40136: LD_VAR 0 2
40140: PPUSH
40141: LD_INT 81
40143: PUSH
40144: LD_VAR 0 1
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PPUSH
40153: CALL_OW 70
40157: ST_TO_ADDR
// end ;
40158: LD_VAR 0 3
40162: RET
// export function IsExtension ( b ) ; begin
40163: LD_INT 0
40165: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
40166: LD_ADDR_VAR 0 2
40170: PUSH
40171: LD_VAR 0 1
40175: PUSH
40176: LD_INT 23
40178: PUSH
40179: LD_INT 20
40181: PUSH
40182: LD_INT 22
40184: PUSH
40185: LD_INT 17
40187: PUSH
40188: LD_INT 24
40190: PUSH
40191: LD_INT 21
40193: PUSH
40194: LD_INT 19
40196: PUSH
40197: LD_INT 16
40199: PUSH
40200: LD_INT 25
40202: PUSH
40203: LD_INT 18
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: LIST
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: IN
40218: ST_TO_ADDR
// end ;
40219: LD_VAR 0 2
40223: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
40224: LD_INT 0
40226: PPUSH
40227: PPUSH
40228: PPUSH
// result := [ ] ;
40229: LD_ADDR_VAR 0 3
40233: PUSH
40234: EMPTY
40235: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
40236: LD_ADDR_VAR 0 4
40240: PUSH
40241: LD_VAR 0 2
40245: PPUSH
40246: LD_INT 21
40248: PUSH
40249: LD_INT 3
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PPUSH
40256: CALL_OW 70
40260: ST_TO_ADDR
// if not tmp then
40261: LD_VAR 0 4
40265: NOT
40266: IFFALSE 40270
// exit ;
40268: GO 40328
// for i in tmp do
40270: LD_ADDR_VAR 0 5
40274: PUSH
40275: LD_VAR 0 4
40279: PUSH
40280: FOR_IN
40281: IFFALSE 40316
// if GetBase ( i ) <> base then
40283: LD_VAR 0 5
40287: PPUSH
40288: CALL_OW 274
40292: PUSH
40293: LD_VAR 0 1
40297: NONEQUAL
40298: IFFALSE 40314
// ComLinkToBase ( base , i ) ;
40300: LD_VAR 0 1
40304: PPUSH
40305: LD_VAR 0 5
40309: PPUSH
40310: CALL_OW 169
40314: GO 40280
40316: POP
40317: POP
// result := tmp ;
40318: LD_ADDR_VAR 0 3
40322: PUSH
40323: LD_VAR 0 4
40327: ST_TO_ADDR
// end ;
40328: LD_VAR 0 3
40332: RET
// export function ComComplete ( unit , b ) ; var i ; begin
40333: LD_INT 0
40335: PPUSH
40336: PPUSH
// if BuildingStatus ( b ) = bs_build then
40337: LD_VAR 0 2
40341: PPUSH
40342: CALL_OW 461
40346: PUSH
40347: LD_INT 1
40349: EQUAL
40350: IFFALSE 40410
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
40352: LD_VAR 0 1
40356: PPUSH
40357: LD_STRING h
40359: PUSH
40360: LD_VAR 0 2
40364: PPUSH
40365: CALL_OW 250
40369: PUSH
40370: LD_VAR 0 2
40374: PPUSH
40375: CALL_OW 251
40379: PUSH
40380: LD_VAR 0 2
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: LD_INT 0
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: PUSH
40403: EMPTY
40404: LIST
40405: PPUSH
40406: CALL_OW 446
// end ;
40410: LD_VAR 0 3
40414: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
40415: LD_INT 0
40417: PPUSH
40418: PPUSH
40419: PPUSH
40420: PPUSH
40421: PPUSH
40422: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
40423: LD_VAR 0 1
40427: NOT
40428: PUSH
40429: LD_VAR 0 1
40433: PPUSH
40434: CALL_OW 263
40438: PUSH
40439: LD_INT 2
40441: EQUAL
40442: NOT
40443: OR
40444: IFFALSE 40448
// exit ;
40446: GO 40764
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
40448: LD_ADDR_VAR 0 6
40452: PUSH
40453: LD_INT 22
40455: PUSH
40456: LD_VAR 0 1
40460: PPUSH
40461: CALL_OW 255
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 2
40472: PUSH
40473: LD_INT 30
40475: PUSH
40476: LD_INT 36
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 34
40485: PUSH
40486: LD_INT 31
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: LIST
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PPUSH
40502: CALL_OW 69
40506: ST_TO_ADDR
// if not tmp then
40507: LD_VAR 0 6
40511: NOT
40512: IFFALSE 40516
// exit ;
40514: GO 40764
// result := [ ] ;
40516: LD_ADDR_VAR 0 2
40520: PUSH
40521: EMPTY
40522: ST_TO_ADDR
// for i in tmp do
40523: LD_ADDR_VAR 0 3
40527: PUSH
40528: LD_VAR 0 6
40532: PUSH
40533: FOR_IN
40534: IFFALSE 40605
// begin t := UnitsInside ( i ) ;
40536: LD_ADDR_VAR 0 4
40540: PUSH
40541: LD_VAR 0 3
40545: PPUSH
40546: CALL_OW 313
40550: ST_TO_ADDR
// if t then
40551: LD_VAR 0 4
40555: IFFALSE 40603
// for j in t do
40557: LD_ADDR_VAR 0 7
40561: PUSH
40562: LD_VAR 0 4
40566: PUSH
40567: FOR_IN
40568: IFFALSE 40601
// result := Insert ( result , result + 1 , j ) ;
40570: LD_ADDR_VAR 0 2
40574: PUSH
40575: LD_VAR 0 2
40579: PPUSH
40580: LD_VAR 0 2
40584: PUSH
40585: LD_INT 1
40587: PLUS
40588: PPUSH
40589: LD_VAR 0 7
40593: PPUSH
40594: CALL_OW 2
40598: ST_TO_ADDR
40599: GO 40567
40601: POP
40602: POP
// end ;
40603: GO 40533
40605: POP
40606: POP
// if not result then
40607: LD_VAR 0 2
40611: NOT
40612: IFFALSE 40616
// exit ;
40614: GO 40764
// mech := result [ 1 ] ;
40616: LD_ADDR_VAR 0 5
40620: PUSH
40621: LD_VAR 0 2
40625: PUSH
40626: LD_INT 1
40628: ARRAY
40629: ST_TO_ADDR
// if result > 1 then
40630: LD_VAR 0 2
40634: PUSH
40635: LD_INT 1
40637: GREATER
40638: IFFALSE 40750
// for i = 2 to result do
40640: LD_ADDR_VAR 0 3
40644: PUSH
40645: DOUBLE
40646: LD_INT 2
40648: DEC
40649: ST_TO_ADDR
40650: LD_VAR 0 2
40654: PUSH
40655: FOR_TO
40656: IFFALSE 40748
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
40658: LD_ADDR_VAR 0 4
40662: PUSH
40663: LD_VAR 0 2
40667: PUSH
40668: LD_VAR 0 3
40672: ARRAY
40673: PPUSH
40674: LD_INT 3
40676: PPUSH
40677: CALL_OW 259
40681: PUSH
40682: LD_VAR 0 2
40686: PUSH
40687: LD_VAR 0 3
40691: ARRAY
40692: PPUSH
40693: CALL_OW 432
40697: MINUS
40698: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
40699: LD_VAR 0 4
40703: PUSH
40704: LD_VAR 0 5
40708: PPUSH
40709: LD_INT 3
40711: PPUSH
40712: CALL_OW 259
40716: PUSH
40717: LD_VAR 0 5
40721: PPUSH
40722: CALL_OW 432
40726: MINUS
40727: GREATEREQUAL
40728: IFFALSE 40746
// mech := result [ i ] ;
40730: LD_ADDR_VAR 0 5
40734: PUSH
40735: LD_VAR 0 2
40739: PUSH
40740: LD_VAR 0 3
40744: ARRAY
40745: ST_TO_ADDR
// end ;
40746: GO 40655
40748: POP
40749: POP
// ComLinkTo ( vehicle , mech ) ;
40750: LD_VAR 0 1
40754: PPUSH
40755: LD_VAR 0 5
40759: PPUSH
40760: CALL_OW 135
// end ;
40764: LD_VAR 0 2
40768: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
40769: LD_INT 0
40771: PPUSH
40772: PPUSH
40773: PPUSH
40774: PPUSH
40775: PPUSH
40776: PPUSH
40777: PPUSH
40778: PPUSH
40779: PPUSH
40780: PPUSH
40781: PPUSH
40782: PPUSH
40783: PPUSH
// result := [ ] ;
40784: LD_ADDR_VAR 0 7
40788: PUSH
40789: EMPTY
40790: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
40791: LD_VAR 0 1
40795: PPUSH
40796: CALL_OW 266
40800: PUSH
40801: LD_INT 0
40803: PUSH
40804: LD_INT 1
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: IN
40811: NOT
40812: IFFALSE 40816
// exit ;
40814: GO 42447
// if name then
40816: LD_VAR 0 3
40820: IFFALSE 40836
// SetBName ( base_dep , name ) ;
40822: LD_VAR 0 1
40826: PPUSH
40827: LD_VAR 0 3
40831: PPUSH
40832: CALL_OW 500
// base := GetBase ( base_dep ) ;
40836: LD_ADDR_VAR 0 15
40840: PUSH
40841: LD_VAR 0 1
40845: PPUSH
40846: CALL_OW 274
40850: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
40851: LD_ADDR_VAR 0 16
40855: PUSH
40856: LD_VAR 0 1
40860: PPUSH
40861: CALL_OW 255
40865: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
40866: LD_ADDR_VAR 0 17
40870: PUSH
40871: LD_VAR 0 1
40875: PPUSH
40876: CALL_OW 248
40880: ST_TO_ADDR
// if sources then
40881: LD_VAR 0 5
40885: IFFALSE 40932
// for i = 1 to 3 do
40887: LD_ADDR_VAR 0 8
40891: PUSH
40892: DOUBLE
40893: LD_INT 1
40895: DEC
40896: ST_TO_ADDR
40897: LD_INT 3
40899: PUSH
40900: FOR_TO
40901: IFFALSE 40930
// AddResourceType ( base , i , sources [ i ] ) ;
40903: LD_VAR 0 15
40907: PPUSH
40908: LD_VAR 0 8
40912: PPUSH
40913: LD_VAR 0 5
40917: PUSH
40918: LD_VAR 0 8
40922: ARRAY
40923: PPUSH
40924: CALL_OW 276
40928: GO 40900
40930: POP
40931: POP
// buildings := GetBaseBuildings ( base , area ) ;
40932: LD_ADDR_VAR 0 18
40936: PUSH
40937: LD_VAR 0 15
40941: PPUSH
40942: LD_VAR 0 2
40946: PPUSH
40947: CALL 40224 0 2
40951: ST_TO_ADDR
// InitHc ;
40952: CALL_OW 19
// InitUc ;
40956: CALL_OW 18
// uc_side := side ;
40960: LD_ADDR_OWVAR 20
40964: PUSH
40965: LD_VAR 0 16
40969: ST_TO_ADDR
// uc_nation := nation ;
40970: LD_ADDR_OWVAR 21
40974: PUSH
40975: LD_VAR 0 17
40979: ST_TO_ADDR
// if buildings then
40980: LD_VAR 0 18
40984: IFFALSE 42306
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
40986: LD_ADDR_VAR 0 19
40990: PUSH
40991: LD_VAR 0 18
40995: PPUSH
40996: LD_INT 2
40998: PUSH
40999: LD_INT 30
41001: PUSH
41002: LD_INT 29
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 30
41011: PUSH
41012: LD_INT 30
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: LIST
41023: PPUSH
41024: CALL_OW 72
41028: ST_TO_ADDR
// if tmp then
41029: LD_VAR 0 19
41033: IFFALSE 41081
// for i in tmp do
41035: LD_ADDR_VAR 0 8
41039: PUSH
41040: LD_VAR 0 19
41044: PUSH
41045: FOR_IN
41046: IFFALSE 41079
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
41048: LD_VAR 0 8
41052: PPUSH
41053: CALL_OW 250
41057: PPUSH
41058: LD_VAR 0 8
41062: PPUSH
41063: CALL_OW 251
41067: PPUSH
41068: LD_VAR 0 16
41072: PPUSH
41073: CALL_OW 441
41077: GO 41045
41079: POP
41080: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
41081: LD_VAR 0 18
41085: PPUSH
41086: LD_INT 2
41088: PUSH
41089: LD_INT 30
41091: PUSH
41092: LD_INT 32
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 30
41101: PUSH
41102: LD_INT 33
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: LIST
41113: PPUSH
41114: CALL_OW 72
41118: IFFALSE 41206
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
41120: LD_ADDR_VAR 0 8
41124: PUSH
41125: LD_VAR 0 18
41129: PPUSH
41130: LD_INT 2
41132: PUSH
41133: LD_INT 30
41135: PUSH
41136: LD_INT 32
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 30
41145: PUSH
41146: LD_INT 33
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: LIST
41157: PPUSH
41158: CALL_OW 72
41162: PUSH
41163: FOR_IN
41164: IFFALSE 41204
// begin if not GetBWeapon ( i ) then
41166: LD_VAR 0 8
41170: PPUSH
41171: CALL_OW 269
41175: NOT
41176: IFFALSE 41202
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
41178: LD_VAR 0 8
41182: PPUSH
41183: LD_VAR 0 8
41187: PPUSH
41188: LD_VAR 0 2
41192: PPUSH
41193: CALL 42452 0 2
41197: PPUSH
41198: CALL_OW 431
// end ;
41202: GO 41163
41204: POP
41205: POP
// end ; for i = 1 to personel do
41206: LD_ADDR_VAR 0 8
41210: PUSH
41211: DOUBLE
41212: LD_INT 1
41214: DEC
41215: ST_TO_ADDR
41216: LD_VAR 0 6
41220: PUSH
41221: FOR_TO
41222: IFFALSE 42286
// begin if i > 4 then
41224: LD_VAR 0 8
41228: PUSH
41229: LD_INT 4
41231: GREATER
41232: IFFALSE 41236
// break ;
41234: GO 42286
// case i of 1 :
41236: LD_VAR 0 8
41240: PUSH
41241: LD_INT 1
41243: DOUBLE
41244: EQUAL
41245: IFTRUE 41249
41247: GO 41329
41249: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
41250: LD_ADDR_VAR 0 12
41254: PUSH
41255: LD_VAR 0 18
41259: PPUSH
41260: LD_INT 22
41262: PUSH
41263: LD_VAR 0 16
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 58
41274: PUSH
41275: EMPTY
41276: LIST
41277: PUSH
41278: LD_INT 2
41280: PUSH
41281: LD_INT 30
41283: PUSH
41284: LD_INT 32
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 30
41293: PUSH
41294: LD_INT 4
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 30
41303: PUSH
41304: LD_INT 5
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: LIST
41315: LIST
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: LIST
41321: PPUSH
41322: CALL_OW 72
41326: ST_TO_ADDR
41327: GO 41551
41329: LD_INT 2
41331: DOUBLE
41332: EQUAL
41333: IFTRUE 41337
41335: GO 41399
41337: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
41338: LD_ADDR_VAR 0 12
41342: PUSH
41343: LD_VAR 0 18
41347: PPUSH
41348: LD_INT 22
41350: PUSH
41351: LD_VAR 0 16
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: LD_INT 2
41362: PUSH
41363: LD_INT 30
41365: PUSH
41366: LD_INT 0
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 30
41375: PUSH
41376: LD_INT 1
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: LIST
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PPUSH
41392: CALL_OW 72
41396: ST_TO_ADDR
41397: GO 41551
41399: LD_INT 3
41401: DOUBLE
41402: EQUAL
41403: IFTRUE 41407
41405: GO 41469
41407: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
41408: LD_ADDR_VAR 0 12
41412: PUSH
41413: LD_VAR 0 18
41417: PPUSH
41418: LD_INT 22
41420: PUSH
41421: LD_VAR 0 16
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 2
41432: PUSH
41433: LD_INT 30
41435: PUSH
41436: LD_INT 2
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 30
41445: PUSH
41446: LD_INT 3
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: LIST
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PPUSH
41462: CALL_OW 72
41466: ST_TO_ADDR
41467: GO 41551
41469: LD_INT 4
41471: DOUBLE
41472: EQUAL
41473: IFTRUE 41477
41475: GO 41550
41477: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
41478: LD_ADDR_VAR 0 12
41482: PUSH
41483: LD_VAR 0 18
41487: PPUSH
41488: LD_INT 22
41490: PUSH
41491: LD_VAR 0 16
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 2
41502: PUSH
41503: LD_INT 30
41505: PUSH
41506: LD_INT 6
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: LD_INT 30
41515: PUSH
41516: LD_INT 7
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 30
41525: PUSH
41526: LD_INT 8
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: PPUSH
41543: CALL_OW 72
41547: ST_TO_ADDR
41548: GO 41551
41550: POP
// if i = 1 then
41551: LD_VAR 0 8
41555: PUSH
41556: LD_INT 1
41558: EQUAL
41559: IFFALSE 41670
// begin tmp := [ ] ;
41561: LD_ADDR_VAR 0 19
41565: PUSH
41566: EMPTY
41567: ST_TO_ADDR
// for j in f do
41568: LD_ADDR_VAR 0 9
41572: PUSH
41573: LD_VAR 0 12
41577: PUSH
41578: FOR_IN
41579: IFFALSE 41652
// if GetBType ( j ) = b_bunker then
41581: LD_VAR 0 9
41585: PPUSH
41586: CALL_OW 266
41590: PUSH
41591: LD_INT 32
41593: EQUAL
41594: IFFALSE 41621
// tmp := Insert ( tmp , 1 , j ) else
41596: LD_ADDR_VAR 0 19
41600: PUSH
41601: LD_VAR 0 19
41605: PPUSH
41606: LD_INT 1
41608: PPUSH
41609: LD_VAR 0 9
41613: PPUSH
41614: CALL_OW 2
41618: ST_TO_ADDR
41619: GO 41650
// tmp := Insert ( tmp , tmp + 1 , j ) ;
41621: LD_ADDR_VAR 0 19
41625: PUSH
41626: LD_VAR 0 19
41630: PPUSH
41631: LD_VAR 0 19
41635: PUSH
41636: LD_INT 1
41638: PLUS
41639: PPUSH
41640: LD_VAR 0 9
41644: PPUSH
41645: CALL_OW 2
41649: ST_TO_ADDR
41650: GO 41578
41652: POP
41653: POP
// if tmp then
41654: LD_VAR 0 19
41658: IFFALSE 41670
// f := tmp ;
41660: LD_ADDR_VAR 0 12
41664: PUSH
41665: LD_VAR 0 19
41669: ST_TO_ADDR
// end ; x := personel [ i ] ;
41670: LD_ADDR_VAR 0 13
41674: PUSH
41675: LD_VAR 0 6
41679: PUSH
41680: LD_VAR 0 8
41684: ARRAY
41685: ST_TO_ADDR
// if x = - 1 then
41686: LD_VAR 0 13
41690: PUSH
41691: LD_INT 1
41693: NEG
41694: EQUAL
41695: IFFALSE 41904
// begin for j in f do
41697: LD_ADDR_VAR 0 9
41701: PUSH
41702: LD_VAR 0 12
41706: PUSH
41707: FOR_IN
41708: IFFALSE 41900
// repeat InitHc ;
41710: CALL_OW 19
// if GetBType ( j ) = b_barracks then
41714: LD_VAR 0 9
41718: PPUSH
41719: CALL_OW 266
41723: PUSH
41724: LD_INT 5
41726: EQUAL
41727: IFFALSE 41797
// begin if UnitsInside ( j ) < 3 then
41729: LD_VAR 0 9
41733: PPUSH
41734: CALL_OW 313
41738: PUSH
41739: LD_INT 3
41741: LESS
41742: IFFALSE 41778
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
41744: LD_INT 0
41746: PPUSH
41747: LD_INT 5
41749: PUSH
41750: LD_INT 8
41752: PUSH
41753: LD_INT 9
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: LIST
41760: PUSH
41761: LD_VAR 0 17
41765: ARRAY
41766: PPUSH
41767: LD_VAR 0 4
41771: PPUSH
41772: CALL_OW 380
41776: GO 41795
// PrepareHuman ( false , i , skill ) ;
41778: LD_INT 0
41780: PPUSH
41781: LD_VAR 0 8
41785: PPUSH
41786: LD_VAR 0 4
41790: PPUSH
41791: CALL_OW 380
// end else
41795: GO 41814
// PrepareHuman ( false , i , skill ) ;
41797: LD_INT 0
41799: PPUSH
41800: LD_VAR 0 8
41804: PPUSH
41805: LD_VAR 0 4
41809: PPUSH
41810: CALL_OW 380
// un := CreateHuman ;
41814: LD_ADDR_VAR 0 14
41818: PUSH
41819: CALL_OW 44
41823: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
41824: LD_ADDR_VAR 0 7
41828: PUSH
41829: LD_VAR 0 7
41833: PPUSH
41834: LD_INT 1
41836: PPUSH
41837: LD_VAR 0 14
41841: PPUSH
41842: CALL_OW 2
41846: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
41847: LD_VAR 0 14
41851: PPUSH
41852: LD_VAR 0 9
41856: PPUSH
41857: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
41861: LD_VAR 0 9
41865: PPUSH
41866: CALL_OW 313
41870: PUSH
41871: LD_INT 6
41873: EQUAL
41874: PUSH
41875: LD_VAR 0 9
41879: PPUSH
41880: CALL_OW 266
41884: PUSH
41885: LD_INT 32
41887: PUSH
41888: LD_INT 31
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: IN
41895: OR
41896: IFFALSE 41710
41898: GO 41707
41900: POP
41901: POP
// end else
41902: GO 42284
// for j = 1 to x do
41904: LD_ADDR_VAR 0 9
41908: PUSH
41909: DOUBLE
41910: LD_INT 1
41912: DEC
41913: ST_TO_ADDR
41914: LD_VAR 0 13
41918: PUSH
41919: FOR_TO
41920: IFFALSE 42282
// begin InitHc ;
41922: CALL_OW 19
// if not f then
41926: LD_VAR 0 12
41930: NOT
41931: IFFALSE 42020
// begin PrepareHuman ( false , i , skill ) ;
41933: LD_INT 0
41935: PPUSH
41936: LD_VAR 0 8
41940: PPUSH
41941: LD_VAR 0 4
41945: PPUSH
41946: CALL_OW 380
// un := CreateHuman ;
41950: LD_ADDR_VAR 0 14
41954: PUSH
41955: CALL_OW 44
41959: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
41960: LD_ADDR_VAR 0 7
41964: PUSH
41965: LD_VAR 0 7
41969: PPUSH
41970: LD_INT 1
41972: PPUSH
41973: LD_VAR 0 14
41977: PPUSH
41978: CALL_OW 2
41982: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
41983: LD_VAR 0 14
41987: PPUSH
41988: LD_VAR 0 1
41992: PPUSH
41993: CALL_OW 250
41997: PPUSH
41998: LD_VAR 0 1
42002: PPUSH
42003: CALL_OW 251
42007: PPUSH
42008: LD_INT 10
42010: PPUSH
42011: LD_INT 0
42013: PPUSH
42014: CALL_OW 50
// continue ;
42018: GO 41919
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
42020: LD_VAR 0 12
42024: PUSH
42025: LD_INT 1
42027: ARRAY
42028: PPUSH
42029: CALL_OW 313
42033: PUSH
42034: LD_VAR 0 12
42038: PUSH
42039: LD_INT 1
42041: ARRAY
42042: PPUSH
42043: CALL_OW 266
42047: PUSH
42048: LD_INT 32
42050: PUSH
42051: LD_INT 31
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: IN
42058: AND
42059: PUSH
42060: LD_VAR 0 12
42064: PUSH
42065: LD_INT 1
42067: ARRAY
42068: PPUSH
42069: CALL_OW 313
42073: PUSH
42074: LD_INT 6
42076: EQUAL
42077: OR
42078: IFFALSE 42098
// f := Delete ( f , 1 ) ;
42080: LD_ADDR_VAR 0 12
42084: PUSH
42085: LD_VAR 0 12
42089: PPUSH
42090: LD_INT 1
42092: PPUSH
42093: CALL_OW 3
42097: ST_TO_ADDR
// if not f then
42098: LD_VAR 0 12
42102: NOT
42103: IFFALSE 42121
// begin x := x + 2 ;
42105: LD_ADDR_VAR 0 13
42109: PUSH
42110: LD_VAR 0 13
42114: PUSH
42115: LD_INT 2
42117: PLUS
42118: ST_TO_ADDR
// continue ;
42119: GO 41919
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
42121: LD_VAR 0 12
42125: PUSH
42126: LD_INT 1
42128: ARRAY
42129: PPUSH
42130: CALL_OW 266
42134: PUSH
42135: LD_INT 5
42137: EQUAL
42138: IFFALSE 42212
// begin if UnitsInside ( f [ 1 ] ) < 3 then
42140: LD_VAR 0 12
42144: PUSH
42145: LD_INT 1
42147: ARRAY
42148: PPUSH
42149: CALL_OW 313
42153: PUSH
42154: LD_INT 3
42156: LESS
42157: IFFALSE 42193
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
42159: LD_INT 0
42161: PPUSH
42162: LD_INT 5
42164: PUSH
42165: LD_INT 8
42167: PUSH
42168: LD_INT 9
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: LIST
42175: PUSH
42176: LD_VAR 0 17
42180: ARRAY
42181: PPUSH
42182: LD_VAR 0 4
42186: PPUSH
42187: CALL_OW 380
42191: GO 42210
// PrepareHuman ( false , i , skill ) ;
42193: LD_INT 0
42195: PPUSH
42196: LD_VAR 0 8
42200: PPUSH
42201: LD_VAR 0 4
42205: PPUSH
42206: CALL_OW 380
// end else
42210: GO 42229
// PrepareHuman ( false , i , skill ) ;
42212: LD_INT 0
42214: PPUSH
42215: LD_VAR 0 8
42219: PPUSH
42220: LD_VAR 0 4
42224: PPUSH
42225: CALL_OW 380
// un := CreateHuman ;
42229: LD_ADDR_VAR 0 14
42233: PUSH
42234: CALL_OW 44
42238: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
42239: LD_ADDR_VAR 0 7
42243: PUSH
42244: LD_VAR 0 7
42248: PPUSH
42249: LD_INT 1
42251: PPUSH
42252: LD_VAR 0 14
42256: PPUSH
42257: CALL_OW 2
42261: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
42262: LD_VAR 0 14
42266: PPUSH
42267: LD_VAR 0 12
42271: PUSH
42272: LD_INT 1
42274: ARRAY
42275: PPUSH
42276: CALL_OW 52
// end ;
42280: GO 41919
42282: POP
42283: POP
// end ;
42284: GO 41221
42286: POP
42287: POP
// result := result ^ buildings ;
42288: LD_ADDR_VAR 0 7
42292: PUSH
42293: LD_VAR 0 7
42297: PUSH
42298: LD_VAR 0 18
42302: ADD
42303: ST_TO_ADDR
// end else
42304: GO 42447
// begin for i = 1 to personel do
42306: LD_ADDR_VAR 0 8
42310: PUSH
42311: DOUBLE
42312: LD_INT 1
42314: DEC
42315: ST_TO_ADDR
42316: LD_VAR 0 6
42320: PUSH
42321: FOR_TO
42322: IFFALSE 42445
// begin if i > 4 then
42324: LD_VAR 0 8
42328: PUSH
42329: LD_INT 4
42331: GREATER
42332: IFFALSE 42336
// break ;
42334: GO 42445
// x := personel [ i ] ;
42336: LD_ADDR_VAR 0 13
42340: PUSH
42341: LD_VAR 0 6
42345: PUSH
42346: LD_VAR 0 8
42350: ARRAY
42351: ST_TO_ADDR
// if x = - 1 then
42352: LD_VAR 0 13
42356: PUSH
42357: LD_INT 1
42359: NEG
42360: EQUAL
42361: IFFALSE 42365
// continue ;
42363: GO 42321
// PrepareHuman ( false , i , skill ) ;
42365: LD_INT 0
42367: PPUSH
42368: LD_VAR 0 8
42372: PPUSH
42373: LD_VAR 0 4
42377: PPUSH
42378: CALL_OW 380
// un := CreateHuman ;
42382: LD_ADDR_VAR 0 14
42386: PUSH
42387: CALL_OW 44
42391: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
42392: LD_VAR 0 14
42396: PPUSH
42397: LD_VAR 0 1
42401: PPUSH
42402: CALL_OW 250
42406: PPUSH
42407: LD_VAR 0 1
42411: PPUSH
42412: CALL_OW 251
42416: PPUSH
42417: LD_INT 10
42419: PPUSH
42420: LD_INT 0
42422: PPUSH
42423: CALL_OW 50
// result := result ^ un ;
42427: LD_ADDR_VAR 0 7
42431: PUSH
42432: LD_VAR 0 7
42436: PUSH
42437: LD_VAR 0 14
42441: ADD
42442: ST_TO_ADDR
// end ;
42443: GO 42321
42445: POP
42446: POP
// end ; end ;
42447: LD_VAR 0 7
42451: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
42452: LD_INT 0
42454: PPUSH
42455: PPUSH
42456: PPUSH
42457: PPUSH
42458: PPUSH
42459: PPUSH
42460: PPUSH
42461: PPUSH
42462: PPUSH
42463: PPUSH
42464: PPUSH
42465: PPUSH
42466: PPUSH
42467: PPUSH
42468: PPUSH
42469: PPUSH
// result := false ;
42470: LD_ADDR_VAR 0 3
42474: PUSH
42475: LD_INT 0
42477: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
42478: LD_VAR 0 1
42482: NOT
42483: PUSH
42484: LD_VAR 0 1
42488: PPUSH
42489: CALL_OW 266
42493: PUSH
42494: LD_INT 32
42496: PUSH
42497: LD_INT 33
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: IN
42504: NOT
42505: OR
42506: IFFALSE 42510
// exit ;
42508: GO 43646
// nat := GetNation ( tower ) ;
42510: LD_ADDR_VAR 0 12
42514: PUSH
42515: LD_VAR 0 1
42519: PPUSH
42520: CALL_OW 248
42524: ST_TO_ADDR
// side := GetSide ( tower ) ;
42525: LD_ADDR_VAR 0 16
42529: PUSH
42530: LD_VAR 0 1
42534: PPUSH
42535: CALL_OW 255
42539: ST_TO_ADDR
// x := GetX ( tower ) ;
42540: LD_ADDR_VAR 0 10
42544: PUSH
42545: LD_VAR 0 1
42549: PPUSH
42550: CALL_OW 250
42554: ST_TO_ADDR
// y := GetY ( tower ) ;
42555: LD_ADDR_VAR 0 11
42559: PUSH
42560: LD_VAR 0 1
42564: PPUSH
42565: CALL_OW 251
42569: ST_TO_ADDR
// if not x or not y then
42570: LD_VAR 0 10
42574: NOT
42575: PUSH
42576: LD_VAR 0 11
42580: NOT
42581: OR
42582: IFFALSE 42586
// exit ;
42584: GO 43646
// weapon := 0 ;
42586: LD_ADDR_VAR 0 18
42590: PUSH
42591: LD_INT 0
42593: ST_TO_ADDR
// fac_list := [ ] ;
42594: LD_ADDR_VAR 0 17
42598: PUSH
42599: EMPTY
42600: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
42601: LD_ADDR_VAR 0 6
42605: PUSH
42606: LD_VAR 0 1
42610: PPUSH
42611: CALL_OW 274
42615: PPUSH
42616: LD_VAR 0 2
42620: PPUSH
42621: CALL 40224 0 2
42625: PPUSH
42626: LD_INT 30
42628: PUSH
42629: LD_INT 3
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PPUSH
42636: CALL_OW 72
42640: ST_TO_ADDR
// if not factories then
42641: LD_VAR 0 6
42645: NOT
42646: IFFALSE 42650
// exit ;
42648: GO 43646
// for i in factories do
42650: LD_ADDR_VAR 0 8
42654: PUSH
42655: LD_VAR 0 6
42659: PUSH
42660: FOR_IN
42661: IFFALSE 42686
// fac_list := fac_list union AvailableWeaponList ( i ) ;
42663: LD_ADDR_VAR 0 17
42667: PUSH
42668: LD_VAR 0 17
42672: PUSH
42673: LD_VAR 0 8
42677: PPUSH
42678: CALL_OW 478
42682: UNION
42683: ST_TO_ADDR
42684: GO 42660
42686: POP
42687: POP
// if not fac_list then
42688: LD_VAR 0 17
42692: NOT
42693: IFFALSE 42697
// exit ;
42695: GO 43646
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
42697: LD_ADDR_VAR 0 5
42701: PUSH
42702: LD_INT 4
42704: PUSH
42705: LD_INT 5
42707: PUSH
42708: LD_INT 9
42710: PUSH
42711: LD_INT 10
42713: PUSH
42714: LD_INT 6
42716: PUSH
42717: LD_INT 7
42719: PUSH
42720: LD_INT 11
42722: PUSH
42723: EMPTY
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: LIST
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 27
42734: PUSH
42735: LD_INT 28
42737: PUSH
42738: LD_INT 26
42740: PUSH
42741: LD_INT 30
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: LIST
42748: LIST
42749: PUSH
42750: LD_INT 43
42752: PUSH
42753: LD_INT 44
42755: PUSH
42756: LD_INT 46
42758: PUSH
42759: LD_INT 45
42761: PUSH
42762: LD_INT 47
42764: PUSH
42765: LD_INT 49
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: LIST
42780: PUSH
42781: LD_VAR 0 12
42785: ARRAY
42786: ST_TO_ADDR
// for i in list do
42787: LD_ADDR_VAR 0 8
42791: PUSH
42792: LD_VAR 0 5
42796: PUSH
42797: FOR_IN
42798: IFFALSE 42831
// if not i in fac_list then
42800: LD_VAR 0 8
42804: PUSH
42805: LD_VAR 0 17
42809: IN
42810: NOT
42811: IFFALSE 42829
// list := list diff i ;
42813: LD_ADDR_VAR 0 5
42817: PUSH
42818: LD_VAR 0 5
42822: PUSH
42823: LD_VAR 0 8
42827: DIFF
42828: ST_TO_ADDR
42829: GO 42797
42831: POP
42832: POP
// if not list then
42833: LD_VAR 0 5
42837: NOT
42838: IFFALSE 42842
// exit ;
42840: GO 43646
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
42842: LD_VAR 0 12
42846: PUSH
42847: LD_INT 3
42849: EQUAL
42850: PUSH
42851: LD_INT 49
42853: PUSH
42854: LD_VAR 0 5
42858: IN
42859: AND
42860: PUSH
42861: LD_INT 31
42863: PPUSH
42864: LD_VAR 0 16
42868: PPUSH
42869: CALL_OW 321
42873: PUSH
42874: LD_INT 2
42876: EQUAL
42877: AND
42878: IFFALSE 42938
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
42880: LD_INT 22
42882: PUSH
42883: LD_VAR 0 16
42887: PUSH
42888: EMPTY
42889: LIST
42890: LIST
42891: PUSH
42892: LD_INT 35
42894: PUSH
42895: LD_INT 49
42897: PUSH
42898: EMPTY
42899: LIST
42900: LIST
42901: PUSH
42902: LD_INT 91
42904: PUSH
42905: LD_VAR 0 1
42909: PUSH
42910: LD_INT 10
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: LIST
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: LIST
42922: PPUSH
42923: CALL_OW 69
42927: NOT
42928: IFFALSE 42938
// weapon := ru_time_lapser ;
42930: LD_ADDR_VAR 0 18
42934: PUSH
42935: LD_INT 49
42937: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
42938: LD_VAR 0 12
42942: PUSH
42943: LD_INT 1
42945: PUSH
42946: LD_INT 2
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: IN
42953: PUSH
42954: LD_INT 11
42956: PUSH
42957: LD_VAR 0 5
42961: IN
42962: PUSH
42963: LD_INT 30
42965: PUSH
42966: LD_VAR 0 5
42970: IN
42971: OR
42972: AND
42973: PUSH
42974: LD_INT 6
42976: PPUSH
42977: LD_VAR 0 16
42981: PPUSH
42982: CALL_OW 321
42986: PUSH
42987: LD_INT 2
42989: EQUAL
42990: AND
42991: IFFALSE 43156
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
42993: LD_INT 22
42995: PUSH
42996: LD_VAR 0 16
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 2
43007: PUSH
43008: LD_INT 35
43010: PUSH
43011: LD_INT 11
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: LD_INT 35
43020: PUSH
43021: LD_INT 30
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 91
43035: PUSH
43036: LD_VAR 0 1
43040: PUSH
43041: LD_INT 18
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: LIST
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: LIST
43053: PPUSH
43054: CALL_OW 69
43058: NOT
43059: PUSH
43060: LD_INT 22
43062: PUSH
43063: LD_VAR 0 16
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: PUSH
43072: LD_INT 2
43074: PUSH
43075: LD_INT 30
43077: PUSH
43078: LD_INT 32
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 30
43087: PUSH
43088: LD_INT 33
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: LIST
43099: PUSH
43100: LD_INT 91
43102: PUSH
43103: LD_VAR 0 1
43107: PUSH
43108: LD_INT 12
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: LIST
43115: PUSH
43116: EMPTY
43117: LIST
43118: LIST
43119: LIST
43120: PUSH
43121: EMPTY
43122: LIST
43123: PPUSH
43124: CALL_OW 69
43128: PUSH
43129: LD_INT 2
43131: GREATER
43132: AND
43133: IFFALSE 43156
// weapon := [ us_radar , ar_radar ] [ nat ] ;
43135: LD_ADDR_VAR 0 18
43139: PUSH
43140: LD_INT 11
43142: PUSH
43143: LD_INT 30
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: LD_VAR 0 12
43154: ARRAY
43155: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
43156: LD_VAR 0 18
43160: NOT
43161: PUSH
43162: LD_INT 40
43164: PPUSH
43165: LD_VAR 0 16
43169: PPUSH
43170: CALL_OW 321
43174: PUSH
43175: LD_INT 2
43177: EQUAL
43178: AND
43179: PUSH
43180: LD_INT 7
43182: PUSH
43183: LD_VAR 0 5
43187: IN
43188: PUSH
43189: LD_INT 28
43191: PUSH
43192: LD_VAR 0 5
43196: IN
43197: OR
43198: PUSH
43199: LD_INT 45
43201: PUSH
43202: LD_VAR 0 5
43206: IN
43207: OR
43208: AND
43209: IFFALSE 43463
// begin hex := GetHexInfo ( x , y ) ;
43211: LD_ADDR_VAR 0 4
43215: PUSH
43216: LD_VAR 0 10
43220: PPUSH
43221: LD_VAR 0 11
43225: PPUSH
43226: CALL_OW 546
43230: ST_TO_ADDR
// if hex [ 1 ] then
43231: LD_VAR 0 4
43235: PUSH
43236: LD_INT 1
43238: ARRAY
43239: IFFALSE 43243
// exit ;
43241: GO 43646
// height := hex [ 2 ] ;
43243: LD_ADDR_VAR 0 15
43247: PUSH
43248: LD_VAR 0 4
43252: PUSH
43253: LD_INT 2
43255: ARRAY
43256: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
43257: LD_ADDR_VAR 0 14
43261: PUSH
43262: LD_INT 0
43264: PUSH
43265: LD_INT 2
43267: PUSH
43268: LD_INT 3
43270: PUSH
43271: LD_INT 5
43273: PUSH
43274: EMPTY
43275: LIST
43276: LIST
43277: LIST
43278: LIST
43279: ST_TO_ADDR
// for i in tmp do
43280: LD_ADDR_VAR 0 8
43284: PUSH
43285: LD_VAR 0 14
43289: PUSH
43290: FOR_IN
43291: IFFALSE 43461
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
43293: LD_ADDR_VAR 0 9
43297: PUSH
43298: LD_VAR 0 10
43302: PPUSH
43303: LD_VAR 0 8
43307: PPUSH
43308: LD_INT 5
43310: PPUSH
43311: CALL_OW 272
43315: PUSH
43316: LD_VAR 0 11
43320: PPUSH
43321: LD_VAR 0 8
43325: PPUSH
43326: LD_INT 5
43328: PPUSH
43329: CALL_OW 273
43333: PUSH
43334: EMPTY
43335: LIST
43336: LIST
43337: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
43338: LD_VAR 0 9
43342: PUSH
43343: LD_INT 1
43345: ARRAY
43346: PPUSH
43347: LD_VAR 0 9
43351: PUSH
43352: LD_INT 2
43354: ARRAY
43355: PPUSH
43356: CALL_OW 488
43360: IFFALSE 43459
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
43362: LD_ADDR_VAR 0 4
43366: PUSH
43367: LD_VAR 0 9
43371: PUSH
43372: LD_INT 1
43374: ARRAY
43375: PPUSH
43376: LD_VAR 0 9
43380: PUSH
43381: LD_INT 2
43383: ARRAY
43384: PPUSH
43385: CALL_OW 546
43389: ST_TO_ADDR
// if hex [ 1 ] then
43390: LD_VAR 0 4
43394: PUSH
43395: LD_INT 1
43397: ARRAY
43398: IFFALSE 43402
// continue ;
43400: GO 43290
// h := hex [ 2 ] ;
43402: LD_ADDR_VAR 0 13
43406: PUSH
43407: LD_VAR 0 4
43411: PUSH
43412: LD_INT 2
43414: ARRAY
43415: ST_TO_ADDR
// if h + 7 < height then
43416: LD_VAR 0 13
43420: PUSH
43421: LD_INT 7
43423: PLUS
43424: PUSH
43425: LD_VAR 0 15
43429: LESS
43430: IFFALSE 43459
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
43432: LD_ADDR_VAR 0 18
43436: PUSH
43437: LD_INT 7
43439: PUSH
43440: LD_INT 28
43442: PUSH
43443: LD_INT 45
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: LIST
43450: PUSH
43451: LD_VAR 0 12
43455: ARRAY
43456: ST_TO_ADDR
// break ;
43457: GO 43461
// end ; end ; end ;
43459: GO 43290
43461: POP
43462: POP
// end ; if not weapon then
43463: LD_VAR 0 18
43467: NOT
43468: IFFALSE 43528
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
43470: LD_ADDR_VAR 0 5
43474: PUSH
43475: LD_VAR 0 5
43479: PUSH
43480: LD_INT 11
43482: PUSH
43483: LD_INT 30
43485: PUSH
43486: LD_INT 49
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: LIST
43493: DIFF
43494: ST_TO_ADDR
// if not list then
43495: LD_VAR 0 5
43499: NOT
43500: IFFALSE 43504
// exit ;
43502: GO 43646
// weapon := list [ rand ( 1 , list ) ] ;
43504: LD_ADDR_VAR 0 18
43508: PUSH
43509: LD_VAR 0 5
43513: PUSH
43514: LD_INT 1
43516: PPUSH
43517: LD_VAR 0 5
43521: PPUSH
43522: CALL_OW 12
43526: ARRAY
43527: ST_TO_ADDR
// end ; if weapon then
43528: LD_VAR 0 18
43532: IFFALSE 43646
// begin tmp := CostOfWeapon ( weapon ) ;
43534: LD_ADDR_VAR 0 14
43538: PUSH
43539: LD_VAR 0 18
43543: PPUSH
43544: CALL_OW 451
43548: ST_TO_ADDR
// j := GetBase ( tower ) ;
43549: LD_ADDR_VAR 0 9
43553: PUSH
43554: LD_VAR 0 1
43558: PPUSH
43559: CALL_OW 274
43563: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
43564: LD_VAR 0 9
43568: PPUSH
43569: LD_INT 1
43571: PPUSH
43572: CALL_OW 275
43576: PUSH
43577: LD_VAR 0 14
43581: PUSH
43582: LD_INT 1
43584: ARRAY
43585: GREATEREQUAL
43586: PUSH
43587: LD_VAR 0 9
43591: PPUSH
43592: LD_INT 2
43594: PPUSH
43595: CALL_OW 275
43599: PUSH
43600: LD_VAR 0 14
43604: PUSH
43605: LD_INT 2
43607: ARRAY
43608: GREATEREQUAL
43609: AND
43610: PUSH
43611: LD_VAR 0 9
43615: PPUSH
43616: LD_INT 3
43618: PPUSH
43619: CALL_OW 275
43623: PUSH
43624: LD_VAR 0 14
43628: PUSH
43629: LD_INT 3
43631: ARRAY
43632: GREATEREQUAL
43633: AND
43634: IFFALSE 43646
// result := weapon ;
43636: LD_ADDR_VAR 0 3
43640: PUSH
43641: LD_VAR 0 18
43645: ST_TO_ADDR
// end ; end ;
43646: LD_VAR 0 3
43650: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
43651: LD_INT 0
43653: PPUSH
43654: PPUSH
// result := true ;
43655: LD_ADDR_VAR 0 3
43659: PUSH
43660: LD_INT 1
43662: ST_TO_ADDR
// if array1 = array2 then
43663: LD_VAR 0 1
43667: PUSH
43668: LD_VAR 0 2
43672: EQUAL
43673: IFFALSE 43733
// begin for i = 1 to array1 do
43675: LD_ADDR_VAR 0 4
43679: PUSH
43680: DOUBLE
43681: LD_INT 1
43683: DEC
43684: ST_TO_ADDR
43685: LD_VAR 0 1
43689: PUSH
43690: FOR_TO
43691: IFFALSE 43729
// if array1 [ i ] <> array2 [ i ] then
43693: LD_VAR 0 1
43697: PUSH
43698: LD_VAR 0 4
43702: ARRAY
43703: PUSH
43704: LD_VAR 0 2
43708: PUSH
43709: LD_VAR 0 4
43713: ARRAY
43714: NONEQUAL
43715: IFFALSE 43727
// begin result := false ;
43717: LD_ADDR_VAR 0 3
43721: PUSH
43722: LD_INT 0
43724: ST_TO_ADDR
// break ;
43725: GO 43729
// end ;
43727: GO 43690
43729: POP
43730: POP
// end else
43731: GO 43741
// result := false ;
43733: LD_ADDR_VAR 0 3
43737: PUSH
43738: LD_INT 0
43740: ST_TO_ADDR
// end ;
43741: LD_VAR 0 3
43745: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
43746: LD_INT 0
43748: PPUSH
43749: PPUSH
43750: PPUSH
// pom := GetBase ( fac ) ;
43751: LD_ADDR_VAR 0 5
43755: PUSH
43756: LD_VAR 0 1
43760: PPUSH
43761: CALL_OW 274
43765: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
43766: LD_ADDR_VAR 0 4
43770: PUSH
43771: LD_VAR 0 2
43775: PUSH
43776: LD_INT 1
43778: ARRAY
43779: PPUSH
43780: LD_VAR 0 2
43784: PUSH
43785: LD_INT 2
43787: ARRAY
43788: PPUSH
43789: LD_VAR 0 2
43793: PUSH
43794: LD_INT 3
43796: ARRAY
43797: PPUSH
43798: LD_VAR 0 2
43802: PUSH
43803: LD_INT 4
43805: ARRAY
43806: PPUSH
43807: CALL_OW 449
43811: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
43812: LD_ADDR_VAR 0 3
43816: PUSH
43817: LD_VAR 0 5
43821: PPUSH
43822: LD_INT 1
43824: PPUSH
43825: CALL_OW 275
43829: PUSH
43830: LD_VAR 0 4
43834: PUSH
43835: LD_INT 1
43837: ARRAY
43838: GREATEREQUAL
43839: PUSH
43840: LD_VAR 0 5
43844: PPUSH
43845: LD_INT 2
43847: PPUSH
43848: CALL_OW 275
43852: PUSH
43853: LD_VAR 0 4
43857: PUSH
43858: LD_INT 2
43860: ARRAY
43861: GREATEREQUAL
43862: AND
43863: PUSH
43864: LD_VAR 0 5
43868: PPUSH
43869: LD_INT 3
43871: PPUSH
43872: CALL_OW 275
43876: PUSH
43877: LD_VAR 0 4
43881: PUSH
43882: LD_INT 3
43884: ARRAY
43885: GREATEREQUAL
43886: AND
43887: ST_TO_ADDR
// end ;
43888: LD_VAR 0 3
43892: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
43893: LD_INT 0
43895: PPUSH
43896: PPUSH
43897: PPUSH
43898: PPUSH
// pom := GetBase ( building ) ;
43899: LD_ADDR_VAR 0 3
43903: PUSH
43904: LD_VAR 0 1
43908: PPUSH
43909: CALL_OW 274
43913: ST_TO_ADDR
// if not pom then
43914: LD_VAR 0 3
43918: NOT
43919: IFFALSE 43923
// exit ;
43921: GO 44093
// btype := GetBType ( building ) ;
43923: LD_ADDR_VAR 0 5
43927: PUSH
43928: LD_VAR 0 1
43932: PPUSH
43933: CALL_OW 266
43937: ST_TO_ADDR
// if btype = b_armoury then
43938: LD_VAR 0 5
43942: PUSH
43943: LD_INT 4
43945: EQUAL
43946: IFFALSE 43956
// btype := b_barracks ;
43948: LD_ADDR_VAR 0 5
43952: PUSH
43953: LD_INT 5
43955: ST_TO_ADDR
// if btype = b_depot then
43956: LD_VAR 0 5
43960: PUSH
43961: LD_INT 0
43963: EQUAL
43964: IFFALSE 43974
// btype := b_warehouse ;
43966: LD_ADDR_VAR 0 5
43970: PUSH
43971: LD_INT 1
43973: ST_TO_ADDR
// if btype = b_workshop then
43974: LD_VAR 0 5
43978: PUSH
43979: LD_INT 2
43981: EQUAL
43982: IFFALSE 43992
// btype := b_factory ;
43984: LD_ADDR_VAR 0 5
43988: PUSH
43989: LD_INT 3
43991: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
43992: LD_ADDR_VAR 0 4
43996: PUSH
43997: LD_VAR 0 5
44001: PPUSH
44002: LD_VAR 0 1
44006: PPUSH
44007: CALL_OW 248
44011: PPUSH
44012: CALL_OW 450
44016: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
44017: LD_ADDR_VAR 0 2
44021: PUSH
44022: LD_VAR 0 3
44026: PPUSH
44027: LD_INT 1
44029: PPUSH
44030: CALL_OW 275
44034: PUSH
44035: LD_VAR 0 4
44039: PUSH
44040: LD_INT 1
44042: ARRAY
44043: GREATEREQUAL
44044: PUSH
44045: LD_VAR 0 3
44049: PPUSH
44050: LD_INT 2
44052: PPUSH
44053: CALL_OW 275
44057: PUSH
44058: LD_VAR 0 4
44062: PUSH
44063: LD_INT 2
44065: ARRAY
44066: GREATEREQUAL
44067: AND
44068: PUSH
44069: LD_VAR 0 3
44073: PPUSH
44074: LD_INT 3
44076: PPUSH
44077: CALL_OW 275
44081: PUSH
44082: LD_VAR 0 4
44086: PUSH
44087: LD_INT 3
44089: ARRAY
44090: GREATEREQUAL
44091: AND
44092: ST_TO_ADDR
// end ;
44093: LD_VAR 0 2
44097: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
44098: LD_INT 0
44100: PPUSH
44101: PPUSH
44102: PPUSH
// pom := GetBase ( building ) ;
44103: LD_ADDR_VAR 0 4
44107: PUSH
44108: LD_VAR 0 1
44112: PPUSH
44113: CALL_OW 274
44117: ST_TO_ADDR
// if not pom then
44118: LD_VAR 0 4
44122: NOT
44123: IFFALSE 44127
// exit ;
44125: GO 44228
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
44127: LD_ADDR_VAR 0 5
44131: PUSH
44132: LD_VAR 0 2
44136: PPUSH
44137: LD_VAR 0 1
44141: PPUSH
44142: CALL_OW 248
44146: PPUSH
44147: CALL_OW 450
44151: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
44152: LD_ADDR_VAR 0 3
44156: PUSH
44157: LD_VAR 0 4
44161: PPUSH
44162: LD_INT 1
44164: PPUSH
44165: CALL_OW 275
44169: PUSH
44170: LD_VAR 0 5
44174: PUSH
44175: LD_INT 1
44177: ARRAY
44178: GREATEREQUAL
44179: PUSH
44180: LD_VAR 0 4
44184: PPUSH
44185: LD_INT 2
44187: PPUSH
44188: CALL_OW 275
44192: PUSH
44193: LD_VAR 0 5
44197: PUSH
44198: LD_INT 2
44200: ARRAY
44201: GREATEREQUAL
44202: AND
44203: PUSH
44204: LD_VAR 0 4
44208: PPUSH
44209: LD_INT 3
44211: PPUSH
44212: CALL_OW 275
44216: PUSH
44217: LD_VAR 0 5
44221: PUSH
44222: LD_INT 3
44224: ARRAY
44225: GREATEREQUAL
44226: AND
44227: ST_TO_ADDR
// end ;
44228: LD_VAR 0 3
44232: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
44233: LD_INT 0
44235: PPUSH
44236: PPUSH
44237: PPUSH
44238: PPUSH
44239: PPUSH
44240: PPUSH
44241: PPUSH
44242: PPUSH
44243: PPUSH
44244: PPUSH
// result := false ;
44245: LD_ADDR_VAR 0 6
44249: PUSH
44250: LD_INT 0
44252: ST_TO_ADDR
// if not base or not btype or not x or not y then
44253: LD_VAR 0 1
44257: NOT
44258: PUSH
44259: LD_VAR 0 2
44263: NOT
44264: OR
44265: PUSH
44266: LD_VAR 0 3
44270: NOT
44271: OR
44272: PUSH
44273: LD_VAR 0 4
44277: NOT
44278: OR
44279: IFFALSE 44283
// exit ;
44281: GO 44892
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
44283: LD_ADDR_VAR 0 12
44287: PUSH
44288: LD_VAR 0 2
44292: PPUSH
44293: LD_VAR 0 3
44297: PPUSH
44298: LD_VAR 0 4
44302: PPUSH
44303: LD_VAR 0 5
44307: PPUSH
44308: LD_VAR 0 1
44312: PUSH
44313: LD_INT 1
44315: ARRAY
44316: PPUSH
44317: CALL_OW 248
44321: PPUSH
44322: LD_INT 0
44324: PPUSH
44325: CALL 45729 0 6
44329: ST_TO_ADDR
// if not hexes then
44330: LD_VAR 0 12
44334: NOT
44335: IFFALSE 44339
// exit ;
44337: GO 44892
// for i = 1 to hexes do
44339: LD_ADDR_VAR 0 7
44343: PUSH
44344: DOUBLE
44345: LD_INT 1
44347: DEC
44348: ST_TO_ADDR
44349: LD_VAR 0 12
44353: PUSH
44354: FOR_TO
44355: IFFALSE 44890
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
44357: LD_ADDR_VAR 0 11
44361: PUSH
44362: LD_VAR 0 12
44366: PUSH
44367: LD_VAR 0 7
44371: ARRAY
44372: PUSH
44373: LD_INT 1
44375: ARRAY
44376: PPUSH
44377: LD_VAR 0 12
44381: PUSH
44382: LD_VAR 0 7
44386: ARRAY
44387: PUSH
44388: LD_INT 2
44390: ARRAY
44391: PPUSH
44392: CALL_OW 428
44396: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
44397: LD_VAR 0 12
44401: PUSH
44402: LD_VAR 0 7
44406: ARRAY
44407: PUSH
44408: LD_INT 1
44410: ARRAY
44411: PPUSH
44412: LD_VAR 0 12
44416: PUSH
44417: LD_VAR 0 7
44421: ARRAY
44422: PUSH
44423: LD_INT 2
44425: ARRAY
44426: PPUSH
44427: CALL_OW 351
44431: PUSH
44432: LD_VAR 0 12
44436: PUSH
44437: LD_VAR 0 7
44441: ARRAY
44442: PUSH
44443: LD_INT 1
44445: ARRAY
44446: PPUSH
44447: LD_VAR 0 12
44451: PUSH
44452: LD_VAR 0 7
44456: ARRAY
44457: PUSH
44458: LD_INT 2
44460: ARRAY
44461: PPUSH
44462: CALL_OW 488
44466: NOT
44467: OR
44468: PUSH
44469: LD_VAR 0 11
44473: PPUSH
44474: CALL_OW 247
44478: PUSH
44479: LD_INT 3
44481: EQUAL
44482: OR
44483: IFFALSE 44489
// exit ;
44485: POP
44486: POP
44487: GO 44892
// if not tmp or not tmp in base then
44489: LD_VAR 0 11
44493: NOT
44494: PUSH
44495: LD_VAR 0 11
44499: PUSH
44500: LD_VAR 0 1
44504: IN
44505: NOT
44506: OR
44507: IFFALSE 44511
// continue ;
44509: GO 44354
// result := true ;
44511: LD_ADDR_VAR 0 6
44515: PUSH
44516: LD_INT 1
44518: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
44519: LD_ADDR_VAR 0 15
44523: PUSH
44524: LD_VAR 0 1
44528: PPUSH
44529: LD_INT 22
44531: PUSH
44532: LD_VAR 0 11
44536: PPUSH
44537: CALL_OW 255
44541: PUSH
44542: EMPTY
44543: LIST
44544: LIST
44545: PUSH
44546: LD_INT 2
44548: PUSH
44549: LD_INT 30
44551: PUSH
44552: LD_INT 0
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 30
44561: PUSH
44562: LD_INT 1
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: EMPTY
44570: LIST
44571: LIST
44572: LIST
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PPUSH
44578: CALL_OW 72
44582: ST_TO_ADDR
// if dep then
44583: LD_VAR 0 15
44587: IFFALSE 44723
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
44589: LD_ADDR_VAR 0 14
44593: PUSH
44594: LD_VAR 0 15
44598: PUSH
44599: LD_INT 1
44601: ARRAY
44602: PPUSH
44603: CALL_OW 250
44607: PPUSH
44608: LD_VAR 0 15
44612: PUSH
44613: LD_INT 1
44615: ARRAY
44616: PPUSH
44617: CALL_OW 254
44621: PPUSH
44622: LD_INT 5
44624: PPUSH
44625: CALL_OW 272
44629: PUSH
44630: LD_VAR 0 15
44634: PUSH
44635: LD_INT 1
44637: ARRAY
44638: PPUSH
44639: CALL_OW 251
44643: PPUSH
44644: LD_VAR 0 15
44648: PUSH
44649: LD_INT 1
44651: ARRAY
44652: PPUSH
44653: CALL_OW 254
44657: PPUSH
44658: LD_INT 5
44660: PPUSH
44661: CALL_OW 273
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
44670: LD_VAR 0 14
44674: PUSH
44675: LD_INT 1
44677: ARRAY
44678: PPUSH
44679: LD_VAR 0 14
44683: PUSH
44684: LD_INT 2
44686: ARRAY
44687: PPUSH
44688: CALL_OW 488
44692: IFFALSE 44723
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
44694: LD_VAR 0 11
44698: PPUSH
44699: LD_VAR 0 14
44703: PUSH
44704: LD_INT 1
44706: ARRAY
44707: PPUSH
44708: LD_VAR 0 14
44712: PUSH
44713: LD_INT 2
44715: ARRAY
44716: PPUSH
44717: CALL_OW 111
// continue ;
44721: GO 44354
// end ; end ; r := GetDir ( tmp ) ;
44723: LD_ADDR_VAR 0 13
44727: PUSH
44728: LD_VAR 0 11
44732: PPUSH
44733: CALL_OW 254
44737: ST_TO_ADDR
// if r = 5 then
44738: LD_VAR 0 13
44742: PUSH
44743: LD_INT 5
44745: EQUAL
44746: IFFALSE 44756
// r := 0 ;
44748: LD_ADDR_VAR 0 13
44752: PUSH
44753: LD_INT 0
44755: ST_TO_ADDR
// for j = r to 5 do
44756: LD_ADDR_VAR 0 8
44760: PUSH
44761: DOUBLE
44762: LD_VAR 0 13
44766: DEC
44767: ST_TO_ADDR
44768: LD_INT 5
44770: PUSH
44771: FOR_TO
44772: IFFALSE 44886
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
44774: LD_ADDR_VAR 0 9
44778: PUSH
44779: LD_VAR 0 11
44783: PPUSH
44784: CALL_OW 250
44788: PPUSH
44789: LD_VAR 0 8
44793: PPUSH
44794: LD_INT 2
44796: PPUSH
44797: CALL_OW 272
44801: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
44802: LD_ADDR_VAR 0 10
44806: PUSH
44807: LD_VAR 0 11
44811: PPUSH
44812: CALL_OW 251
44816: PPUSH
44817: LD_VAR 0 8
44821: PPUSH
44822: LD_INT 2
44824: PPUSH
44825: CALL_OW 273
44829: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
44830: LD_VAR 0 9
44834: PPUSH
44835: LD_VAR 0 10
44839: PPUSH
44840: CALL_OW 488
44844: PUSH
44845: LD_VAR 0 9
44849: PPUSH
44850: LD_VAR 0 10
44854: PPUSH
44855: CALL_OW 428
44859: NOT
44860: AND
44861: IFFALSE 44884
// begin ComMoveXY ( tmp , _x , _y ) ;
44863: LD_VAR 0 11
44867: PPUSH
44868: LD_VAR 0 9
44872: PPUSH
44873: LD_VAR 0 10
44877: PPUSH
44878: CALL_OW 111
// break ;
44882: GO 44886
// end ; end ;
44884: GO 44771
44886: POP
44887: POP
// end ;
44888: GO 44354
44890: POP
44891: POP
// end ;
44892: LD_VAR 0 6
44896: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
44897: LD_INT 0
44899: PPUSH
44900: PPUSH
44901: PPUSH
44902: PPUSH
44903: PPUSH
44904: PPUSH
44905: PPUSH
44906: PPUSH
44907: PPUSH
44908: PPUSH
// result := false ;
44909: LD_ADDR_VAR 0 6
44913: PUSH
44914: LD_INT 0
44916: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
44917: LD_VAR 0 1
44921: NOT
44922: PUSH
44923: LD_VAR 0 1
44927: PPUSH
44928: CALL_OW 266
44932: PUSH
44933: LD_INT 0
44935: PUSH
44936: LD_INT 1
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: IN
44943: NOT
44944: OR
44945: PUSH
44946: LD_VAR 0 2
44950: NOT
44951: OR
44952: PUSH
44953: LD_VAR 0 5
44957: PUSH
44958: LD_INT 0
44960: PUSH
44961: LD_INT 1
44963: PUSH
44964: LD_INT 2
44966: PUSH
44967: LD_INT 3
44969: PUSH
44970: LD_INT 4
44972: PUSH
44973: LD_INT 5
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: LIST
44980: LIST
44981: LIST
44982: LIST
44983: IN
44984: NOT
44985: OR
44986: PUSH
44987: LD_VAR 0 3
44991: PPUSH
44992: LD_VAR 0 4
44996: PPUSH
44997: CALL_OW 488
45001: NOT
45002: OR
45003: IFFALSE 45007
// exit ;
45005: GO 45724
// pom := GetBase ( depot ) ;
45007: LD_ADDR_VAR 0 10
45011: PUSH
45012: LD_VAR 0 1
45016: PPUSH
45017: CALL_OW 274
45021: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
45022: LD_ADDR_VAR 0 11
45026: PUSH
45027: LD_VAR 0 2
45031: PPUSH
45032: LD_VAR 0 1
45036: PPUSH
45037: CALL_OW 248
45041: PPUSH
45042: CALL_OW 450
45046: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
45047: LD_VAR 0 10
45051: PPUSH
45052: LD_INT 1
45054: PPUSH
45055: CALL_OW 275
45059: PUSH
45060: LD_VAR 0 11
45064: PUSH
45065: LD_INT 1
45067: ARRAY
45068: GREATEREQUAL
45069: PUSH
45070: LD_VAR 0 10
45074: PPUSH
45075: LD_INT 2
45077: PPUSH
45078: CALL_OW 275
45082: PUSH
45083: LD_VAR 0 11
45087: PUSH
45088: LD_INT 2
45090: ARRAY
45091: GREATEREQUAL
45092: AND
45093: PUSH
45094: LD_VAR 0 10
45098: PPUSH
45099: LD_INT 3
45101: PPUSH
45102: CALL_OW 275
45106: PUSH
45107: LD_VAR 0 11
45111: PUSH
45112: LD_INT 3
45114: ARRAY
45115: GREATEREQUAL
45116: AND
45117: NOT
45118: IFFALSE 45122
// exit ;
45120: GO 45724
// if GetBType ( depot ) = b_depot then
45122: LD_VAR 0 1
45126: PPUSH
45127: CALL_OW 266
45131: PUSH
45132: LD_INT 0
45134: EQUAL
45135: IFFALSE 45147
// dist := 28 else
45137: LD_ADDR_VAR 0 14
45141: PUSH
45142: LD_INT 28
45144: ST_TO_ADDR
45145: GO 45155
// dist := 36 ;
45147: LD_ADDR_VAR 0 14
45151: PUSH
45152: LD_INT 36
45154: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
45155: LD_VAR 0 1
45159: PPUSH
45160: LD_VAR 0 3
45164: PPUSH
45165: LD_VAR 0 4
45169: PPUSH
45170: CALL_OW 297
45174: PUSH
45175: LD_VAR 0 14
45179: GREATER
45180: IFFALSE 45184
// exit ;
45182: GO 45724
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
45184: LD_ADDR_VAR 0 12
45188: PUSH
45189: LD_VAR 0 2
45193: PPUSH
45194: LD_VAR 0 3
45198: PPUSH
45199: LD_VAR 0 4
45203: PPUSH
45204: LD_VAR 0 5
45208: PPUSH
45209: LD_VAR 0 1
45213: PPUSH
45214: CALL_OW 248
45218: PPUSH
45219: LD_INT 0
45221: PPUSH
45222: CALL 45729 0 6
45226: ST_TO_ADDR
// if not hexes then
45227: LD_VAR 0 12
45231: NOT
45232: IFFALSE 45236
// exit ;
45234: GO 45724
// hex := GetHexInfo ( x , y ) ;
45236: LD_ADDR_VAR 0 15
45240: PUSH
45241: LD_VAR 0 3
45245: PPUSH
45246: LD_VAR 0 4
45250: PPUSH
45251: CALL_OW 546
45255: ST_TO_ADDR
// if hex [ 1 ] then
45256: LD_VAR 0 15
45260: PUSH
45261: LD_INT 1
45263: ARRAY
45264: IFFALSE 45268
// exit ;
45266: GO 45724
// height := hex [ 2 ] ;
45268: LD_ADDR_VAR 0 13
45272: PUSH
45273: LD_VAR 0 15
45277: PUSH
45278: LD_INT 2
45280: ARRAY
45281: ST_TO_ADDR
// for i = 1 to hexes do
45282: LD_ADDR_VAR 0 7
45286: PUSH
45287: DOUBLE
45288: LD_INT 1
45290: DEC
45291: ST_TO_ADDR
45292: LD_VAR 0 12
45296: PUSH
45297: FOR_TO
45298: IFFALSE 45628
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
45300: LD_VAR 0 12
45304: PUSH
45305: LD_VAR 0 7
45309: ARRAY
45310: PUSH
45311: LD_INT 1
45313: ARRAY
45314: PPUSH
45315: LD_VAR 0 12
45319: PUSH
45320: LD_VAR 0 7
45324: ARRAY
45325: PUSH
45326: LD_INT 2
45328: ARRAY
45329: PPUSH
45330: CALL_OW 488
45334: NOT
45335: PUSH
45336: LD_VAR 0 12
45340: PUSH
45341: LD_VAR 0 7
45345: ARRAY
45346: PUSH
45347: LD_INT 1
45349: ARRAY
45350: PPUSH
45351: LD_VAR 0 12
45355: PUSH
45356: LD_VAR 0 7
45360: ARRAY
45361: PUSH
45362: LD_INT 2
45364: ARRAY
45365: PPUSH
45366: CALL_OW 428
45370: PUSH
45371: LD_INT 0
45373: GREATER
45374: OR
45375: PUSH
45376: LD_VAR 0 12
45380: PUSH
45381: LD_VAR 0 7
45385: ARRAY
45386: PUSH
45387: LD_INT 1
45389: ARRAY
45390: PPUSH
45391: LD_VAR 0 12
45395: PUSH
45396: LD_VAR 0 7
45400: ARRAY
45401: PUSH
45402: LD_INT 2
45404: ARRAY
45405: PPUSH
45406: CALL_OW 351
45410: OR
45411: IFFALSE 45417
// exit ;
45413: POP
45414: POP
45415: GO 45724
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45417: LD_ADDR_VAR 0 8
45421: PUSH
45422: LD_VAR 0 12
45426: PUSH
45427: LD_VAR 0 7
45431: ARRAY
45432: PUSH
45433: LD_INT 1
45435: ARRAY
45436: PPUSH
45437: LD_VAR 0 12
45441: PUSH
45442: LD_VAR 0 7
45446: ARRAY
45447: PUSH
45448: LD_INT 2
45450: ARRAY
45451: PPUSH
45452: CALL_OW 546
45456: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
45457: LD_VAR 0 8
45461: PUSH
45462: LD_INT 1
45464: ARRAY
45465: PUSH
45466: LD_VAR 0 8
45470: PUSH
45471: LD_INT 2
45473: ARRAY
45474: PUSH
45475: LD_VAR 0 13
45479: PUSH
45480: LD_INT 2
45482: PLUS
45483: GREATER
45484: OR
45485: PUSH
45486: LD_VAR 0 8
45490: PUSH
45491: LD_INT 2
45493: ARRAY
45494: PUSH
45495: LD_VAR 0 13
45499: PUSH
45500: LD_INT 2
45502: MINUS
45503: LESS
45504: OR
45505: PUSH
45506: LD_VAR 0 8
45510: PUSH
45511: LD_INT 3
45513: ARRAY
45514: PUSH
45515: LD_INT 0
45517: PUSH
45518: LD_INT 8
45520: PUSH
45521: LD_INT 9
45523: PUSH
45524: LD_INT 10
45526: PUSH
45527: LD_INT 11
45529: PUSH
45530: LD_INT 12
45532: PUSH
45533: LD_INT 13
45535: PUSH
45536: LD_INT 16
45538: PUSH
45539: LD_INT 17
45541: PUSH
45542: LD_INT 18
45544: PUSH
45545: LD_INT 19
45547: PUSH
45548: LD_INT 20
45550: PUSH
45551: LD_INT 21
45553: PUSH
45554: EMPTY
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: IN
45569: NOT
45570: OR
45571: PUSH
45572: LD_VAR 0 8
45576: PUSH
45577: LD_INT 5
45579: ARRAY
45580: NOT
45581: OR
45582: PUSH
45583: LD_VAR 0 8
45587: PUSH
45588: LD_INT 6
45590: ARRAY
45591: PUSH
45592: LD_INT 1
45594: PUSH
45595: LD_INT 2
45597: PUSH
45598: LD_INT 7
45600: PUSH
45601: LD_INT 9
45603: PUSH
45604: LD_INT 10
45606: PUSH
45607: LD_INT 11
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: IN
45618: NOT
45619: OR
45620: IFFALSE 45626
// exit ;
45622: POP
45623: POP
45624: GO 45724
// end ;
45626: GO 45297
45628: POP
45629: POP
// side := GetSide ( depot ) ;
45630: LD_ADDR_VAR 0 9
45634: PUSH
45635: LD_VAR 0 1
45639: PPUSH
45640: CALL_OW 255
45644: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
45645: LD_VAR 0 9
45649: PPUSH
45650: LD_VAR 0 3
45654: PPUSH
45655: LD_VAR 0 4
45659: PPUSH
45660: LD_INT 20
45662: PPUSH
45663: CALL 38378 0 4
45667: PUSH
45668: LD_INT 4
45670: ARRAY
45671: IFFALSE 45675
// exit ;
45673: GO 45724
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
45675: LD_VAR 0 2
45679: PUSH
45680: LD_INT 29
45682: PUSH
45683: LD_INT 30
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: IN
45690: PUSH
45691: LD_VAR 0 3
45695: PPUSH
45696: LD_VAR 0 4
45700: PPUSH
45701: LD_VAR 0 9
45705: PPUSH
45706: CALL_OW 440
45710: NOT
45711: AND
45712: IFFALSE 45716
// exit ;
45714: GO 45724
// result := true ;
45716: LD_ADDR_VAR 0 6
45720: PUSH
45721: LD_INT 1
45723: ST_TO_ADDR
// end ;
45724: LD_VAR 0 6
45728: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
45729: LD_INT 0
45731: PPUSH
45732: PPUSH
45733: PPUSH
45734: PPUSH
45735: PPUSH
45736: PPUSH
45737: PPUSH
45738: PPUSH
45739: PPUSH
45740: PPUSH
45741: PPUSH
45742: PPUSH
45743: PPUSH
45744: PPUSH
45745: PPUSH
45746: PPUSH
45747: PPUSH
45748: PPUSH
45749: PPUSH
45750: PPUSH
45751: PPUSH
45752: PPUSH
45753: PPUSH
45754: PPUSH
45755: PPUSH
45756: PPUSH
45757: PPUSH
45758: PPUSH
45759: PPUSH
45760: PPUSH
45761: PPUSH
45762: PPUSH
45763: PPUSH
45764: PPUSH
45765: PPUSH
45766: PPUSH
45767: PPUSH
45768: PPUSH
45769: PPUSH
45770: PPUSH
45771: PPUSH
45772: PPUSH
45773: PPUSH
45774: PPUSH
45775: PPUSH
45776: PPUSH
45777: PPUSH
45778: PPUSH
45779: PPUSH
45780: PPUSH
45781: PPUSH
45782: PPUSH
45783: PPUSH
45784: PPUSH
45785: PPUSH
45786: PPUSH
45787: PPUSH
45788: PPUSH
// result = [ ] ;
45789: LD_ADDR_VAR 0 7
45793: PUSH
45794: EMPTY
45795: ST_TO_ADDR
// temp_list = [ ] ;
45796: LD_ADDR_VAR 0 9
45800: PUSH
45801: EMPTY
45802: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
45803: LD_VAR 0 4
45807: PUSH
45808: LD_INT 0
45810: PUSH
45811: LD_INT 1
45813: PUSH
45814: LD_INT 2
45816: PUSH
45817: LD_INT 3
45819: PUSH
45820: LD_INT 4
45822: PUSH
45823: LD_INT 5
45825: PUSH
45826: EMPTY
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: IN
45834: NOT
45835: PUSH
45836: LD_VAR 0 1
45840: PUSH
45841: LD_INT 0
45843: PUSH
45844: LD_INT 1
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: IN
45851: PUSH
45852: LD_VAR 0 5
45856: PUSH
45857: LD_INT 1
45859: PUSH
45860: LD_INT 2
45862: PUSH
45863: LD_INT 3
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: LIST
45870: IN
45871: NOT
45872: AND
45873: OR
45874: IFFALSE 45878
// exit ;
45876: GO 64269
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
45878: LD_VAR 0 1
45882: PUSH
45883: LD_INT 6
45885: PUSH
45886: LD_INT 7
45888: PUSH
45889: LD_INT 8
45891: PUSH
45892: LD_INT 13
45894: PUSH
45895: LD_INT 12
45897: PUSH
45898: LD_INT 15
45900: PUSH
45901: LD_INT 11
45903: PUSH
45904: LD_INT 14
45906: PUSH
45907: LD_INT 10
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: LIST
45914: LIST
45915: LIST
45916: LIST
45917: LIST
45918: LIST
45919: LIST
45920: IN
45921: IFFALSE 45931
// btype = b_lab ;
45923: LD_ADDR_VAR 0 1
45927: PUSH
45928: LD_INT 6
45930: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
45931: LD_VAR 0 6
45935: PUSH
45936: LD_INT 0
45938: PUSH
45939: LD_INT 1
45941: PUSH
45942: LD_INT 2
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: LIST
45949: IN
45950: NOT
45951: PUSH
45952: LD_VAR 0 1
45956: PUSH
45957: LD_INT 0
45959: PUSH
45960: LD_INT 1
45962: PUSH
45963: LD_INT 2
45965: PUSH
45966: LD_INT 3
45968: PUSH
45969: LD_INT 6
45971: PUSH
45972: LD_INT 36
45974: PUSH
45975: LD_INT 4
45977: PUSH
45978: LD_INT 5
45980: PUSH
45981: LD_INT 31
45983: PUSH
45984: LD_INT 32
45986: PUSH
45987: LD_INT 33
45989: PUSH
45990: EMPTY
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: IN
46003: NOT
46004: PUSH
46005: LD_VAR 0 6
46009: PUSH
46010: LD_INT 1
46012: EQUAL
46013: AND
46014: OR
46015: PUSH
46016: LD_VAR 0 1
46020: PUSH
46021: LD_INT 2
46023: PUSH
46024: LD_INT 3
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: IN
46031: NOT
46032: PUSH
46033: LD_VAR 0 6
46037: PUSH
46038: LD_INT 2
46040: EQUAL
46041: AND
46042: OR
46043: IFFALSE 46053
// mode = 0 ;
46045: LD_ADDR_VAR 0 6
46049: PUSH
46050: LD_INT 0
46052: ST_TO_ADDR
// case mode of 0 :
46053: LD_VAR 0 6
46057: PUSH
46058: LD_INT 0
46060: DOUBLE
46061: EQUAL
46062: IFTRUE 46066
46064: GO 57519
46066: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46067: LD_ADDR_VAR 0 11
46071: PUSH
46072: LD_INT 0
46074: PUSH
46075: LD_INT 0
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: LD_INT 0
46084: PUSH
46085: LD_INT 1
46087: NEG
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: PUSH
46093: LD_INT 1
46095: PUSH
46096: LD_INT 0
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: PUSH
46103: LD_INT 1
46105: PUSH
46106: LD_INT 1
46108: PUSH
46109: EMPTY
46110: LIST
46111: LIST
46112: PUSH
46113: LD_INT 0
46115: PUSH
46116: LD_INT 1
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 1
46125: NEG
46126: PUSH
46127: LD_INT 0
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: LD_INT 1
46136: NEG
46137: PUSH
46138: LD_INT 1
46140: NEG
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 1
46148: NEG
46149: PUSH
46150: LD_INT 2
46152: NEG
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: PUSH
46158: LD_INT 0
46160: PUSH
46161: LD_INT 2
46163: NEG
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 1
46171: PUSH
46172: LD_INT 1
46174: NEG
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: PUSH
46180: LD_INT 1
46182: PUSH
46183: LD_INT 2
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PUSH
46190: LD_INT 0
46192: PUSH
46193: LD_INT 2
46195: PUSH
46196: EMPTY
46197: LIST
46198: LIST
46199: PUSH
46200: LD_INT 1
46202: NEG
46203: PUSH
46204: LD_INT 1
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: LD_INT 1
46213: PUSH
46214: LD_INT 3
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: PUSH
46221: LD_INT 0
46223: PUSH
46224: LD_INT 3
46226: PUSH
46227: EMPTY
46228: LIST
46229: LIST
46230: PUSH
46231: LD_INT 1
46233: NEG
46234: PUSH
46235: LD_INT 2
46237: PUSH
46238: EMPTY
46239: LIST
46240: LIST
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: LIST
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: LIST
46258: LIST
46259: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46260: LD_ADDR_VAR 0 12
46264: PUSH
46265: LD_INT 0
46267: PUSH
46268: LD_INT 0
46270: PUSH
46271: EMPTY
46272: LIST
46273: LIST
46274: PUSH
46275: LD_INT 0
46277: PUSH
46278: LD_INT 1
46280: NEG
46281: PUSH
46282: EMPTY
46283: LIST
46284: LIST
46285: PUSH
46286: LD_INT 1
46288: PUSH
46289: LD_INT 0
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: PUSH
46296: LD_INT 1
46298: PUSH
46299: LD_INT 1
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: PUSH
46306: LD_INT 0
46308: PUSH
46309: LD_INT 1
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PUSH
46316: LD_INT 1
46318: NEG
46319: PUSH
46320: LD_INT 0
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: PUSH
46327: LD_INT 1
46329: NEG
46330: PUSH
46331: LD_INT 1
46333: NEG
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 1
46341: PUSH
46342: LD_INT 1
46344: NEG
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 2
46352: PUSH
46353: LD_INT 0
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 2
46362: PUSH
46363: LD_INT 1
46365: PUSH
46366: EMPTY
46367: LIST
46368: LIST
46369: PUSH
46370: LD_INT 1
46372: NEG
46373: PUSH
46374: LD_INT 1
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 2
46383: NEG
46384: PUSH
46385: LD_INT 0
46387: PUSH
46388: EMPTY
46389: LIST
46390: LIST
46391: PUSH
46392: LD_INT 2
46394: NEG
46395: PUSH
46396: LD_INT 1
46398: NEG
46399: PUSH
46400: EMPTY
46401: LIST
46402: LIST
46403: PUSH
46404: LD_INT 2
46406: NEG
46407: PUSH
46408: LD_INT 1
46410: PUSH
46411: EMPTY
46412: LIST
46413: LIST
46414: PUSH
46415: LD_INT 3
46417: NEG
46418: PUSH
46419: LD_INT 0
46421: PUSH
46422: EMPTY
46423: LIST
46424: LIST
46425: PUSH
46426: LD_INT 3
46428: NEG
46429: PUSH
46430: LD_INT 1
46432: NEG
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: LIST
46455: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46456: LD_ADDR_VAR 0 13
46460: PUSH
46461: LD_INT 0
46463: PUSH
46464: LD_INT 0
46466: PUSH
46467: EMPTY
46468: LIST
46469: LIST
46470: PUSH
46471: LD_INT 0
46473: PUSH
46474: LD_INT 1
46476: NEG
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: PUSH
46482: LD_INT 1
46484: PUSH
46485: LD_INT 0
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: PUSH
46492: LD_INT 1
46494: PUSH
46495: LD_INT 1
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: PUSH
46502: LD_INT 0
46504: PUSH
46505: LD_INT 1
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: LD_INT 1
46514: NEG
46515: PUSH
46516: LD_INT 0
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 1
46525: NEG
46526: PUSH
46527: LD_INT 1
46529: NEG
46530: PUSH
46531: EMPTY
46532: LIST
46533: LIST
46534: PUSH
46535: LD_INT 1
46537: NEG
46538: PUSH
46539: LD_INT 2
46541: NEG
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PUSH
46547: LD_INT 2
46549: PUSH
46550: LD_INT 1
46552: PUSH
46553: EMPTY
46554: LIST
46555: LIST
46556: PUSH
46557: LD_INT 2
46559: PUSH
46560: LD_INT 2
46562: PUSH
46563: EMPTY
46564: LIST
46565: LIST
46566: PUSH
46567: LD_INT 1
46569: PUSH
46570: LD_INT 2
46572: PUSH
46573: EMPTY
46574: LIST
46575: LIST
46576: PUSH
46577: LD_INT 2
46579: NEG
46580: PUSH
46581: LD_INT 1
46583: NEG
46584: PUSH
46585: EMPTY
46586: LIST
46587: LIST
46588: PUSH
46589: LD_INT 2
46591: NEG
46592: PUSH
46593: LD_INT 2
46595: NEG
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: PUSH
46601: LD_INT 2
46603: NEG
46604: PUSH
46605: LD_INT 3
46607: NEG
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 3
46615: NEG
46616: PUSH
46617: LD_INT 2
46619: NEG
46620: PUSH
46621: EMPTY
46622: LIST
46623: LIST
46624: PUSH
46625: LD_INT 3
46627: NEG
46628: PUSH
46629: LD_INT 3
46631: NEG
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: LIST
46641: LIST
46642: LIST
46643: LIST
46644: LIST
46645: LIST
46646: LIST
46647: LIST
46648: LIST
46649: LIST
46650: LIST
46651: LIST
46652: LIST
46653: LIST
46654: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46655: LD_ADDR_VAR 0 14
46659: PUSH
46660: LD_INT 0
46662: PUSH
46663: LD_INT 0
46665: PUSH
46666: EMPTY
46667: LIST
46668: LIST
46669: PUSH
46670: LD_INT 0
46672: PUSH
46673: LD_INT 1
46675: NEG
46676: PUSH
46677: EMPTY
46678: LIST
46679: LIST
46680: PUSH
46681: LD_INT 1
46683: PUSH
46684: LD_INT 0
46686: PUSH
46687: EMPTY
46688: LIST
46689: LIST
46690: PUSH
46691: LD_INT 1
46693: PUSH
46694: LD_INT 1
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: LD_INT 0
46703: PUSH
46704: LD_INT 1
46706: PUSH
46707: EMPTY
46708: LIST
46709: LIST
46710: PUSH
46711: LD_INT 1
46713: NEG
46714: PUSH
46715: LD_INT 0
46717: PUSH
46718: EMPTY
46719: LIST
46720: LIST
46721: PUSH
46722: LD_INT 1
46724: NEG
46725: PUSH
46726: LD_INT 1
46728: NEG
46729: PUSH
46730: EMPTY
46731: LIST
46732: LIST
46733: PUSH
46734: LD_INT 1
46736: NEG
46737: PUSH
46738: LD_INT 2
46740: NEG
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: PUSH
46746: LD_INT 0
46748: PUSH
46749: LD_INT 2
46751: NEG
46752: PUSH
46753: EMPTY
46754: LIST
46755: LIST
46756: PUSH
46757: LD_INT 1
46759: PUSH
46760: LD_INT 1
46762: NEG
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: PUSH
46768: LD_INT 1
46770: PUSH
46771: LD_INT 2
46773: PUSH
46774: EMPTY
46775: LIST
46776: LIST
46777: PUSH
46778: LD_INT 0
46780: PUSH
46781: LD_INT 2
46783: PUSH
46784: EMPTY
46785: LIST
46786: LIST
46787: PUSH
46788: LD_INT 1
46790: NEG
46791: PUSH
46792: LD_INT 1
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PUSH
46799: LD_INT 1
46801: NEG
46802: PUSH
46803: LD_INT 3
46805: NEG
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 0
46813: PUSH
46814: LD_INT 3
46816: NEG
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: PUSH
46822: LD_INT 1
46824: PUSH
46825: LD_INT 2
46827: NEG
46828: PUSH
46829: EMPTY
46830: LIST
46831: LIST
46832: PUSH
46833: EMPTY
46834: LIST
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: LIST
46847: LIST
46848: LIST
46849: LIST
46850: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46851: LD_ADDR_VAR 0 15
46855: PUSH
46856: LD_INT 0
46858: PUSH
46859: LD_INT 0
46861: PUSH
46862: EMPTY
46863: LIST
46864: LIST
46865: PUSH
46866: LD_INT 0
46868: PUSH
46869: LD_INT 1
46871: NEG
46872: PUSH
46873: EMPTY
46874: LIST
46875: LIST
46876: PUSH
46877: LD_INT 1
46879: PUSH
46880: LD_INT 0
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: PUSH
46887: LD_INT 1
46889: PUSH
46890: LD_INT 1
46892: PUSH
46893: EMPTY
46894: LIST
46895: LIST
46896: PUSH
46897: LD_INT 0
46899: PUSH
46900: LD_INT 1
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: PUSH
46907: LD_INT 1
46909: NEG
46910: PUSH
46911: LD_INT 0
46913: PUSH
46914: EMPTY
46915: LIST
46916: LIST
46917: PUSH
46918: LD_INT 1
46920: NEG
46921: PUSH
46922: LD_INT 1
46924: NEG
46925: PUSH
46926: EMPTY
46927: LIST
46928: LIST
46929: PUSH
46930: LD_INT 1
46932: PUSH
46933: LD_INT 1
46935: NEG
46936: PUSH
46937: EMPTY
46938: LIST
46939: LIST
46940: PUSH
46941: LD_INT 2
46943: PUSH
46944: LD_INT 0
46946: PUSH
46947: EMPTY
46948: LIST
46949: LIST
46950: PUSH
46951: LD_INT 2
46953: PUSH
46954: LD_INT 1
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: PUSH
46961: LD_INT 1
46963: NEG
46964: PUSH
46965: LD_INT 1
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: PUSH
46972: LD_INT 2
46974: NEG
46975: PUSH
46976: LD_INT 0
46978: PUSH
46979: EMPTY
46980: LIST
46981: LIST
46982: PUSH
46983: LD_INT 2
46985: NEG
46986: PUSH
46987: LD_INT 1
46989: NEG
46990: PUSH
46991: EMPTY
46992: LIST
46993: LIST
46994: PUSH
46995: LD_INT 2
46997: PUSH
46998: LD_INT 1
47000: NEG
47001: PUSH
47002: EMPTY
47003: LIST
47004: LIST
47005: PUSH
47006: LD_INT 3
47008: PUSH
47009: LD_INT 0
47011: PUSH
47012: EMPTY
47013: LIST
47014: LIST
47015: PUSH
47016: LD_INT 3
47018: PUSH
47019: LD_INT 1
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47044: LD_ADDR_VAR 0 16
47048: PUSH
47049: LD_INT 0
47051: PUSH
47052: LD_INT 0
47054: PUSH
47055: EMPTY
47056: LIST
47057: LIST
47058: PUSH
47059: LD_INT 0
47061: PUSH
47062: LD_INT 1
47064: NEG
47065: PUSH
47066: EMPTY
47067: LIST
47068: LIST
47069: PUSH
47070: LD_INT 1
47072: PUSH
47073: LD_INT 0
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: PUSH
47080: LD_INT 1
47082: PUSH
47083: LD_INT 1
47085: PUSH
47086: EMPTY
47087: LIST
47088: LIST
47089: PUSH
47090: LD_INT 0
47092: PUSH
47093: LD_INT 1
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: PUSH
47100: LD_INT 1
47102: NEG
47103: PUSH
47104: LD_INT 0
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: LD_INT 1
47113: NEG
47114: PUSH
47115: LD_INT 1
47117: NEG
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: PUSH
47123: LD_INT 1
47125: NEG
47126: PUSH
47127: LD_INT 2
47129: NEG
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 2
47137: PUSH
47138: LD_INT 1
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 2
47147: PUSH
47148: LD_INT 2
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: LD_INT 1
47157: PUSH
47158: LD_INT 2
47160: PUSH
47161: EMPTY
47162: LIST
47163: LIST
47164: PUSH
47165: LD_INT 2
47167: NEG
47168: PUSH
47169: LD_INT 1
47171: NEG
47172: PUSH
47173: EMPTY
47174: LIST
47175: LIST
47176: PUSH
47177: LD_INT 2
47179: NEG
47180: PUSH
47181: LD_INT 2
47183: NEG
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: PUSH
47189: LD_INT 3
47191: PUSH
47192: LD_INT 2
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: PUSH
47199: LD_INT 3
47201: PUSH
47202: LD_INT 3
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: LD_INT 2
47211: PUSH
47212: LD_INT 3
47214: PUSH
47215: EMPTY
47216: LIST
47217: LIST
47218: PUSH
47219: EMPTY
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: LIST
47236: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47237: LD_ADDR_VAR 0 17
47241: PUSH
47242: LD_INT 0
47244: PUSH
47245: LD_INT 0
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: PUSH
47252: LD_INT 0
47254: PUSH
47255: LD_INT 1
47257: NEG
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PUSH
47263: LD_INT 1
47265: PUSH
47266: LD_INT 0
47268: PUSH
47269: EMPTY
47270: LIST
47271: LIST
47272: PUSH
47273: LD_INT 1
47275: PUSH
47276: LD_INT 1
47278: PUSH
47279: EMPTY
47280: LIST
47281: LIST
47282: PUSH
47283: LD_INT 0
47285: PUSH
47286: LD_INT 1
47288: PUSH
47289: EMPTY
47290: LIST
47291: LIST
47292: PUSH
47293: LD_INT 1
47295: NEG
47296: PUSH
47297: LD_INT 0
47299: PUSH
47300: EMPTY
47301: LIST
47302: LIST
47303: PUSH
47304: LD_INT 1
47306: NEG
47307: PUSH
47308: LD_INT 1
47310: NEG
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: PUSH
47316: LD_INT 1
47318: NEG
47319: PUSH
47320: LD_INT 2
47322: NEG
47323: PUSH
47324: EMPTY
47325: LIST
47326: LIST
47327: PUSH
47328: LD_INT 0
47330: PUSH
47331: LD_INT 2
47333: NEG
47334: PUSH
47335: EMPTY
47336: LIST
47337: LIST
47338: PUSH
47339: LD_INT 1
47341: PUSH
47342: LD_INT 1
47344: NEG
47345: PUSH
47346: EMPTY
47347: LIST
47348: LIST
47349: PUSH
47350: LD_INT 2
47352: PUSH
47353: LD_INT 0
47355: PUSH
47356: EMPTY
47357: LIST
47358: LIST
47359: PUSH
47360: LD_INT 2
47362: PUSH
47363: LD_INT 1
47365: PUSH
47366: EMPTY
47367: LIST
47368: LIST
47369: PUSH
47370: LD_INT 2
47372: PUSH
47373: LD_INT 2
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: LD_INT 1
47382: PUSH
47383: LD_INT 2
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: PUSH
47390: LD_INT 0
47392: PUSH
47393: LD_INT 2
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: PUSH
47400: LD_INT 1
47402: NEG
47403: PUSH
47404: LD_INT 1
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: PUSH
47411: LD_INT 2
47413: NEG
47414: PUSH
47415: LD_INT 0
47417: PUSH
47418: EMPTY
47419: LIST
47420: LIST
47421: PUSH
47422: LD_INT 2
47424: NEG
47425: PUSH
47426: LD_INT 1
47428: NEG
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: PUSH
47434: LD_INT 2
47436: NEG
47437: PUSH
47438: LD_INT 2
47440: NEG
47441: PUSH
47442: EMPTY
47443: LIST
47444: LIST
47445: PUSH
47446: EMPTY
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: LIST
47464: LIST
47465: LIST
47466: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47467: LD_ADDR_VAR 0 18
47471: PUSH
47472: LD_INT 0
47474: PUSH
47475: LD_INT 0
47477: PUSH
47478: EMPTY
47479: LIST
47480: LIST
47481: PUSH
47482: LD_INT 0
47484: PUSH
47485: LD_INT 1
47487: NEG
47488: PUSH
47489: EMPTY
47490: LIST
47491: LIST
47492: PUSH
47493: LD_INT 1
47495: PUSH
47496: LD_INT 0
47498: PUSH
47499: EMPTY
47500: LIST
47501: LIST
47502: PUSH
47503: LD_INT 1
47505: PUSH
47506: LD_INT 1
47508: PUSH
47509: EMPTY
47510: LIST
47511: LIST
47512: PUSH
47513: LD_INT 0
47515: PUSH
47516: LD_INT 1
47518: PUSH
47519: EMPTY
47520: LIST
47521: LIST
47522: PUSH
47523: LD_INT 1
47525: NEG
47526: PUSH
47527: LD_INT 0
47529: PUSH
47530: EMPTY
47531: LIST
47532: LIST
47533: PUSH
47534: LD_INT 1
47536: NEG
47537: PUSH
47538: LD_INT 1
47540: NEG
47541: PUSH
47542: EMPTY
47543: LIST
47544: LIST
47545: PUSH
47546: LD_INT 1
47548: NEG
47549: PUSH
47550: LD_INT 2
47552: NEG
47553: PUSH
47554: EMPTY
47555: LIST
47556: LIST
47557: PUSH
47558: LD_INT 0
47560: PUSH
47561: LD_INT 2
47563: NEG
47564: PUSH
47565: EMPTY
47566: LIST
47567: LIST
47568: PUSH
47569: LD_INT 1
47571: PUSH
47572: LD_INT 1
47574: NEG
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: LD_INT 2
47582: PUSH
47583: LD_INT 0
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: PUSH
47590: LD_INT 2
47592: PUSH
47593: LD_INT 1
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: PUSH
47600: LD_INT 2
47602: PUSH
47603: LD_INT 2
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: PUSH
47610: LD_INT 1
47612: PUSH
47613: LD_INT 2
47615: PUSH
47616: EMPTY
47617: LIST
47618: LIST
47619: PUSH
47620: LD_INT 0
47622: PUSH
47623: LD_INT 2
47625: PUSH
47626: EMPTY
47627: LIST
47628: LIST
47629: PUSH
47630: LD_INT 1
47632: NEG
47633: PUSH
47634: LD_INT 1
47636: PUSH
47637: EMPTY
47638: LIST
47639: LIST
47640: PUSH
47641: LD_INT 2
47643: NEG
47644: PUSH
47645: LD_INT 0
47647: PUSH
47648: EMPTY
47649: LIST
47650: LIST
47651: PUSH
47652: LD_INT 2
47654: NEG
47655: PUSH
47656: LD_INT 1
47658: NEG
47659: PUSH
47660: EMPTY
47661: LIST
47662: LIST
47663: PUSH
47664: LD_INT 2
47666: NEG
47667: PUSH
47668: LD_INT 2
47670: NEG
47671: PUSH
47672: EMPTY
47673: LIST
47674: LIST
47675: PUSH
47676: EMPTY
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: LIST
47687: LIST
47688: LIST
47689: LIST
47690: LIST
47691: LIST
47692: LIST
47693: LIST
47694: LIST
47695: LIST
47696: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47697: LD_ADDR_VAR 0 19
47701: PUSH
47702: LD_INT 0
47704: PUSH
47705: LD_INT 0
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: PUSH
47712: LD_INT 0
47714: PUSH
47715: LD_INT 1
47717: NEG
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 1
47725: PUSH
47726: LD_INT 0
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 1
47735: PUSH
47736: LD_INT 1
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 0
47745: PUSH
47746: LD_INT 1
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 1
47755: NEG
47756: PUSH
47757: LD_INT 0
47759: PUSH
47760: EMPTY
47761: LIST
47762: LIST
47763: PUSH
47764: LD_INT 1
47766: NEG
47767: PUSH
47768: LD_INT 1
47770: NEG
47771: PUSH
47772: EMPTY
47773: LIST
47774: LIST
47775: PUSH
47776: LD_INT 1
47778: NEG
47779: PUSH
47780: LD_INT 2
47782: NEG
47783: PUSH
47784: EMPTY
47785: LIST
47786: LIST
47787: PUSH
47788: LD_INT 0
47790: PUSH
47791: LD_INT 2
47793: NEG
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: PUSH
47799: LD_INT 1
47801: PUSH
47802: LD_INT 1
47804: NEG
47805: PUSH
47806: EMPTY
47807: LIST
47808: LIST
47809: PUSH
47810: LD_INT 2
47812: PUSH
47813: LD_INT 0
47815: PUSH
47816: EMPTY
47817: LIST
47818: LIST
47819: PUSH
47820: LD_INT 2
47822: PUSH
47823: LD_INT 1
47825: PUSH
47826: EMPTY
47827: LIST
47828: LIST
47829: PUSH
47830: LD_INT 2
47832: PUSH
47833: LD_INT 2
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: LD_INT 1
47842: PUSH
47843: LD_INT 2
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: PUSH
47850: LD_INT 0
47852: PUSH
47853: LD_INT 2
47855: PUSH
47856: EMPTY
47857: LIST
47858: LIST
47859: PUSH
47860: LD_INT 1
47862: NEG
47863: PUSH
47864: LD_INT 1
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: PUSH
47871: LD_INT 2
47873: NEG
47874: PUSH
47875: LD_INT 0
47877: PUSH
47878: EMPTY
47879: LIST
47880: LIST
47881: PUSH
47882: LD_INT 2
47884: NEG
47885: PUSH
47886: LD_INT 1
47888: NEG
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PUSH
47894: LD_INT 2
47896: NEG
47897: PUSH
47898: LD_INT 2
47900: NEG
47901: PUSH
47902: EMPTY
47903: LIST
47904: LIST
47905: PUSH
47906: EMPTY
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: LIST
47912: LIST
47913: LIST
47914: LIST
47915: LIST
47916: LIST
47917: LIST
47918: LIST
47919: LIST
47920: LIST
47921: LIST
47922: LIST
47923: LIST
47924: LIST
47925: LIST
47926: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47927: LD_ADDR_VAR 0 20
47931: PUSH
47932: LD_INT 0
47934: PUSH
47935: LD_INT 0
47937: PUSH
47938: EMPTY
47939: LIST
47940: LIST
47941: PUSH
47942: LD_INT 0
47944: PUSH
47945: LD_INT 1
47947: NEG
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PUSH
47953: LD_INT 1
47955: PUSH
47956: LD_INT 0
47958: PUSH
47959: EMPTY
47960: LIST
47961: LIST
47962: PUSH
47963: LD_INT 1
47965: PUSH
47966: LD_INT 1
47968: PUSH
47969: EMPTY
47970: LIST
47971: LIST
47972: PUSH
47973: LD_INT 0
47975: PUSH
47976: LD_INT 1
47978: PUSH
47979: EMPTY
47980: LIST
47981: LIST
47982: PUSH
47983: LD_INT 1
47985: NEG
47986: PUSH
47987: LD_INT 0
47989: PUSH
47990: EMPTY
47991: LIST
47992: LIST
47993: PUSH
47994: LD_INT 1
47996: NEG
47997: PUSH
47998: LD_INT 1
48000: NEG
48001: PUSH
48002: EMPTY
48003: LIST
48004: LIST
48005: PUSH
48006: LD_INT 1
48008: NEG
48009: PUSH
48010: LD_INT 2
48012: NEG
48013: PUSH
48014: EMPTY
48015: LIST
48016: LIST
48017: PUSH
48018: LD_INT 0
48020: PUSH
48021: LD_INT 2
48023: NEG
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: PUSH
48029: LD_INT 1
48031: PUSH
48032: LD_INT 1
48034: NEG
48035: PUSH
48036: EMPTY
48037: LIST
48038: LIST
48039: PUSH
48040: LD_INT 2
48042: PUSH
48043: LD_INT 0
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: PUSH
48050: LD_INT 2
48052: PUSH
48053: LD_INT 1
48055: PUSH
48056: EMPTY
48057: LIST
48058: LIST
48059: PUSH
48060: LD_INT 2
48062: PUSH
48063: LD_INT 2
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: PUSH
48070: LD_INT 1
48072: PUSH
48073: LD_INT 2
48075: PUSH
48076: EMPTY
48077: LIST
48078: LIST
48079: PUSH
48080: LD_INT 0
48082: PUSH
48083: LD_INT 2
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: PUSH
48090: LD_INT 1
48092: NEG
48093: PUSH
48094: LD_INT 1
48096: PUSH
48097: EMPTY
48098: LIST
48099: LIST
48100: PUSH
48101: LD_INT 2
48103: NEG
48104: PUSH
48105: LD_INT 0
48107: PUSH
48108: EMPTY
48109: LIST
48110: LIST
48111: PUSH
48112: LD_INT 2
48114: NEG
48115: PUSH
48116: LD_INT 1
48118: NEG
48119: PUSH
48120: EMPTY
48121: LIST
48122: LIST
48123: PUSH
48124: LD_INT 2
48126: NEG
48127: PUSH
48128: LD_INT 2
48130: NEG
48131: PUSH
48132: EMPTY
48133: LIST
48134: LIST
48135: PUSH
48136: EMPTY
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48157: LD_ADDR_VAR 0 21
48161: PUSH
48162: LD_INT 0
48164: PUSH
48165: LD_INT 0
48167: PUSH
48168: EMPTY
48169: LIST
48170: LIST
48171: PUSH
48172: LD_INT 0
48174: PUSH
48175: LD_INT 1
48177: NEG
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: PUSH
48183: LD_INT 1
48185: PUSH
48186: LD_INT 0
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 1
48195: PUSH
48196: LD_INT 1
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 0
48205: PUSH
48206: LD_INT 1
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: LD_INT 1
48215: NEG
48216: PUSH
48217: LD_INT 0
48219: PUSH
48220: EMPTY
48221: LIST
48222: LIST
48223: PUSH
48224: LD_INT 1
48226: NEG
48227: PUSH
48228: LD_INT 1
48230: NEG
48231: PUSH
48232: EMPTY
48233: LIST
48234: LIST
48235: PUSH
48236: LD_INT 1
48238: NEG
48239: PUSH
48240: LD_INT 2
48242: NEG
48243: PUSH
48244: EMPTY
48245: LIST
48246: LIST
48247: PUSH
48248: LD_INT 0
48250: PUSH
48251: LD_INT 2
48253: NEG
48254: PUSH
48255: EMPTY
48256: LIST
48257: LIST
48258: PUSH
48259: LD_INT 1
48261: PUSH
48262: LD_INT 1
48264: NEG
48265: PUSH
48266: EMPTY
48267: LIST
48268: LIST
48269: PUSH
48270: LD_INT 2
48272: PUSH
48273: LD_INT 0
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: PUSH
48280: LD_INT 2
48282: PUSH
48283: LD_INT 1
48285: PUSH
48286: EMPTY
48287: LIST
48288: LIST
48289: PUSH
48290: LD_INT 2
48292: PUSH
48293: LD_INT 2
48295: PUSH
48296: EMPTY
48297: LIST
48298: LIST
48299: PUSH
48300: LD_INT 1
48302: PUSH
48303: LD_INT 2
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 0
48312: PUSH
48313: LD_INT 2
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: LD_INT 1
48322: NEG
48323: PUSH
48324: LD_INT 1
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 2
48333: NEG
48334: PUSH
48335: LD_INT 0
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: PUSH
48342: LD_INT 2
48344: NEG
48345: PUSH
48346: LD_INT 1
48348: NEG
48349: PUSH
48350: EMPTY
48351: LIST
48352: LIST
48353: PUSH
48354: LD_INT 2
48356: NEG
48357: PUSH
48358: LD_INT 2
48360: NEG
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: EMPTY
48367: LIST
48368: LIST
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: LIST
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48387: LD_ADDR_VAR 0 22
48391: PUSH
48392: LD_INT 0
48394: PUSH
48395: LD_INT 0
48397: PUSH
48398: EMPTY
48399: LIST
48400: LIST
48401: PUSH
48402: LD_INT 0
48404: PUSH
48405: LD_INT 1
48407: NEG
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: PUSH
48413: LD_INT 1
48415: PUSH
48416: LD_INT 0
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 1
48425: PUSH
48426: LD_INT 1
48428: PUSH
48429: EMPTY
48430: LIST
48431: LIST
48432: PUSH
48433: LD_INT 0
48435: PUSH
48436: LD_INT 1
48438: PUSH
48439: EMPTY
48440: LIST
48441: LIST
48442: PUSH
48443: LD_INT 1
48445: NEG
48446: PUSH
48447: LD_INT 0
48449: PUSH
48450: EMPTY
48451: LIST
48452: LIST
48453: PUSH
48454: LD_INT 1
48456: NEG
48457: PUSH
48458: LD_INT 1
48460: NEG
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: PUSH
48466: LD_INT 1
48468: NEG
48469: PUSH
48470: LD_INT 2
48472: NEG
48473: PUSH
48474: EMPTY
48475: LIST
48476: LIST
48477: PUSH
48478: LD_INT 0
48480: PUSH
48481: LD_INT 2
48483: NEG
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: PUSH
48489: LD_INT 1
48491: PUSH
48492: LD_INT 1
48494: NEG
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: PUSH
48500: LD_INT 2
48502: PUSH
48503: LD_INT 0
48505: PUSH
48506: EMPTY
48507: LIST
48508: LIST
48509: PUSH
48510: LD_INT 2
48512: PUSH
48513: LD_INT 1
48515: PUSH
48516: EMPTY
48517: LIST
48518: LIST
48519: PUSH
48520: LD_INT 2
48522: PUSH
48523: LD_INT 2
48525: PUSH
48526: EMPTY
48527: LIST
48528: LIST
48529: PUSH
48530: LD_INT 1
48532: PUSH
48533: LD_INT 2
48535: PUSH
48536: EMPTY
48537: LIST
48538: LIST
48539: PUSH
48540: LD_INT 0
48542: PUSH
48543: LD_INT 2
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PUSH
48550: LD_INT 1
48552: NEG
48553: PUSH
48554: LD_INT 1
48556: PUSH
48557: EMPTY
48558: LIST
48559: LIST
48560: PUSH
48561: LD_INT 2
48563: NEG
48564: PUSH
48565: LD_INT 0
48567: PUSH
48568: EMPTY
48569: LIST
48570: LIST
48571: PUSH
48572: LD_INT 2
48574: NEG
48575: PUSH
48576: LD_INT 1
48578: NEG
48579: PUSH
48580: EMPTY
48581: LIST
48582: LIST
48583: PUSH
48584: LD_INT 2
48586: NEG
48587: PUSH
48588: LD_INT 2
48590: NEG
48591: PUSH
48592: EMPTY
48593: LIST
48594: LIST
48595: PUSH
48596: EMPTY
48597: LIST
48598: LIST
48599: LIST
48600: LIST
48601: LIST
48602: LIST
48603: LIST
48604: LIST
48605: LIST
48606: LIST
48607: LIST
48608: LIST
48609: LIST
48610: LIST
48611: LIST
48612: LIST
48613: LIST
48614: LIST
48615: LIST
48616: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
48617: LD_ADDR_VAR 0 23
48621: PUSH
48622: LD_INT 0
48624: PUSH
48625: LD_INT 0
48627: PUSH
48628: EMPTY
48629: LIST
48630: LIST
48631: PUSH
48632: LD_INT 0
48634: PUSH
48635: LD_INT 1
48637: NEG
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: PUSH
48643: LD_INT 1
48645: PUSH
48646: LD_INT 0
48648: PUSH
48649: EMPTY
48650: LIST
48651: LIST
48652: PUSH
48653: LD_INT 1
48655: PUSH
48656: LD_INT 1
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: PUSH
48663: LD_INT 0
48665: PUSH
48666: LD_INT 1
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PUSH
48673: LD_INT 1
48675: NEG
48676: PUSH
48677: LD_INT 0
48679: PUSH
48680: EMPTY
48681: LIST
48682: LIST
48683: PUSH
48684: LD_INT 1
48686: NEG
48687: PUSH
48688: LD_INT 1
48690: NEG
48691: PUSH
48692: EMPTY
48693: LIST
48694: LIST
48695: PUSH
48696: LD_INT 1
48698: NEG
48699: PUSH
48700: LD_INT 2
48702: NEG
48703: PUSH
48704: EMPTY
48705: LIST
48706: LIST
48707: PUSH
48708: LD_INT 0
48710: PUSH
48711: LD_INT 2
48713: NEG
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: PUSH
48719: LD_INT 1
48721: PUSH
48722: LD_INT 1
48724: NEG
48725: PUSH
48726: EMPTY
48727: LIST
48728: LIST
48729: PUSH
48730: LD_INT 2
48732: PUSH
48733: LD_INT 0
48735: PUSH
48736: EMPTY
48737: LIST
48738: LIST
48739: PUSH
48740: LD_INT 2
48742: PUSH
48743: LD_INT 1
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: PUSH
48750: LD_INT 2
48752: PUSH
48753: LD_INT 2
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: PUSH
48760: LD_INT 1
48762: PUSH
48763: LD_INT 2
48765: PUSH
48766: EMPTY
48767: LIST
48768: LIST
48769: PUSH
48770: LD_INT 0
48772: PUSH
48773: LD_INT 2
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: PUSH
48780: LD_INT 1
48782: NEG
48783: PUSH
48784: LD_INT 1
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: PUSH
48791: LD_INT 2
48793: NEG
48794: PUSH
48795: LD_INT 0
48797: PUSH
48798: EMPTY
48799: LIST
48800: LIST
48801: PUSH
48802: LD_INT 2
48804: NEG
48805: PUSH
48806: LD_INT 1
48808: NEG
48809: PUSH
48810: EMPTY
48811: LIST
48812: LIST
48813: PUSH
48814: LD_INT 2
48816: NEG
48817: PUSH
48818: LD_INT 2
48820: NEG
48821: PUSH
48822: EMPTY
48823: LIST
48824: LIST
48825: PUSH
48826: LD_INT 2
48828: NEG
48829: PUSH
48830: LD_INT 3
48832: NEG
48833: PUSH
48834: EMPTY
48835: LIST
48836: LIST
48837: PUSH
48838: LD_INT 1
48840: NEG
48841: PUSH
48842: LD_INT 3
48844: NEG
48845: PUSH
48846: EMPTY
48847: LIST
48848: LIST
48849: PUSH
48850: LD_INT 1
48852: PUSH
48853: LD_INT 2
48855: NEG
48856: PUSH
48857: EMPTY
48858: LIST
48859: LIST
48860: PUSH
48861: LD_INT 2
48863: PUSH
48864: LD_INT 1
48866: NEG
48867: PUSH
48868: EMPTY
48869: LIST
48870: LIST
48871: PUSH
48872: EMPTY
48873: LIST
48874: LIST
48875: LIST
48876: LIST
48877: LIST
48878: LIST
48879: LIST
48880: LIST
48881: LIST
48882: LIST
48883: LIST
48884: LIST
48885: LIST
48886: LIST
48887: LIST
48888: LIST
48889: LIST
48890: LIST
48891: LIST
48892: LIST
48893: LIST
48894: LIST
48895: LIST
48896: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
48897: LD_ADDR_VAR 0 24
48901: PUSH
48902: LD_INT 0
48904: PUSH
48905: LD_INT 0
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: PUSH
48912: LD_INT 0
48914: PUSH
48915: LD_INT 1
48917: NEG
48918: PUSH
48919: EMPTY
48920: LIST
48921: LIST
48922: PUSH
48923: LD_INT 1
48925: PUSH
48926: LD_INT 0
48928: PUSH
48929: EMPTY
48930: LIST
48931: LIST
48932: PUSH
48933: LD_INT 1
48935: PUSH
48936: LD_INT 1
48938: PUSH
48939: EMPTY
48940: LIST
48941: LIST
48942: PUSH
48943: LD_INT 0
48945: PUSH
48946: LD_INT 1
48948: PUSH
48949: EMPTY
48950: LIST
48951: LIST
48952: PUSH
48953: LD_INT 1
48955: NEG
48956: PUSH
48957: LD_INT 0
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PUSH
48964: LD_INT 1
48966: NEG
48967: PUSH
48968: LD_INT 1
48970: NEG
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 1
48978: NEG
48979: PUSH
48980: LD_INT 2
48982: NEG
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: LD_INT 0
48990: PUSH
48991: LD_INT 2
48993: NEG
48994: PUSH
48995: EMPTY
48996: LIST
48997: LIST
48998: PUSH
48999: LD_INT 1
49001: PUSH
49002: LD_INT 1
49004: NEG
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 2
49012: PUSH
49013: LD_INT 0
49015: PUSH
49016: EMPTY
49017: LIST
49018: LIST
49019: PUSH
49020: LD_INT 2
49022: PUSH
49023: LD_INT 1
49025: PUSH
49026: EMPTY
49027: LIST
49028: LIST
49029: PUSH
49030: LD_INT 2
49032: PUSH
49033: LD_INT 2
49035: PUSH
49036: EMPTY
49037: LIST
49038: LIST
49039: PUSH
49040: LD_INT 1
49042: PUSH
49043: LD_INT 2
49045: PUSH
49046: EMPTY
49047: LIST
49048: LIST
49049: PUSH
49050: LD_INT 0
49052: PUSH
49053: LD_INT 2
49055: PUSH
49056: EMPTY
49057: LIST
49058: LIST
49059: PUSH
49060: LD_INT 1
49062: NEG
49063: PUSH
49064: LD_INT 1
49066: PUSH
49067: EMPTY
49068: LIST
49069: LIST
49070: PUSH
49071: LD_INT 2
49073: NEG
49074: PUSH
49075: LD_INT 0
49077: PUSH
49078: EMPTY
49079: LIST
49080: LIST
49081: PUSH
49082: LD_INT 2
49084: NEG
49085: PUSH
49086: LD_INT 1
49088: NEG
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: LD_INT 2
49096: NEG
49097: PUSH
49098: LD_INT 2
49100: NEG
49101: PUSH
49102: EMPTY
49103: LIST
49104: LIST
49105: PUSH
49106: LD_INT 1
49108: PUSH
49109: LD_INT 2
49111: NEG
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 2
49119: PUSH
49120: LD_INT 1
49122: NEG
49123: PUSH
49124: EMPTY
49125: LIST
49126: LIST
49127: PUSH
49128: LD_INT 3
49130: PUSH
49131: LD_INT 1
49133: PUSH
49134: EMPTY
49135: LIST
49136: LIST
49137: PUSH
49138: LD_INT 3
49140: PUSH
49141: LD_INT 2
49143: PUSH
49144: EMPTY
49145: LIST
49146: LIST
49147: PUSH
49148: EMPTY
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: LIST
49160: LIST
49161: LIST
49162: LIST
49163: LIST
49164: LIST
49165: LIST
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
49173: LD_ADDR_VAR 0 25
49177: PUSH
49178: LD_INT 0
49180: PUSH
49181: LD_INT 0
49183: PUSH
49184: EMPTY
49185: LIST
49186: LIST
49187: PUSH
49188: LD_INT 0
49190: PUSH
49191: LD_INT 1
49193: NEG
49194: PUSH
49195: EMPTY
49196: LIST
49197: LIST
49198: PUSH
49199: LD_INT 1
49201: PUSH
49202: LD_INT 0
49204: PUSH
49205: EMPTY
49206: LIST
49207: LIST
49208: PUSH
49209: LD_INT 1
49211: PUSH
49212: LD_INT 1
49214: PUSH
49215: EMPTY
49216: LIST
49217: LIST
49218: PUSH
49219: LD_INT 0
49221: PUSH
49222: LD_INT 1
49224: PUSH
49225: EMPTY
49226: LIST
49227: LIST
49228: PUSH
49229: LD_INT 1
49231: NEG
49232: PUSH
49233: LD_INT 0
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: LD_INT 1
49242: NEG
49243: PUSH
49244: LD_INT 1
49246: NEG
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PUSH
49252: LD_INT 1
49254: NEG
49255: PUSH
49256: LD_INT 2
49258: NEG
49259: PUSH
49260: EMPTY
49261: LIST
49262: LIST
49263: PUSH
49264: LD_INT 0
49266: PUSH
49267: LD_INT 2
49269: NEG
49270: PUSH
49271: EMPTY
49272: LIST
49273: LIST
49274: PUSH
49275: LD_INT 1
49277: PUSH
49278: LD_INT 1
49280: NEG
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: PUSH
49286: LD_INT 2
49288: PUSH
49289: LD_INT 0
49291: PUSH
49292: EMPTY
49293: LIST
49294: LIST
49295: PUSH
49296: LD_INT 2
49298: PUSH
49299: LD_INT 1
49301: PUSH
49302: EMPTY
49303: LIST
49304: LIST
49305: PUSH
49306: LD_INT 2
49308: PUSH
49309: LD_INT 2
49311: PUSH
49312: EMPTY
49313: LIST
49314: LIST
49315: PUSH
49316: LD_INT 1
49318: PUSH
49319: LD_INT 2
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 0
49328: PUSH
49329: LD_INT 2
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: LD_INT 1
49338: NEG
49339: PUSH
49340: LD_INT 1
49342: PUSH
49343: EMPTY
49344: LIST
49345: LIST
49346: PUSH
49347: LD_INT 2
49349: NEG
49350: PUSH
49351: LD_INT 0
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: PUSH
49358: LD_INT 2
49360: NEG
49361: PUSH
49362: LD_INT 1
49364: NEG
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: PUSH
49370: LD_INT 2
49372: NEG
49373: PUSH
49374: LD_INT 2
49376: NEG
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: PUSH
49382: LD_INT 3
49384: PUSH
49385: LD_INT 1
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 3
49394: PUSH
49395: LD_INT 2
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: PUSH
49402: LD_INT 2
49404: PUSH
49405: LD_INT 3
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: PUSH
49412: LD_INT 1
49414: PUSH
49415: LD_INT 3
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: LIST
49426: LIST
49427: LIST
49428: LIST
49429: LIST
49430: LIST
49431: LIST
49432: LIST
49433: LIST
49434: LIST
49435: LIST
49436: LIST
49437: LIST
49438: LIST
49439: LIST
49440: LIST
49441: LIST
49442: LIST
49443: LIST
49444: LIST
49445: LIST
49446: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
49447: LD_ADDR_VAR 0 26
49451: PUSH
49452: LD_INT 0
49454: PUSH
49455: LD_INT 0
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: LD_INT 0
49464: PUSH
49465: LD_INT 1
49467: NEG
49468: PUSH
49469: EMPTY
49470: LIST
49471: LIST
49472: PUSH
49473: LD_INT 1
49475: PUSH
49476: LD_INT 0
49478: PUSH
49479: EMPTY
49480: LIST
49481: LIST
49482: PUSH
49483: LD_INT 1
49485: PUSH
49486: LD_INT 1
49488: PUSH
49489: EMPTY
49490: LIST
49491: LIST
49492: PUSH
49493: LD_INT 0
49495: PUSH
49496: LD_INT 1
49498: PUSH
49499: EMPTY
49500: LIST
49501: LIST
49502: PUSH
49503: LD_INT 1
49505: NEG
49506: PUSH
49507: LD_INT 0
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: PUSH
49514: LD_INT 1
49516: NEG
49517: PUSH
49518: LD_INT 1
49520: NEG
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: LD_INT 1
49528: NEG
49529: PUSH
49530: LD_INT 2
49532: NEG
49533: PUSH
49534: EMPTY
49535: LIST
49536: LIST
49537: PUSH
49538: LD_INT 0
49540: PUSH
49541: LD_INT 2
49543: NEG
49544: PUSH
49545: EMPTY
49546: LIST
49547: LIST
49548: PUSH
49549: LD_INT 1
49551: PUSH
49552: LD_INT 1
49554: NEG
49555: PUSH
49556: EMPTY
49557: LIST
49558: LIST
49559: PUSH
49560: LD_INT 2
49562: PUSH
49563: LD_INT 0
49565: PUSH
49566: EMPTY
49567: LIST
49568: LIST
49569: PUSH
49570: LD_INT 2
49572: PUSH
49573: LD_INT 1
49575: PUSH
49576: EMPTY
49577: LIST
49578: LIST
49579: PUSH
49580: LD_INT 2
49582: PUSH
49583: LD_INT 2
49585: PUSH
49586: EMPTY
49587: LIST
49588: LIST
49589: PUSH
49590: LD_INT 1
49592: PUSH
49593: LD_INT 2
49595: PUSH
49596: EMPTY
49597: LIST
49598: LIST
49599: PUSH
49600: LD_INT 0
49602: PUSH
49603: LD_INT 2
49605: PUSH
49606: EMPTY
49607: LIST
49608: LIST
49609: PUSH
49610: LD_INT 1
49612: NEG
49613: PUSH
49614: LD_INT 1
49616: PUSH
49617: EMPTY
49618: LIST
49619: LIST
49620: PUSH
49621: LD_INT 2
49623: NEG
49624: PUSH
49625: LD_INT 0
49627: PUSH
49628: EMPTY
49629: LIST
49630: LIST
49631: PUSH
49632: LD_INT 2
49634: NEG
49635: PUSH
49636: LD_INT 1
49638: NEG
49639: PUSH
49640: EMPTY
49641: LIST
49642: LIST
49643: PUSH
49644: LD_INT 2
49646: NEG
49647: PUSH
49648: LD_INT 2
49650: NEG
49651: PUSH
49652: EMPTY
49653: LIST
49654: LIST
49655: PUSH
49656: LD_INT 2
49658: PUSH
49659: LD_INT 3
49661: PUSH
49662: EMPTY
49663: LIST
49664: LIST
49665: PUSH
49666: LD_INT 1
49668: PUSH
49669: LD_INT 3
49671: PUSH
49672: EMPTY
49673: LIST
49674: LIST
49675: PUSH
49676: LD_INT 1
49678: NEG
49679: PUSH
49680: LD_INT 2
49682: PUSH
49683: EMPTY
49684: LIST
49685: LIST
49686: PUSH
49687: LD_INT 2
49689: NEG
49690: PUSH
49691: LD_INT 1
49693: PUSH
49694: EMPTY
49695: LIST
49696: LIST
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: LIST
49702: LIST
49703: LIST
49704: LIST
49705: LIST
49706: LIST
49707: LIST
49708: LIST
49709: LIST
49710: LIST
49711: LIST
49712: LIST
49713: LIST
49714: LIST
49715: LIST
49716: LIST
49717: LIST
49718: LIST
49719: LIST
49720: LIST
49721: LIST
49722: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
49723: LD_ADDR_VAR 0 27
49727: PUSH
49728: LD_INT 0
49730: PUSH
49731: LD_INT 0
49733: PUSH
49734: EMPTY
49735: LIST
49736: LIST
49737: PUSH
49738: LD_INT 0
49740: PUSH
49741: LD_INT 1
49743: NEG
49744: PUSH
49745: EMPTY
49746: LIST
49747: LIST
49748: PUSH
49749: LD_INT 1
49751: PUSH
49752: LD_INT 0
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: PUSH
49759: LD_INT 1
49761: PUSH
49762: LD_INT 1
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: PUSH
49769: LD_INT 0
49771: PUSH
49772: LD_INT 1
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PUSH
49779: LD_INT 1
49781: NEG
49782: PUSH
49783: LD_INT 0
49785: PUSH
49786: EMPTY
49787: LIST
49788: LIST
49789: PUSH
49790: LD_INT 1
49792: NEG
49793: PUSH
49794: LD_INT 1
49796: NEG
49797: PUSH
49798: EMPTY
49799: LIST
49800: LIST
49801: PUSH
49802: LD_INT 1
49804: NEG
49805: PUSH
49806: LD_INT 2
49808: NEG
49809: PUSH
49810: EMPTY
49811: LIST
49812: LIST
49813: PUSH
49814: LD_INT 0
49816: PUSH
49817: LD_INT 2
49819: NEG
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: PUSH
49825: LD_INT 1
49827: PUSH
49828: LD_INT 1
49830: NEG
49831: PUSH
49832: EMPTY
49833: LIST
49834: LIST
49835: PUSH
49836: LD_INT 2
49838: PUSH
49839: LD_INT 0
49841: PUSH
49842: EMPTY
49843: LIST
49844: LIST
49845: PUSH
49846: LD_INT 2
49848: PUSH
49849: LD_INT 1
49851: PUSH
49852: EMPTY
49853: LIST
49854: LIST
49855: PUSH
49856: LD_INT 2
49858: PUSH
49859: LD_INT 2
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: LD_INT 1
49868: PUSH
49869: LD_INT 2
49871: PUSH
49872: EMPTY
49873: LIST
49874: LIST
49875: PUSH
49876: LD_INT 0
49878: PUSH
49879: LD_INT 2
49881: PUSH
49882: EMPTY
49883: LIST
49884: LIST
49885: PUSH
49886: LD_INT 1
49888: NEG
49889: PUSH
49890: LD_INT 1
49892: PUSH
49893: EMPTY
49894: LIST
49895: LIST
49896: PUSH
49897: LD_INT 2
49899: NEG
49900: PUSH
49901: LD_INT 0
49903: PUSH
49904: EMPTY
49905: LIST
49906: LIST
49907: PUSH
49908: LD_INT 2
49910: NEG
49911: PUSH
49912: LD_INT 1
49914: NEG
49915: PUSH
49916: EMPTY
49917: LIST
49918: LIST
49919: PUSH
49920: LD_INT 2
49922: NEG
49923: PUSH
49924: LD_INT 2
49926: NEG
49927: PUSH
49928: EMPTY
49929: LIST
49930: LIST
49931: PUSH
49932: LD_INT 1
49934: NEG
49935: PUSH
49936: LD_INT 2
49938: PUSH
49939: EMPTY
49940: LIST
49941: LIST
49942: PUSH
49943: LD_INT 2
49945: NEG
49946: PUSH
49947: LD_INT 1
49949: PUSH
49950: EMPTY
49951: LIST
49952: LIST
49953: PUSH
49954: LD_INT 3
49956: NEG
49957: PUSH
49958: LD_INT 1
49960: NEG
49961: PUSH
49962: EMPTY
49963: LIST
49964: LIST
49965: PUSH
49966: LD_INT 3
49968: NEG
49969: PUSH
49970: LD_INT 2
49972: NEG
49973: PUSH
49974: EMPTY
49975: LIST
49976: LIST
49977: PUSH
49978: EMPTY
49979: LIST
49980: LIST
49981: LIST
49982: LIST
49983: LIST
49984: LIST
49985: LIST
49986: LIST
49987: LIST
49988: LIST
49989: LIST
49990: LIST
49991: LIST
49992: LIST
49993: LIST
49994: LIST
49995: LIST
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: LIST
50001: LIST
50002: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
50003: LD_ADDR_VAR 0 28
50007: PUSH
50008: LD_INT 0
50010: PUSH
50011: LD_INT 0
50013: PUSH
50014: EMPTY
50015: LIST
50016: LIST
50017: PUSH
50018: LD_INT 0
50020: PUSH
50021: LD_INT 1
50023: NEG
50024: PUSH
50025: EMPTY
50026: LIST
50027: LIST
50028: PUSH
50029: LD_INT 1
50031: PUSH
50032: LD_INT 0
50034: PUSH
50035: EMPTY
50036: LIST
50037: LIST
50038: PUSH
50039: LD_INT 1
50041: PUSH
50042: LD_INT 1
50044: PUSH
50045: EMPTY
50046: LIST
50047: LIST
50048: PUSH
50049: LD_INT 0
50051: PUSH
50052: LD_INT 1
50054: PUSH
50055: EMPTY
50056: LIST
50057: LIST
50058: PUSH
50059: LD_INT 1
50061: NEG
50062: PUSH
50063: LD_INT 0
50065: PUSH
50066: EMPTY
50067: LIST
50068: LIST
50069: PUSH
50070: LD_INT 1
50072: NEG
50073: PUSH
50074: LD_INT 1
50076: NEG
50077: PUSH
50078: EMPTY
50079: LIST
50080: LIST
50081: PUSH
50082: LD_INT 1
50084: NEG
50085: PUSH
50086: LD_INT 2
50088: NEG
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: PUSH
50094: LD_INT 0
50096: PUSH
50097: LD_INT 2
50099: NEG
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PUSH
50105: LD_INT 1
50107: PUSH
50108: LD_INT 1
50110: NEG
50111: PUSH
50112: EMPTY
50113: LIST
50114: LIST
50115: PUSH
50116: LD_INT 2
50118: PUSH
50119: LD_INT 0
50121: PUSH
50122: EMPTY
50123: LIST
50124: LIST
50125: PUSH
50126: LD_INT 2
50128: PUSH
50129: LD_INT 1
50131: PUSH
50132: EMPTY
50133: LIST
50134: LIST
50135: PUSH
50136: LD_INT 2
50138: PUSH
50139: LD_INT 2
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: PUSH
50146: LD_INT 1
50148: PUSH
50149: LD_INT 2
50151: PUSH
50152: EMPTY
50153: LIST
50154: LIST
50155: PUSH
50156: LD_INT 0
50158: PUSH
50159: LD_INT 2
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PUSH
50166: LD_INT 1
50168: NEG
50169: PUSH
50170: LD_INT 1
50172: PUSH
50173: EMPTY
50174: LIST
50175: LIST
50176: PUSH
50177: LD_INT 2
50179: NEG
50180: PUSH
50181: LD_INT 0
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: LD_INT 2
50190: NEG
50191: PUSH
50192: LD_INT 1
50194: NEG
50195: PUSH
50196: EMPTY
50197: LIST
50198: LIST
50199: PUSH
50200: LD_INT 2
50202: NEG
50203: PUSH
50204: LD_INT 2
50206: NEG
50207: PUSH
50208: EMPTY
50209: LIST
50210: LIST
50211: PUSH
50212: LD_INT 2
50214: NEG
50215: PUSH
50216: LD_INT 3
50218: NEG
50219: PUSH
50220: EMPTY
50221: LIST
50222: LIST
50223: PUSH
50224: LD_INT 1
50226: NEG
50227: PUSH
50228: LD_INT 3
50230: NEG
50231: PUSH
50232: EMPTY
50233: LIST
50234: LIST
50235: PUSH
50236: LD_INT 3
50238: NEG
50239: PUSH
50240: LD_INT 1
50242: NEG
50243: PUSH
50244: EMPTY
50245: LIST
50246: LIST
50247: PUSH
50248: LD_INT 3
50250: NEG
50251: PUSH
50252: LD_INT 2
50254: NEG
50255: PUSH
50256: EMPTY
50257: LIST
50258: LIST
50259: PUSH
50260: EMPTY
50261: LIST
50262: LIST
50263: LIST
50264: LIST
50265: LIST
50266: LIST
50267: LIST
50268: LIST
50269: LIST
50270: LIST
50271: LIST
50272: LIST
50273: LIST
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: LIST
50281: LIST
50282: LIST
50283: LIST
50284: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
50285: LD_ADDR_VAR 0 29
50289: PUSH
50290: LD_INT 0
50292: PUSH
50293: LD_INT 0
50295: PUSH
50296: EMPTY
50297: LIST
50298: LIST
50299: PUSH
50300: LD_INT 0
50302: PUSH
50303: LD_INT 1
50305: NEG
50306: PUSH
50307: EMPTY
50308: LIST
50309: LIST
50310: PUSH
50311: LD_INT 1
50313: PUSH
50314: LD_INT 0
50316: PUSH
50317: EMPTY
50318: LIST
50319: LIST
50320: PUSH
50321: LD_INT 1
50323: PUSH
50324: LD_INT 1
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 0
50333: PUSH
50334: LD_INT 1
50336: PUSH
50337: EMPTY
50338: LIST
50339: LIST
50340: PUSH
50341: LD_INT 1
50343: NEG
50344: PUSH
50345: LD_INT 0
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 1
50354: NEG
50355: PUSH
50356: LD_INT 1
50358: NEG
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: PUSH
50364: LD_INT 1
50366: NEG
50367: PUSH
50368: LD_INT 2
50370: NEG
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: LD_INT 0
50378: PUSH
50379: LD_INT 2
50381: NEG
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: PUSH
50387: LD_INT 1
50389: PUSH
50390: LD_INT 1
50392: NEG
50393: PUSH
50394: EMPTY
50395: LIST
50396: LIST
50397: PUSH
50398: LD_INT 2
50400: PUSH
50401: LD_INT 0
50403: PUSH
50404: EMPTY
50405: LIST
50406: LIST
50407: PUSH
50408: LD_INT 2
50410: PUSH
50411: LD_INT 1
50413: PUSH
50414: EMPTY
50415: LIST
50416: LIST
50417: PUSH
50418: LD_INT 1
50420: PUSH
50421: LD_INT 2
50423: PUSH
50424: EMPTY
50425: LIST
50426: LIST
50427: PUSH
50428: LD_INT 0
50430: PUSH
50431: LD_INT 2
50433: PUSH
50434: EMPTY
50435: LIST
50436: LIST
50437: PUSH
50438: LD_INT 1
50440: NEG
50441: PUSH
50442: LD_INT 1
50444: PUSH
50445: EMPTY
50446: LIST
50447: LIST
50448: PUSH
50449: LD_INT 2
50451: NEG
50452: PUSH
50453: LD_INT 1
50455: NEG
50456: PUSH
50457: EMPTY
50458: LIST
50459: LIST
50460: PUSH
50461: LD_INT 2
50463: NEG
50464: PUSH
50465: LD_INT 2
50467: NEG
50468: PUSH
50469: EMPTY
50470: LIST
50471: LIST
50472: PUSH
50473: LD_INT 2
50475: NEG
50476: PUSH
50477: LD_INT 3
50479: NEG
50480: PUSH
50481: EMPTY
50482: LIST
50483: LIST
50484: PUSH
50485: LD_INT 2
50487: PUSH
50488: LD_INT 1
50490: NEG
50491: PUSH
50492: EMPTY
50493: LIST
50494: LIST
50495: PUSH
50496: LD_INT 3
50498: PUSH
50499: LD_INT 1
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: PUSH
50506: LD_INT 1
50508: PUSH
50509: LD_INT 3
50511: PUSH
50512: EMPTY
50513: LIST
50514: LIST
50515: PUSH
50516: LD_INT 1
50518: NEG
50519: PUSH
50520: LD_INT 2
50522: PUSH
50523: EMPTY
50524: LIST
50525: LIST
50526: PUSH
50527: LD_INT 3
50529: NEG
50530: PUSH
50531: LD_INT 2
50533: NEG
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: PUSH
50539: EMPTY
50540: LIST
50541: LIST
50542: LIST
50543: LIST
50544: LIST
50545: LIST
50546: LIST
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: LIST
50552: LIST
50553: LIST
50554: LIST
50555: LIST
50556: LIST
50557: LIST
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: LIST
50563: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
50564: LD_ADDR_VAR 0 30
50568: PUSH
50569: LD_INT 0
50571: PUSH
50572: LD_INT 0
50574: PUSH
50575: EMPTY
50576: LIST
50577: LIST
50578: PUSH
50579: LD_INT 0
50581: PUSH
50582: LD_INT 1
50584: NEG
50585: PUSH
50586: EMPTY
50587: LIST
50588: LIST
50589: PUSH
50590: LD_INT 1
50592: PUSH
50593: LD_INT 0
50595: PUSH
50596: EMPTY
50597: LIST
50598: LIST
50599: PUSH
50600: LD_INT 1
50602: PUSH
50603: LD_INT 1
50605: PUSH
50606: EMPTY
50607: LIST
50608: LIST
50609: PUSH
50610: LD_INT 0
50612: PUSH
50613: LD_INT 1
50615: PUSH
50616: EMPTY
50617: LIST
50618: LIST
50619: PUSH
50620: LD_INT 1
50622: NEG
50623: PUSH
50624: LD_INT 0
50626: PUSH
50627: EMPTY
50628: LIST
50629: LIST
50630: PUSH
50631: LD_INT 1
50633: NEG
50634: PUSH
50635: LD_INT 1
50637: NEG
50638: PUSH
50639: EMPTY
50640: LIST
50641: LIST
50642: PUSH
50643: LD_INT 1
50645: NEG
50646: PUSH
50647: LD_INT 2
50649: NEG
50650: PUSH
50651: EMPTY
50652: LIST
50653: LIST
50654: PUSH
50655: LD_INT 0
50657: PUSH
50658: LD_INT 2
50660: NEG
50661: PUSH
50662: EMPTY
50663: LIST
50664: LIST
50665: PUSH
50666: LD_INT 1
50668: PUSH
50669: LD_INT 1
50671: NEG
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: LD_INT 2
50679: PUSH
50680: LD_INT 0
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: PUSH
50687: LD_INT 2
50689: PUSH
50690: LD_INT 1
50692: PUSH
50693: EMPTY
50694: LIST
50695: LIST
50696: PUSH
50697: LD_INT 2
50699: PUSH
50700: LD_INT 2
50702: PUSH
50703: EMPTY
50704: LIST
50705: LIST
50706: PUSH
50707: LD_INT 1
50709: PUSH
50710: LD_INT 2
50712: PUSH
50713: EMPTY
50714: LIST
50715: LIST
50716: PUSH
50717: LD_INT 1
50719: NEG
50720: PUSH
50721: LD_INT 1
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: PUSH
50728: LD_INT 2
50730: NEG
50731: PUSH
50732: LD_INT 0
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 2
50741: NEG
50742: PUSH
50743: LD_INT 1
50745: NEG
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: PUSH
50751: LD_INT 1
50753: NEG
50754: PUSH
50755: LD_INT 3
50757: NEG
50758: PUSH
50759: EMPTY
50760: LIST
50761: LIST
50762: PUSH
50763: LD_INT 1
50765: PUSH
50766: LD_INT 2
50768: NEG
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: PUSH
50774: LD_INT 3
50776: PUSH
50777: LD_INT 2
50779: PUSH
50780: EMPTY
50781: LIST
50782: LIST
50783: PUSH
50784: LD_INT 2
50786: PUSH
50787: LD_INT 3
50789: PUSH
50790: EMPTY
50791: LIST
50792: LIST
50793: PUSH
50794: LD_INT 2
50796: NEG
50797: PUSH
50798: LD_INT 1
50800: PUSH
50801: EMPTY
50802: LIST
50803: LIST
50804: PUSH
50805: LD_INT 3
50807: NEG
50808: PUSH
50809: LD_INT 1
50811: NEG
50812: PUSH
50813: EMPTY
50814: LIST
50815: LIST
50816: PUSH
50817: EMPTY
50818: LIST
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: LIST
50826: LIST
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: LIST
50834: LIST
50835: LIST
50836: LIST
50837: LIST
50838: LIST
50839: LIST
50840: LIST
50841: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
50842: LD_ADDR_VAR 0 31
50846: PUSH
50847: LD_INT 0
50849: PUSH
50850: LD_INT 0
50852: PUSH
50853: EMPTY
50854: LIST
50855: LIST
50856: PUSH
50857: LD_INT 0
50859: PUSH
50860: LD_INT 1
50862: NEG
50863: PUSH
50864: EMPTY
50865: LIST
50866: LIST
50867: PUSH
50868: LD_INT 1
50870: PUSH
50871: LD_INT 0
50873: PUSH
50874: EMPTY
50875: LIST
50876: LIST
50877: PUSH
50878: LD_INT 1
50880: PUSH
50881: LD_INT 1
50883: PUSH
50884: EMPTY
50885: LIST
50886: LIST
50887: PUSH
50888: LD_INT 0
50890: PUSH
50891: LD_INT 1
50893: PUSH
50894: EMPTY
50895: LIST
50896: LIST
50897: PUSH
50898: LD_INT 1
50900: NEG
50901: PUSH
50902: LD_INT 0
50904: PUSH
50905: EMPTY
50906: LIST
50907: LIST
50908: PUSH
50909: LD_INT 1
50911: NEG
50912: PUSH
50913: LD_INT 1
50915: NEG
50916: PUSH
50917: EMPTY
50918: LIST
50919: LIST
50920: PUSH
50921: LD_INT 1
50923: NEG
50924: PUSH
50925: LD_INT 2
50927: NEG
50928: PUSH
50929: EMPTY
50930: LIST
50931: LIST
50932: PUSH
50933: LD_INT 1
50935: PUSH
50936: LD_INT 1
50938: NEG
50939: PUSH
50940: EMPTY
50941: LIST
50942: LIST
50943: PUSH
50944: LD_INT 2
50946: PUSH
50947: LD_INT 0
50949: PUSH
50950: EMPTY
50951: LIST
50952: LIST
50953: PUSH
50954: LD_INT 2
50956: PUSH
50957: LD_INT 1
50959: PUSH
50960: EMPTY
50961: LIST
50962: LIST
50963: PUSH
50964: LD_INT 2
50966: PUSH
50967: LD_INT 2
50969: PUSH
50970: EMPTY
50971: LIST
50972: LIST
50973: PUSH
50974: LD_INT 1
50976: PUSH
50977: LD_INT 2
50979: PUSH
50980: EMPTY
50981: LIST
50982: LIST
50983: PUSH
50984: LD_INT 0
50986: PUSH
50987: LD_INT 2
50989: PUSH
50990: EMPTY
50991: LIST
50992: LIST
50993: PUSH
50994: LD_INT 1
50996: NEG
50997: PUSH
50998: LD_INT 1
51000: PUSH
51001: EMPTY
51002: LIST
51003: LIST
51004: PUSH
51005: LD_INT 2
51007: NEG
51008: PUSH
51009: LD_INT 1
51011: NEG
51012: PUSH
51013: EMPTY
51014: LIST
51015: LIST
51016: PUSH
51017: LD_INT 2
51019: NEG
51020: PUSH
51021: LD_INT 2
51023: NEG
51024: PUSH
51025: EMPTY
51026: LIST
51027: LIST
51028: PUSH
51029: LD_INT 2
51031: NEG
51032: PUSH
51033: LD_INT 3
51035: NEG
51036: PUSH
51037: EMPTY
51038: LIST
51039: LIST
51040: PUSH
51041: LD_INT 2
51043: PUSH
51044: LD_INT 1
51046: NEG
51047: PUSH
51048: EMPTY
51049: LIST
51050: LIST
51051: PUSH
51052: LD_INT 3
51054: PUSH
51055: LD_INT 1
51057: PUSH
51058: EMPTY
51059: LIST
51060: LIST
51061: PUSH
51062: LD_INT 1
51064: PUSH
51065: LD_INT 3
51067: PUSH
51068: EMPTY
51069: LIST
51070: LIST
51071: PUSH
51072: LD_INT 1
51074: NEG
51075: PUSH
51076: LD_INT 2
51078: PUSH
51079: EMPTY
51080: LIST
51081: LIST
51082: PUSH
51083: LD_INT 3
51085: NEG
51086: PUSH
51087: LD_INT 2
51089: NEG
51090: PUSH
51091: EMPTY
51092: LIST
51093: LIST
51094: PUSH
51095: EMPTY
51096: LIST
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
51120: LD_ADDR_VAR 0 32
51124: PUSH
51125: LD_INT 0
51127: PUSH
51128: LD_INT 0
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: PUSH
51135: LD_INT 0
51137: PUSH
51138: LD_INT 1
51140: NEG
51141: PUSH
51142: EMPTY
51143: LIST
51144: LIST
51145: PUSH
51146: LD_INT 1
51148: PUSH
51149: LD_INT 0
51151: PUSH
51152: EMPTY
51153: LIST
51154: LIST
51155: PUSH
51156: LD_INT 1
51158: PUSH
51159: LD_INT 1
51161: PUSH
51162: EMPTY
51163: LIST
51164: LIST
51165: PUSH
51166: LD_INT 0
51168: PUSH
51169: LD_INT 1
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: PUSH
51176: LD_INT 1
51178: NEG
51179: PUSH
51180: LD_INT 0
51182: PUSH
51183: EMPTY
51184: LIST
51185: LIST
51186: PUSH
51187: LD_INT 1
51189: NEG
51190: PUSH
51191: LD_INT 1
51193: NEG
51194: PUSH
51195: EMPTY
51196: LIST
51197: LIST
51198: PUSH
51199: LD_INT 1
51201: NEG
51202: PUSH
51203: LD_INT 2
51205: NEG
51206: PUSH
51207: EMPTY
51208: LIST
51209: LIST
51210: PUSH
51211: LD_INT 0
51213: PUSH
51214: LD_INT 2
51216: NEG
51217: PUSH
51218: EMPTY
51219: LIST
51220: LIST
51221: PUSH
51222: LD_INT 1
51224: PUSH
51225: LD_INT 1
51227: NEG
51228: PUSH
51229: EMPTY
51230: LIST
51231: LIST
51232: PUSH
51233: LD_INT 2
51235: PUSH
51236: LD_INT 1
51238: PUSH
51239: EMPTY
51240: LIST
51241: LIST
51242: PUSH
51243: LD_INT 2
51245: PUSH
51246: LD_INT 2
51248: PUSH
51249: EMPTY
51250: LIST
51251: LIST
51252: PUSH
51253: LD_INT 1
51255: PUSH
51256: LD_INT 2
51258: PUSH
51259: EMPTY
51260: LIST
51261: LIST
51262: PUSH
51263: LD_INT 0
51265: PUSH
51266: LD_INT 2
51268: PUSH
51269: EMPTY
51270: LIST
51271: LIST
51272: PUSH
51273: LD_INT 1
51275: NEG
51276: PUSH
51277: LD_INT 1
51279: PUSH
51280: EMPTY
51281: LIST
51282: LIST
51283: PUSH
51284: LD_INT 2
51286: NEG
51287: PUSH
51288: LD_INT 0
51290: PUSH
51291: EMPTY
51292: LIST
51293: LIST
51294: PUSH
51295: LD_INT 2
51297: NEG
51298: PUSH
51299: LD_INT 1
51301: NEG
51302: PUSH
51303: EMPTY
51304: LIST
51305: LIST
51306: PUSH
51307: LD_INT 1
51309: NEG
51310: PUSH
51311: LD_INT 3
51313: NEG
51314: PUSH
51315: EMPTY
51316: LIST
51317: LIST
51318: PUSH
51319: LD_INT 1
51321: PUSH
51322: LD_INT 2
51324: NEG
51325: PUSH
51326: EMPTY
51327: LIST
51328: LIST
51329: PUSH
51330: LD_INT 3
51332: PUSH
51333: LD_INT 2
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: PUSH
51340: LD_INT 2
51342: PUSH
51343: LD_INT 3
51345: PUSH
51346: EMPTY
51347: LIST
51348: LIST
51349: PUSH
51350: LD_INT 2
51352: NEG
51353: PUSH
51354: LD_INT 1
51356: PUSH
51357: EMPTY
51358: LIST
51359: LIST
51360: PUSH
51361: LD_INT 3
51363: NEG
51364: PUSH
51365: LD_INT 1
51367: NEG
51368: PUSH
51369: EMPTY
51370: LIST
51371: LIST
51372: PUSH
51373: EMPTY
51374: LIST
51375: LIST
51376: LIST
51377: LIST
51378: LIST
51379: LIST
51380: LIST
51381: LIST
51382: LIST
51383: LIST
51384: LIST
51385: LIST
51386: LIST
51387: LIST
51388: LIST
51389: LIST
51390: LIST
51391: LIST
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
51398: LD_ADDR_VAR 0 33
51402: PUSH
51403: LD_INT 0
51405: PUSH
51406: LD_INT 0
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: PUSH
51413: LD_INT 0
51415: PUSH
51416: LD_INT 1
51418: NEG
51419: PUSH
51420: EMPTY
51421: LIST
51422: LIST
51423: PUSH
51424: LD_INT 1
51426: PUSH
51427: LD_INT 0
51429: PUSH
51430: EMPTY
51431: LIST
51432: LIST
51433: PUSH
51434: LD_INT 1
51436: PUSH
51437: LD_INT 1
51439: PUSH
51440: EMPTY
51441: LIST
51442: LIST
51443: PUSH
51444: LD_INT 0
51446: PUSH
51447: LD_INT 1
51449: PUSH
51450: EMPTY
51451: LIST
51452: LIST
51453: PUSH
51454: LD_INT 1
51456: NEG
51457: PUSH
51458: LD_INT 0
51460: PUSH
51461: EMPTY
51462: LIST
51463: LIST
51464: PUSH
51465: LD_INT 1
51467: NEG
51468: PUSH
51469: LD_INT 1
51471: NEG
51472: PUSH
51473: EMPTY
51474: LIST
51475: LIST
51476: PUSH
51477: LD_INT 1
51479: NEG
51480: PUSH
51481: LD_INT 2
51483: NEG
51484: PUSH
51485: EMPTY
51486: LIST
51487: LIST
51488: PUSH
51489: LD_INT 1
51491: PUSH
51492: LD_INT 1
51494: NEG
51495: PUSH
51496: EMPTY
51497: LIST
51498: LIST
51499: PUSH
51500: LD_INT 2
51502: PUSH
51503: LD_INT 0
51505: PUSH
51506: EMPTY
51507: LIST
51508: LIST
51509: PUSH
51510: LD_INT 2
51512: PUSH
51513: LD_INT 1
51515: PUSH
51516: EMPTY
51517: LIST
51518: LIST
51519: PUSH
51520: LD_INT 1
51522: PUSH
51523: LD_INT 2
51525: PUSH
51526: EMPTY
51527: LIST
51528: LIST
51529: PUSH
51530: LD_INT 0
51532: PUSH
51533: LD_INT 2
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: PUSH
51540: LD_INT 1
51542: NEG
51543: PUSH
51544: LD_INT 1
51546: PUSH
51547: EMPTY
51548: LIST
51549: LIST
51550: PUSH
51551: LD_INT 2
51553: NEG
51554: PUSH
51555: LD_INT 0
51557: PUSH
51558: EMPTY
51559: LIST
51560: LIST
51561: PUSH
51562: LD_INT 2
51564: NEG
51565: PUSH
51566: LD_INT 1
51568: NEG
51569: PUSH
51570: EMPTY
51571: LIST
51572: LIST
51573: PUSH
51574: LD_INT 2
51576: NEG
51577: PUSH
51578: LD_INT 2
51580: NEG
51581: PUSH
51582: EMPTY
51583: LIST
51584: LIST
51585: PUSH
51586: LD_INT 2
51588: NEG
51589: PUSH
51590: LD_INT 3
51592: NEG
51593: PUSH
51594: EMPTY
51595: LIST
51596: LIST
51597: PUSH
51598: LD_INT 2
51600: PUSH
51601: LD_INT 1
51603: NEG
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: PUSH
51609: LD_INT 3
51611: PUSH
51612: LD_INT 1
51614: PUSH
51615: EMPTY
51616: LIST
51617: LIST
51618: PUSH
51619: LD_INT 1
51621: PUSH
51622: LD_INT 3
51624: PUSH
51625: EMPTY
51626: LIST
51627: LIST
51628: PUSH
51629: LD_INT 1
51631: NEG
51632: PUSH
51633: LD_INT 2
51635: PUSH
51636: EMPTY
51637: LIST
51638: LIST
51639: PUSH
51640: LD_INT 3
51642: NEG
51643: PUSH
51644: LD_INT 2
51646: NEG
51647: PUSH
51648: EMPTY
51649: LIST
51650: LIST
51651: PUSH
51652: EMPTY
51653: LIST
51654: LIST
51655: LIST
51656: LIST
51657: LIST
51658: LIST
51659: LIST
51660: LIST
51661: LIST
51662: LIST
51663: LIST
51664: LIST
51665: LIST
51666: LIST
51667: LIST
51668: LIST
51669: LIST
51670: LIST
51671: LIST
51672: LIST
51673: LIST
51674: LIST
51675: LIST
51676: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
51677: LD_ADDR_VAR 0 34
51681: PUSH
51682: LD_INT 0
51684: PUSH
51685: LD_INT 0
51687: PUSH
51688: EMPTY
51689: LIST
51690: LIST
51691: PUSH
51692: LD_INT 0
51694: PUSH
51695: LD_INT 1
51697: NEG
51698: PUSH
51699: EMPTY
51700: LIST
51701: LIST
51702: PUSH
51703: LD_INT 1
51705: PUSH
51706: LD_INT 0
51708: PUSH
51709: EMPTY
51710: LIST
51711: LIST
51712: PUSH
51713: LD_INT 1
51715: PUSH
51716: LD_INT 1
51718: PUSH
51719: EMPTY
51720: LIST
51721: LIST
51722: PUSH
51723: LD_INT 0
51725: PUSH
51726: LD_INT 1
51728: PUSH
51729: EMPTY
51730: LIST
51731: LIST
51732: PUSH
51733: LD_INT 1
51735: NEG
51736: PUSH
51737: LD_INT 0
51739: PUSH
51740: EMPTY
51741: LIST
51742: LIST
51743: PUSH
51744: LD_INT 1
51746: NEG
51747: PUSH
51748: LD_INT 1
51750: NEG
51751: PUSH
51752: EMPTY
51753: LIST
51754: LIST
51755: PUSH
51756: LD_INT 1
51758: NEG
51759: PUSH
51760: LD_INT 2
51762: NEG
51763: PUSH
51764: EMPTY
51765: LIST
51766: LIST
51767: PUSH
51768: LD_INT 0
51770: PUSH
51771: LD_INT 2
51773: NEG
51774: PUSH
51775: EMPTY
51776: LIST
51777: LIST
51778: PUSH
51779: LD_INT 1
51781: PUSH
51782: LD_INT 1
51784: NEG
51785: PUSH
51786: EMPTY
51787: LIST
51788: LIST
51789: PUSH
51790: LD_INT 2
51792: PUSH
51793: LD_INT 1
51795: PUSH
51796: EMPTY
51797: LIST
51798: LIST
51799: PUSH
51800: LD_INT 2
51802: PUSH
51803: LD_INT 2
51805: PUSH
51806: EMPTY
51807: LIST
51808: LIST
51809: PUSH
51810: LD_INT 1
51812: PUSH
51813: LD_INT 2
51815: PUSH
51816: EMPTY
51817: LIST
51818: LIST
51819: PUSH
51820: LD_INT 1
51822: NEG
51823: PUSH
51824: LD_INT 1
51826: PUSH
51827: EMPTY
51828: LIST
51829: LIST
51830: PUSH
51831: LD_INT 2
51833: NEG
51834: PUSH
51835: LD_INT 0
51837: PUSH
51838: EMPTY
51839: LIST
51840: LIST
51841: PUSH
51842: LD_INT 2
51844: NEG
51845: PUSH
51846: LD_INT 1
51848: NEG
51849: PUSH
51850: EMPTY
51851: LIST
51852: LIST
51853: PUSH
51854: LD_INT 2
51856: NEG
51857: PUSH
51858: LD_INT 2
51860: NEG
51861: PUSH
51862: EMPTY
51863: LIST
51864: LIST
51865: PUSH
51866: LD_INT 1
51868: NEG
51869: PUSH
51870: LD_INT 3
51872: NEG
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: PUSH
51878: LD_INT 1
51880: PUSH
51881: LD_INT 2
51883: NEG
51884: PUSH
51885: EMPTY
51886: LIST
51887: LIST
51888: PUSH
51889: LD_INT 3
51891: PUSH
51892: LD_INT 2
51894: PUSH
51895: EMPTY
51896: LIST
51897: LIST
51898: PUSH
51899: LD_INT 2
51901: PUSH
51902: LD_INT 3
51904: PUSH
51905: EMPTY
51906: LIST
51907: LIST
51908: PUSH
51909: LD_INT 2
51911: NEG
51912: PUSH
51913: LD_INT 1
51915: PUSH
51916: EMPTY
51917: LIST
51918: LIST
51919: PUSH
51920: LD_INT 3
51922: NEG
51923: PUSH
51924: LD_INT 1
51926: NEG
51927: PUSH
51928: EMPTY
51929: LIST
51930: LIST
51931: PUSH
51932: EMPTY
51933: LIST
51934: LIST
51935: LIST
51936: LIST
51937: LIST
51938: LIST
51939: LIST
51940: LIST
51941: LIST
51942: LIST
51943: LIST
51944: LIST
51945: LIST
51946: LIST
51947: LIST
51948: LIST
51949: LIST
51950: LIST
51951: LIST
51952: LIST
51953: LIST
51954: LIST
51955: LIST
51956: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
51957: LD_ADDR_VAR 0 35
51961: PUSH
51962: LD_INT 0
51964: PUSH
51965: LD_INT 0
51967: PUSH
51968: EMPTY
51969: LIST
51970: LIST
51971: PUSH
51972: LD_INT 0
51974: PUSH
51975: LD_INT 1
51977: NEG
51978: PUSH
51979: EMPTY
51980: LIST
51981: LIST
51982: PUSH
51983: LD_INT 1
51985: PUSH
51986: LD_INT 0
51988: PUSH
51989: EMPTY
51990: LIST
51991: LIST
51992: PUSH
51993: LD_INT 1
51995: PUSH
51996: LD_INT 1
51998: PUSH
51999: EMPTY
52000: LIST
52001: LIST
52002: PUSH
52003: LD_INT 0
52005: PUSH
52006: LD_INT 1
52008: PUSH
52009: EMPTY
52010: LIST
52011: LIST
52012: PUSH
52013: LD_INT 1
52015: NEG
52016: PUSH
52017: LD_INT 0
52019: PUSH
52020: EMPTY
52021: LIST
52022: LIST
52023: PUSH
52024: LD_INT 1
52026: NEG
52027: PUSH
52028: LD_INT 1
52030: NEG
52031: PUSH
52032: EMPTY
52033: LIST
52034: LIST
52035: PUSH
52036: LD_INT 2
52038: PUSH
52039: LD_INT 1
52041: PUSH
52042: EMPTY
52043: LIST
52044: LIST
52045: PUSH
52046: LD_INT 2
52048: NEG
52049: PUSH
52050: LD_INT 1
52052: NEG
52053: PUSH
52054: EMPTY
52055: LIST
52056: LIST
52057: PUSH
52058: EMPTY
52059: LIST
52060: LIST
52061: LIST
52062: LIST
52063: LIST
52064: LIST
52065: LIST
52066: LIST
52067: LIST
52068: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
52069: LD_ADDR_VAR 0 36
52073: PUSH
52074: LD_INT 0
52076: PUSH
52077: LD_INT 0
52079: PUSH
52080: EMPTY
52081: LIST
52082: LIST
52083: PUSH
52084: LD_INT 0
52086: PUSH
52087: LD_INT 1
52089: NEG
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: PUSH
52095: LD_INT 1
52097: PUSH
52098: LD_INT 0
52100: PUSH
52101: EMPTY
52102: LIST
52103: LIST
52104: PUSH
52105: LD_INT 1
52107: PUSH
52108: LD_INT 1
52110: PUSH
52111: EMPTY
52112: LIST
52113: LIST
52114: PUSH
52115: LD_INT 0
52117: PUSH
52118: LD_INT 1
52120: PUSH
52121: EMPTY
52122: LIST
52123: LIST
52124: PUSH
52125: LD_INT 1
52127: NEG
52128: PUSH
52129: LD_INT 0
52131: PUSH
52132: EMPTY
52133: LIST
52134: LIST
52135: PUSH
52136: LD_INT 1
52138: NEG
52139: PUSH
52140: LD_INT 1
52142: NEG
52143: PUSH
52144: EMPTY
52145: LIST
52146: LIST
52147: PUSH
52148: LD_INT 1
52150: NEG
52151: PUSH
52152: LD_INT 2
52154: NEG
52155: PUSH
52156: EMPTY
52157: LIST
52158: LIST
52159: PUSH
52160: LD_INT 1
52162: PUSH
52163: LD_INT 2
52165: PUSH
52166: EMPTY
52167: LIST
52168: LIST
52169: PUSH
52170: EMPTY
52171: LIST
52172: LIST
52173: LIST
52174: LIST
52175: LIST
52176: LIST
52177: LIST
52178: LIST
52179: LIST
52180: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
52181: LD_ADDR_VAR 0 37
52185: PUSH
52186: LD_INT 0
52188: PUSH
52189: LD_INT 0
52191: PUSH
52192: EMPTY
52193: LIST
52194: LIST
52195: PUSH
52196: LD_INT 0
52198: PUSH
52199: LD_INT 1
52201: NEG
52202: PUSH
52203: EMPTY
52204: LIST
52205: LIST
52206: PUSH
52207: LD_INT 1
52209: PUSH
52210: LD_INT 0
52212: PUSH
52213: EMPTY
52214: LIST
52215: LIST
52216: PUSH
52217: LD_INT 1
52219: PUSH
52220: LD_INT 1
52222: PUSH
52223: EMPTY
52224: LIST
52225: LIST
52226: PUSH
52227: LD_INT 0
52229: PUSH
52230: LD_INT 1
52232: PUSH
52233: EMPTY
52234: LIST
52235: LIST
52236: PUSH
52237: LD_INT 1
52239: NEG
52240: PUSH
52241: LD_INT 0
52243: PUSH
52244: EMPTY
52245: LIST
52246: LIST
52247: PUSH
52248: LD_INT 1
52250: NEG
52251: PUSH
52252: LD_INT 1
52254: NEG
52255: PUSH
52256: EMPTY
52257: LIST
52258: LIST
52259: PUSH
52260: LD_INT 1
52262: PUSH
52263: LD_INT 1
52265: NEG
52266: PUSH
52267: EMPTY
52268: LIST
52269: LIST
52270: PUSH
52271: LD_INT 1
52273: NEG
52274: PUSH
52275: LD_INT 1
52277: PUSH
52278: EMPTY
52279: LIST
52280: LIST
52281: PUSH
52282: EMPTY
52283: LIST
52284: LIST
52285: LIST
52286: LIST
52287: LIST
52288: LIST
52289: LIST
52290: LIST
52291: LIST
52292: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
52293: LD_ADDR_VAR 0 38
52297: PUSH
52298: LD_INT 0
52300: PUSH
52301: LD_INT 0
52303: PUSH
52304: EMPTY
52305: LIST
52306: LIST
52307: PUSH
52308: LD_INT 0
52310: PUSH
52311: LD_INT 1
52313: NEG
52314: PUSH
52315: EMPTY
52316: LIST
52317: LIST
52318: PUSH
52319: LD_INT 1
52321: PUSH
52322: LD_INT 0
52324: PUSH
52325: EMPTY
52326: LIST
52327: LIST
52328: PUSH
52329: LD_INT 1
52331: PUSH
52332: LD_INT 1
52334: PUSH
52335: EMPTY
52336: LIST
52337: LIST
52338: PUSH
52339: LD_INT 0
52341: PUSH
52342: LD_INT 1
52344: PUSH
52345: EMPTY
52346: LIST
52347: LIST
52348: PUSH
52349: LD_INT 1
52351: NEG
52352: PUSH
52353: LD_INT 0
52355: PUSH
52356: EMPTY
52357: LIST
52358: LIST
52359: PUSH
52360: LD_INT 1
52362: NEG
52363: PUSH
52364: LD_INT 1
52366: NEG
52367: PUSH
52368: EMPTY
52369: LIST
52370: LIST
52371: PUSH
52372: LD_INT 2
52374: PUSH
52375: LD_INT 1
52377: PUSH
52378: EMPTY
52379: LIST
52380: LIST
52381: PUSH
52382: LD_INT 2
52384: NEG
52385: PUSH
52386: LD_INT 1
52388: NEG
52389: PUSH
52390: EMPTY
52391: LIST
52392: LIST
52393: PUSH
52394: EMPTY
52395: LIST
52396: LIST
52397: LIST
52398: LIST
52399: LIST
52400: LIST
52401: LIST
52402: LIST
52403: LIST
52404: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
52405: LD_ADDR_VAR 0 39
52409: PUSH
52410: LD_INT 0
52412: PUSH
52413: LD_INT 0
52415: PUSH
52416: EMPTY
52417: LIST
52418: LIST
52419: PUSH
52420: LD_INT 0
52422: PUSH
52423: LD_INT 1
52425: NEG
52426: PUSH
52427: EMPTY
52428: LIST
52429: LIST
52430: PUSH
52431: LD_INT 1
52433: PUSH
52434: LD_INT 0
52436: PUSH
52437: EMPTY
52438: LIST
52439: LIST
52440: PUSH
52441: LD_INT 1
52443: PUSH
52444: LD_INT 1
52446: PUSH
52447: EMPTY
52448: LIST
52449: LIST
52450: PUSH
52451: LD_INT 0
52453: PUSH
52454: LD_INT 1
52456: PUSH
52457: EMPTY
52458: LIST
52459: LIST
52460: PUSH
52461: LD_INT 1
52463: NEG
52464: PUSH
52465: LD_INT 0
52467: PUSH
52468: EMPTY
52469: LIST
52470: LIST
52471: PUSH
52472: LD_INT 1
52474: NEG
52475: PUSH
52476: LD_INT 1
52478: NEG
52479: PUSH
52480: EMPTY
52481: LIST
52482: LIST
52483: PUSH
52484: LD_INT 1
52486: NEG
52487: PUSH
52488: LD_INT 2
52490: NEG
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: PUSH
52496: LD_INT 1
52498: PUSH
52499: LD_INT 2
52501: PUSH
52502: EMPTY
52503: LIST
52504: LIST
52505: PUSH
52506: EMPTY
52507: LIST
52508: LIST
52509: LIST
52510: LIST
52511: LIST
52512: LIST
52513: LIST
52514: LIST
52515: LIST
52516: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
52517: LD_ADDR_VAR 0 40
52521: PUSH
52522: LD_INT 0
52524: PUSH
52525: LD_INT 0
52527: PUSH
52528: EMPTY
52529: LIST
52530: LIST
52531: PUSH
52532: LD_INT 0
52534: PUSH
52535: LD_INT 1
52537: NEG
52538: PUSH
52539: EMPTY
52540: LIST
52541: LIST
52542: PUSH
52543: LD_INT 1
52545: PUSH
52546: LD_INT 0
52548: PUSH
52549: EMPTY
52550: LIST
52551: LIST
52552: PUSH
52553: LD_INT 1
52555: PUSH
52556: LD_INT 1
52558: PUSH
52559: EMPTY
52560: LIST
52561: LIST
52562: PUSH
52563: LD_INT 0
52565: PUSH
52566: LD_INT 1
52568: PUSH
52569: EMPTY
52570: LIST
52571: LIST
52572: PUSH
52573: LD_INT 1
52575: NEG
52576: PUSH
52577: LD_INT 0
52579: PUSH
52580: EMPTY
52581: LIST
52582: LIST
52583: PUSH
52584: LD_INT 1
52586: NEG
52587: PUSH
52588: LD_INT 1
52590: NEG
52591: PUSH
52592: EMPTY
52593: LIST
52594: LIST
52595: PUSH
52596: LD_INT 1
52598: PUSH
52599: LD_INT 1
52601: NEG
52602: PUSH
52603: EMPTY
52604: LIST
52605: LIST
52606: PUSH
52607: LD_INT 1
52609: NEG
52610: PUSH
52611: LD_INT 1
52613: PUSH
52614: EMPTY
52615: LIST
52616: LIST
52617: PUSH
52618: EMPTY
52619: LIST
52620: LIST
52621: LIST
52622: LIST
52623: LIST
52624: LIST
52625: LIST
52626: LIST
52627: LIST
52628: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
52629: LD_ADDR_VAR 0 41
52633: PUSH
52634: LD_INT 0
52636: PUSH
52637: LD_INT 0
52639: PUSH
52640: EMPTY
52641: LIST
52642: LIST
52643: PUSH
52644: LD_INT 0
52646: PUSH
52647: LD_INT 1
52649: NEG
52650: PUSH
52651: EMPTY
52652: LIST
52653: LIST
52654: PUSH
52655: LD_INT 1
52657: PUSH
52658: LD_INT 0
52660: PUSH
52661: EMPTY
52662: LIST
52663: LIST
52664: PUSH
52665: LD_INT 1
52667: PUSH
52668: LD_INT 1
52670: PUSH
52671: EMPTY
52672: LIST
52673: LIST
52674: PUSH
52675: LD_INT 0
52677: PUSH
52678: LD_INT 1
52680: PUSH
52681: EMPTY
52682: LIST
52683: LIST
52684: PUSH
52685: LD_INT 1
52687: NEG
52688: PUSH
52689: LD_INT 0
52691: PUSH
52692: EMPTY
52693: LIST
52694: LIST
52695: PUSH
52696: LD_INT 1
52698: NEG
52699: PUSH
52700: LD_INT 1
52702: NEG
52703: PUSH
52704: EMPTY
52705: LIST
52706: LIST
52707: PUSH
52708: LD_INT 1
52710: NEG
52711: PUSH
52712: LD_INT 2
52714: NEG
52715: PUSH
52716: EMPTY
52717: LIST
52718: LIST
52719: PUSH
52720: LD_INT 1
52722: PUSH
52723: LD_INT 1
52725: NEG
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: PUSH
52731: LD_INT 2
52733: PUSH
52734: LD_INT 0
52736: PUSH
52737: EMPTY
52738: LIST
52739: LIST
52740: PUSH
52741: LD_INT 2
52743: PUSH
52744: LD_INT 1
52746: PUSH
52747: EMPTY
52748: LIST
52749: LIST
52750: PUSH
52751: LD_INT 2
52753: PUSH
52754: LD_INT 2
52756: PUSH
52757: EMPTY
52758: LIST
52759: LIST
52760: PUSH
52761: LD_INT 1
52763: PUSH
52764: LD_INT 2
52766: PUSH
52767: EMPTY
52768: LIST
52769: LIST
52770: PUSH
52771: LD_INT 1
52773: NEG
52774: PUSH
52775: LD_INT 1
52777: PUSH
52778: EMPTY
52779: LIST
52780: LIST
52781: PUSH
52782: LD_INT 2
52784: NEG
52785: PUSH
52786: LD_INT 0
52788: PUSH
52789: EMPTY
52790: LIST
52791: LIST
52792: PUSH
52793: LD_INT 2
52795: NEG
52796: PUSH
52797: LD_INT 1
52799: NEG
52800: PUSH
52801: EMPTY
52802: LIST
52803: LIST
52804: PUSH
52805: LD_INT 2
52807: NEG
52808: PUSH
52809: LD_INT 2
52811: NEG
52812: PUSH
52813: EMPTY
52814: LIST
52815: LIST
52816: PUSH
52817: LD_INT 2
52819: NEG
52820: PUSH
52821: LD_INT 3
52823: NEG
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: PUSH
52829: LD_INT 2
52831: PUSH
52832: LD_INT 1
52834: NEG
52835: PUSH
52836: EMPTY
52837: LIST
52838: LIST
52839: PUSH
52840: LD_INT 3
52842: PUSH
52843: LD_INT 0
52845: PUSH
52846: EMPTY
52847: LIST
52848: LIST
52849: PUSH
52850: LD_INT 3
52852: PUSH
52853: LD_INT 1
52855: PUSH
52856: EMPTY
52857: LIST
52858: LIST
52859: PUSH
52860: LD_INT 3
52862: PUSH
52863: LD_INT 2
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: PUSH
52870: LD_INT 3
52872: PUSH
52873: LD_INT 3
52875: PUSH
52876: EMPTY
52877: LIST
52878: LIST
52879: PUSH
52880: LD_INT 2
52882: PUSH
52883: LD_INT 3
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PUSH
52890: LD_INT 2
52892: NEG
52893: PUSH
52894: LD_INT 1
52896: PUSH
52897: EMPTY
52898: LIST
52899: LIST
52900: PUSH
52901: LD_INT 3
52903: NEG
52904: PUSH
52905: LD_INT 0
52907: PUSH
52908: EMPTY
52909: LIST
52910: LIST
52911: PUSH
52912: LD_INT 3
52914: NEG
52915: PUSH
52916: LD_INT 1
52918: NEG
52919: PUSH
52920: EMPTY
52921: LIST
52922: LIST
52923: PUSH
52924: LD_INT 3
52926: NEG
52927: PUSH
52928: LD_INT 2
52930: NEG
52931: PUSH
52932: EMPTY
52933: LIST
52934: LIST
52935: PUSH
52936: LD_INT 3
52938: NEG
52939: PUSH
52940: LD_INT 3
52942: NEG
52943: PUSH
52944: EMPTY
52945: LIST
52946: LIST
52947: PUSH
52948: EMPTY
52949: LIST
52950: LIST
52951: LIST
52952: LIST
52953: LIST
52954: LIST
52955: LIST
52956: LIST
52957: LIST
52958: LIST
52959: LIST
52960: LIST
52961: LIST
52962: LIST
52963: LIST
52964: LIST
52965: LIST
52966: LIST
52967: LIST
52968: LIST
52969: LIST
52970: LIST
52971: LIST
52972: LIST
52973: LIST
52974: LIST
52975: LIST
52976: LIST
52977: LIST
52978: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
52979: LD_ADDR_VAR 0 42
52983: PUSH
52984: LD_INT 0
52986: PUSH
52987: LD_INT 0
52989: PUSH
52990: EMPTY
52991: LIST
52992: LIST
52993: PUSH
52994: LD_INT 0
52996: PUSH
52997: LD_INT 1
52999: NEG
53000: PUSH
53001: EMPTY
53002: LIST
53003: LIST
53004: PUSH
53005: LD_INT 1
53007: PUSH
53008: LD_INT 0
53010: PUSH
53011: EMPTY
53012: LIST
53013: LIST
53014: PUSH
53015: LD_INT 1
53017: PUSH
53018: LD_INT 1
53020: PUSH
53021: EMPTY
53022: LIST
53023: LIST
53024: PUSH
53025: LD_INT 0
53027: PUSH
53028: LD_INT 1
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: PUSH
53035: LD_INT 1
53037: NEG
53038: PUSH
53039: LD_INT 0
53041: PUSH
53042: EMPTY
53043: LIST
53044: LIST
53045: PUSH
53046: LD_INT 1
53048: NEG
53049: PUSH
53050: LD_INT 1
53052: NEG
53053: PUSH
53054: EMPTY
53055: LIST
53056: LIST
53057: PUSH
53058: LD_INT 1
53060: NEG
53061: PUSH
53062: LD_INT 2
53064: NEG
53065: PUSH
53066: EMPTY
53067: LIST
53068: LIST
53069: PUSH
53070: LD_INT 0
53072: PUSH
53073: LD_INT 2
53075: NEG
53076: PUSH
53077: EMPTY
53078: LIST
53079: LIST
53080: PUSH
53081: LD_INT 1
53083: PUSH
53084: LD_INT 1
53086: NEG
53087: PUSH
53088: EMPTY
53089: LIST
53090: LIST
53091: PUSH
53092: LD_INT 2
53094: PUSH
53095: LD_INT 1
53097: PUSH
53098: EMPTY
53099: LIST
53100: LIST
53101: PUSH
53102: LD_INT 2
53104: PUSH
53105: LD_INT 2
53107: PUSH
53108: EMPTY
53109: LIST
53110: LIST
53111: PUSH
53112: LD_INT 1
53114: PUSH
53115: LD_INT 2
53117: PUSH
53118: EMPTY
53119: LIST
53120: LIST
53121: PUSH
53122: LD_INT 0
53124: PUSH
53125: LD_INT 2
53127: PUSH
53128: EMPTY
53129: LIST
53130: LIST
53131: PUSH
53132: LD_INT 1
53134: NEG
53135: PUSH
53136: LD_INT 1
53138: PUSH
53139: EMPTY
53140: LIST
53141: LIST
53142: PUSH
53143: LD_INT 2
53145: NEG
53146: PUSH
53147: LD_INT 1
53149: NEG
53150: PUSH
53151: EMPTY
53152: LIST
53153: LIST
53154: PUSH
53155: LD_INT 2
53157: NEG
53158: PUSH
53159: LD_INT 2
53161: NEG
53162: PUSH
53163: EMPTY
53164: LIST
53165: LIST
53166: PUSH
53167: LD_INT 2
53169: NEG
53170: PUSH
53171: LD_INT 3
53173: NEG
53174: PUSH
53175: EMPTY
53176: LIST
53177: LIST
53178: PUSH
53179: LD_INT 1
53181: NEG
53182: PUSH
53183: LD_INT 3
53185: NEG
53186: PUSH
53187: EMPTY
53188: LIST
53189: LIST
53190: PUSH
53191: LD_INT 0
53193: PUSH
53194: LD_INT 3
53196: NEG
53197: PUSH
53198: EMPTY
53199: LIST
53200: LIST
53201: PUSH
53202: LD_INT 1
53204: PUSH
53205: LD_INT 2
53207: NEG
53208: PUSH
53209: EMPTY
53210: LIST
53211: LIST
53212: PUSH
53213: LD_INT 3
53215: PUSH
53216: LD_INT 2
53218: PUSH
53219: EMPTY
53220: LIST
53221: LIST
53222: PUSH
53223: LD_INT 3
53225: PUSH
53226: LD_INT 3
53228: PUSH
53229: EMPTY
53230: LIST
53231: LIST
53232: PUSH
53233: LD_INT 2
53235: PUSH
53236: LD_INT 3
53238: PUSH
53239: EMPTY
53240: LIST
53241: LIST
53242: PUSH
53243: LD_INT 1
53245: PUSH
53246: LD_INT 3
53248: PUSH
53249: EMPTY
53250: LIST
53251: LIST
53252: PUSH
53253: LD_INT 0
53255: PUSH
53256: LD_INT 3
53258: PUSH
53259: EMPTY
53260: LIST
53261: LIST
53262: PUSH
53263: LD_INT 1
53265: NEG
53266: PUSH
53267: LD_INT 2
53269: PUSH
53270: EMPTY
53271: LIST
53272: LIST
53273: PUSH
53274: LD_INT 3
53276: NEG
53277: PUSH
53278: LD_INT 2
53280: NEG
53281: PUSH
53282: EMPTY
53283: LIST
53284: LIST
53285: PUSH
53286: LD_INT 3
53288: NEG
53289: PUSH
53290: LD_INT 3
53292: NEG
53293: PUSH
53294: EMPTY
53295: LIST
53296: LIST
53297: PUSH
53298: EMPTY
53299: LIST
53300: LIST
53301: LIST
53302: LIST
53303: LIST
53304: LIST
53305: LIST
53306: LIST
53307: LIST
53308: LIST
53309: LIST
53310: LIST
53311: LIST
53312: LIST
53313: LIST
53314: LIST
53315: LIST
53316: LIST
53317: LIST
53318: LIST
53319: LIST
53320: LIST
53321: LIST
53322: LIST
53323: LIST
53324: LIST
53325: LIST
53326: LIST
53327: LIST
53328: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
53329: LD_ADDR_VAR 0 43
53333: PUSH
53334: LD_INT 0
53336: PUSH
53337: LD_INT 0
53339: PUSH
53340: EMPTY
53341: LIST
53342: LIST
53343: PUSH
53344: LD_INT 0
53346: PUSH
53347: LD_INT 1
53349: NEG
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: PUSH
53355: LD_INT 1
53357: PUSH
53358: LD_INT 0
53360: PUSH
53361: EMPTY
53362: LIST
53363: LIST
53364: PUSH
53365: LD_INT 1
53367: PUSH
53368: LD_INT 1
53370: PUSH
53371: EMPTY
53372: LIST
53373: LIST
53374: PUSH
53375: LD_INT 0
53377: PUSH
53378: LD_INT 1
53380: PUSH
53381: EMPTY
53382: LIST
53383: LIST
53384: PUSH
53385: LD_INT 1
53387: NEG
53388: PUSH
53389: LD_INT 0
53391: PUSH
53392: EMPTY
53393: LIST
53394: LIST
53395: PUSH
53396: LD_INT 1
53398: NEG
53399: PUSH
53400: LD_INT 1
53402: NEG
53403: PUSH
53404: EMPTY
53405: LIST
53406: LIST
53407: PUSH
53408: LD_INT 1
53410: NEG
53411: PUSH
53412: LD_INT 2
53414: NEG
53415: PUSH
53416: EMPTY
53417: LIST
53418: LIST
53419: PUSH
53420: LD_INT 0
53422: PUSH
53423: LD_INT 2
53425: NEG
53426: PUSH
53427: EMPTY
53428: LIST
53429: LIST
53430: PUSH
53431: LD_INT 1
53433: PUSH
53434: LD_INT 1
53436: NEG
53437: PUSH
53438: EMPTY
53439: LIST
53440: LIST
53441: PUSH
53442: LD_INT 2
53444: PUSH
53445: LD_INT 0
53447: PUSH
53448: EMPTY
53449: LIST
53450: LIST
53451: PUSH
53452: LD_INT 2
53454: PUSH
53455: LD_INT 1
53457: PUSH
53458: EMPTY
53459: LIST
53460: LIST
53461: PUSH
53462: LD_INT 1
53464: PUSH
53465: LD_INT 2
53467: PUSH
53468: EMPTY
53469: LIST
53470: LIST
53471: PUSH
53472: LD_INT 0
53474: PUSH
53475: LD_INT 2
53477: PUSH
53478: EMPTY
53479: LIST
53480: LIST
53481: PUSH
53482: LD_INT 1
53484: NEG
53485: PUSH
53486: LD_INT 1
53488: PUSH
53489: EMPTY
53490: LIST
53491: LIST
53492: PUSH
53493: LD_INT 2
53495: NEG
53496: PUSH
53497: LD_INT 0
53499: PUSH
53500: EMPTY
53501: LIST
53502: LIST
53503: PUSH
53504: LD_INT 2
53506: NEG
53507: PUSH
53508: LD_INT 1
53510: NEG
53511: PUSH
53512: EMPTY
53513: LIST
53514: LIST
53515: PUSH
53516: LD_INT 1
53518: NEG
53519: PUSH
53520: LD_INT 3
53522: NEG
53523: PUSH
53524: EMPTY
53525: LIST
53526: LIST
53527: PUSH
53528: LD_INT 0
53530: PUSH
53531: LD_INT 3
53533: NEG
53534: PUSH
53535: EMPTY
53536: LIST
53537: LIST
53538: PUSH
53539: LD_INT 1
53541: PUSH
53542: LD_INT 2
53544: NEG
53545: PUSH
53546: EMPTY
53547: LIST
53548: LIST
53549: PUSH
53550: LD_INT 2
53552: PUSH
53553: LD_INT 1
53555: NEG
53556: PUSH
53557: EMPTY
53558: LIST
53559: LIST
53560: PUSH
53561: LD_INT 3
53563: PUSH
53564: LD_INT 0
53566: PUSH
53567: EMPTY
53568: LIST
53569: LIST
53570: PUSH
53571: LD_INT 3
53573: PUSH
53574: LD_INT 1
53576: PUSH
53577: EMPTY
53578: LIST
53579: LIST
53580: PUSH
53581: LD_INT 1
53583: PUSH
53584: LD_INT 3
53586: PUSH
53587: EMPTY
53588: LIST
53589: LIST
53590: PUSH
53591: LD_INT 0
53593: PUSH
53594: LD_INT 3
53596: PUSH
53597: EMPTY
53598: LIST
53599: LIST
53600: PUSH
53601: LD_INT 1
53603: NEG
53604: PUSH
53605: LD_INT 2
53607: PUSH
53608: EMPTY
53609: LIST
53610: LIST
53611: PUSH
53612: LD_INT 2
53614: NEG
53615: PUSH
53616: LD_INT 1
53618: PUSH
53619: EMPTY
53620: LIST
53621: LIST
53622: PUSH
53623: LD_INT 3
53625: NEG
53626: PUSH
53627: LD_INT 0
53629: PUSH
53630: EMPTY
53631: LIST
53632: LIST
53633: PUSH
53634: LD_INT 3
53636: NEG
53637: PUSH
53638: LD_INT 1
53640: NEG
53641: PUSH
53642: EMPTY
53643: LIST
53644: LIST
53645: PUSH
53646: EMPTY
53647: LIST
53648: LIST
53649: LIST
53650: LIST
53651: LIST
53652: LIST
53653: LIST
53654: LIST
53655: LIST
53656: LIST
53657: LIST
53658: LIST
53659: LIST
53660: LIST
53661: LIST
53662: LIST
53663: LIST
53664: LIST
53665: LIST
53666: LIST
53667: LIST
53668: LIST
53669: LIST
53670: LIST
53671: LIST
53672: LIST
53673: LIST
53674: LIST
53675: LIST
53676: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
53677: LD_ADDR_VAR 0 44
53681: PUSH
53682: LD_INT 0
53684: PUSH
53685: LD_INT 0
53687: PUSH
53688: EMPTY
53689: LIST
53690: LIST
53691: PUSH
53692: LD_INT 0
53694: PUSH
53695: LD_INT 1
53697: NEG
53698: PUSH
53699: EMPTY
53700: LIST
53701: LIST
53702: PUSH
53703: LD_INT 1
53705: PUSH
53706: LD_INT 0
53708: PUSH
53709: EMPTY
53710: LIST
53711: LIST
53712: PUSH
53713: LD_INT 1
53715: PUSH
53716: LD_INT 1
53718: PUSH
53719: EMPTY
53720: LIST
53721: LIST
53722: PUSH
53723: LD_INT 0
53725: PUSH
53726: LD_INT 1
53728: PUSH
53729: EMPTY
53730: LIST
53731: LIST
53732: PUSH
53733: LD_INT 1
53735: NEG
53736: PUSH
53737: LD_INT 0
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: PUSH
53744: LD_INT 1
53746: NEG
53747: PUSH
53748: LD_INT 1
53750: NEG
53751: PUSH
53752: EMPTY
53753: LIST
53754: LIST
53755: PUSH
53756: LD_INT 1
53758: NEG
53759: PUSH
53760: LD_INT 2
53762: NEG
53763: PUSH
53764: EMPTY
53765: LIST
53766: LIST
53767: PUSH
53768: LD_INT 1
53770: PUSH
53771: LD_INT 1
53773: NEG
53774: PUSH
53775: EMPTY
53776: LIST
53777: LIST
53778: PUSH
53779: LD_INT 2
53781: PUSH
53782: LD_INT 0
53784: PUSH
53785: EMPTY
53786: LIST
53787: LIST
53788: PUSH
53789: LD_INT 2
53791: PUSH
53792: LD_INT 1
53794: PUSH
53795: EMPTY
53796: LIST
53797: LIST
53798: PUSH
53799: LD_INT 2
53801: PUSH
53802: LD_INT 2
53804: PUSH
53805: EMPTY
53806: LIST
53807: LIST
53808: PUSH
53809: LD_INT 1
53811: PUSH
53812: LD_INT 2
53814: PUSH
53815: EMPTY
53816: LIST
53817: LIST
53818: PUSH
53819: LD_INT 1
53821: NEG
53822: PUSH
53823: LD_INT 1
53825: PUSH
53826: EMPTY
53827: LIST
53828: LIST
53829: PUSH
53830: LD_INT 2
53832: NEG
53833: PUSH
53834: LD_INT 0
53836: PUSH
53837: EMPTY
53838: LIST
53839: LIST
53840: PUSH
53841: LD_INT 2
53843: NEG
53844: PUSH
53845: LD_INT 1
53847: NEG
53848: PUSH
53849: EMPTY
53850: LIST
53851: LIST
53852: PUSH
53853: LD_INT 2
53855: NEG
53856: PUSH
53857: LD_INT 2
53859: NEG
53860: PUSH
53861: EMPTY
53862: LIST
53863: LIST
53864: PUSH
53865: LD_INT 2
53867: NEG
53868: PUSH
53869: LD_INT 3
53871: NEG
53872: PUSH
53873: EMPTY
53874: LIST
53875: LIST
53876: PUSH
53877: LD_INT 2
53879: PUSH
53880: LD_INT 1
53882: NEG
53883: PUSH
53884: EMPTY
53885: LIST
53886: LIST
53887: PUSH
53888: LD_INT 3
53890: PUSH
53891: LD_INT 0
53893: PUSH
53894: EMPTY
53895: LIST
53896: LIST
53897: PUSH
53898: LD_INT 3
53900: PUSH
53901: LD_INT 1
53903: PUSH
53904: EMPTY
53905: LIST
53906: LIST
53907: PUSH
53908: LD_INT 3
53910: PUSH
53911: LD_INT 2
53913: PUSH
53914: EMPTY
53915: LIST
53916: LIST
53917: PUSH
53918: LD_INT 3
53920: PUSH
53921: LD_INT 3
53923: PUSH
53924: EMPTY
53925: LIST
53926: LIST
53927: PUSH
53928: LD_INT 2
53930: PUSH
53931: LD_INT 3
53933: PUSH
53934: EMPTY
53935: LIST
53936: LIST
53937: PUSH
53938: LD_INT 2
53940: NEG
53941: PUSH
53942: LD_INT 1
53944: PUSH
53945: EMPTY
53946: LIST
53947: LIST
53948: PUSH
53949: LD_INT 3
53951: NEG
53952: PUSH
53953: LD_INT 0
53955: PUSH
53956: EMPTY
53957: LIST
53958: LIST
53959: PUSH
53960: LD_INT 3
53962: NEG
53963: PUSH
53964: LD_INT 1
53966: NEG
53967: PUSH
53968: EMPTY
53969: LIST
53970: LIST
53971: PUSH
53972: LD_INT 3
53974: NEG
53975: PUSH
53976: LD_INT 2
53978: NEG
53979: PUSH
53980: EMPTY
53981: LIST
53982: LIST
53983: PUSH
53984: LD_INT 3
53986: NEG
53987: PUSH
53988: LD_INT 3
53990: NEG
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: PUSH
53996: EMPTY
53997: LIST
53998: LIST
53999: LIST
54000: LIST
54001: LIST
54002: LIST
54003: LIST
54004: LIST
54005: LIST
54006: LIST
54007: LIST
54008: LIST
54009: LIST
54010: LIST
54011: LIST
54012: LIST
54013: LIST
54014: LIST
54015: LIST
54016: LIST
54017: LIST
54018: LIST
54019: LIST
54020: LIST
54021: LIST
54022: LIST
54023: LIST
54024: LIST
54025: LIST
54026: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
54027: LD_ADDR_VAR 0 45
54031: PUSH
54032: LD_INT 0
54034: PUSH
54035: LD_INT 0
54037: PUSH
54038: EMPTY
54039: LIST
54040: LIST
54041: PUSH
54042: LD_INT 0
54044: PUSH
54045: LD_INT 1
54047: NEG
54048: PUSH
54049: EMPTY
54050: LIST
54051: LIST
54052: PUSH
54053: LD_INT 1
54055: PUSH
54056: LD_INT 0
54058: PUSH
54059: EMPTY
54060: LIST
54061: LIST
54062: PUSH
54063: LD_INT 1
54065: PUSH
54066: LD_INT 1
54068: PUSH
54069: EMPTY
54070: LIST
54071: LIST
54072: PUSH
54073: LD_INT 0
54075: PUSH
54076: LD_INT 1
54078: PUSH
54079: EMPTY
54080: LIST
54081: LIST
54082: PUSH
54083: LD_INT 1
54085: NEG
54086: PUSH
54087: LD_INT 0
54089: PUSH
54090: EMPTY
54091: LIST
54092: LIST
54093: PUSH
54094: LD_INT 1
54096: NEG
54097: PUSH
54098: LD_INT 1
54100: NEG
54101: PUSH
54102: EMPTY
54103: LIST
54104: LIST
54105: PUSH
54106: LD_INT 1
54108: NEG
54109: PUSH
54110: LD_INT 2
54112: NEG
54113: PUSH
54114: EMPTY
54115: LIST
54116: LIST
54117: PUSH
54118: LD_INT 0
54120: PUSH
54121: LD_INT 2
54123: NEG
54124: PUSH
54125: EMPTY
54126: LIST
54127: LIST
54128: PUSH
54129: LD_INT 1
54131: PUSH
54132: LD_INT 1
54134: NEG
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: PUSH
54140: LD_INT 2
54142: PUSH
54143: LD_INT 1
54145: PUSH
54146: EMPTY
54147: LIST
54148: LIST
54149: PUSH
54150: LD_INT 2
54152: PUSH
54153: LD_INT 2
54155: PUSH
54156: EMPTY
54157: LIST
54158: LIST
54159: PUSH
54160: LD_INT 1
54162: PUSH
54163: LD_INT 2
54165: PUSH
54166: EMPTY
54167: LIST
54168: LIST
54169: PUSH
54170: LD_INT 0
54172: PUSH
54173: LD_INT 2
54175: PUSH
54176: EMPTY
54177: LIST
54178: LIST
54179: PUSH
54180: LD_INT 1
54182: NEG
54183: PUSH
54184: LD_INT 1
54186: PUSH
54187: EMPTY
54188: LIST
54189: LIST
54190: PUSH
54191: LD_INT 2
54193: NEG
54194: PUSH
54195: LD_INT 1
54197: NEG
54198: PUSH
54199: EMPTY
54200: LIST
54201: LIST
54202: PUSH
54203: LD_INT 2
54205: NEG
54206: PUSH
54207: LD_INT 2
54209: NEG
54210: PUSH
54211: EMPTY
54212: LIST
54213: LIST
54214: PUSH
54215: LD_INT 2
54217: NEG
54218: PUSH
54219: LD_INT 3
54221: NEG
54222: PUSH
54223: EMPTY
54224: LIST
54225: LIST
54226: PUSH
54227: LD_INT 1
54229: NEG
54230: PUSH
54231: LD_INT 3
54233: NEG
54234: PUSH
54235: EMPTY
54236: LIST
54237: LIST
54238: PUSH
54239: LD_INT 0
54241: PUSH
54242: LD_INT 3
54244: NEG
54245: PUSH
54246: EMPTY
54247: LIST
54248: LIST
54249: PUSH
54250: LD_INT 1
54252: PUSH
54253: LD_INT 2
54255: NEG
54256: PUSH
54257: EMPTY
54258: LIST
54259: LIST
54260: PUSH
54261: LD_INT 3
54263: PUSH
54264: LD_INT 2
54266: PUSH
54267: EMPTY
54268: LIST
54269: LIST
54270: PUSH
54271: LD_INT 3
54273: PUSH
54274: LD_INT 3
54276: PUSH
54277: EMPTY
54278: LIST
54279: LIST
54280: PUSH
54281: LD_INT 2
54283: PUSH
54284: LD_INT 3
54286: PUSH
54287: EMPTY
54288: LIST
54289: LIST
54290: PUSH
54291: LD_INT 1
54293: PUSH
54294: LD_INT 3
54296: PUSH
54297: EMPTY
54298: LIST
54299: LIST
54300: PUSH
54301: LD_INT 0
54303: PUSH
54304: LD_INT 3
54306: PUSH
54307: EMPTY
54308: LIST
54309: LIST
54310: PUSH
54311: LD_INT 1
54313: NEG
54314: PUSH
54315: LD_INT 2
54317: PUSH
54318: EMPTY
54319: LIST
54320: LIST
54321: PUSH
54322: LD_INT 3
54324: NEG
54325: PUSH
54326: LD_INT 2
54328: NEG
54329: PUSH
54330: EMPTY
54331: LIST
54332: LIST
54333: PUSH
54334: LD_INT 3
54336: NEG
54337: PUSH
54338: LD_INT 3
54340: NEG
54341: PUSH
54342: EMPTY
54343: LIST
54344: LIST
54345: PUSH
54346: EMPTY
54347: LIST
54348: LIST
54349: LIST
54350: LIST
54351: LIST
54352: LIST
54353: LIST
54354: LIST
54355: LIST
54356: LIST
54357: LIST
54358: LIST
54359: LIST
54360: LIST
54361: LIST
54362: LIST
54363: LIST
54364: LIST
54365: LIST
54366: LIST
54367: LIST
54368: LIST
54369: LIST
54370: LIST
54371: LIST
54372: LIST
54373: LIST
54374: LIST
54375: LIST
54376: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
54377: LD_ADDR_VAR 0 46
54381: PUSH
54382: LD_INT 0
54384: PUSH
54385: LD_INT 0
54387: PUSH
54388: EMPTY
54389: LIST
54390: LIST
54391: PUSH
54392: LD_INT 0
54394: PUSH
54395: LD_INT 1
54397: NEG
54398: PUSH
54399: EMPTY
54400: LIST
54401: LIST
54402: PUSH
54403: LD_INT 1
54405: PUSH
54406: LD_INT 0
54408: PUSH
54409: EMPTY
54410: LIST
54411: LIST
54412: PUSH
54413: LD_INT 1
54415: PUSH
54416: LD_INT 1
54418: PUSH
54419: EMPTY
54420: LIST
54421: LIST
54422: PUSH
54423: LD_INT 0
54425: PUSH
54426: LD_INT 1
54428: PUSH
54429: EMPTY
54430: LIST
54431: LIST
54432: PUSH
54433: LD_INT 1
54435: NEG
54436: PUSH
54437: LD_INT 0
54439: PUSH
54440: EMPTY
54441: LIST
54442: LIST
54443: PUSH
54444: LD_INT 1
54446: NEG
54447: PUSH
54448: LD_INT 1
54450: NEG
54451: PUSH
54452: EMPTY
54453: LIST
54454: LIST
54455: PUSH
54456: LD_INT 1
54458: NEG
54459: PUSH
54460: LD_INT 2
54462: NEG
54463: PUSH
54464: EMPTY
54465: LIST
54466: LIST
54467: PUSH
54468: LD_INT 0
54470: PUSH
54471: LD_INT 2
54473: NEG
54474: PUSH
54475: EMPTY
54476: LIST
54477: LIST
54478: PUSH
54479: LD_INT 1
54481: PUSH
54482: LD_INT 1
54484: NEG
54485: PUSH
54486: EMPTY
54487: LIST
54488: LIST
54489: PUSH
54490: LD_INT 2
54492: PUSH
54493: LD_INT 0
54495: PUSH
54496: EMPTY
54497: LIST
54498: LIST
54499: PUSH
54500: LD_INT 2
54502: PUSH
54503: LD_INT 1
54505: PUSH
54506: EMPTY
54507: LIST
54508: LIST
54509: PUSH
54510: LD_INT 1
54512: PUSH
54513: LD_INT 2
54515: PUSH
54516: EMPTY
54517: LIST
54518: LIST
54519: PUSH
54520: LD_INT 0
54522: PUSH
54523: LD_INT 2
54525: PUSH
54526: EMPTY
54527: LIST
54528: LIST
54529: PUSH
54530: LD_INT 1
54532: NEG
54533: PUSH
54534: LD_INT 1
54536: PUSH
54537: EMPTY
54538: LIST
54539: LIST
54540: PUSH
54541: LD_INT 2
54543: NEG
54544: PUSH
54545: LD_INT 0
54547: PUSH
54548: EMPTY
54549: LIST
54550: LIST
54551: PUSH
54552: LD_INT 2
54554: NEG
54555: PUSH
54556: LD_INT 1
54558: NEG
54559: PUSH
54560: EMPTY
54561: LIST
54562: LIST
54563: PUSH
54564: LD_INT 1
54566: NEG
54567: PUSH
54568: LD_INT 3
54570: NEG
54571: PUSH
54572: EMPTY
54573: LIST
54574: LIST
54575: PUSH
54576: LD_INT 0
54578: PUSH
54579: LD_INT 3
54581: NEG
54582: PUSH
54583: EMPTY
54584: LIST
54585: LIST
54586: PUSH
54587: LD_INT 1
54589: PUSH
54590: LD_INT 2
54592: NEG
54593: PUSH
54594: EMPTY
54595: LIST
54596: LIST
54597: PUSH
54598: LD_INT 2
54600: PUSH
54601: LD_INT 1
54603: NEG
54604: PUSH
54605: EMPTY
54606: LIST
54607: LIST
54608: PUSH
54609: LD_INT 3
54611: PUSH
54612: LD_INT 0
54614: PUSH
54615: EMPTY
54616: LIST
54617: LIST
54618: PUSH
54619: LD_INT 3
54621: PUSH
54622: LD_INT 1
54624: PUSH
54625: EMPTY
54626: LIST
54627: LIST
54628: PUSH
54629: LD_INT 1
54631: PUSH
54632: LD_INT 3
54634: PUSH
54635: EMPTY
54636: LIST
54637: LIST
54638: PUSH
54639: LD_INT 0
54641: PUSH
54642: LD_INT 3
54644: PUSH
54645: EMPTY
54646: LIST
54647: LIST
54648: PUSH
54649: LD_INT 1
54651: NEG
54652: PUSH
54653: LD_INT 2
54655: PUSH
54656: EMPTY
54657: LIST
54658: LIST
54659: PUSH
54660: LD_INT 2
54662: NEG
54663: PUSH
54664: LD_INT 1
54666: PUSH
54667: EMPTY
54668: LIST
54669: LIST
54670: PUSH
54671: LD_INT 3
54673: NEG
54674: PUSH
54675: LD_INT 0
54677: PUSH
54678: EMPTY
54679: LIST
54680: LIST
54681: PUSH
54682: LD_INT 3
54684: NEG
54685: PUSH
54686: LD_INT 1
54688: NEG
54689: PUSH
54690: EMPTY
54691: LIST
54692: LIST
54693: PUSH
54694: EMPTY
54695: LIST
54696: LIST
54697: LIST
54698: LIST
54699: LIST
54700: LIST
54701: LIST
54702: LIST
54703: LIST
54704: LIST
54705: LIST
54706: LIST
54707: LIST
54708: LIST
54709: LIST
54710: LIST
54711: LIST
54712: LIST
54713: LIST
54714: LIST
54715: LIST
54716: LIST
54717: LIST
54718: LIST
54719: LIST
54720: LIST
54721: LIST
54722: LIST
54723: LIST
54724: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
54725: LD_ADDR_VAR 0 47
54729: PUSH
54730: LD_INT 0
54732: PUSH
54733: LD_INT 0
54735: PUSH
54736: EMPTY
54737: LIST
54738: LIST
54739: PUSH
54740: LD_INT 0
54742: PUSH
54743: LD_INT 1
54745: NEG
54746: PUSH
54747: EMPTY
54748: LIST
54749: LIST
54750: PUSH
54751: LD_INT 1
54753: PUSH
54754: LD_INT 0
54756: PUSH
54757: EMPTY
54758: LIST
54759: LIST
54760: PUSH
54761: LD_INT 1
54763: PUSH
54764: LD_INT 1
54766: PUSH
54767: EMPTY
54768: LIST
54769: LIST
54770: PUSH
54771: LD_INT 0
54773: PUSH
54774: LD_INT 1
54776: PUSH
54777: EMPTY
54778: LIST
54779: LIST
54780: PUSH
54781: LD_INT 1
54783: NEG
54784: PUSH
54785: LD_INT 0
54787: PUSH
54788: EMPTY
54789: LIST
54790: LIST
54791: PUSH
54792: LD_INT 1
54794: NEG
54795: PUSH
54796: LD_INT 1
54798: NEG
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: PUSH
54804: LD_INT 1
54806: NEG
54807: PUSH
54808: LD_INT 2
54810: NEG
54811: PUSH
54812: EMPTY
54813: LIST
54814: LIST
54815: PUSH
54816: LD_INT 0
54818: PUSH
54819: LD_INT 2
54821: NEG
54822: PUSH
54823: EMPTY
54824: LIST
54825: LIST
54826: PUSH
54827: LD_INT 1
54829: PUSH
54830: LD_INT 1
54832: NEG
54833: PUSH
54834: EMPTY
54835: LIST
54836: LIST
54837: PUSH
54838: LD_INT 2
54840: NEG
54841: PUSH
54842: LD_INT 1
54844: NEG
54845: PUSH
54846: EMPTY
54847: LIST
54848: LIST
54849: PUSH
54850: LD_INT 2
54852: NEG
54853: PUSH
54854: LD_INT 2
54856: NEG
54857: PUSH
54858: EMPTY
54859: LIST
54860: LIST
54861: PUSH
54862: EMPTY
54863: LIST
54864: LIST
54865: LIST
54866: LIST
54867: LIST
54868: LIST
54869: LIST
54870: LIST
54871: LIST
54872: LIST
54873: LIST
54874: LIST
54875: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
54876: LD_ADDR_VAR 0 48
54880: PUSH
54881: LD_INT 0
54883: PUSH
54884: LD_INT 0
54886: PUSH
54887: EMPTY
54888: LIST
54889: LIST
54890: PUSH
54891: LD_INT 0
54893: PUSH
54894: LD_INT 1
54896: NEG
54897: PUSH
54898: EMPTY
54899: LIST
54900: LIST
54901: PUSH
54902: LD_INT 1
54904: PUSH
54905: LD_INT 0
54907: PUSH
54908: EMPTY
54909: LIST
54910: LIST
54911: PUSH
54912: LD_INT 1
54914: PUSH
54915: LD_INT 1
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: PUSH
54922: LD_INT 0
54924: PUSH
54925: LD_INT 1
54927: PUSH
54928: EMPTY
54929: LIST
54930: LIST
54931: PUSH
54932: LD_INT 1
54934: NEG
54935: PUSH
54936: LD_INT 0
54938: PUSH
54939: EMPTY
54940: LIST
54941: LIST
54942: PUSH
54943: LD_INT 1
54945: NEG
54946: PUSH
54947: LD_INT 1
54949: NEG
54950: PUSH
54951: EMPTY
54952: LIST
54953: LIST
54954: PUSH
54955: LD_INT 1
54957: NEG
54958: PUSH
54959: LD_INT 2
54961: NEG
54962: PUSH
54963: EMPTY
54964: LIST
54965: LIST
54966: PUSH
54967: LD_INT 0
54969: PUSH
54970: LD_INT 2
54972: NEG
54973: PUSH
54974: EMPTY
54975: LIST
54976: LIST
54977: PUSH
54978: LD_INT 1
54980: PUSH
54981: LD_INT 1
54983: NEG
54984: PUSH
54985: EMPTY
54986: LIST
54987: LIST
54988: PUSH
54989: LD_INT 2
54991: PUSH
54992: LD_INT 0
54994: PUSH
54995: EMPTY
54996: LIST
54997: LIST
54998: PUSH
54999: LD_INT 2
55001: PUSH
55002: LD_INT 1
55004: PUSH
55005: EMPTY
55006: LIST
55007: LIST
55008: PUSH
55009: EMPTY
55010: LIST
55011: LIST
55012: LIST
55013: LIST
55014: LIST
55015: LIST
55016: LIST
55017: LIST
55018: LIST
55019: LIST
55020: LIST
55021: LIST
55022: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
55023: LD_ADDR_VAR 0 49
55027: PUSH
55028: LD_INT 0
55030: PUSH
55031: LD_INT 0
55033: PUSH
55034: EMPTY
55035: LIST
55036: LIST
55037: PUSH
55038: LD_INT 0
55040: PUSH
55041: LD_INT 1
55043: NEG
55044: PUSH
55045: EMPTY
55046: LIST
55047: LIST
55048: PUSH
55049: LD_INT 1
55051: PUSH
55052: LD_INT 0
55054: PUSH
55055: EMPTY
55056: LIST
55057: LIST
55058: PUSH
55059: LD_INT 1
55061: PUSH
55062: LD_INT 1
55064: PUSH
55065: EMPTY
55066: LIST
55067: LIST
55068: PUSH
55069: LD_INT 0
55071: PUSH
55072: LD_INT 1
55074: PUSH
55075: EMPTY
55076: LIST
55077: LIST
55078: PUSH
55079: LD_INT 1
55081: NEG
55082: PUSH
55083: LD_INT 0
55085: PUSH
55086: EMPTY
55087: LIST
55088: LIST
55089: PUSH
55090: LD_INT 1
55092: NEG
55093: PUSH
55094: LD_INT 1
55096: NEG
55097: PUSH
55098: EMPTY
55099: LIST
55100: LIST
55101: PUSH
55102: LD_INT 1
55104: PUSH
55105: LD_INT 1
55107: NEG
55108: PUSH
55109: EMPTY
55110: LIST
55111: LIST
55112: PUSH
55113: LD_INT 2
55115: PUSH
55116: LD_INT 0
55118: PUSH
55119: EMPTY
55120: LIST
55121: LIST
55122: PUSH
55123: LD_INT 2
55125: PUSH
55126: LD_INT 1
55128: PUSH
55129: EMPTY
55130: LIST
55131: LIST
55132: PUSH
55133: LD_INT 2
55135: PUSH
55136: LD_INT 2
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: PUSH
55143: LD_INT 1
55145: PUSH
55146: LD_INT 2
55148: PUSH
55149: EMPTY
55150: LIST
55151: LIST
55152: PUSH
55153: EMPTY
55154: LIST
55155: LIST
55156: LIST
55157: LIST
55158: LIST
55159: LIST
55160: LIST
55161: LIST
55162: LIST
55163: LIST
55164: LIST
55165: LIST
55166: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
55167: LD_ADDR_VAR 0 50
55171: PUSH
55172: LD_INT 0
55174: PUSH
55175: LD_INT 0
55177: PUSH
55178: EMPTY
55179: LIST
55180: LIST
55181: PUSH
55182: LD_INT 0
55184: PUSH
55185: LD_INT 1
55187: NEG
55188: PUSH
55189: EMPTY
55190: LIST
55191: LIST
55192: PUSH
55193: LD_INT 1
55195: PUSH
55196: LD_INT 0
55198: PUSH
55199: EMPTY
55200: LIST
55201: LIST
55202: PUSH
55203: LD_INT 1
55205: PUSH
55206: LD_INT 1
55208: PUSH
55209: EMPTY
55210: LIST
55211: LIST
55212: PUSH
55213: LD_INT 0
55215: PUSH
55216: LD_INT 1
55218: PUSH
55219: EMPTY
55220: LIST
55221: LIST
55222: PUSH
55223: LD_INT 1
55225: NEG
55226: PUSH
55227: LD_INT 0
55229: PUSH
55230: EMPTY
55231: LIST
55232: LIST
55233: PUSH
55234: LD_INT 1
55236: NEG
55237: PUSH
55238: LD_INT 1
55240: NEG
55241: PUSH
55242: EMPTY
55243: LIST
55244: LIST
55245: PUSH
55246: LD_INT 2
55248: PUSH
55249: LD_INT 1
55251: PUSH
55252: EMPTY
55253: LIST
55254: LIST
55255: PUSH
55256: LD_INT 2
55258: PUSH
55259: LD_INT 2
55261: PUSH
55262: EMPTY
55263: LIST
55264: LIST
55265: PUSH
55266: LD_INT 1
55268: PUSH
55269: LD_INT 2
55271: PUSH
55272: EMPTY
55273: LIST
55274: LIST
55275: PUSH
55276: LD_INT 0
55278: PUSH
55279: LD_INT 2
55281: PUSH
55282: EMPTY
55283: LIST
55284: LIST
55285: PUSH
55286: LD_INT 1
55288: NEG
55289: PUSH
55290: LD_INT 1
55292: PUSH
55293: EMPTY
55294: LIST
55295: LIST
55296: PUSH
55297: EMPTY
55298: LIST
55299: LIST
55300: LIST
55301: LIST
55302: LIST
55303: LIST
55304: LIST
55305: LIST
55306: LIST
55307: LIST
55308: LIST
55309: LIST
55310: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
55311: LD_ADDR_VAR 0 51
55315: PUSH
55316: LD_INT 0
55318: PUSH
55319: LD_INT 0
55321: PUSH
55322: EMPTY
55323: LIST
55324: LIST
55325: PUSH
55326: LD_INT 0
55328: PUSH
55329: LD_INT 1
55331: NEG
55332: PUSH
55333: EMPTY
55334: LIST
55335: LIST
55336: PUSH
55337: LD_INT 1
55339: PUSH
55340: LD_INT 0
55342: PUSH
55343: EMPTY
55344: LIST
55345: LIST
55346: PUSH
55347: LD_INT 1
55349: PUSH
55350: LD_INT 1
55352: PUSH
55353: EMPTY
55354: LIST
55355: LIST
55356: PUSH
55357: LD_INT 0
55359: PUSH
55360: LD_INT 1
55362: PUSH
55363: EMPTY
55364: LIST
55365: LIST
55366: PUSH
55367: LD_INT 1
55369: NEG
55370: PUSH
55371: LD_INT 0
55373: PUSH
55374: EMPTY
55375: LIST
55376: LIST
55377: PUSH
55378: LD_INT 1
55380: NEG
55381: PUSH
55382: LD_INT 1
55384: NEG
55385: PUSH
55386: EMPTY
55387: LIST
55388: LIST
55389: PUSH
55390: LD_INT 1
55392: PUSH
55393: LD_INT 2
55395: PUSH
55396: EMPTY
55397: LIST
55398: LIST
55399: PUSH
55400: LD_INT 0
55402: PUSH
55403: LD_INT 2
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: PUSH
55410: LD_INT 1
55412: NEG
55413: PUSH
55414: LD_INT 1
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: PUSH
55421: LD_INT 2
55423: NEG
55424: PUSH
55425: LD_INT 0
55427: PUSH
55428: EMPTY
55429: LIST
55430: LIST
55431: PUSH
55432: LD_INT 2
55434: NEG
55435: PUSH
55436: LD_INT 1
55438: NEG
55439: PUSH
55440: EMPTY
55441: LIST
55442: LIST
55443: PUSH
55444: EMPTY
55445: LIST
55446: LIST
55447: LIST
55448: LIST
55449: LIST
55450: LIST
55451: LIST
55452: LIST
55453: LIST
55454: LIST
55455: LIST
55456: LIST
55457: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55458: LD_ADDR_VAR 0 52
55462: PUSH
55463: LD_INT 0
55465: PUSH
55466: LD_INT 0
55468: PUSH
55469: EMPTY
55470: LIST
55471: LIST
55472: PUSH
55473: LD_INT 0
55475: PUSH
55476: LD_INT 1
55478: NEG
55479: PUSH
55480: EMPTY
55481: LIST
55482: LIST
55483: PUSH
55484: LD_INT 1
55486: PUSH
55487: LD_INT 0
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: PUSH
55494: LD_INT 1
55496: PUSH
55497: LD_INT 1
55499: PUSH
55500: EMPTY
55501: LIST
55502: LIST
55503: PUSH
55504: LD_INT 0
55506: PUSH
55507: LD_INT 1
55509: PUSH
55510: EMPTY
55511: LIST
55512: LIST
55513: PUSH
55514: LD_INT 1
55516: NEG
55517: PUSH
55518: LD_INT 0
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: PUSH
55525: LD_INT 1
55527: NEG
55528: PUSH
55529: LD_INT 1
55531: NEG
55532: PUSH
55533: EMPTY
55534: LIST
55535: LIST
55536: PUSH
55537: LD_INT 1
55539: NEG
55540: PUSH
55541: LD_INT 2
55543: NEG
55544: PUSH
55545: EMPTY
55546: LIST
55547: LIST
55548: PUSH
55549: LD_INT 1
55551: NEG
55552: PUSH
55553: LD_INT 1
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: PUSH
55560: LD_INT 2
55562: NEG
55563: PUSH
55564: LD_INT 0
55566: PUSH
55567: EMPTY
55568: LIST
55569: LIST
55570: PUSH
55571: LD_INT 2
55573: NEG
55574: PUSH
55575: LD_INT 1
55577: NEG
55578: PUSH
55579: EMPTY
55580: LIST
55581: LIST
55582: PUSH
55583: LD_INT 2
55585: NEG
55586: PUSH
55587: LD_INT 2
55589: NEG
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: LIST
55599: LIST
55600: LIST
55601: LIST
55602: LIST
55603: LIST
55604: LIST
55605: LIST
55606: LIST
55607: LIST
55608: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55609: LD_ADDR_VAR 0 53
55613: PUSH
55614: LD_INT 0
55616: PUSH
55617: LD_INT 0
55619: PUSH
55620: EMPTY
55621: LIST
55622: LIST
55623: PUSH
55624: LD_INT 0
55626: PUSH
55627: LD_INT 1
55629: NEG
55630: PUSH
55631: EMPTY
55632: LIST
55633: LIST
55634: PUSH
55635: LD_INT 1
55637: PUSH
55638: LD_INT 0
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: PUSH
55645: LD_INT 1
55647: PUSH
55648: LD_INT 1
55650: PUSH
55651: EMPTY
55652: LIST
55653: LIST
55654: PUSH
55655: LD_INT 0
55657: PUSH
55658: LD_INT 1
55660: PUSH
55661: EMPTY
55662: LIST
55663: LIST
55664: PUSH
55665: LD_INT 1
55667: NEG
55668: PUSH
55669: LD_INT 0
55671: PUSH
55672: EMPTY
55673: LIST
55674: LIST
55675: PUSH
55676: LD_INT 1
55678: NEG
55679: PUSH
55680: LD_INT 1
55682: NEG
55683: PUSH
55684: EMPTY
55685: LIST
55686: LIST
55687: PUSH
55688: LD_INT 1
55690: NEG
55691: PUSH
55692: LD_INT 2
55694: NEG
55695: PUSH
55696: EMPTY
55697: LIST
55698: LIST
55699: PUSH
55700: LD_INT 0
55702: PUSH
55703: LD_INT 2
55705: NEG
55706: PUSH
55707: EMPTY
55708: LIST
55709: LIST
55710: PUSH
55711: LD_INT 1
55713: PUSH
55714: LD_INT 1
55716: NEG
55717: PUSH
55718: EMPTY
55719: LIST
55720: LIST
55721: PUSH
55722: LD_INT 2
55724: PUSH
55725: LD_INT 0
55727: PUSH
55728: EMPTY
55729: LIST
55730: LIST
55731: PUSH
55732: LD_INT 2
55734: PUSH
55735: LD_INT 1
55737: PUSH
55738: EMPTY
55739: LIST
55740: LIST
55741: PUSH
55742: LD_INT 2
55744: PUSH
55745: LD_INT 2
55747: PUSH
55748: EMPTY
55749: LIST
55750: LIST
55751: PUSH
55752: LD_INT 1
55754: PUSH
55755: LD_INT 2
55757: PUSH
55758: EMPTY
55759: LIST
55760: LIST
55761: PUSH
55762: LD_INT 0
55764: PUSH
55765: LD_INT 2
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: PUSH
55772: LD_INT 1
55774: NEG
55775: PUSH
55776: LD_INT 1
55778: PUSH
55779: EMPTY
55780: LIST
55781: LIST
55782: PUSH
55783: LD_INT 2
55785: NEG
55786: PUSH
55787: LD_INT 0
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: PUSH
55794: LD_INT 2
55796: NEG
55797: PUSH
55798: LD_INT 1
55800: NEG
55801: PUSH
55802: EMPTY
55803: LIST
55804: LIST
55805: PUSH
55806: LD_INT 2
55808: NEG
55809: PUSH
55810: LD_INT 2
55812: NEG
55813: PUSH
55814: EMPTY
55815: LIST
55816: LIST
55817: PUSH
55818: EMPTY
55819: LIST
55820: LIST
55821: LIST
55822: LIST
55823: LIST
55824: LIST
55825: LIST
55826: LIST
55827: LIST
55828: LIST
55829: LIST
55830: LIST
55831: LIST
55832: LIST
55833: LIST
55834: LIST
55835: LIST
55836: LIST
55837: LIST
55838: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55839: LD_ADDR_VAR 0 54
55843: PUSH
55844: LD_INT 0
55846: PUSH
55847: LD_INT 0
55849: PUSH
55850: EMPTY
55851: LIST
55852: LIST
55853: PUSH
55854: LD_INT 0
55856: PUSH
55857: LD_INT 1
55859: NEG
55860: PUSH
55861: EMPTY
55862: LIST
55863: LIST
55864: PUSH
55865: LD_INT 1
55867: PUSH
55868: LD_INT 0
55870: PUSH
55871: EMPTY
55872: LIST
55873: LIST
55874: PUSH
55875: LD_INT 1
55877: PUSH
55878: LD_INT 1
55880: PUSH
55881: EMPTY
55882: LIST
55883: LIST
55884: PUSH
55885: LD_INT 0
55887: PUSH
55888: LD_INT 1
55890: PUSH
55891: EMPTY
55892: LIST
55893: LIST
55894: PUSH
55895: LD_INT 1
55897: NEG
55898: PUSH
55899: LD_INT 0
55901: PUSH
55902: EMPTY
55903: LIST
55904: LIST
55905: PUSH
55906: LD_INT 1
55908: NEG
55909: PUSH
55910: LD_INT 1
55912: NEG
55913: PUSH
55914: EMPTY
55915: LIST
55916: LIST
55917: PUSH
55918: LD_INT 1
55920: NEG
55921: PUSH
55922: LD_INT 2
55924: NEG
55925: PUSH
55926: EMPTY
55927: LIST
55928: LIST
55929: PUSH
55930: LD_INT 0
55932: PUSH
55933: LD_INT 2
55935: NEG
55936: PUSH
55937: EMPTY
55938: LIST
55939: LIST
55940: PUSH
55941: LD_INT 1
55943: PUSH
55944: LD_INT 1
55946: NEG
55947: PUSH
55948: EMPTY
55949: LIST
55950: LIST
55951: PUSH
55952: LD_INT 2
55954: PUSH
55955: LD_INT 0
55957: PUSH
55958: EMPTY
55959: LIST
55960: LIST
55961: PUSH
55962: LD_INT 2
55964: PUSH
55965: LD_INT 1
55967: PUSH
55968: EMPTY
55969: LIST
55970: LIST
55971: PUSH
55972: LD_INT 2
55974: PUSH
55975: LD_INT 2
55977: PUSH
55978: EMPTY
55979: LIST
55980: LIST
55981: PUSH
55982: LD_INT 1
55984: PUSH
55985: LD_INT 2
55987: PUSH
55988: EMPTY
55989: LIST
55990: LIST
55991: PUSH
55992: LD_INT 0
55994: PUSH
55995: LD_INT 2
55997: PUSH
55998: EMPTY
55999: LIST
56000: LIST
56001: PUSH
56002: LD_INT 1
56004: NEG
56005: PUSH
56006: LD_INT 1
56008: PUSH
56009: EMPTY
56010: LIST
56011: LIST
56012: PUSH
56013: LD_INT 2
56015: NEG
56016: PUSH
56017: LD_INT 0
56019: PUSH
56020: EMPTY
56021: LIST
56022: LIST
56023: PUSH
56024: LD_INT 2
56026: NEG
56027: PUSH
56028: LD_INT 1
56030: NEG
56031: PUSH
56032: EMPTY
56033: LIST
56034: LIST
56035: PUSH
56036: LD_INT 2
56038: NEG
56039: PUSH
56040: LD_INT 2
56042: NEG
56043: PUSH
56044: EMPTY
56045: LIST
56046: LIST
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: LIST
56052: LIST
56053: LIST
56054: LIST
56055: LIST
56056: LIST
56057: LIST
56058: LIST
56059: LIST
56060: LIST
56061: LIST
56062: LIST
56063: LIST
56064: LIST
56065: LIST
56066: LIST
56067: LIST
56068: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56069: LD_ADDR_VAR 0 55
56073: PUSH
56074: LD_INT 0
56076: PUSH
56077: LD_INT 0
56079: PUSH
56080: EMPTY
56081: LIST
56082: LIST
56083: PUSH
56084: LD_INT 0
56086: PUSH
56087: LD_INT 1
56089: NEG
56090: PUSH
56091: EMPTY
56092: LIST
56093: LIST
56094: PUSH
56095: LD_INT 1
56097: PUSH
56098: LD_INT 0
56100: PUSH
56101: EMPTY
56102: LIST
56103: LIST
56104: PUSH
56105: LD_INT 1
56107: PUSH
56108: LD_INT 1
56110: PUSH
56111: EMPTY
56112: LIST
56113: LIST
56114: PUSH
56115: LD_INT 0
56117: PUSH
56118: LD_INT 1
56120: PUSH
56121: EMPTY
56122: LIST
56123: LIST
56124: PUSH
56125: LD_INT 1
56127: NEG
56128: PUSH
56129: LD_INT 0
56131: PUSH
56132: EMPTY
56133: LIST
56134: LIST
56135: PUSH
56136: LD_INT 1
56138: NEG
56139: PUSH
56140: LD_INT 1
56142: NEG
56143: PUSH
56144: EMPTY
56145: LIST
56146: LIST
56147: PUSH
56148: LD_INT 1
56150: NEG
56151: PUSH
56152: LD_INT 2
56154: NEG
56155: PUSH
56156: EMPTY
56157: LIST
56158: LIST
56159: PUSH
56160: LD_INT 0
56162: PUSH
56163: LD_INT 2
56165: NEG
56166: PUSH
56167: EMPTY
56168: LIST
56169: LIST
56170: PUSH
56171: LD_INT 1
56173: PUSH
56174: LD_INT 1
56176: NEG
56177: PUSH
56178: EMPTY
56179: LIST
56180: LIST
56181: PUSH
56182: LD_INT 2
56184: PUSH
56185: LD_INT 0
56187: PUSH
56188: EMPTY
56189: LIST
56190: LIST
56191: PUSH
56192: LD_INT 2
56194: PUSH
56195: LD_INT 1
56197: PUSH
56198: EMPTY
56199: LIST
56200: LIST
56201: PUSH
56202: LD_INT 2
56204: PUSH
56205: LD_INT 2
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: PUSH
56212: LD_INT 1
56214: PUSH
56215: LD_INT 2
56217: PUSH
56218: EMPTY
56219: LIST
56220: LIST
56221: PUSH
56222: LD_INT 0
56224: PUSH
56225: LD_INT 2
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: PUSH
56232: LD_INT 1
56234: NEG
56235: PUSH
56236: LD_INT 1
56238: PUSH
56239: EMPTY
56240: LIST
56241: LIST
56242: PUSH
56243: LD_INT 2
56245: NEG
56246: PUSH
56247: LD_INT 0
56249: PUSH
56250: EMPTY
56251: LIST
56252: LIST
56253: PUSH
56254: LD_INT 2
56256: NEG
56257: PUSH
56258: LD_INT 1
56260: NEG
56261: PUSH
56262: EMPTY
56263: LIST
56264: LIST
56265: PUSH
56266: LD_INT 2
56268: NEG
56269: PUSH
56270: LD_INT 2
56272: NEG
56273: PUSH
56274: EMPTY
56275: LIST
56276: LIST
56277: PUSH
56278: EMPTY
56279: LIST
56280: LIST
56281: LIST
56282: LIST
56283: LIST
56284: LIST
56285: LIST
56286: LIST
56287: LIST
56288: LIST
56289: LIST
56290: LIST
56291: LIST
56292: LIST
56293: LIST
56294: LIST
56295: LIST
56296: LIST
56297: LIST
56298: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56299: LD_ADDR_VAR 0 56
56303: PUSH
56304: LD_INT 0
56306: PUSH
56307: LD_INT 0
56309: PUSH
56310: EMPTY
56311: LIST
56312: LIST
56313: PUSH
56314: LD_INT 0
56316: PUSH
56317: LD_INT 1
56319: NEG
56320: PUSH
56321: EMPTY
56322: LIST
56323: LIST
56324: PUSH
56325: LD_INT 1
56327: PUSH
56328: LD_INT 0
56330: PUSH
56331: EMPTY
56332: LIST
56333: LIST
56334: PUSH
56335: LD_INT 1
56337: PUSH
56338: LD_INT 1
56340: PUSH
56341: EMPTY
56342: LIST
56343: LIST
56344: PUSH
56345: LD_INT 0
56347: PUSH
56348: LD_INT 1
56350: PUSH
56351: EMPTY
56352: LIST
56353: LIST
56354: PUSH
56355: LD_INT 1
56357: NEG
56358: PUSH
56359: LD_INT 0
56361: PUSH
56362: EMPTY
56363: LIST
56364: LIST
56365: PUSH
56366: LD_INT 1
56368: NEG
56369: PUSH
56370: LD_INT 1
56372: NEG
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: PUSH
56378: LD_INT 1
56380: NEG
56381: PUSH
56382: LD_INT 2
56384: NEG
56385: PUSH
56386: EMPTY
56387: LIST
56388: LIST
56389: PUSH
56390: LD_INT 0
56392: PUSH
56393: LD_INT 2
56395: NEG
56396: PUSH
56397: EMPTY
56398: LIST
56399: LIST
56400: PUSH
56401: LD_INT 1
56403: PUSH
56404: LD_INT 1
56406: NEG
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: PUSH
56412: LD_INT 2
56414: PUSH
56415: LD_INT 0
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: PUSH
56422: LD_INT 2
56424: PUSH
56425: LD_INT 1
56427: PUSH
56428: EMPTY
56429: LIST
56430: LIST
56431: PUSH
56432: LD_INT 2
56434: PUSH
56435: LD_INT 2
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: PUSH
56442: LD_INT 1
56444: PUSH
56445: LD_INT 2
56447: PUSH
56448: EMPTY
56449: LIST
56450: LIST
56451: PUSH
56452: LD_INT 0
56454: PUSH
56455: LD_INT 2
56457: PUSH
56458: EMPTY
56459: LIST
56460: LIST
56461: PUSH
56462: LD_INT 1
56464: NEG
56465: PUSH
56466: LD_INT 1
56468: PUSH
56469: EMPTY
56470: LIST
56471: LIST
56472: PUSH
56473: LD_INT 2
56475: NEG
56476: PUSH
56477: LD_INT 0
56479: PUSH
56480: EMPTY
56481: LIST
56482: LIST
56483: PUSH
56484: LD_INT 2
56486: NEG
56487: PUSH
56488: LD_INT 1
56490: NEG
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: PUSH
56496: LD_INT 2
56498: NEG
56499: PUSH
56500: LD_INT 2
56502: NEG
56503: PUSH
56504: EMPTY
56505: LIST
56506: LIST
56507: PUSH
56508: EMPTY
56509: LIST
56510: LIST
56511: LIST
56512: LIST
56513: LIST
56514: LIST
56515: LIST
56516: LIST
56517: LIST
56518: LIST
56519: LIST
56520: LIST
56521: LIST
56522: LIST
56523: LIST
56524: LIST
56525: LIST
56526: LIST
56527: LIST
56528: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56529: LD_ADDR_VAR 0 57
56533: PUSH
56534: LD_INT 0
56536: PUSH
56537: LD_INT 0
56539: PUSH
56540: EMPTY
56541: LIST
56542: LIST
56543: PUSH
56544: LD_INT 0
56546: PUSH
56547: LD_INT 1
56549: NEG
56550: PUSH
56551: EMPTY
56552: LIST
56553: LIST
56554: PUSH
56555: LD_INT 1
56557: PUSH
56558: LD_INT 0
56560: PUSH
56561: EMPTY
56562: LIST
56563: LIST
56564: PUSH
56565: LD_INT 1
56567: PUSH
56568: LD_INT 1
56570: PUSH
56571: EMPTY
56572: LIST
56573: LIST
56574: PUSH
56575: LD_INT 0
56577: PUSH
56578: LD_INT 1
56580: PUSH
56581: EMPTY
56582: LIST
56583: LIST
56584: PUSH
56585: LD_INT 1
56587: NEG
56588: PUSH
56589: LD_INT 0
56591: PUSH
56592: EMPTY
56593: LIST
56594: LIST
56595: PUSH
56596: LD_INT 1
56598: NEG
56599: PUSH
56600: LD_INT 1
56602: NEG
56603: PUSH
56604: EMPTY
56605: LIST
56606: LIST
56607: PUSH
56608: LD_INT 1
56610: NEG
56611: PUSH
56612: LD_INT 2
56614: NEG
56615: PUSH
56616: EMPTY
56617: LIST
56618: LIST
56619: PUSH
56620: LD_INT 0
56622: PUSH
56623: LD_INT 2
56625: NEG
56626: PUSH
56627: EMPTY
56628: LIST
56629: LIST
56630: PUSH
56631: LD_INT 1
56633: PUSH
56634: LD_INT 1
56636: NEG
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: PUSH
56642: LD_INT 2
56644: PUSH
56645: LD_INT 0
56647: PUSH
56648: EMPTY
56649: LIST
56650: LIST
56651: PUSH
56652: LD_INT 2
56654: PUSH
56655: LD_INT 1
56657: PUSH
56658: EMPTY
56659: LIST
56660: LIST
56661: PUSH
56662: LD_INT 2
56664: PUSH
56665: LD_INT 2
56667: PUSH
56668: EMPTY
56669: LIST
56670: LIST
56671: PUSH
56672: LD_INT 1
56674: PUSH
56675: LD_INT 2
56677: PUSH
56678: EMPTY
56679: LIST
56680: LIST
56681: PUSH
56682: LD_INT 0
56684: PUSH
56685: LD_INT 2
56687: PUSH
56688: EMPTY
56689: LIST
56690: LIST
56691: PUSH
56692: LD_INT 1
56694: NEG
56695: PUSH
56696: LD_INT 1
56698: PUSH
56699: EMPTY
56700: LIST
56701: LIST
56702: PUSH
56703: LD_INT 2
56705: NEG
56706: PUSH
56707: LD_INT 0
56709: PUSH
56710: EMPTY
56711: LIST
56712: LIST
56713: PUSH
56714: LD_INT 2
56716: NEG
56717: PUSH
56718: LD_INT 1
56720: NEG
56721: PUSH
56722: EMPTY
56723: LIST
56724: LIST
56725: PUSH
56726: LD_INT 2
56728: NEG
56729: PUSH
56730: LD_INT 2
56732: NEG
56733: PUSH
56734: EMPTY
56735: LIST
56736: LIST
56737: PUSH
56738: EMPTY
56739: LIST
56740: LIST
56741: LIST
56742: LIST
56743: LIST
56744: LIST
56745: LIST
56746: LIST
56747: LIST
56748: LIST
56749: LIST
56750: LIST
56751: LIST
56752: LIST
56753: LIST
56754: LIST
56755: LIST
56756: LIST
56757: LIST
56758: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56759: LD_ADDR_VAR 0 58
56763: PUSH
56764: LD_INT 0
56766: PUSH
56767: LD_INT 0
56769: PUSH
56770: EMPTY
56771: LIST
56772: LIST
56773: PUSH
56774: LD_INT 0
56776: PUSH
56777: LD_INT 1
56779: NEG
56780: PUSH
56781: EMPTY
56782: LIST
56783: LIST
56784: PUSH
56785: LD_INT 1
56787: PUSH
56788: LD_INT 0
56790: PUSH
56791: EMPTY
56792: LIST
56793: LIST
56794: PUSH
56795: LD_INT 1
56797: PUSH
56798: LD_INT 1
56800: PUSH
56801: EMPTY
56802: LIST
56803: LIST
56804: PUSH
56805: LD_INT 0
56807: PUSH
56808: LD_INT 1
56810: PUSH
56811: EMPTY
56812: LIST
56813: LIST
56814: PUSH
56815: LD_INT 1
56817: NEG
56818: PUSH
56819: LD_INT 0
56821: PUSH
56822: EMPTY
56823: LIST
56824: LIST
56825: PUSH
56826: LD_INT 1
56828: NEG
56829: PUSH
56830: LD_INT 1
56832: NEG
56833: PUSH
56834: EMPTY
56835: LIST
56836: LIST
56837: PUSH
56838: LD_INT 1
56840: NEG
56841: PUSH
56842: LD_INT 2
56844: NEG
56845: PUSH
56846: EMPTY
56847: LIST
56848: LIST
56849: PUSH
56850: LD_INT 0
56852: PUSH
56853: LD_INT 2
56855: NEG
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: PUSH
56861: LD_INT 1
56863: PUSH
56864: LD_INT 1
56866: NEG
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: PUSH
56872: LD_INT 2
56874: PUSH
56875: LD_INT 0
56877: PUSH
56878: EMPTY
56879: LIST
56880: LIST
56881: PUSH
56882: LD_INT 2
56884: PUSH
56885: LD_INT 1
56887: PUSH
56888: EMPTY
56889: LIST
56890: LIST
56891: PUSH
56892: LD_INT 2
56894: PUSH
56895: LD_INT 2
56897: PUSH
56898: EMPTY
56899: LIST
56900: LIST
56901: PUSH
56902: LD_INT 1
56904: PUSH
56905: LD_INT 2
56907: PUSH
56908: EMPTY
56909: LIST
56910: LIST
56911: PUSH
56912: LD_INT 0
56914: PUSH
56915: LD_INT 2
56917: PUSH
56918: EMPTY
56919: LIST
56920: LIST
56921: PUSH
56922: LD_INT 1
56924: NEG
56925: PUSH
56926: LD_INT 1
56928: PUSH
56929: EMPTY
56930: LIST
56931: LIST
56932: PUSH
56933: LD_INT 2
56935: NEG
56936: PUSH
56937: LD_INT 0
56939: PUSH
56940: EMPTY
56941: LIST
56942: LIST
56943: PUSH
56944: LD_INT 2
56946: NEG
56947: PUSH
56948: LD_INT 1
56950: NEG
56951: PUSH
56952: EMPTY
56953: LIST
56954: LIST
56955: PUSH
56956: LD_INT 2
56958: NEG
56959: PUSH
56960: LD_INT 2
56962: NEG
56963: PUSH
56964: EMPTY
56965: LIST
56966: LIST
56967: PUSH
56968: EMPTY
56969: LIST
56970: LIST
56971: LIST
56972: LIST
56973: LIST
56974: LIST
56975: LIST
56976: LIST
56977: LIST
56978: LIST
56979: LIST
56980: LIST
56981: LIST
56982: LIST
56983: LIST
56984: LIST
56985: LIST
56986: LIST
56987: LIST
56988: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
56989: LD_ADDR_VAR 0 59
56993: PUSH
56994: LD_INT 0
56996: PUSH
56997: LD_INT 0
56999: PUSH
57000: EMPTY
57001: LIST
57002: LIST
57003: PUSH
57004: LD_INT 0
57006: PUSH
57007: LD_INT 1
57009: NEG
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: PUSH
57015: LD_INT 1
57017: PUSH
57018: LD_INT 0
57020: PUSH
57021: EMPTY
57022: LIST
57023: LIST
57024: PUSH
57025: LD_INT 1
57027: PUSH
57028: LD_INT 1
57030: PUSH
57031: EMPTY
57032: LIST
57033: LIST
57034: PUSH
57035: LD_INT 0
57037: PUSH
57038: LD_INT 1
57040: PUSH
57041: EMPTY
57042: LIST
57043: LIST
57044: PUSH
57045: LD_INT 1
57047: NEG
57048: PUSH
57049: LD_INT 0
57051: PUSH
57052: EMPTY
57053: LIST
57054: LIST
57055: PUSH
57056: LD_INT 1
57058: NEG
57059: PUSH
57060: LD_INT 1
57062: NEG
57063: PUSH
57064: EMPTY
57065: LIST
57066: LIST
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: LIST
57072: LIST
57073: LIST
57074: LIST
57075: LIST
57076: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57077: LD_ADDR_VAR 0 60
57081: PUSH
57082: LD_INT 0
57084: PUSH
57085: LD_INT 0
57087: PUSH
57088: EMPTY
57089: LIST
57090: LIST
57091: PUSH
57092: LD_INT 0
57094: PUSH
57095: LD_INT 1
57097: NEG
57098: PUSH
57099: EMPTY
57100: LIST
57101: LIST
57102: PUSH
57103: LD_INT 1
57105: PUSH
57106: LD_INT 0
57108: PUSH
57109: EMPTY
57110: LIST
57111: LIST
57112: PUSH
57113: LD_INT 1
57115: PUSH
57116: LD_INT 1
57118: PUSH
57119: EMPTY
57120: LIST
57121: LIST
57122: PUSH
57123: LD_INT 0
57125: PUSH
57126: LD_INT 1
57128: PUSH
57129: EMPTY
57130: LIST
57131: LIST
57132: PUSH
57133: LD_INT 1
57135: NEG
57136: PUSH
57137: LD_INT 0
57139: PUSH
57140: EMPTY
57141: LIST
57142: LIST
57143: PUSH
57144: LD_INT 1
57146: NEG
57147: PUSH
57148: LD_INT 1
57150: NEG
57151: PUSH
57152: EMPTY
57153: LIST
57154: LIST
57155: PUSH
57156: EMPTY
57157: LIST
57158: LIST
57159: LIST
57160: LIST
57161: LIST
57162: LIST
57163: LIST
57164: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57165: LD_ADDR_VAR 0 61
57169: PUSH
57170: LD_INT 0
57172: PUSH
57173: LD_INT 0
57175: PUSH
57176: EMPTY
57177: LIST
57178: LIST
57179: PUSH
57180: LD_INT 0
57182: PUSH
57183: LD_INT 1
57185: NEG
57186: PUSH
57187: EMPTY
57188: LIST
57189: LIST
57190: PUSH
57191: LD_INT 1
57193: PUSH
57194: LD_INT 0
57196: PUSH
57197: EMPTY
57198: LIST
57199: LIST
57200: PUSH
57201: LD_INT 1
57203: PUSH
57204: LD_INT 1
57206: PUSH
57207: EMPTY
57208: LIST
57209: LIST
57210: PUSH
57211: LD_INT 0
57213: PUSH
57214: LD_INT 1
57216: PUSH
57217: EMPTY
57218: LIST
57219: LIST
57220: PUSH
57221: LD_INT 1
57223: NEG
57224: PUSH
57225: LD_INT 0
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: LD_INT 1
57234: NEG
57235: PUSH
57236: LD_INT 1
57238: NEG
57239: PUSH
57240: EMPTY
57241: LIST
57242: LIST
57243: PUSH
57244: EMPTY
57245: LIST
57246: LIST
57247: LIST
57248: LIST
57249: LIST
57250: LIST
57251: LIST
57252: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57253: LD_ADDR_VAR 0 62
57257: PUSH
57258: LD_INT 0
57260: PUSH
57261: LD_INT 0
57263: PUSH
57264: EMPTY
57265: LIST
57266: LIST
57267: PUSH
57268: LD_INT 0
57270: PUSH
57271: LD_INT 1
57273: NEG
57274: PUSH
57275: EMPTY
57276: LIST
57277: LIST
57278: PUSH
57279: LD_INT 1
57281: PUSH
57282: LD_INT 0
57284: PUSH
57285: EMPTY
57286: LIST
57287: LIST
57288: PUSH
57289: LD_INT 1
57291: PUSH
57292: LD_INT 1
57294: PUSH
57295: EMPTY
57296: LIST
57297: LIST
57298: PUSH
57299: LD_INT 0
57301: PUSH
57302: LD_INT 1
57304: PUSH
57305: EMPTY
57306: LIST
57307: LIST
57308: PUSH
57309: LD_INT 1
57311: NEG
57312: PUSH
57313: LD_INT 0
57315: PUSH
57316: EMPTY
57317: LIST
57318: LIST
57319: PUSH
57320: LD_INT 1
57322: NEG
57323: PUSH
57324: LD_INT 1
57326: NEG
57327: PUSH
57328: EMPTY
57329: LIST
57330: LIST
57331: PUSH
57332: EMPTY
57333: LIST
57334: LIST
57335: LIST
57336: LIST
57337: LIST
57338: LIST
57339: LIST
57340: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57341: LD_ADDR_VAR 0 63
57345: PUSH
57346: LD_INT 0
57348: PUSH
57349: LD_INT 0
57351: PUSH
57352: EMPTY
57353: LIST
57354: LIST
57355: PUSH
57356: LD_INT 0
57358: PUSH
57359: LD_INT 1
57361: NEG
57362: PUSH
57363: EMPTY
57364: LIST
57365: LIST
57366: PUSH
57367: LD_INT 1
57369: PUSH
57370: LD_INT 0
57372: PUSH
57373: EMPTY
57374: LIST
57375: LIST
57376: PUSH
57377: LD_INT 1
57379: PUSH
57380: LD_INT 1
57382: PUSH
57383: EMPTY
57384: LIST
57385: LIST
57386: PUSH
57387: LD_INT 0
57389: PUSH
57390: LD_INT 1
57392: PUSH
57393: EMPTY
57394: LIST
57395: LIST
57396: PUSH
57397: LD_INT 1
57399: NEG
57400: PUSH
57401: LD_INT 0
57403: PUSH
57404: EMPTY
57405: LIST
57406: LIST
57407: PUSH
57408: LD_INT 1
57410: NEG
57411: PUSH
57412: LD_INT 1
57414: NEG
57415: PUSH
57416: EMPTY
57417: LIST
57418: LIST
57419: PUSH
57420: EMPTY
57421: LIST
57422: LIST
57423: LIST
57424: LIST
57425: LIST
57426: LIST
57427: LIST
57428: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57429: LD_ADDR_VAR 0 64
57433: PUSH
57434: LD_INT 0
57436: PUSH
57437: LD_INT 0
57439: PUSH
57440: EMPTY
57441: LIST
57442: LIST
57443: PUSH
57444: LD_INT 0
57446: PUSH
57447: LD_INT 1
57449: NEG
57450: PUSH
57451: EMPTY
57452: LIST
57453: LIST
57454: PUSH
57455: LD_INT 1
57457: PUSH
57458: LD_INT 0
57460: PUSH
57461: EMPTY
57462: LIST
57463: LIST
57464: PUSH
57465: LD_INT 1
57467: PUSH
57468: LD_INT 1
57470: PUSH
57471: EMPTY
57472: LIST
57473: LIST
57474: PUSH
57475: LD_INT 0
57477: PUSH
57478: LD_INT 1
57480: PUSH
57481: EMPTY
57482: LIST
57483: LIST
57484: PUSH
57485: LD_INT 1
57487: NEG
57488: PUSH
57489: LD_INT 0
57491: PUSH
57492: EMPTY
57493: LIST
57494: LIST
57495: PUSH
57496: LD_INT 1
57498: NEG
57499: PUSH
57500: LD_INT 1
57502: NEG
57503: PUSH
57504: EMPTY
57505: LIST
57506: LIST
57507: PUSH
57508: EMPTY
57509: LIST
57510: LIST
57511: LIST
57512: LIST
57513: LIST
57514: LIST
57515: LIST
57516: ST_TO_ADDR
// end ; 1 :
57517: GO 63414
57519: LD_INT 1
57521: DOUBLE
57522: EQUAL
57523: IFTRUE 57527
57525: GO 60150
57527: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
57528: LD_ADDR_VAR 0 11
57532: PUSH
57533: LD_INT 1
57535: NEG
57536: PUSH
57537: LD_INT 3
57539: NEG
57540: PUSH
57541: EMPTY
57542: LIST
57543: LIST
57544: PUSH
57545: LD_INT 0
57547: PUSH
57548: LD_INT 3
57550: NEG
57551: PUSH
57552: EMPTY
57553: LIST
57554: LIST
57555: PUSH
57556: LD_INT 1
57558: PUSH
57559: LD_INT 2
57561: NEG
57562: PUSH
57563: EMPTY
57564: LIST
57565: LIST
57566: PUSH
57567: EMPTY
57568: LIST
57569: LIST
57570: LIST
57571: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
57572: LD_ADDR_VAR 0 12
57576: PUSH
57577: LD_INT 2
57579: PUSH
57580: LD_INT 1
57582: NEG
57583: PUSH
57584: EMPTY
57585: LIST
57586: LIST
57587: PUSH
57588: LD_INT 3
57590: PUSH
57591: LD_INT 0
57593: PUSH
57594: EMPTY
57595: LIST
57596: LIST
57597: PUSH
57598: LD_INT 3
57600: PUSH
57601: LD_INT 1
57603: PUSH
57604: EMPTY
57605: LIST
57606: LIST
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: LIST
57612: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
57613: LD_ADDR_VAR 0 13
57617: PUSH
57618: LD_INT 3
57620: PUSH
57621: LD_INT 2
57623: PUSH
57624: EMPTY
57625: LIST
57626: LIST
57627: PUSH
57628: LD_INT 3
57630: PUSH
57631: LD_INT 3
57633: PUSH
57634: EMPTY
57635: LIST
57636: LIST
57637: PUSH
57638: LD_INT 2
57640: PUSH
57641: LD_INT 3
57643: PUSH
57644: EMPTY
57645: LIST
57646: LIST
57647: PUSH
57648: EMPTY
57649: LIST
57650: LIST
57651: LIST
57652: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
57653: LD_ADDR_VAR 0 14
57657: PUSH
57658: LD_INT 1
57660: PUSH
57661: LD_INT 3
57663: PUSH
57664: EMPTY
57665: LIST
57666: LIST
57667: PUSH
57668: LD_INT 0
57670: PUSH
57671: LD_INT 3
57673: PUSH
57674: EMPTY
57675: LIST
57676: LIST
57677: PUSH
57678: LD_INT 1
57680: NEG
57681: PUSH
57682: LD_INT 2
57684: PUSH
57685: EMPTY
57686: LIST
57687: LIST
57688: PUSH
57689: EMPTY
57690: LIST
57691: LIST
57692: LIST
57693: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
57694: LD_ADDR_VAR 0 15
57698: PUSH
57699: LD_INT 2
57701: NEG
57702: PUSH
57703: LD_INT 1
57705: PUSH
57706: EMPTY
57707: LIST
57708: LIST
57709: PUSH
57710: LD_INT 3
57712: NEG
57713: PUSH
57714: LD_INT 0
57716: PUSH
57717: EMPTY
57718: LIST
57719: LIST
57720: PUSH
57721: LD_INT 3
57723: NEG
57724: PUSH
57725: LD_INT 1
57727: NEG
57728: PUSH
57729: EMPTY
57730: LIST
57731: LIST
57732: PUSH
57733: EMPTY
57734: LIST
57735: LIST
57736: LIST
57737: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
57738: LD_ADDR_VAR 0 16
57742: PUSH
57743: LD_INT 2
57745: NEG
57746: PUSH
57747: LD_INT 3
57749: NEG
57750: PUSH
57751: EMPTY
57752: LIST
57753: LIST
57754: PUSH
57755: LD_INT 3
57757: NEG
57758: PUSH
57759: LD_INT 2
57761: NEG
57762: PUSH
57763: EMPTY
57764: LIST
57765: LIST
57766: PUSH
57767: LD_INT 3
57769: NEG
57770: PUSH
57771: LD_INT 3
57773: NEG
57774: PUSH
57775: EMPTY
57776: LIST
57777: LIST
57778: PUSH
57779: EMPTY
57780: LIST
57781: LIST
57782: LIST
57783: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
57784: LD_ADDR_VAR 0 17
57788: PUSH
57789: LD_INT 1
57791: NEG
57792: PUSH
57793: LD_INT 3
57795: NEG
57796: PUSH
57797: EMPTY
57798: LIST
57799: LIST
57800: PUSH
57801: LD_INT 0
57803: PUSH
57804: LD_INT 3
57806: NEG
57807: PUSH
57808: EMPTY
57809: LIST
57810: LIST
57811: PUSH
57812: LD_INT 1
57814: PUSH
57815: LD_INT 2
57817: NEG
57818: PUSH
57819: EMPTY
57820: LIST
57821: LIST
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: LIST
57827: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
57828: LD_ADDR_VAR 0 18
57832: PUSH
57833: LD_INT 2
57835: PUSH
57836: LD_INT 1
57838: NEG
57839: PUSH
57840: EMPTY
57841: LIST
57842: LIST
57843: PUSH
57844: LD_INT 3
57846: PUSH
57847: LD_INT 0
57849: PUSH
57850: EMPTY
57851: LIST
57852: LIST
57853: PUSH
57854: LD_INT 3
57856: PUSH
57857: LD_INT 1
57859: PUSH
57860: EMPTY
57861: LIST
57862: LIST
57863: PUSH
57864: EMPTY
57865: LIST
57866: LIST
57867: LIST
57868: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
57869: LD_ADDR_VAR 0 19
57873: PUSH
57874: LD_INT 3
57876: PUSH
57877: LD_INT 2
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: PUSH
57884: LD_INT 3
57886: PUSH
57887: LD_INT 3
57889: PUSH
57890: EMPTY
57891: LIST
57892: LIST
57893: PUSH
57894: LD_INT 2
57896: PUSH
57897: LD_INT 3
57899: PUSH
57900: EMPTY
57901: LIST
57902: LIST
57903: PUSH
57904: EMPTY
57905: LIST
57906: LIST
57907: LIST
57908: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
57909: LD_ADDR_VAR 0 20
57913: PUSH
57914: LD_INT 1
57916: PUSH
57917: LD_INT 3
57919: PUSH
57920: EMPTY
57921: LIST
57922: LIST
57923: PUSH
57924: LD_INT 0
57926: PUSH
57927: LD_INT 3
57929: PUSH
57930: EMPTY
57931: LIST
57932: LIST
57933: PUSH
57934: LD_INT 1
57936: NEG
57937: PUSH
57938: LD_INT 2
57940: PUSH
57941: EMPTY
57942: LIST
57943: LIST
57944: PUSH
57945: EMPTY
57946: LIST
57947: LIST
57948: LIST
57949: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
57950: LD_ADDR_VAR 0 21
57954: PUSH
57955: LD_INT 2
57957: NEG
57958: PUSH
57959: LD_INT 1
57961: PUSH
57962: EMPTY
57963: LIST
57964: LIST
57965: PUSH
57966: LD_INT 3
57968: NEG
57969: PUSH
57970: LD_INT 0
57972: PUSH
57973: EMPTY
57974: LIST
57975: LIST
57976: PUSH
57977: LD_INT 3
57979: NEG
57980: PUSH
57981: LD_INT 1
57983: NEG
57984: PUSH
57985: EMPTY
57986: LIST
57987: LIST
57988: PUSH
57989: EMPTY
57990: LIST
57991: LIST
57992: LIST
57993: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
57994: LD_ADDR_VAR 0 22
57998: PUSH
57999: LD_INT 2
58001: NEG
58002: PUSH
58003: LD_INT 3
58005: NEG
58006: PUSH
58007: EMPTY
58008: LIST
58009: LIST
58010: PUSH
58011: LD_INT 3
58013: NEG
58014: PUSH
58015: LD_INT 2
58017: NEG
58018: PUSH
58019: EMPTY
58020: LIST
58021: LIST
58022: PUSH
58023: LD_INT 3
58025: NEG
58026: PUSH
58027: LD_INT 3
58029: NEG
58030: PUSH
58031: EMPTY
58032: LIST
58033: LIST
58034: PUSH
58035: EMPTY
58036: LIST
58037: LIST
58038: LIST
58039: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
58040: LD_ADDR_VAR 0 23
58044: PUSH
58045: LD_INT 0
58047: PUSH
58048: LD_INT 3
58050: NEG
58051: PUSH
58052: EMPTY
58053: LIST
58054: LIST
58055: PUSH
58056: LD_INT 1
58058: NEG
58059: PUSH
58060: LD_INT 4
58062: NEG
58063: PUSH
58064: EMPTY
58065: LIST
58066: LIST
58067: PUSH
58068: LD_INT 1
58070: PUSH
58071: LD_INT 3
58073: NEG
58074: PUSH
58075: EMPTY
58076: LIST
58077: LIST
58078: PUSH
58079: EMPTY
58080: LIST
58081: LIST
58082: LIST
58083: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
58084: LD_ADDR_VAR 0 24
58088: PUSH
58089: LD_INT 3
58091: PUSH
58092: LD_INT 0
58094: PUSH
58095: EMPTY
58096: LIST
58097: LIST
58098: PUSH
58099: LD_INT 3
58101: PUSH
58102: LD_INT 1
58104: NEG
58105: PUSH
58106: EMPTY
58107: LIST
58108: LIST
58109: PUSH
58110: LD_INT 4
58112: PUSH
58113: LD_INT 1
58115: PUSH
58116: EMPTY
58117: LIST
58118: LIST
58119: PUSH
58120: EMPTY
58121: LIST
58122: LIST
58123: LIST
58124: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
58125: LD_ADDR_VAR 0 25
58129: PUSH
58130: LD_INT 3
58132: PUSH
58133: LD_INT 3
58135: PUSH
58136: EMPTY
58137: LIST
58138: LIST
58139: PUSH
58140: LD_INT 4
58142: PUSH
58143: LD_INT 3
58145: PUSH
58146: EMPTY
58147: LIST
58148: LIST
58149: PUSH
58150: LD_INT 3
58152: PUSH
58153: LD_INT 4
58155: PUSH
58156: EMPTY
58157: LIST
58158: LIST
58159: PUSH
58160: EMPTY
58161: LIST
58162: LIST
58163: LIST
58164: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
58165: LD_ADDR_VAR 0 26
58169: PUSH
58170: LD_INT 0
58172: PUSH
58173: LD_INT 3
58175: PUSH
58176: EMPTY
58177: LIST
58178: LIST
58179: PUSH
58180: LD_INT 1
58182: PUSH
58183: LD_INT 4
58185: PUSH
58186: EMPTY
58187: LIST
58188: LIST
58189: PUSH
58190: LD_INT 1
58192: NEG
58193: PUSH
58194: LD_INT 3
58196: PUSH
58197: EMPTY
58198: LIST
58199: LIST
58200: PUSH
58201: EMPTY
58202: LIST
58203: LIST
58204: LIST
58205: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
58206: LD_ADDR_VAR 0 27
58210: PUSH
58211: LD_INT 3
58213: NEG
58214: PUSH
58215: LD_INT 0
58217: PUSH
58218: EMPTY
58219: LIST
58220: LIST
58221: PUSH
58222: LD_INT 3
58224: NEG
58225: PUSH
58226: LD_INT 1
58228: PUSH
58229: EMPTY
58230: LIST
58231: LIST
58232: PUSH
58233: LD_INT 4
58235: NEG
58236: PUSH
58237: LD_INT 1
58239: NEG
58240: PUSH
58241: EMPTY
58242: LIST
58243: LIST
58244: PUSH
58245: EMPTY
58246: LIST
58247: LIST
58248: LIST
58249: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
58250: LD_ADDR_VAR 0 28
58254: PUSH
58255: LD_INT 3
58257: NEG
58258: PUSH
58259: LD_INT 3
58261: NEG
58262: PUSH
58263: EMPTY
58264: LIST
58265: LIST
58266: PUSH
58267: LD_INT 3
58269: NEG
58270: PUSH
58271: LD_INT 4
58273: NEG
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: PUSH
58279: LD_INT 4
58281: NEG
58282: PUSH
58283: LD_INT 3
58285: NEG
58286: PUSH
58287: EMPTY
58288: LIST
58289: LIST
58290: PUSH
58291: EMPTY
58292: LIST
58293: LIST
58294: LIST
58295: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
58296: LD_ADDR_VAR 0 29
58300: PUSH
58301: LD_INT 1
58303: NEG
58304: PUSH
58305: LD_INT 3
58307: NEG
58308: PUSH
58309: EMPTY
58310: LIST
58311: LIST
58312: PUSH
58313: LD_INT 0
58315: PUSH
58316: LD_INT 3
58318: NEG
58319: PUSH
58320: EMPTY
58321: LIST
58322: LIST
58323: PUSH
58324: LD_INT 1
58326: PUSH
58327: LD_INT 2
58329: NEG
58330: PUSH
58331: EMPTY
58332: LIST
58333: LIST
58334: PUSH
58335: LD_INT 1
58337: NEG
58338: PUSH
58339: LD_INT 4
58341: NEG
58342: PUSH
58343: EMPTY
58344: LIST
58345: LIST
58346: PUSH
58347: LD_INT 0
58349: PUSH
58350: LD_INT 4
58352: NEG
58353: PUSH
58354: EMPTY
58355: LIST
58356: LIST
58357: PUSH
58358: LD_INT 1
58360: PUSH
58361: LD_INT 3
58363: NEG
58364: PUSH
58365: EMPTY
58366: LIST
58367: LIST
58368: PUSH
58369: LD_INT 1
58371: NEG
58372: PUSH
58373: LD_INT 5
58375: NEG
58376: PUSH
58377: EMPTY
58378: LIST
58379: LIST
58380: PUSH
58381: LD_INT 0
58383: PUSH
58384: LD_INT 5
58386: NEG
58387: PUSH
58388: EMPTY
58389: LIST
58390: LIST
58391: PUSH
58392: LD_INT 1
58394: PUSH
58395: LD_INT 4
58397: NEG
58398: PUSH
58399: EMPTY
58400: LIST
58401: LIST
58402: PUSH
58403: LD_INT 1
58405: NEG
58406: PUSH
58407: LD_INT 6
58409: NEG
58410: PUSH
58411: EMPTY
58412: LIST
58413: LIST
58414: PUSH
58415: LD_INT 0
58417: PUSH
58418: LD_INT 6
58420: NEG
58421: PUSH
58422: EMPTY
58423: LIST
58424: LIST
58425: PUSH
58426: LD_INT 1
58428: PUSH
58429: LD_INT 5
58431: NEG
58432: PUSH
58433: EMPTY
58434: LIST
58435: LIST
58436: PUSH
58437: EMPTY
58438: LIST
58439: LIST
58440: LIST
58441: LIST
58442: LIST
58443: LIST
58444: LIST
58445: LIST
58446: LIST
58447: LIST
58448: LIST
58449: LIST
58450: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
58451: LD_ADDR_VAR 0 30
58455: PUSH
58456: LD_INT 2
58458: PUSH
58459: LD_INT 1
58461: NEG
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: PUSH
58467: LD_INT 3
58469: PUSH
58470: LD_INT 0
58472: PUSH
58473: EMPTY
58474: LIST
58475: LIST
58476: PUSH
58477: LD_INT 3
58479: PUSH
58480: LD_INT 1
58482: PUSH
58483: EMPTY
58484: LIST
58485: LIST
58486: PUSH
58487: LD_INT 3
58489: PUSH
58490: LD_INT 1
58492: NEG
58493: PUSH
58494: EMPTY
58495: LIST
58496: LIST
58497: PUSH
58498: LD_INT 4
58500: PUSH
58501: LD_INT 0
58503: PUSH
58504: EMPTY
58505: LIST
58506: LIST
58507: PUSH
58508: LD_INT 4
58510: PUSH
58511: LD_INT 1
58513: PUSH
58514: EMPTY
58515: LIST
58516: LIST
58517: PUSH
58518: LD_INT 4
58520: PUSH
58521: LD_INT 1
58523: NEG
58524: PUSH
58525: EMPTY
58526: LIST
58527: LIST
58528: PUSH
58529: LD_INT 5
58531: PUSH
58532: LD_INT 0
58534: PUSH
58535: EMPTY
58536: LIST
58537: LIST
58538: PUSH
58539: LD_INT 5
58541: PUSH
58542: LD_INT 1
58544: PUSH
58545: EMPTY
58546: LIST
58547: LIST
58548: PUSH
58549: LD_INT 5
58551: PUSH
58552: LD_INT 1
58554: NEG
58555: PUSH
58556: EMPTY
58557: LIST
58558: LIST
58559: PUSH
58560: LD_INT 6
58562: PUSH
58563: LD_INT 0
58565: PUSH
58566: EMPTY
58567: LIST
58568: LIST
58569: PUSH
58570: LD_INT 6
58572: PUSH
58573: LD_INT 1
58575: PUSH
58576: EMPTY
58577: LIST
58578: LIST
58579: PUSH
58580: EMPTY
58581: LIST
58582: LIST
58583: LIST
58584: LIST
58585: LIST
58586: LIST
58587: LIST
58588: LIST
58589: LIST
58590: LIST
58591: LIST
58592: LIST
58593: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
58594: LD_ADDR_VAR 0 31
58598: PUSH
58599: LD_INT 3
58601: PUSH
58602: LD_INT 2
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: PUSH
58609: LD_INT 3
58611: PUSH
58612: LD_INT 3
58614: PUSH
58615: EMPTY
58616: LIST
58617: LIST
58618: PUSH
58619: LD_INT 2
58621: PUSH
58622: LD_INT 3
58624: PUSH
58625: EMPTY
58626: LIST
58627: LIST
58628: PUSH
58629: LD_INT 4
58631: PUSH
58632: LD_INT 3
58634: PUSH
58635: EMPTY
58636: LIST
58637: LIST
58638: PUSH
58639: LD_INT 4
58641: PUSH
58642: LD_INT 4
58644: PUSH
58645: EMPTY
58646: LIST
58647: LIST
58648: PUSH
58649: LD_INT 3
58651: PUSH
58652: LD_INT 4
58654: PUSH
58655: EMPTY
58656: LIST
58657: LIST
58658: PUSH
58659: LD_INT 5
58661: PUSH
58662: LD_INT 4
58664: PUSH
58665: EMPTY
58666: LIST
58667: LIST
58668: PUSH
58669: LD_INT 5
58671: PUSH
58672: LD_INT 5
58674: PUSH
58675: EMPTY
58676: LIST
58677: LIST
58678: PUSH
58679: LD_INT 4
58681: PUSH
58682: LD_INT 5
58684: PUSH
58685: EMPTY
58686: LIST
58687: LIST
58688: PUSH
58689: LD_INT 6
58691: PUSH
58692: LD_INT 5
58694: PUSH
58695: EMPTY
58696: LIST
58697: LIST
58698: PUSH
58699: LD_INT 6
58701: PUSH
58702: LD_INT 6
58704: PUSH
58705: EMPTY
58706: LIST
58707: LIST
58708: PUSH
58709: LD_INT 5
58711: PUSH
58712: LD_INT 6
58714: PUSH
58715: EMPTY
58716: LIST
58717: LIST
58718: PUSH
58719: EMPTY
58720: LIST
58721: LIST
58722: LIST
58723: LIST
58724: LIST
58725: LIST
58726: LIST
58727: LIST
58728: LIST
58729: LIST
58730: LIST
58731: LIST
58732: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
58733: LD_ADDR_VAR 0 32
58737: PUSH
58738: LD_INT 1
58740: PUSH
58741: LD_INT 3
58743: PUSH
58744: EMPTY
58745: LIST
58746: LIST
58747: PUSH
58748: LD_INT 0
58750: PUSH
58751: LD_INT 3
58753: PUSH
58754: EMPTY
58755: LIST
58756: LIST
58757: PUSH
58758: LD_INT 1
58760: NEG
58761: PUSH
58762: LD_INT 2
58764: PUSH
58765: EMPTY
58766: LIST
58767: LIST
58768: PUSH
58769: LD_INT 1
58771: PUSH
58772: LD_INT 4
58774: PUSH
58775: EMPTY
58776: LIST
58777: LIST
58778: PUSH
58779: LD_INT 0
58781: PUSH
58782: LD_INT 4
58784: PUSH
58785: EMPTY
58786: LIST
58787: LIST
58788: PUSH
58789: LD_INT 1
58791: NEG
58792: PUSH
58793: LD_INT 3
58795: PUSH
58796: EMPTY
58797: LIST
58798: LIST
58799: PUSH
58800: LD_INT 1
58802: PUSH
58803: LD_INT 5
58805: PUSH
58806: EMPTY
58807: LIST
58808: LIST
58809: PUSH
58810: LD_INT 0
58812: PUSH
58813: LD_INT 5
58815: PUSH
58816: EMPTY
58817: LIST
58818: LIST
58819: PUSH
58820: LD_INT 1
58822: NEG
58823: PUSH
58824: LD_INT 4
58826: PUSH
58827: EMPTY
58828: LIST
58829: LIST
58830: PUSH
58831: LD_INT 1
58833: PUSH
58834: LD_INT 6
58836: PUSH
58837: EMPTY
58838: LIST
58839: LIST
58840: PUSH
58841: LD_INT 0
58843: PUSH
58844: LD_INT 6
58846: PUSH
58847: EMPTY
58848: LIST
58849: LIST
58850: PUSH
58851: LD_INT 1
58853: NEG
58854: PUSH
58855: LD_INT 5
58857: PUSH
58858: EMPTY
58859: LIST
58860: LIST
58861: PUSH
58862: EMPTY
58863: LIST
58864: LIST
58865: LIST
58866: LIST
58867: LIST
58868: LIST
58869: LIST
58870: LIST
58871: LIST
58872: LIST
58873: LIST
58874: LIST
58875: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
58876: LD_ADDR_VAR 0 33
58880: PUSH
58881: LD_INT 2
58883: NEG
58884: PUSH
58885: LD_INT 1
58887: PUSH
58888: EMPTY
58889: LIST
58890: LIST
58891: PUSH
58892: LD_INT 3
58894: NEG
58895: PUSH
58896: LD_INT 0
58898: PUSH
58899: EMPTY
58900: LIST
58901: LIST
58902: PUSH
58903: LD_INT 3
58905: NEG
58906: PUSH
58907: LD_INT 1
58909: NEG
58910: PUSH
58911: EMPTY
58912: LIST
58913: LIST
58914: PUSH
58915: LD_INT 3
58917: NEG
58918: PUSH
58919: LD_INT 1
58921: PUSH
58922: EMPTY
58923: LIST
58924: LIST
58925: PUSH
58926: LD_INT 4
58928: NEG
58929: PUSH
58930: LD_INT 0
58932: PUSH
58933: EMPTY
58934: LIST
58935: LIST
58936: PUSH
58937: LD_INT 4
58939: NEG
58940: PUSH
58941: LD_INT 1
58943: NEG
58944: PUSH
58945: EMPTY
58946: LIST
58947: LIST
58948: PUSH
58949: LD_INT 4
58951: NEG
58952: PUSH
58953: LD_INT 1
58955: PUSH
58956: EMPTY
58957: LIST
58958: LIST
58959: PUSH
58960: LD_INT 5
58962: NEG
58963: PUSH
58964: LD_INT 0
58966: PUSH
58967: EMPTY
58968: LIST
58969: LIST
58970: PUSH
58971: LD_INT 5
58973: NEG
58974: PUSH
58975: LD_INT 1
58977: NEG
58978: PUSH
58979: EMPTY
58980: LIST
58981: LIST
58982: PUSH
58983: LD_INT 5
58985: NEG
58986: PUSH
58987: LD_INT 1
58989: PUSH
58990: EMPTY
58991: LIST
58992: LIST
58993: PUSH
58994: LD_INT 6
58996: NEG
58997: PUSH
58998: LD_INT 0
59000: PUSH
59001: EMPTY
59002: LIST
59003: LIST
59004: PUSH
59005: LD_INT 6
59007: NEG
59008: PUSH
59009: LD_INT 1
59011: NEG
59012: PUSH
59013: EMPTY
59014: LIST
59015: LIST
59016: PUSH
59017: EMPTY
59018: LIST
59019: LIST
59020: LIST
59021: LIST
59022: LIST
59023: LIST
59024: LIST
59025: LIST
59026: LIST
59027: LIST
59028: LIST
59029: LIST
59030: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
59031: LD_ADDR_VAR 0 34
59035: PUSH
59036: LD_INT 2
59038: NEG
59039: PUSH
59040: LD_INT 3
59042: NEG
59043: PUSH
59044: EMPTY
59045: LIST
59046: LIST
59047: PUSH
59048: LD_INT 3
59050: NEG
59051: PUSH
59052: LD_INT 2
59054: NEG
59055: PUSH
59056: EMPTY
59057: LIST
59058: LIST
59059: PUSH
59060: LD_INT 3
59062: NEG
59063: PUSH
59064: LD_INT 3
59066: NEG
59067: PUSH
59068: EMPTY
59069: LIST
59070: LIST
59071: PUSH
59072: LD_INT 3
59074: NEG
59075: PUSH
59076: LD_INT 4
59078: NEG
59079: PUSH
59080: EMPTY
59081: LIST
59082: LIST
59083: PUSH
59084: LD_INT 4
59086: NEG
59087: PUSH
59088: LD_INT 3
59090: NEG
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: PUSH
59096: LD_INT 4
59098: NEG
59099: PUSH
59100: LD_INT 4
59102: NEG
59103: PUSH
59104: EMPTY
59105: LIST
59106: LIST
59107: PUSH
59108: LD_INT 4
59110: NEG
59111: PUSH
59112: LD_INT 5
59114: NEG
59115: PUSH
59116: EMPTY
59117: LIST
59118: LIST
59119: PUSH
59120: LD_INT 5
59122: NEG
59123: PUSH
59124: LD_INT 4
59126: NEG
59127: PUSH
59128: EMPTY
59129: LIST
59130: LIST
59131: PUSH
59132: LD_INT 5
59134: NEG
59135: PUSH
59136: LD_INT 5
59138: NEG
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: PUSH
59144: LD_INT 5
59146: NEG
59147: PUSH
59148: LD_INT 6
59150: NEG
59151: PUSH
59152: EMPTY
59153: LIST
59154: LIST
59155: PUSH
59156: LD_INT 6
59158: NEG
59159: PUSH
59160: LD_INT 5
59162: NEG
59163: PUSH
59164: EMPTY
59165: LIST
59166: LIST
59167: PUSH
59168: LD_INT 6
59170: NEG
59171: PUSH
59172: LD_INT 6
59174: NEG
59175: PUSH
59176: EMPTY
59177: LIST
59178: LIST
59179: PUSH
59180: EMPTY
59181: LIST
59182: LIST
59183: LIST
59184: LIST
59185: LIST
59186: LIST
59187: LIST
59188: LIST
59189: LIST
59190: LIST
59191: LIST
59192: LIST
59193: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
59194: LD_ADDR_VAR 0 41
59198: PUSH
59199: LD_INT 0
59201: PUSH
59202: LD_INT 2
59204: NEG
59205: PUSH
59206: EMPTY
59207: LIST
59208: LIST
59209: PUSH
59210: LD_INT 1
59212: NEG
59213: PUSH
59214: LD_INT 3
59216: NEG
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: PUSH
59222: LD_INT 1
59224: PUSH
59225: LD_INT 2
59227: NEG
59228: PUSH
59229: EMPTY
59230: LIST
59231: LIST
59232: PUSH
59233: EMPTY
59234: LIST
59235: LIST
59236: LIST
59237: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
59238: LD_ADDR_VAR 0 42
59242: PUSH
59243: LD_INT 2
59245: PUSH
59246: LD_INT 0
59248: PUSH
59249: EMPTY
59250: LIST
59251: LIST
59252: PUSH
59253: LD_INT 2
59255: PUSH
59256: LD_INT 1
59258: NEG
59259: PUSH
59260: EMPTY
59261: LIST
59262: LIST
59263: PUSH
59264: LD_INT 3
59266: PUSH
59267: LD_INT 1
59269: PUSH
59270: EMPTY
59271: LIST
59272: LIST
59273: PUSH
59274: EMPTY
59275: LIST
59276: LIST
59277: LIST
59278: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
59279: LD_ADDR_VAR 0 43
59283: PUSH
59284: LD_INT 2
59286: PUSH
59287: LD_INT 2
59289: PUSH
59290: EMPTY
59291: LIST
59292: LIST
59293: PUSH
59294: LD_INT 3
59296: PUSH
59297: LD_INT 2
59299: PUSH
59300: EMPTY
59301: LIST
59302: LIST
59303: PUSH
59304: LD_INT 2
59306: PUSH
59307: LD_INT 3
59309: PUSH
59310: EMPTY
59311: LIST
59312: LIST
59313: PUSH
59314: EMPTY
59315: LIST
59316: LIST
59317: LIST
59318: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
59319: LD_ADDR_VAR 0 44
59323: PUSH
59324: LD_INT 0
59326: PUSH
59327: LD_INT 2
59329: PUSH
59330: EMPTY
59331: LIST
59332: LIST
59333: PUSH
59334: LD_INT 1
59336: PUSH
59337: LD_INT 3
59339: PUSH
59340: EMPTY
59341: LIST
59342: LIST
59343: PUSH
59344: LD_INT 1
59346: NEG
59347: PUSH
59348: LD_INT 2
59350: PUSH
59351: EMPTY
59352: LIST
59353: LIST
59354: PUSH
59355: EMPTY
59356: LIST
59357: LIST
59358: LIST
59359: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
59360: LD_ADDR_VAR 0 45
59364: PUSH
59365: LD_INT 2
59367: NEG
59368: PUSH
59369: LD_INT 0
59371: PUSH
59372: EMPTY
59373: LIST
59374: LIST
59375: PUSH
59376: LD_INT 2
59378: NEG
59379: PUSH
59380: LD_INT 1
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: PUSH
59387: LD_INT 3
59389: NEG
59390: PUSH
59391: LD_INT 1
59393: NEG
59394: PUSH
59395: EMPTY
59396: LIST
59397: LIST
59398: PUSH
59399: EMPTY
59400: LIST
59401: LIST
59402: LIST
59403: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
59404: LD_ADDR_VAR 0 46
59408: PUSH
59409: LD_INT 2
59411: NEG
59412: PUSH
59413: LD_INT 2
59415: NEG
59416: PUSH
59417: EMPTY
59418: LIST
59419: LIST
59420: PUSH
59421: LD_INT 2
59423: NEG
59424: PUSH
59425: LD_INT 3
59427: NEG
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: PUSH
59433: LD_INT 3
59435: NEG
59436: PUSH
59437: LD_INT 2
59439: NEG
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: PUSH
59445: EMPTY
59446: LIST
59447: LIST
59448: LIST
59449: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
59450: LD_ADDR_VAR 0 47
59454: PUSH
59455: LD_INT 2
59457: NEG
59458: PUSH
59459: LD_INT 3
59461: NEG
59462: PUSH
59463: EMPTY
59464: LIST
59465: LIST
59466: PUSH
59467: LD_INT 1
59469: NEG
59470: PUSH
59471: LD_INT 3
59473: NEG
59474: PUSH
59475: EMPTY
59476: LIST
59477: LIST
59478: PUSH
59479: EMPTY
59480: LIST
59481: LIST
59482: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
59483: LD_ADDR_VAR 0 48
59487: PUSH
59488: LD_INT 1
59490: PUSH
59491: LD_INT 2
59493: NEG
59494: PUSH
59495: EMPTY
59496: LIST
59497: LIST
59498: PUSH
59499: LD_INT 2
59501: PUSH
59502: LD_INT 1
59504: NEG
59505: PUSH
59506: EMPTY
59507: LIST
59508: LIST
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
59514: LD_ADDR_VAR 0 49
59518: PUSH
59519: LD_INT 3
59521: PUSH
59522: LD_INT 1
59524: PUSH
59525: EMPTY
59526: LIST
59527: LIST
59528: PUSH
59529: LD_INT 3
59531: PUSH
59532: LD_INT 2
59534: PUSH
59535: EMPTY
59536: LIST
59537: LIST
59538: PUSH
59539: EMPTY
59540: LIST
59541: LIST
59542: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
59543: LD_ADDR_VAR 0 50
59547: PUSH
59548: LD_INT 2
59550: PUSH
59551: LD_INT 3
59553: PUSH
59554: EMPTY
59555: LIST
59556: LIST
59557: PUSH
59558: LD_INT 1
59560: PUSH
59561: LD_INT 3
59563: PUSH
59564: EMPTY
59565: LIST
59566: LIST
59567: PUSH
59568: EMPTY
59569: LIST
59570: LIST
59571: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
59572: LD_ADDR_VAR 0 51
59576: PUSH
59577: LD_INT 1
59579: NEG
59580: PUSH
59581: LD_INT 2
59583: PUSH
59584: EMPTY
59585: LIST
59586: LIST
59587: PUSH
59588: LD_INT 2
59590: NEG
59591: PUSH
59592: LD_INT 1
59594: PUSH
59595: EMPTY
59596: LIST
59597: LIST
59598: PUSH
59599: EMPTY
59600: LIST
59601: LIST
59602: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
59603: LD_ADDR_VAR 0 52
59607: PUSH
59608: LD_INT 3
59610: NEG
59611: PUSH
59612: LD_INT 1
59614: NEG
59615: PUSH
59616: EMPTY
59617: LIST
59618: LIST
59619: PUSH
59620: LD_INT 3
59622: NEG
59623: PUSH
59624: LD_INT 2
59626: NEG
59627: PUSH
59628: EMPTY
59629: LIST
59630: LIST
59631: PUSH
59632: EMPTY
59633: LIST
59634: LIST
59635: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
59636: LD_ADDR_VAR 0 53
59640: PUSH
59641: LD_INT 1
59643: NEG
59644: PUSH
59645: LD_INT 3
59647: NEG
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: PUSH
59653: LD_INT 0
59655: PUSH
59656: LD_INT 3
59658: NEG
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: PUSH
59664: LD_INT 1
59666: PUSH
59667: LD_INT 2
59669: NEG
59670: PUSH
59671: EMPTY
59672: LIST
59673: LIST
59674: PUSH
59675: EMPTY
59676: LIST
59677: LIST
59678: LIST
59679: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
59680: LD_ADDR_VAR 0 54
59684: PUSH
59685: LD_INT 2
59687: PUSH
59688: LD_INT 1
59690: NEG
59691: PUSH
59692: EMPTY
59693: LIST
59694: LIST
59695: PUSH
59696: LD_INT 3
59698: PUSH
59699: LD_INT 0
59701: PUSH
59702: EMPTY
59703: LIST
59704: LIST
59705: PUSH
59706: LD_INT 3
59708: PUSH
59709: LD_INT 1
59711: PUSH
59712: EMPTY
59713: LIST
59714: LIST
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: LIST
59720: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
59721: LD_ADDR_VAR 0 55
59725: PUSH
59726: LD_INT 3
59728: PUSH
59729: LD_INT 2
59731: PUSH
59732: EMPTY
59733: LIST
59734: LIST
59735: PUSH
59736: LD_INT 3
59738: PUSH
59739: LD_INT 3
59741: PUSH
59742: EMPTY
59743: LIST
59744: LIST
59745: PUSH
59746: LD_INT 2
59748: PUSH
59749: LD_INT 3
59751: PUSH
59752: EMPTY
59753: LIST
59754: LIST
59755: PUSH
59756: EMPTY
59757: LIST
59758: LIST
59759: LIST
59760: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
59761: LD_ADDR_VAR 0 56
59765: PUSH
59766: LD_INT 1
59768: PUSH
59769: LD_INT 3
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PUSH
59776: LD_INT 0
59778: PUSH
59779: LD_INT 3
59781: PUSH
59782: EMPTY
59783: LIST
59784: LIST
59785: PUSH
59786: LD_INT 1
59788: NEG
59789: PUSH
59790: LD_INT 2
59792: PUSH
59793: EMPTY
59794: LIST
59795: LIST
59796: PUSH
59797: EMPTY
59798: LIST
59799: LIST
59800: LIST
59801: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
59802: LD_ADDR_VAR 0 57
59806: PUSH
59807: LD_INT 2
59809: NEG
59810: PUSH
59811: LD_INT 1
59813: PUSH
59814: EMPTY
59815: LIST
59816: LIST
59817: PUSH
59818: LD_INT 3
59820: NEG
59821: PUSH
59822: LD_INT 0
59824: PUSH
59825: EMPTY
59826: LIST
59827: LIST
59828: PUSH
59829: LD_INT 3
59831: NEG
59832: PUSH
59833: LD_INT 1
59835: NEG
59836: PUSH
59837: EMPTY
59838: LIST
59839: LIST
59840: PUSH
59841: EMPTY
59842: LIST
59843: LIST
59844: LIST
59845: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
59846: LD_ADDR_VAR 0 58
59850: PUSH
59851: LD_INT 2
59853: NEG
59854: PUSH
59855: LD_INT 3
59857: NEG
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: PUSH
59863: LD_INT 3
59865: NEG
59866: PUSH
59867: LD_INT 2
59869: NEG
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PUSH
59875: LD_INT 3
59877: NEG
59878: PUSH
59879: LD_INT 3
59881: NEG
59882: PUSH
59883: EMPTY
59884: LIST
59885: LIST
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: LIST
59891: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
59892: LD_ADDR_VAR 0 59
59896: PUSH
59897: LD_INT 1
59899: NEG
59900: PUSH
59901: LD_INT 2
59903: NEG
59904: PUSH
59905: EMPTY
59906: LIST
59907: LIST
59908: PUSH
59909: LD_INT 0
59911: PUSH
59912: LD_INT 2
59914: NEG
59915: PUSH
59916: EMPTY
59917: LIST
59918: LIST
59919: PUSH
59920: LD_INT 1
59922: PUSH
59923: LD_INT 1
59925: NEG
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: LIST
59935: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
59936: LD_ADDR_VAR 0 60
59940: PUSH
59941: LD_INT 1
59943: PUSH
59944: LD_INT 1
59946: NEG
59947: PUSH
59948: EMPTY
59949: LIST
59950: LIST
59951: PUSH
59952: LD_INT 2
59954: PUSH
59955: LD_INT 0
59957: PUSH
59958: EMPTY
59959: LIST
59960: LIST
59961: PUSH
59962: LD_INT 2
59964: PUSH
59965: LD_INT 1
59967: PUSH
59968: EMPTY
59969: LIST
59970: LIST
59971: PUSH
59972: EMPTY
59973: LIST
59974: LIST
59975: LIST
59976: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
59977: LD_ADDR_VAR 0 61
59981: PUSH
59982: LD_INT 2
59984: PUSH
59985: LD_INT 1
59987: PUSH
59988: EMPTY
59989: LIST
59990: LIST
59991: PUSH
59992: LD_INT 2
59994: PUSH
59995: LD_INT 2
59997: PUSH
59998: EMPTY
59999: LIST
60000: LIST
60001: PUSH
60002: LD_INT 1
60004: PUSH
60005: LD_INT 2
60007: PUSH
60008: EMPTY
60009: LIST
60010: LIST
60011: PUSH
60012: EMPTY
60013: LIST
60014: LIST
60015: LIST
60016: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
60017: LD_ADDR_VAR 0 62
60021: PUSH
60022: LD_INT 1
60024: PUSH
60025: LD_INT 2
60027: PUSH
60028: EMPTY
60029: LIST
60030: LIST
60031: PUSH
60032: LD_INT 0
60034: PUSH
60035: LD_INT 2
60037: PUSH
60038: EMPTY
60039: LIST
60040: LIST
60041: PUSH
60042: LD_INT 1
60044: NEG
60045: PUSH
60046: LD_INT 1
60048: PUSH
60049: EMPTY
60050: LIST
60051: LIST
60052: PUSH
60053: EMPTY
60054: LIST
60055: LIST
60056: LIST
60057: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
60058: LD_ADDR_VAR 0 63
60062: PUSH
60063: LD_INT 1
60065: NEG
60066: PUSH
60067: LD_INT 1
60069: PUSH
60070: EMPTY
60071: LIST
60072: LIST
60073: PUSH
60074: LD_INT 2
60076: NEG
60077: PUSH
60078: LD_INT 0
60080: PUSH
60081: EMPTY
60082: LIST
60083: LIST
60084: PUSH
60085: LD_INT 2
60087: NEG
60088: PUSH
60089: LD_INT 1
60091: NEG
60092: PUSH
60093: EMPTY
60094: LIST
60095: LIST
60096: PUSH
60097: EMPTY
60098: LIST
60099: LIST
60100: LIST
60101: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60102: LD_ADDR_VAR 0 64
60106: PUSH
60107: LD_INT 1
60109: NEG
60110: PUSH
60111: LD_INT 2
60113: NEG
60114: PUSH
60115: EMPTY
60116: LIST
60117: LIST
60118: PUSH
60119: LD_INT 2
60121: NEG
60122: PUSH
60123: LD_INT 1
60125: NEG
60126: PUSH
60127: EMPTY
60128: LIST
60129: LIST
60130: PUSH
60131: LD_INT 2
60133: NEG
60134: PUSH
60135: LD_INT 2
60137: NEG
60138: PUSH
60139: EMPTY
60140: LIST
60141: LIST
60142: PUSH
60143: EMPTY
60144: LIST
60145: LIST
60146: LIST
60147: ST_TO_ADDR
// end ; 2 :
60148: GO 63414
60150: LD_INT 2
60152: DOUBLE
60153: EQUAL
60154: IFTRUE 60158
60156: GO 63413
60158: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
60159: LD_ADDR_VAR 0 29
60163: PUSH
60164: LD_INT 4
60166: PUSH
60167: LD_INT 0
60169: PUSH
60170: EMPTY
60171: LIST
60172: LIST
60173: PUSH
60174: LD_INT 4
60176: PUSH
60177: LD_INT 1
60179: NEG
60180: PUSH
60181: EMPTY
60182: LIST
60183: LIST
60184: PUSH
60185: LD_INT 5
60187: PUSH
60188: LD_INT 0
60190: PUSH
60191: EMPTY
60192: LIST
60193: LIST
60194: PUSH
60195: LD_INT 5
60197: PUSH
60198: LD_INT 1
60200: PUSH
60201: EMPTY
60202: LIST
60203: LIST
60204: PUSH
60205: LD_INT 4
60207: PUSH
60208: LD_INT 1
60210: PUSH
60211: EMPTY
60212: LIST
60213: LIST
60214: PUSH
60215: LD_INT 3
60217: PUSH
60218: LD_INT 0
60220: PUSH
60221: EMPTY
60222: LIST
60223: LIST
60224: PUSH
60225: LD_INT 3
60227: PUSH
60228: LD_INT 1
60230: NEG
60231: PUSH
60232: EMPTY
60233: LIST
60234: LIST
60235: PUSH
60236: LD_INT 3
60238: PUSH
60239: LD_INT 2
60241: NEG
60242: PUSH
60243: EMPTY
60244: LIST
60245: LIST
60246: PUSH
60247: LD_INT 5
60249: PUSH
60250: LD_INT 2
60252: PUSH
60253: EMPTY
60254: LIST
60255: LIST
60256: PUSH
60257: LD_INT 3
60259: PUSH
60260: LD_INT 3
60262: PUSH
60263: EMPTY
60264: LIST
60265: LIST
60266: PUSH
60267: LD_INT 3
60269: PUSH
60270: LD_INT 2
60272: PUSH
60273: EMPTY
60274: LIST
60275: LIST
60276: PUSH
60277: LD_INT 4
60279: PUSH
60280: LD_INT 3
60282: PUSH
60283: EMPTY
60284: LIST
60285: LIST
60286: PUSH
60287: LD_INT 4
60289: PUSH
60290: LD_INT 4
60292: PUSH
60293: EMPTY
60294: LIST
60295: LIST
60296: PUSH
60297: LD_INT 3
60299: PUSH
60300: LD_INT 4
60302: PUSH
60303: EMPTY
60304: LIST
60305: LIST
60306: PUSH
60307: LD_INT 2
60309: PUSH
60310: LD_INT 3
60312: PUSH
60313: EMPTY
60314: LIST
60315: LIST
60316: PUSH
60317: LD_INT 2
60319: PUSH
60320: LD_INT 2
60322: PUSH
60323: EMPTY
60324: LIST
60325: LIST
60326: PUSH
60327: LD_INT 4
60329: PUSH
60330: LD_INT 2
60332: PUSH
60333: EMPTY
60334: LIST
60335: LIST
60336: PUSH
60337: LD_INT 2
60339: PUSH
60340: LD_INT 4
60342: PUSH
60343: EMPTY
60344: LIST
60345: LIST
60346: PUSH
60347: LD_INT 0
60349: PUSH
60350: LD_INT 4
60352: PUSH
60353: EMPTY
60354: LIST
60355: LIST
60356: PUSH
60357: LD_INT 0
60359: PUSH
60360: LD_INT 3
60362: PUSH
60363: EMPTY
60364: LIST
60365: LIST
60366: PUSH
60367: LD_INT 1
60369: PUSH
60370: LD_INT 4
60372: PUSH
60373: EMPTY
60374: LIST
60375: LIST
60376: PUSH
60377: LD_INT 1
60379: PUSH
60380: LD_INT 5
60382: PUSH
60383: EMPTY
60384: LIST
60385: LIST
60386: PUSH
60387: LD_INT 0
60389: PUSH
60390: LD_INT 5
60392: PUSH
60393: EMPTY
60394: LIST
60395: LIST
60396: PUSH
60397: LD_INT 1
60399: NEG
60400: PUSH
60401: LD_INT 4
60403: PUSH
60404: EMPTY
60405: LIST
60406: LIST
60407: PUSH
60408: LD_INT 1
60410: NEG
60411: PUSH
60412: LD_INT 3
60414: PUSH
60415: EMPTY
60416: LIST
60417: LIST
60418: PUSH
60419: LD_INT 2
60421: PUSH
60422: LD_INT 5
60424: PUSH
60425: EMPTY
60426: LIST
60427: LIST
60428: PUSH
60429: LD_INT 2
60431: NEG
60432: PUSH
60433: LD_INT 3
60435: PUSH
60436: EMPTY
60437: LIST
60438: LIST
60439: PUSH
60440: LD_INT 3
60442: NEG
60443: PUSH
60444: LD_INT 0
60446: PUSH
60447: EMPTY
60448: LIST
60449: LIST
60450: PUSH
60451: LD_INT 3
60453: NEG
60454: PUSH
60455: LD_INT 1
60457: NEG
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: PUSH
60463: LD_INT 2
60465: NEG
60466: PUSH
60467: LD_INT 0
60469: PUSH
60470: EMPTY
60471: LIST
60472: LIST
60473: PUSH
60474: LD_INT 2
60476: NEG
60477: PUSH
60478: LD_INT 1
60480: PUSH
60481: EMPTY
60482: LIST
60483: LIST
60484: PUSH
60485: LD_INT 3
60487: NEG
60488: PUSH
60489: LD_INT 1
60491: PUSH
60492: EMPTY
60493: LIST
60494: LIST
60495: PUSH
60496: LD_INT 4
60498: NEG
60499: PUSH
60500: LD_INT 0
60502: PUSH
60503: EMPTY
60504: LIST
60505: LIST
60506: PUSH
60507: LD_INT 4
60509: NEG
60510: PUSH
60511: LD_INT 1
60513: NEG
60514: PUSH
60515: EMPTY
60516: LIST
60517: LIST
60518: PUSH
60519: LD_INT 4
60521: NEG
60522: PUSH
60523: LD_INT 2
60525: NEG
60526: PUSH
60527: EMPTY
60528: LIST
60529: LIST
60530: PUSH
60531: LD_INT 2
60533: NEG
60534: PUSH
60535: LD_INT 2
60537: PUSH
60538: EMPTY
60539: LIST
60540: LIST
60541: PUSH
60542: LD_INT 4
60544: NEG
60545: PUSH
60546: LD_INT 4
60548: NEG
60549: PUSH
60550: EMPTY
60551: LIST
60552: LIST
60553: PUSH
60554: LD_INT 4
60556: NEG
60557: PUSH
60558: LD_INT 5
60560: NEG
60561: PUSH
60562: EMPTY
60563: LIST
60564: LIST
60565: PUSH
60566: LD_INT 3
60568: NEG
60569: PUSH
60570: LD_INT 4
60572: NEG
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: PUSH
60578: LD_INT 3
60580: NEG
60581: PUSH
60582: LD_INT 3
60584: NEG
60585: PUSH
60586: EMPTY
60587: LIST
60588: LIST
60589: PUSH
60590: LD_INT 4
60592: NEG
60593: PUSH
60594: LD_INT 3
60596: NEG
60597: PUSH
60598: EMPTY
60599: LIST
60600: LIST
60601: PUSH
60602: LD_INT 5
60604: NEG
60605: PUSH
60606: LD_INT 4
60608: NEG
60609: PUSH
60610: EMPTY
60611: LIST
60612: LIST
60613: PUSH
60614: LD_INT 5
60616: NEG
60617: PUSH
60618: LD_INT 5
60620: NEG
60621: PUSH
60622: EMPTY
60623: LIST
60624: LIST
60625: PUSH
60626: LD_INT 3
60628: NEG
60629: PUSH
60630: LD_INT 5
60632: NEG
60633: PUSH
60634: EMPTY
60635: LIST
60636: LIST
60637: PUSH
60638: LD_INT 5
60640: NEG
60641: PUSH
60642: LD_INT 3
60644: NEG
60645: PUSH
60646: EMPTY
60647: LIST
60648: LIST
60649: PUSH
60650: EMPTY
60651: LIST
60652: LIST
60653: LIST
60654: LIST
60655: LIST
60656: LIST
60657: LIST
60658: LIST
60659: LIST
60660: LIST
60661: LIST
60662: LIST
60663: LIST
60664: LIST
60665: LIST
60666: LIST
60667: LIST
60668: LIST
60669: LIST
60670: LIST
60671: LIST
60672: LIST
60673: LIST
60674: LIST
60675: LIST
60676: LIST
60677: LIST
60678: LIST
60679: LIST
60680: LIST
60681: LIST
60682: LIST
60683: LIST
60684: LIST
60685: LIST
60686: LIST
60687: LIST
60688: LIST
60689: LIST
60690: LIST
60691: LIST
60692: LIST
60693: LIST
60694: LIST
60695: LIST
60696: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
60697: LD_ADDR_VAR 0 30
60701: PUSH
60702: LD_INT 4
60704: PUSH
60705: LD_INT 4
60707: PUSH
60708: EMPTY
60709: LIST
60710: LIST
60711: PUSH
60712: LD_INT 4
60714: PUSH
60715: LD_INT 3
60717: PUSH
60718: EMPTY
60719: LIST
60720: LIST
60721: PUSH
60722: LD_INT 5
60724: PUSH
60725: LD_INT 4
60727: PUSH
60728: EMPTY
60729: LIST
60730: LIST
60731: PUSH
60732: LD_INT 5
60734: PUSH
60735: LD_INT 5
60737: PUSH
60738: EMPTY
60739: LIST
60740: LIST
60741: PUSH
60742: LD_INT 4
60744: PUSH
60745: LD_INT 5
60747: PUSH
60748: EMPTY
60749: LIST
60750: LIST
60751: PUSH
60752: LD_INT 3
60754: PUSH
60755: LD_INT 4
60757: PUSH
60758: EMPTY
60759: LIST
60760: LIST
60761: PUSH
60762: LD_INT 3
60764: PUSH
60765: LD_INT 3
60767: PUSH
60768: EMPTY
60769: LIST
60770: LIST
60771: PUSH
60772: LD_INT 5
60774: PUSH
60775: LD_INT 3
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: PUSH
60782: LD_INT 3
60784: PUSH
60785: LD_INT 5
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: PUSH
60792: LD_INT 0
60794: PUSH
60795: LD_INT 3
60797: PUSH
60798: EMPTY
60799: LIST
60800: LIST
60801: PUSH
60802: LD_INT 0
60804: PUSH
60805: LD_INT 2
60807: PUSH
60808: EMPTY
60809: LIST
60810: LIST
60811: PUSH
60812: LD_INT 1
60814: PUSH
60815: LD_INT 3
60817: PUSH
60818: EMPTY
60819: LIST
60820: LIST
60821: PUSH
60822: LD_INT 1
60824: PUSH
60825: LD_INT 4
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: PUSH
60832: LD_INT 0
60834: PUSH
60835: LD_INT 4
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: PUSH
60842: LD_INT 1
60844: NEG
60845: PUSH
60846: LD_INT 3
60848: PUSH
60849: EMPTY
60850: LIST
60851: LIST
60852: PUSH
60853: LD_INT 1
60855: NEG
60856: PUSH
60857: LD_INT 2
60859: PUSH
60860: EMPTY
60861: LIST
60862: LIST
60863: PUSH
60864: LD_INT 2
60866: PUSH
60867: LD_INT 4
60869: PUSH
60870: EMPTY
60871: LIST
60872: LIST
60873: PUSH
60874: LD_INT 2
60876: NEG
60877: PUSH
60878: LD_INT 2
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: PUSH
60885: LD_INT 4
60887: NEG
60888: PUSH
60889: LD_INT 0
60891: PUSH
60892: EMPTY
60893: LIST
60894: LIST
60895: PUSH
60896: LD_INT 4
60898: NEG
60899: PUSH
60900: LD_INT 1
60902: NEG
60903: PUSH
60904: EMPTY
60905: LIST
60906: LIST
60907: PUSH
60908: LD_INT 3
60910: NEG
60911: PUSH
60912: LD_INT 0
60914: PUSH
60915: EMPTY
60916: LIST
60917: LIST
60918: PUSH
60919: LD_INT 3
60921: NEG
60922: PUSH
60923: LD_INT 1
60925: PUSH
60926: EMPTY
60927: LIST
60928: LIST
60929: PUSH
60930: LD_INT 4
60932: NEG
60933: PUSH
60934: LD_INT 1
60936: PUSH
60937: EMPTY
60938: LIST
60939: LIST
60940: PUSH
60941: LD_INT 5
60943: NEG
60944: PUSH
60945: LD_INT 0
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: LD_INT 5
60954: NEG
60955: PUSH
60956: LD_INT 1
60958: NEG
60959: PUSH
60960: EMPTY
60961: LIST
60962: LIST
60963: PUSH
60964: LD_INT 5
60966: NEG
60967: PUSH
60968: LD_INT 2
60970: NEG
60971: PUSH
60972: EMPTY
60973: LIST
60974: LIST
60975: PUSH
60976: LD_INT 3
60978: NEG
60979: PUSH
60980: LD_INT 2
60982: PUSH
60983: EMPTY
60984: LIST
60985: LIST
60986: PUSH
60987: LD_INT 3
60989: NEG
60990: PUSH
60991: LD_INT 3
60993: NEG
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: PUSH
60999: LD_INT 3
61001: NEG
61002: PUSH
61003: LD_INT 4
61005: NEG
61006: PUSH
61007: EMPTY
61008: LIST
61009: LIST
61010: PUSH
61011: LD_INT 2
61013: NEG
61014: PUSH
61015: LD_INT 3
61017: NEG
61018: PUSH
61019: EMPTY
61020: LIST
61021: LIST
61022: PUSH
61023: LD_INT 2
61025: NEG
61026: PUSH
61027: LD_INT 2
61029: NEG
61030: PUSH
61031: EMPTY
61032: LIST
61033: LIST
61034: PUSH
61035: LD_INT 3
61037: NEG
61038: PUSH
61039: LD_INT 2
61041: NEG
61042: PUSH
61043: EMPTY
61044: LIST
61045: LIST
61046: PUSH
61047: LD_INT 4
61049: NEG
61050: PUSH
61051: LD_INT 3
61053: NEG
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PUSH
61059: LD_INT 4
61061: NEG
61062: PUSH
61063: LD_INT 4
61065: NEG
61066: PUSH
61067: EMPTY
61068: LIST
61069: LIST
61070: PUSH
61071: LD_INT 2
61073: NEG
61074: PUSH
61075: LD_INT 4
61077: NEG
61078: PUSH
61079: EMPTY
61080: LIST
61081: LIST
61082: PUSH
61083: LD_INT 4
61085: NEG
61086: PUSH
61087: LD_INT 2
61089: NEG
61090: PUSH
61091: EMPTY
61092: LIST
61093: LIST
61094: PUSH
61095: LD_INT 0
61097: PUSH
61098: LD_INT 4
61100: NEG
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PUSH
61106: LD_INT 0
61108: PUSH
61109: LD_INT 5
61111: NEG
61112: PUSH
61113: EMPTY
61114: LIST
61115: LIST
61116: PUSH
61117: LD_INT 1
61119: PUSH
61120: LD_INT 4
61122: NEG
61123: PUSH
61124: EMPTY
61125: LIST
61126: LIST
61127: PUSH
61128: LD_INT 1
61130: PUSH
61131: LD_INT 3
61133: NEG
61134: PUSH
61135: EMPTY
61136: LIST
61137: LIST
61138: PUSH
61139: LD_INT 0
61141: PUSH
61142: LD_INT 3
61144: NEG
61145: PUSH
61146: EMPTY
61147: LIST
61148: LIST
61149: PUSH
61150: LD_INT 1
61152: NEG
61153: PUSH
61154: LD_INT 4
61156: NEG
61157: PUSH
61158: EMPTY
61159: LIST
61160: LIST
61161: PUSH
61162: LD_INT 1
61164: NEG
61165: PUSH
61166: LD_INT 5
61168: NEG
61169: PUSH
61170: EMPTY
61171: LIST
61172: LIST
61173: PUSH
61174: LD_INT 2
61176: PUSH
61177: LD_INT 3
61179: NEG
61180: PUSH
61181: EMPTY
61182: LIST
61183: LIST
61184: PUSH
61185: LD_INT 2
61187: NEG
61188: PUSH
61189: LD_INT 5
61191: NEG
61192: PUSH
61193: EMPTY
61194: LIST
61195: LIST
61196: PUSH
61197: EMPTY
61198: LIST
61199: LIST
61200: LIST
61201: LIST
61202: LIST
61203: LIST
61204: LIST
61205: LIST
61206: LIST
61207: LIST
61208: LIST
61209: LIST
61210: LIST
61211: LIST
61212: LIST
61213: LIST
61214: LIST
61215: LIST
61216: LIST
61217: LIST
61218: LIST
61219: LIST
61220: LIST
61221: LIST
61222: LIST
61223: LIST
61224: LIST
61225: LIST
61226: LIST
61227: LIST
61228: LIST
61229: LIST
61230: LIST
61231: LIST
61232: LIST
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: LIST
61238: LIST
61239: LIST
61240: LIST
61241: LIST
61242: LIST
61243: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
61244: LD_ADDR_VAR 0 31
61248: PUSH
61249: LD_INT 0
61251: PUSH
61252: LD_INT 4
61254: PUSH
61255: EMPTY
61256: LIST
61257: LIST
61258: PUSH
61259: LD_INT 0
61261: PUSH
61262: LD_INT 3
61264: PUSH
61265: EMPTY
61266: LIST
61267: LIST
61268: PUSH
61269: LD_INT 1
61271: PUSH
61272: LD_INT 4
61274: PUSH
61275: EMPTY
61276: LIST
61277: LIST
61278: PUSH
61279: LD_INT 1
61281: PUSH
61282: LD_INT 5
61284: PUSH
61285: EMPTY
61286: LIST
61287: LIST
61288: PUSH
61289: LD_INT 0
61291: PUSH
61292: LD_INT 5
61294: PUSH
61295: EMPTY
61296: LIST
61297: LIST
61298: PUSH
61299: LD_INT 1
61301: NEG
61302: PUSH
61303: LD_INT 4
61305: PUSH
61306: EMPTY
61307: LIST
61308: LIST
61309: PUSH
61310: LD_INT 1
61312: NEG
61313: PUSH
61314: LD_INT 3
61316: PUSH
61317: EMPTY
61318: LIST
61319: LIST
61320: PUSH
61321: LD_INT 2
61323: PUSH
61324: LD_INT 5
61326: PUSH
61327: EMPTY
61328: LIST
61329: LIST
61330: PUSH
61331: LD_INT 2
61333: NEG
61334: PUSH
61335: LD_INT 3
61337: PUSH
61338: EMPTY
61339: LIST
61340: LIST
61341: PUSH
61342: LD_INT 3
61344: NEG
61345: PUSH
61346: LD_INT 0
61348: PUSH
61349: EMPTY
61350: LIST
61351: LIST
61352: PUSH
61353: LD_INT 3
61355: NEG
61356: PUSH
61357: LD_INT 1
61359: NEG
61360: PUSH
61361: EMPTY
61362: LIST
61363: LIST
61364: PUSH
61365: LD_INT 2
61367: NEG
61368: PUSH
61369: LD_INT 0
61371: PUSH
61372: EMPTY
61373: LIST
61374: LIST
61375: PUSH
61376: LD_INT 2
61378: NEG
61379: PUSH
61380: LD_INT 1
61382: PUSH
61383: EMPTY
61384: LIST
61385: LIST
61386: PUSH
61387: LD_INT 3
61389: NEG
61390: PUSH
61391: LD_INT 1
61393: PUSH
61394: EMPTY
61395: LIST
61396: LIST
61397: PUSH
61398: LD_INT 4
61400: NEG
61401: PUSH
61402: LD_INT 0
61404: PUSH
61405: EMPTY
61406: LIST
61407: LIST
61408: PUSH
61409: LD_INT 4
61411: NEG
61412: PUSH
61413: LD_INT 1
61415: NEG
61416: PUSH
61417: EMPTY
61418: LIST
61419: LIST
61420: PUSH
61421: LD_INT 4
61423: NEG
61424: PUSH
61425: LD_INT 2
61427: NEG
61428: PUSH
61429: EMPTY
61430: LIST
61431: LIST
61432: PUSH
61433: LD_INT 2
61435: NEG
61436: PUSH
61437: LD_INT 2
61439: PUSH
61440: EMPTY
61441: LIST
61442: LIST
61443: PUSH
61444: LD_INT 4
61446: NEG
61447: PUSH
61448: LD_INT 4
61450: NEG
61451: PUSH
61452: EMPTY
61453: LIST
61454: LIST
61455: PUSH
61456: LD_INT 4
61458: NEG
61459: PUSH
61460: LD_INT 5
61462: NEG
61463: PUSH
61464: EMPTY
61465: LIST
61466: LIST
61467: PUSH
61468: LD_INT 3
61470: NEG
61471: PUSH
61472: LD_INT 4
61474: NEG
61475: PUSH
61476: EMPTY
61477: LIST
61478: LIST
61479: PUSH
61480: LD_INT 3
61482: NEG
61483: PUSH
61484: LD_INT 3
61486: NEG
61487: PUSH
61488: EMPTY
61489: LIST
61490: LIST
61491: PUSH
61492: LD_INT 4
61494: NEG
61495: PUSH
61496: LD_INT 3
61498: NEG
61499: PUSH
61500: EMPTY
61501: LIST
61502: LIST
61503: PUSH
61504: LD_INT 5
61506: NEG
61507: PUSH
61508: LD_INT 4
61510: NEG
61511: PUSH
61512: EMPTY
61513: LIST
61514: LIST
61515: PUSH
61516: LD_INT 5
61518: NEG
61519: PUSH
61520: LD_INT 5
61522: NEG
61523: PUSH
61524: EMPTY
61525: LIST
61526: LIST
61527: PUSH
61528: LD_INT 3
61530: NEG
61531: PUSH
61532: LD_INT 5
61534: NEG
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: PUSH
61540: LD_INT 5
61542: NEG
61543: PUSH
61544: LD_INT 3
61546: NEG
61547: PUSH
61548: EMPTY
61549: LIST
61550: LIST
61551: PUSH
61552: LD_INT 0
61554: PUSH
61555: LD_INT 3
61557: NEG
61558: PUSH
61559: EMPTY
61560: LIST
61561: LIST
61562: PUSH
61563: LD_INT 0
61565: PUSH
61566: LD_INT 4
61568: NEG
61569: PUSH
61570: EMPTY
61571: LIST
61572: LIST
61573: PUSH
61574: LD_INT 1
61576: PUSH
61577: LD_INT 3
61579: NEG
61580: PUSH
61581: EMPTY
61582: LIST
61583: LIST
61584: PUSH
61585: LD_INT 1
61587: PUSH
61588: LD_INT 2
61590: NEG
61591: PUSH
61592: EMPTY
61593: LIST
61594: LIST
61595: PUSH
61596: LD_INT 0
61598: PUSH
61599: LD_INT 2
61601: NEG
61602: PUSH
61603: EMPTY
61604: LIST
61605: LIST
61606: PUSH
61607: LD_INT 1
61609: NEG
61610: PUSH
61611: LD_INT 3
61613: NEG
61614: PUSH
61615: EMPTY
61616: LIST
61617: LIST
61618: PUSH
61619: LD_INT 1
61621: NEG
61622: PUSH
61623: LD_INT 4
61625: NEG
61626: PUSH
61627: EMPTY
61628: LIST
61629: LIST
61630: PUSH
61631: LD_INT 2
61633: PUSH
61634: LD_INT 2
61636: NEG
61637: PUSH
61638: EMPTY
61639: LIST
61640: LIST
61641: PUSH
61642: LD_INT 2
61644: NEG
61645: PUSH
61646: LD_INT 4
61648: NEG
61649: PUSH
61650: EMPTY
61651: LIST
61652: LIST
61653: PUSH
61654: LD_INT 4
61656: PUSH
61657: LD_INT 0
61659: PUSH
61660: EMPTY
61661: LIST
61662: LIST
61663: PUSH
61664: LD_INT 4
61666: PUSH
61667: LD_INT 1
61669: NEG
61670: PUSH
61671: EMPTY
61672: LIST
61673: LIST
61674: PUSH
61675: LD_INT 5
61677: PUSH
61678: LD_INT 0
61680: PUSH
61681: EMPTY
61682: LIST
61683: LIST
61684: PUSH
61685: LD_INT 5
61687: PUSH
61688: LD_INT 1
61690: PUSH
61691: EMPTY
61692: LIST
61693: LIST
61694: PUSH
61695: LD_INT 4
61697: PUSH
61698: LD_INT 1
61700: PUSH
61701: EMPTY
61702: LIST
61703: LIST
61704: PUSH
61705: LD_INT 3
61707: PUSH
61708: LD_INT 0
61710: PUSH
61711: EMPTY
61712: LIST
61713: LIST
61714: PUSH
61715: LD_INT 3
61717: PUSH
61718: LD_INT 1
61720: NEG
61721: PUSH
61722: EMPTY
61723: LIST
61724: LIST
61725: PUSH
61726: LD_INT 3
61728: PUSH
61729: LD_INT 2
61731: NEG
61732: PUSH
61733: EMPTY
61734: LIST
61735: LIST
61736: PUSH
61737: LD_INT 5
61739: PUSH
61740: LD_INT 2
61742: PUSH
61743: EMPTY
61744: LIST
61745: LIST
61746: PUSH
61747: EMPTY
61748: LIST
61749: LIST
61750: LIST
61751: LIST
61752: LIST
61753: LIST
61754: LIST
61755: LIST
61756: LIST
61757: LIST
61758: LIST
61759: LIST
61760: LIST
61761: LIST
61762: LIST
61763: LIST
61764: LIST
61765: LIST
61766: LIST
61767: LIST
61768: LIST
61769: LIST
61770: LIST
61771: LIST
61772: LIST
61773: LIST
61774: LIST
61775: LIST
61776: LIST
61777: LIST
61778: LIST
61779: LIST
61780: LIST
61781: LIST
61782: LIST
61783: LIST
61784: LIST
61785: LIST
61786: LIST
61787: LIST
61788: LIST
61789: LIST
61790: LIST
61791: LIST
61792: LIST
61793: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
61794: LD_ADDR_VAR 0 32
61798: PUSH
61799: LD_INT 4
61801: NEG
61802: PUSH
61803: LD_INT 0
61805: PUSH
61806: EMPTY
61807: LIST
61808: LIST
61809: PUSH
61810: LD_INT 4
61812: NEG
61813: PUSH
61814: LD_INT 1
61816: NEG
61817: PUSH
61818: EMPTY
61819: LIST
61820: LIST
61821: PUSH
61822: LD_INT 3
61824: NEG
61825: PUSH
61826: LD_INT 0
61828: PUSH
61829: EMPTY
61830: LIST
61831: LIST
61832: PUSH
61833: LD_INT 3
61835: NEG
61836: PUSH
61837: LD_INT 1
61839: PUSH
61840: EMPTY
61841: LIST
61842: LIST
61843: PUSH
61844: LD_INT 4
61846: NEG
61847: PUSH
61848: LD_INT 1
61850: PUSH
61851: EMPTY
61852: LIST
61853: LIST
61854: PUSH
61855: LD_INT 5
61857: NEG
61858: PUSH
61859: LD_INT 0
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: PUSH
61866: LD_INT 5
61868: NEG
61869: PUSH
61870: LD_INT 1
61872: NEG
61873: PUSH
61874: EMPTY
61875: LIST
61876: LIST
61877: PUSH
61878: LD_INT 5
61880: NEG
61881: PUSH
61882: LD_INT 2
61884: NEG
61885: PUSH
61886: EMPTY
61887: LIST
61888: LIST
61889: PUSH
61890: LD_INT 3
61892: NEG
61893: PUSH
61894: LD_INT 2
61896: PUSH
61897: EMPTY
61898: LIST
61899: LIST
61900: PUSH
61901: LD_INT 3
61903: NEG
61904: PUSH
61905: LD_INT 3
61907: NEG
61908: PUSH
61909: EMPTY
61910: LIST
61911: LIST
61912: PUSH
61913: LD_INT 3
61915: NEG
61916: PUSH
61917: LD_INT 4
61919: NEG
61920: PUSH
61921: EMPTY
61922: LIST
61923: LIST
61924: PUSH
61925: LD_INT 2
61927: NEG
61928: PUSH
61929: LD_INT 3
61931: NEG
61932: PUSH
61933: EMPTY
61934: LIST
61935: LIST
61936: PUSH
61937: LD_INT 2
61939: NEG
61940: PUSH
61941: LD_INT 2
61943: NEG
61944: PUSH
61945: EMPTY
61946: LIST
61947: LIST
61948: PUSH
61949: LD_INT 3
61951: NEG
61952: PUSH
61953: LD_INT 2
61955: NEG
61956: PUSH
61957: EMPTY
61958: LIST
61959: LIST
61960: PUSH
61961: LD_INT 4
61963: NEG
61964: PUSH
61965: LD_INT 3
61967: NEG
61968: PUSH
61969: EMPTY
61970: LIST
61971: LIST
61972: PUSH
61973: LD_INT 4
61975: NEG
61976: PUSH
61977: LD_INT 4
61979: NEG
61980: PUSH
61981: EMPTY
61982: LIST
61983: LIST
61984: PUSH
61985: LD_INT 2
61987: NEG
61988: PUSH
61989: LD_INT 4
61991: NEG
61992: PUSH
61993: EMPTY
61994: LIST
61995: LIST
61996: PUSH
61997: LD_INT 4
61999: NEG
62000: PUSH
62001: LD_INT 2
62003: NEG
62004: PUSH
62005: EMPTY
62006: LIST
62007: LIST
62008: PUSH
62009: LD_INT 0
62011: PUSH
62012: LD_INT 4
62014: NEG
62015: PUSH
62016: EMPTY
62017: LIST
62018: LIST
62019: PUSH
62020: LD_INT 0
62022: PUSH
62023: LD_INT 5
62025: NEG
62026: PUSH
62027: EMPTY
62028: LIST
62029: LIST
62030: PUSH
62031: LD_INT 1
62033: PUSH
62034: LD_INT 4
62036: NEG
62037: PUSH
62038: EMPTY
62039: LIST
62040: LIST
62041: PUSH
62042: LD_INT 1
62044: PUSH
62045: LD_INT 3
62047: NEG
62048: PUSH
62049: EMPTY
62050: LIST
62051: LIST
62052: PUSH
62053: LD_INT 0
62055: PUSH
62056: LD_INT 3
62058: NEG
62059: PUSH
62060: EMPTY
62061: LIST
62062: LIST
62063: PUSH
62064: LD_INT 1
62066: NEG
62067: PUSH
62068: LD_INT 4
62070: NEG
62071: PUSH
62072: EMPTY
62073: LIST
62074: LIST
62075: PUSH
62076: LD_INT 1
62078: NEG
62079: PUSH
62080: LD_INT 5
62082: NEG
62083: PUSH
62084: EMPTY
62085: LIST
62086: LIST
62087: PUSH
62088: LD_INT 2
62090: PUSH
62091: LD_INT 3
62093: NEG
62094: PUSH
62095: EMPTY
62096: LIST
62097: LIST
62098: PUSH
62099: LD_INT 2
62101: NEG
62102: PUSH
62103: LD_INT 5
62105: NEG
62106: PUSH
62107: EMPTY
62108: LIST
62109: LIST
62110: PUSH
62111: LD_INT 3
62113: PUSH
62114: LD_INT 0
62116: PUSH
62117: EMPTY
62118: LIST
62119: LIST
62120: PUSH
62121: LD_INT 3
62123: PUSH
62124: LD_INT 1
62126: NEG
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: PUSH
62132: LD_INT 4
62134: PUSH
62135: LD_INT 0
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PUSH
62142: LD_INT 4
62144: PUSH
62145: LD_INT 1
62147: PUSH
62148: EMPTY
62149: LIST
62150: LIST
62151: PUSH
62152: LD_INT 3
62154: PUSH
62155: LD_INT 1
62157: PUSH
62158: EMPTY
62159: LIST
62160: LIST
62161: PUSH
62162: LD_INT 2
62164: PUSH
62165: LD_INT 0
62167: PUSH
62168: EMPTY
62169: LIST
62170: LIST
62171: PUSH
62172: LD_INT 2
62174: PUSH
62175: LD_INT 1
62177: NEG
62178: PUSH
62179: EMPTY
62180: LIST
62181: LIST
62182: PUSH
62183: LD_INT 2
62185: PUSH
62186: LD_INT 2
62188: NEG
62189: PUSH
62190: EMPTY
62191: LIST
62192: LIST
62193: PUSH
62194: LD_INT 4
62196: PUSH
62197: LD_INT 2
62199: PUSH
62200: EMPTY
62201: LIST
62202: LIST
62203: PUSH
62204: LD_INT 4
62206: PUSH
62207: LD_INT 4
62209: PUSH
62210: EMPTY
62211: LIST
62212: LIST
62213: PUSH
62214: LD_INT 4
62216: PUSH
62217: LD_INT 3
62219: PUSH
62220: EMPTY
62221: LIST
62222: LIST
62223: PUSH
62224: LD_INT 5
62226: PUSH
62227: LD_INT 4
62229: PUSH
62230: EMPTY
62231: LIST
62232: LIST
62233: PUSH
62234: LD_INT 5
62236: PUSH
62237: LD_INT 5
62239: PUSH
62240: EMPTY
62241: LIST
62242: LIST
62243: PUSH
62244: LD_INT 4
62246: PUSH
62247: LD_INT 5
62249: PUSH
62250: EMPTY
62251: LIST
62252: LIST
62253: PUSH
62254: LD_INT 3
62256: PUSH
62257: LD_INT 4
62259: PUSH
62260: EMPTY
62261: LIST
62262: LIST
62263: PUSH
62264: LD_INT 3
62266: PUSH
62267: LD_INT 3
62269: PUSH
62270: EMPTY
62271: LIST
62272: LIST
62273: PUSH
62274: LD_INT 5
62276: PUSH
62277: LD_INT 3
62279: PUSH
62280: EMPTY
62281: LIST
62282: LIST
62283: PUSH
62284: LD_INT 3
62286: PUSH
62287: LD_INT 5
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: PUSH
62294: EMPTY
62295: LIST
62296: LIST
62297: LIST
62298: LIST
62299: LIST
62300: LIST
62301: LIST
62302: LIST
62303: LIST
62304: LIST
62305: LIST
62306: LIST
62307: LIST
62308: LIST
62309: LIST
62310: LIST
62311: LIST
62312: LIST
62313: LIST
62314: LIST
62315: LIST
62316: LIST
62317: LIST
62318: LIST
62319: LIST
62320: LIST
62321: LIST
62322: LIST
62323: LIST
62324: LIST
62325: LIST
62326: LIST
62327: LIST
62328: LIST
62329: LIST
62330: LIST
62331: LIST
62332: LIST
62333: LIST
62334: LIST
62335: LIST
62336: LIST
62337: LIST
62338: LIST
62339: LIST
62340: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
62341: LD_ADDR_VAR 0 33
62345: PUSH
62346: LD_INT 4
62348: NEG
62349: PUSH
62350: LD_INT 4
62352: NEG
62353: PUSH
62354: EMPTY
62355: LIST
62356: LIST
62357: PUSH
62358: LD_INT 4
62360: NEG
62361: PUSH
62362: LD_INT 5
62364: NEG
62365: PUSH
62366: EMPTY
62367: LIST
62368: LIST
62369: PUSH
62370: LD_INT 3
62372: NEG
62373: PUSH
62374: LD_INT 4
62376: NEG
62377: PUSH
62378: EMPTY
62379: LIST
62380: LIST
62381: PUSH
62382: LD_INT 3
62384: NEG
62385: PUSH
62386: LD_INT 3
62388: NEG
62389: PUSH
62390: EMPTY
62391: LIST
62392: LIST
62393: PUSH
62394: LD_INT 4
62396: NEG
62397: PUSH
62398: LD_INT 3
62400: NEG
62401: PUSH
62402: EMPTY
62403: LIST
62404: LIST
62405: PUSH
62406: LD_INT 5
62408: NEG
62409: PUSH
62410: LD_INT 4
62412: NEG
62413: PUSH
62414: EMPTY
62415: LIST
62416: LIST
62417: PUSH
62418: LD_INT 5
62420: NEG
62421: PUSH
62422: LD_INT 5
62424: NEG
62425: PUSH
62426: EMPTY
62427: LIST
62428: LIST
62429: PUSH
62430: LD_INT 3
62432: NEG
62433: PUSH
62434: LD_INT 5
62436: NEG
62437: PUSH
62438: EMPTY
62439: LIST
62440: LIST
62441: PUSH
62442: LD_INT 5
62444: NEG
62445: PUSH
62446: LD_INT 3
62448: NEG
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: PUSH
62454: LD_INT 0
62456: PUSH
62457: LD_INT 3
62459: NEG
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: PUSH
62465: LD_INT 0
62467: PUSH
62468: LD_INT 4
62470: NEG
62471: PUSH
62472: EMPTY
62473: LIST
62474: LIST
62475: PUSH
62476: LD_INT 1
62478: PUSH
62479: LD_INT 3
62481: NEG
62482: PUSH
62483: EMPTY
62484: LIST
62485: LIST
62486: PUSH
62487: LD_INT 1
62489: PUSH
62490: LD_INT 2
62492: NEG
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 0
62500: PUSH
62501: LD_INT 2
62503: NEG
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: PUSH
62509: LD_INT 1
62511: NEG
62512: PUSH
62513: LD_INT 3
62515: NEG
62516: PUSH
62517: EMPTY
62518: LIST
62519: LIST
62520: PUSH
62521: LD_INT 1
62523: NEG
62524: PUSH
62525: LD_INT 4
62527: NEG
62528: PUSH
62529: EMPTY
62530: LIST
62531: LIST
62532: PUSH
62533: LD_INT 2
62535: PUSH
62536: LD_INT 2
62538: NEG
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: PUSH
62544: LD_INT 2
62546: NEG
62547: PUSH
62548: LD_INT 4
62550: NEG
62551: PUSH
62552: EMPTY
62553: LIST
62554: LIST
62555: PUSH
62556: LD_INT 4
62558: PUSH
62559: LD_INT 0
62561: PUSH
62562: EMPTY
62563: LIST
62564: LIST
62565: PUSH
62566: LD_INT 4
62568: PUSH
62569: LD_INT 1
62571: NEG
62572: PUSH
62573: EMPTY
62574: LIST
62575: LIST
62576: PUSH
62577: LD_INT 5
62579: PUSH
62580: LD_INT 0
62582: PUSH
62583: EMPTY
62584: LIST
62585: LIST
62586: PUSH
62587: LD_INT 5
62589: PUSH
62590: LD_INT 1
62592: PUSH
62593: EMPTY
62594: LIST
62595: LIST
62596: PUSH
62597: LD_INT 4
62599: PUSH
62600: LD_INT 1
62602: PUSH
62603: EMPTY
62604: LIST
62605: LIST
62606: PUSH
62607: LD_INT 3
62609: PUSH
62610: LD_INT 0
62612: PUSH
62613: EMPTY
62614: LIST
62615: LIST
62616: PUSH
62617: LD_INT 3
62619: PUSH
62620: LD_INT 1
62622: NEG
62623: PUSH
62624: EMPTY
62625: LIST
62626: LIST
62627: PUSH
62628: LD_INT 3
62630: PUSH
62631: LD_INT 2
62633: NEG
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PUSH
62639: LD_INT 5
62641: PUSH
62642: LD_INT 2
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: PUSH
62649: LD_INT 3
62651: PUSH
62652: LD_INT 3
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: PUSH
62659: LD_INT 3
62661: PUSH
62662: LD_INT 2
62664: PUSH
62665: EMPTY
62666: LIST
62667: LIST
62668: PUSH
62669: LD_INT 4
62671: PUSH
62672: LD_INT 3
62674: PUSH
62675: EMPTY
62676: LIST
62677: LIST
62678: PUSH
62679: LD_INT 4
62681: PUSH
62682: LD_INT 4
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: PUSH
62689: LD_INT 3
62691: PUSH
62692: LD_INT 4
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PUSH
62699: LD_INT 2
62701: PUSH
62702: LD_INT 3
62704: PUSH
62705: EMPTY
62706: LIST
62707: LIST
62708: PUSH
62709: LD_INT 2
62711: PUSH
62712: LD_INT 2
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: PUSH
62719: LD_INT 4
62721: PUSH
62722: LD_INT 2
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PUSH
62729: LD_INT 2
62731: PUSH
62732: LD_INT 4
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: PUSH
62739: LD_INT 0
62741: PUSH
62742: LD_INT 4
62744: PUSH
62745: EMPTY
62746: LIST
62747: LIST
62748: PUSH
62749: LD_INT 0
62751: PUSH
62752: LD_INT 3
62754: PUSH
62755: EMPTY
62756: LIST
62757: LIST
62758: PUSH
62759: LD_INT 1
62761: PUSH
62762: LD_INT 4
62764: PUSH
62765: EMPTY
62766: LIST
62767: LIST
62768: PUSH
62769: LD_INT 1
62771: PUSH
62772: LD_INT 5
62774: PUSH
62775: EMPTY
62776: LIST
62777: LIST
62778: PUSH
62779: LD_INT 0
62781: PUSH
62782: LD_INT 5
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: PUSH
62789: LD_INT 1
62791: NEG
62792: PUSH
62793: LD_INT 4
62795: PUSH
62796: EMPTY
62797: LIST
62798: LIST
62799: PUSH
62800: LD_INT 1
62802: NEG
62803: PUSH
62804: LD_INT 3
62806: PUSH
62807: EMPTY
62808: LIST
62809: LIST
62810: PUSH
62811: LD_INT 2
62813: PUSH
62814: LD_INT 5
62816: PUSH
62817: EMPTY
62818: LIST
62819: LIST
62820: PUSH
62821: LD_INT 2
62823: NEG
62824: PUSH
62825: LD_INT 3
62827: PUSH
62828: EMPTY
62829: LIST
62830: LIST
62831: PUSH
62832: EMPTY
62833: LIST
62834: LIST
62835: LIST
62836: LIST
62837: LIST
62838: LIST
62839: LIST
62840: LIST
62841: LIST
62842: LIST
62843: LIST
62844: LIST
62845: LIST
62846: LIST
62847: LIST
62848: LIST
62849: LIST
62850: LIST
62851: LIST
62852: LIST
62853: LIST
62854: LIST
62855: LIST
62856: LIST
62857: LIST
62858: LIST
62859: LIST
62860: LIST
62861: LIST
62862: LIST
62863: LIST
62864: LIST
62865: LIST
62866: LIST
62867: LIST
62868: LIST
62869: LIST
62870: LIST
62871: LIST
62872: LIST
62873: LIST
62874: LIST
62875: LIST
62876: LIST
62877: LIST
62878: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
62879: LD_ADDR_VAR 0 34
62883: PUSH
62884: LD_INT 0
62886: PUSH
62887: LD_INT 4
62889: NEG
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: PUSH
62895: LD_INT 0
62897: PUSH
62898: LD_INT 5
62900: NEG
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: LD_INT 1
62908: PUSH
62909: LD_INT 4
62911: NEG
62912: PUSH
62913: EMPTY
62914: LIST
62915: LIST
62916: PUSH
62917: LD_INT 1
62919: PUSH
62920: LD_INT 3
62922: NEG
62923: PUSH
62924: EMPTY
62925: LIST
62926: LIST
62927: PUSH
62928: LD_INT 0
62930: PUSH
62931: LD_INT 3
62933: NEG
62934: PUSH
62935: EMPTY
62936: LIST
62937: LIST
62938: PUSH
62939: LD_INT 1
62941: NEG
62942: PUSH
62943: LD_INT 4
62945: NEG
62946: PUSH
62947: EMPTY
62948: LIST
62949: LIST
62950: PUSH
62951: LD_INT 1
62953: NEG
62954: PUSH
62955: LD_INT 5
62957: NEG
62958: PUSH
62959: EMPTY
62960: LIST
62961: LIST
62962: PUSH
62963: LD_INT 2
62965: PUSH
62966: LD_INT 3
62968: NEG
62969: PUSH
62970: EMPTY
62971: LIST
62972: LIST
62973: PUSH
62974: LD_INT 2
62976: NEG
62977: PUSH
62978: LD_INT 5
62980: NEG
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: PUSH
62986: LD_INT 3
62988: PUSH
62989: LD_INT 0
62991: PUSH
62992: EMPTY
62993: LIST
62994: LIST
62995: PUSH
62996: LD_INT 3
62998: PUSH
62999: LD_INT 1
63001: NEG
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: PUSH
63007: LD_INT 4
63009: PUSH
63010: LD_INT 0
63012: PUSH
63013: EMPTY
63014: LIST
63015: LIST
63016: PUSH
63017: LD_INT 4
63019: PUSH
63020: LD_INT 1
63022: PUSH
63023: EMPTY
63024: LIST
63025: LIST
63026: PUSH
63027: LD_INT 3
63029: PUSH
63030: LD_INT 1
63032: PUSH
63033: EMPTY
63034: LIST
63035: LIST
63036: PUSH
63037: LD_INT 2
63039: PUSH
63040: LD_INT 0
63042: PUSH
63043: EMPTY
63044: LIST
63045: LIST
63046: PUSH
63047: LD_INT 2
63049: PUSH
63050: LD_INT 1
63052: NEG
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: PUSH
63058: LD_INT 2
63060: PUSH
63061: LD_INT 2
63063: NEG
63064: PUSH
63065: EMPTY
63066: LIST
63067: LIST
63068: PUSH
63069: LD_INT 4
63071: PUSH
63072: LD_INT 2
63074: PUSH
63075: EMPTY
63076: LIST
63077: LIST
63078: PUSH
63079: LD_INT 4
63081: PUSH
63082: LD_INT 4
63084: PUSH
63085: EMPTY
63086: LIST
63087: LIST
63088: PUSH
63089: LD_INT 4
63091: PUSH
63092: LD_INT 3
63094: PUSH
63095: EMPTY
63096: LIST
63097: LIST
63098: PUSH
63099: LD_INT 5
63101: PUSH
63102: LD_INT 4
63104: PUSH
63105: EMPTY
63106: LIST
63107: LIST
63108: PUSH
63109: LD_INT 5
63111: PUSH
63112: LD_INT 5
63114: PUSH
63115: EMPTY
63116: LIST
63117: LIST
63118: PUSH
63119: LD_INT 4
63121: PUSH
63122: LD_INT 5
63124: PUSH
63125: EMPTY
63126: LIST
63127: LIST
63128: PUSH
63129: LD_INT 3
63131: PUSH
63132: LD_INT 4
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: LD_INT 3
63141: PUSH
63142: LD_INT 3
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: PUSH
63149: LD_INT 5
63151: PUSH
63152: LD_INT 3
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: PUSH
63159: LD_INT 3
63161: PUSH
63162: LD_INT 5
63164: PUSH
63165: EMPTY
63166: LIST
63167: LIST
63168: PUSH
63169: LD_INT 0
63171: PUSH
63172: LD_INT 3
63174: PUSH
63175: EMPTY
63176: LIST
63177: LIST
63178: PUSH
63179: LD_INT 0
63181: PUSH
63182: LD_INT 2
63184: PUSH
63185: EMPTY
63186: LIST
63187: LIST
63188: PUSH
63189: LD_INT 1
63191: PUSH
63192: LD_INT 3
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: PUSH
63199: LD_INT 1
63201: PUSH
63202: LD_INT 4
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: LD_INT 0
63211: PUSH
63212: LD_INT 4
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: PUSH
63219: LD_INT 1
63221: NEG
63222: PUSH
63223: LD_INT 3
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: PUSH
63230: LD_INT 1
63232: NEG
63233: PUSH
63234: LD_INT 2
63236: PUSH
63237: EMPTY
63238: LIST
63239: LIST
63240: PUSH
63241: LD_INT 2
63243: PUSH
63244: LD_INT 4
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: LD_INT 2
63253: NEG
63254: PUSH
63255: LD_INT 2
63257: PUSH
63258: EMPTY
63259: LIST
63260: LIST
63261: PUSH
63262: LD_INT 4
63264: NEG
63265: PUSH
63266: LD_INT 0
63268: PUSH
63269: EMPTY
63270: LIST
63271: LIST
63272: PUSH
63273: LD_INT 4
63275: NEG
63276: PUSH
63277: LD_INT 1
63279: NEG
63280: PUSH
63281: EMPTY
63282: LIST
63283: LIST
63284: PUSH
63285: LD_INT 3
63287: NEG
63288: PUSH
63289: LD_INT 0
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: PUSH
63296: LD_INT 3
63298: NEG
63299: PUSH
63300: LD_INT 1
63302: PUSH
63303: EMPTY
63304: LIST
63305: LIST
63306: PUSH
63307: LD_INT 4
63309: NEG
63310: PUSH
63311: LD_INT 1
63313: PUSH
63314: EMPTY
63315: LIST
63316: LIST
63317: PUSH
63318: LD_INT 5
63320: NEG
63321: PUSH
63322: LD_INT 0
63324: PUSH
63325: EMPTY
63326: LIST
63327: LIST
63328: PUSH
63329: LD_INT 5
63331: NEG
63332: PUSH
63333: LD_INT 1
63335: NEG
63336: PUSH
63337: EMPTY
63338: LIST
63339: LIST
63340: PUSH
63341: LD_INT 5
63343: NEG
63344: PUSH
63345: LD_INT 2
63347: NEG
63348: PUSH
63349: EMPTY
63350: LIST
63351: LIST
63352: PUSH
63353: LD_INT 3
63355: NEG
63356: PUSH
63357: LD_INT 2
63359: PUSH
63360: EMPTY
63361: LIST
63362: LIST
63363: PUSH
63364: EMPTY
63365: LIST
63366: LIST
63367: LIST
63368: LIST
63369: LIST
63370: LIST
63371: LIST
63372: LIST
63373: LIST
63374: LIST
63375: LIST
63376: LIST
63377: LIST
63378: LIST
63379: LIST
63380: LIST
63381: LIST
63382: LIST
63383: LIST
63384: LIST
63385: LIST
63386: LIST
63387: LIST
63388: LIST
63389: LIST
63390: LIST
63391: LIST
63392: LIST
63393: LIST
63394: LIST
63395: LIST
63396: LIST
63397: LIST
63398: LIST
63399: LIST
63400: LIST
63401: LIST
63402: LIST
63403: LIST
63404: LIST
63405: LIST
63406: LIST
63407: LIST
63408: LIST
63409: LIST
63410: ST_TO_ADDR
// end ; end ;
63411: GO 63414
63413: POP
// case btype of b_depot , b_warehouse :
63414: LD_VAR 0 1
63418: PUSH
63419: LD_INT 0
63421: DOUBLE
63422: EQUAL
63423: IFTRUE 63433
63425: LD_INT 1
63427: DOUBLE
63428: EQUAL
63429: IFTRUE 63433
63431: GO 63634
63433: POP
// case nation of nation_american :
63434: LD_VAR 0 5
63438: PUSH
63439: LD_INT 1
63441: DOUBLE
63442: EQUAL
63443: IFTRUE 63447
63445: GO 63503
63447: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
63448: LD_ADDR_VAR 0 9
63452: PUSH
63453: LD_VAR 0 11
63457: PUSH
63458: LD_VAR 0 12
63462: PUSH
63463: LD_VAR 0 13
63467: PUSH
63468: LD_VAR 0 14
63472: PUSH
63473: LD_VAR 0 15
63477: PUSH
63478: LD_VAR 0 16
63482: PUSH
63483: EMPTY
63484: LIST
63485: LIST
63486: LIST
63487: LIST
63488: LIST
63489: LIST
63490: PUSH
63491: LD_VAR 0 4
63495: PUSH
63496: LD_INT 1
63498: PLUS
63499: ARRAY
63500: ST_TO_ADDR
63501: GO 63632
63503: LD_INT 2
63505: DOUBLE
63506: EQUAL
63507: IFTRUE 63511
63509: GO 63567
63511: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
63512: LD_ADDR_VAR 0 9
63516: PUSH
63517: LD_VAR 0 17
63521: PUSH
63522: LD_VAR 0 18
63526: PUSH
63527: LD_VAR 0 19
63531: PUSH
63532: LD_VAR 0 20
63536: PUSH
63537: LD_VAR 0 21
63541: PUSH
63542: LD_VAR 0 22
63546: PUSH
63547: EMPTY
63548: LIST
63549: LIST
63550: LIST
63551: LIST
63552: LIST
63553: LIST
63554: PUSH
63555: LD_VAR 0 4
63559: PUSH
63560: LD_INT 1
63562: PLUS
63563: ARRAY
63564: ST_TO_ADDR
63565: GO 63632
63567: LD_INT 3
63569: DOUBLE
63570: EQUAL
63571: IFTRUE 63575
63573: GO 63631
63575: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
63576: LD_ADDR_VAR 0 9
63580: PUSH
63581: LD_VAR 0 23
63585: PUSH
63586: LD_VAR 0 24
63590: PUSH
63591: LD_VAR 0 25
63595: PUSH
63596: LD_VAR 0 26
63600: PUSH
63601: LD_VAR 0 27
63605: PUSH
63606: LD_VAR 0 28
63610: PUSH
63611: EMPTY
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: PUSH
63619: LD_VAR 0 4
63623: PUSH
63624: LD_INT 1
63626: PLUS
63627: ARRAY
63628: ST_TO_ADDR
63629: GO 63632
63631: POP
63632: GO 64187
63634: LD_INT 2
63636: DOUBLE
63637: EQUAL
63638: IFTRUE 63648
63640: LD_INT 3
63642: DOUBLE
63643: EQUAL
63644: IFTRUE 63648
63646: GO 63704
63648: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
63649: LD_ADDR_VAR 0 9
63653: PUSH
63654: LD_VAR 0 29
63658: PUSH
63659: LD_VAR 0 30
63663: PUSH
63664: LD_VAR 0 31
63668: PUSH
63669: LD_VAR 0 32
63673: PUSH
63674: LD_VAR 0 33
63678: PUSH
63679: LD_VAR 0 34
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: LIST
63688: LIST
63689: LIST
63690: LIST
63691: PUSH
63692: LD_VAR 0 4
63696: PUSH
63697: LD_INT 1
63699: PLUS
63700: ARRAY
63701: ST_TO_ADDR
63702: GO 64187
63704: LD_INT 16
63706: DOUBLE
63707: EQUAL
63708: IFTRUE 63766
63710: LD_INT 17
63712: DOUBLE
63713: EQUAL
63714: IFTRUE 63766
63716: LD_INT 18
63718: DOUBLE
63719: EQUAL
63720: IFTRUE 63766
63722: LD_INT 19
63724: DOUBLE
63725: EQUAL
63726: IFTRUE 63766
63728: LD_INT 22
63730: DOUBLE
63731: EQUAL
63732: IFTRUE 63766
63734: LD_INT 20
63736: DOUBLE
63737: EQUAL
63738: IFTRUE 63766
63740: LD_INT 21
63742: DOUBLE
63743: EQUAL
63744: IFTRUE 63766
63746: LD_INT 23
63748: DOUBLE
63749: EQUAL
63750: IFTRUE 63766
63752: LD_INT 24
63754: DOUBLE
63755: EQUAL
63756: IFTRUE 63766
63758: LD_INT 25
63760: DOUBLE
63761: EQUAL
63762: IFTRUE 63766
63764: GO 63822
63766: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
63767: LD_ADDR_VAR 0 9
63771: PUSH
63772: LD_VAR 0 35
63776: PUSH
63777: LD_VAR 0 36
63781: PUSH
63782: LD_VAR 0 37
63786: PUSH
63787: LD_VAR 0 38
63791: PUSH
63792: LD_VAR 0 39
63796: PUSH
63797: LD_VAR 0 40
63801: PUSH
63802: EMPTY
63803: LIST
63804: LIST
63805: LIST
63806: LIST
63807: LIST
63808: LIST
63809: PUSH
63810: LD_VAR 0 4
63814: PUSH
63815: LD_INT 1
63817: PLUS
63818: ARRAY
63819: ST_TO_ADDR
63820: GO 64187
63822: LD_INT 6
63824: DOUBLE
63825: EQUAL
63826: IFTRUE 63878
63828: LD_INT 7
63830: DOUBLE
63831: EQUAL
63832: IFTRUE 63878
63834: LD_INT 8
63836: DOUBLE
63837: EQUAL
63838: IFTRUE 63878
63840: LD_INT 13
63842: DOUBLE
63843: EQUAL
63844: IFTRUE 63878
63846: LD_INT 12
63848: DOUBLE
63849: EQUAL
63850: IFTRUE 63878
63852: LD_INT 15
63854: DOUBLE
63855: EQUAL
63856: IFTRUE 63878
63858: LD_INT 11
63860: DOUBLE
63861: EQUAL
63862: IFTRUE 63878
63864: LD_INT 14
63866: DOUBLE
63867: EQUAL
63868: IFTRUE 63878
63870: LD_INT 10
63872: DOUBLE
63873: EQUAL
63874: IFTRUE 63878
63876: GO 63934
63878: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
63879: LD_ADDR_VAR 0 9
63883: PUSH
63884: LD_VAR 0 41
63888: PUSH
63889: LD_VAR 0 42
63893: PUSH
63894: LD_VAR 0 43
63898: PUSH
63899: LD_VAR 0 44
63903: PUSH
63904: LD_VAR 0 45
63908: PUSH
63909: LD_VAR 0 46
63913: PUSH
63914: EMPTY
63915: LIST
63916: LIST
63917: LIST
63918: LIST
63919: LIST
63920: LIST
63921: PUSH
63922: LD_VAR 0 4
63926: PUSH
63927: LD_INT 1
63929: PLUS
63930: ARRAY
63931: ST_TO_ADDR
63932: GO 64187
63934: LD_INT 36
63936: DOUBLE
63937: EQUAL
63938: IFTRUE 63942
63940: GO 63998
63942: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
63943: LD_ADDR_VAR 0 9
63947: PUSH
63948: LD_VAR 0 47
63952: PUSH
63953: LD_VAR 0 48
63957: PUSH
63958: LD_VAR 0 49
63962: PUSH
63963: LD_VAR 0 50
63967: PUSH
63968: LD_VAR 0 51
63972: PUSH
63973: LD_VAR 0 52
63977: PUSH
63978: EMPTY
63979: LIST
63980: LIST
63981: LIST
63982: LIST
63983: LIST
63984: LIST
63985: PUSH
63986: LD_VAR 0 4
63990: PUSH
63991: LD_INT 1
63993: PLUS
63994: ARRAY
63995: ST_TO_ADDR
63996: GO 64187
63998: LD_INT 4
64000: DOUBLE
64001: EQUAL
64002: IFTRUE 64024
64004: LD_INT 5
64006: DOUBLE
64007: EQUAL
64008: IFTRUE 64024
64010: LD_INT 34
64012: DOUBLE
64013: EQUAL
64014: IFTRUE 64024
64016: LD_INT 37
64018: DOUBLE
64019: EQUAL
64020: IFTRUE 64024
64022: GO 64080
64024: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
64025: LD_ADDR_VAR 0 9
64029: PUSH
64030: LD_VAR 0 53
64034: PUSH
64035: LD_VAR 0 54
64039: PUSH
64040: LD_VAR 0 55
64044: PUSH
64045: LD_VAR 0 56
64049: PUSH
64050: LD_VAR 0 57
64054: PUSH
64055: LD_VAR 0 58
64059: PUSH
64060: EMPTY
64061: LIST
64062: LIST
64063: LIST
64064: LIST
64065: LIST
64066: LIST
64067: PUSH
64068: LD_VAR 0 4
64072: PUSH
64073: LD_INT 1
64075: PLUS
64076: ARRAY
64077: ST_TO_ADDR
64078: GO 64187
64080: LD_INT 31
64082: DOUBLE
64083: EQUAL
64084: IFTRUE 64130
64086: LD_INT 32
64088: DOUBLE
64089: EQUAL
64090: IFTRUE 64130
64092: LD_INT 33
64094: DOUBLE
64095: EQUAL
64096: IFTRUE 64130
64098: LD_INT 27
64100: DOUBLE
64101: EQUAL
64102: IFTRUE 64130
64104: LD_INT 26
64106: DOUBLE
64107: EQUAL
64108: IFTRUE 64130
64110: LD_INT 28
64112: DOUBLE
64113: EQUAL
64114: IFTRUE 64130
64116: LD_INT 29
64118: DOUBLE
64119: EQUAL
64120: IFTRUE 64130
64122: LD_INT 30
64124: DOUBLE
64125: EQUAL
64126: IFTRUE 64130
64128: GO 64186
64130: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
64131: LD_ADDR_VAR 0 9
64135: PUSH
64136: LD_VAR 0 59
64140: PUSH
64141: LD_VAR 0 60
64145: PUSH
64146: LD_VAR 0 61
64150: PUSH
64151: LD_VAR 0 62
64155: PUSH
64156: LD_VAR 0 63
64160: PUSH
64161: LD_VAR 0 64
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: LIST
64170: LIST
64171: LIST
64172: LIST
64173: PUSH
64174: LD_VAR 0 4
64178: PUSH
64179: LD_INT 1
64181: PLUS
64182: ARRAY
64183: ST_TO_ADDR
64184: GO 64187
64186: POP
// temp_list2 = [ ] ;
64187: LD_ADDR_VAR 0 10
64191: PUSH
64192: EMPTY
64193: ST_TO_ADDR
// for i in temp_list do
64194: LD_ADDR_VAR 0 8
64198: PUSH
64199: LD_VAR 0 9
64203: PUSH
64204: FOR_IN
64205: IFFALSE 64257
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
64207: LD_ADDR_VAR 0 10
64211: PUSH
64212: LD_VAR 0 10
64216: PUSH
64217: LD_VAR 0 8
64221: PUSH
64222: LD_INT 1
64224: ARRAY
64225: PUSH
64226: LD_VAR 0 2
64230: PLUS
64231: PUSH
64232: LD_VAR 0 8
64236: PUSH
64237: LD_INT 2
64239: ARRAY
64240: PUSH
64241: LD_VAR 0 3
64245: PLUS
64246: PUSH
64247: EMPTY
64248: LIST
64249: LIST
64250: PUSH
64251: EMPTY
64252: LIST
64253: ADD
64254: ST_TO_ADDR
64255: GO 64204
64257: POP
64258: POP
// result = temp_list2 ;
64259: LD_ADDR_VAR 0 7
64263: PUSH
64264: LD_VAR 0 10
64268: ST_TO_ADDR
// end ;
64269: LD_VAR 0 7
64273: RET
// export function EnemyInRange ( unit , dist ) ; begin
64274: LD_INT 0
64276: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
64277: LD_ADDR_VAR 0 3
64281: PUSH
64282: LD_VAR 0 1
64286: PPUSH
64287: CALL_OW 255
64291: PPUSH
64292: LD_VAR 0 1
64296: PPUSH
64297: CALL_OW 250
64301: PPUSH
64302: LD_VAR 0 1
64306: PPUSH
64307: CALL_OW 251
64311: PPUSH
64312: LD_VAR 0 2
64316: PPUSH
64317: CALL 38378 0 4
64321: PUSH
64322: LD_INT 4
64324: ARRAY
64325: ST_TO_ADDR
// end ;
64326: LD_VAR 0 3
64330: RET
// export function PlayerSeeMe ( unit ) ; begin
64331: LD_INT 0
64333: PPUSH
// result := See ( your_side , unit ) ;
64334: LD_ADDR_VAR 0 2
64338: PUSH
64339: LD_OWVAR 2
64343: PPUSH
64344: LD_VAR 0 1
64348: PPUSH
64349: CALL_OW 292
64353: ST_TO_ADDR
// end ;
64354: LD_VAR 0 2
64358: RET
// export function ReverseDir ( unit ) ; begin
64359: LD_INT 0
64361: PPUSH
// if not unit then
64362: LD_VAR 0 1
64366: NOT
64367: IFFALSE 64371
// exit ;
64369: GO 64394
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
64371: LD_ADDR_VAR 0 2
64375: PUSH
64376: LD_VAR 0 1
64380: PPUSH
64381: CALL_OW 254
64385: PUSH
64386: LD_INT 3
64388: PLUS
64389: PUSH
64390: LD_INT 6
64392: MOD
64393: ST_TO_ADDR
// end ;
64394: LD_VAR 0 2
64398: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
64399: LD_INT 0
64401: PPUSH
64402: PPUSH
64403: PPUSH
64404: PPUSH
64405: PPUSH
// if not hexes then
64406: LD_VAR 0 2
64410: NOT
64411: IFFALSE 64415
// exit ;
64413: GO 64563
// dist := 9999 ;
64415: LD_ADDR_VAR 0 5
64419: PUSH
64420: LD_INT 9999
64422: ST_TO_ADDR
// for i = 1 to hexes do
64423: LD_ADDR_VAR 0 4
64427: PUSH
64428: DOUBLE
64429: LD_INT 1
64431: DEC
64432: ST_TO_ADDR
64433: LD_VAR 0 2
64437: PUSH
64438: FOR_TO
64439: IFFALSE 64551
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
64441: LD_VAR 0 1
64445: PPUSH
64446: LD_VAR 0 2
64450: PUSH
64451: LD_VAR 0 4
64455: ARRAY
64456: PUSH
64457: LD_INT 1
64459: ARRAY
64460: PPUSH
64461: LD_VAR 0 2
64465: PUSH
64466: LD_VAR 0 4
64470: ARRAY
64471: PUSH
64472: LD_INT 2
64474: ARRAY
64475: PPUSH
64476: CALL_OW 297
64480: PUSH
64481: LD_VAR 0 5
64485: LESS
64486: IFFALSE 64549
// begin hex := hexes [ i ] ;
64488: LD_ADDR_VAR 0 7
64492: PUSH
64493: LD_VAR 0 2
64497: PUSH
64498: LD_VAR 0 4
64502: ARRAY
64503: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64504: LD_ADDR_VAR 0 5
64508: PUSH
64509: LD_VAR 0 1
64513: PPUSH
64514: LD_VAR 0 2
64518: PUSH
64519: LD_VAR 0 4
64523: ARRAY
64524: PUSH
64525: LD_INT 1
64527: ARRAY
64528: PPUSH
64529: LD_VAR 0 2
64533: PUSH
64534: LD_VAR 0 4
64538: ARRAY
64539: PUSH
64540: LD_INT 2
64542: ARRAY
64543: PPUSH
64544: CALL_OW 297
64548: ST_TO_ADDR
// end ; end ;
64549: GO 64438
64551: POP
64552: POP
// result := hex ;
64553: LD_ADDR_VAR 0 3
64557: PUSH
64558: LD_VAR 0 7
64562: ST_TO_ADDR
// end ;
64563: LD_VAR 0 3
64567: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
64568: LD_INT 0
64570: PPUSH
64571: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
64572: LD_VAR 0 1
64576: NOT
64577: PUSH
64578: LD_VAR 0 1
64582: PUSH
64583: LD_INT 21
64585: PUSH
64586: LD_INT 2
64588: PUSH
64589: EMPTY
64590: LIST
64591: LIST
64592: PUSH
64593: LD_INT 23
64595: PUSH
64596: LD_INT 2
64598: PUSH
64599: EMPTY
64600: LIST
64601: LIST
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PPUSH
64607: CALL_OW 69
64611: IN
64612: NOT
64613: OR
64614: IFFALSE 64618
// exit ;
64616: GO 64665
// for i = 1 to 3 do
64618: LD_ADDR_VAR 0 3
64622: PUSH
64623: DOUBLE
64624: LD_INT 1
64626: DEC
64627: ST_TO_ADDR
64628: LD_INT 3
64630: PUSH
64631: FOR_TO
64632: IFFALSE 64663
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
64634: LD_VAR 0 1
64638: PPUSH
64639: CALL_OW 250
64643: PPUSH
64644: LD_VAR 0 1
64648: PPUSH
64649: CALL_OW 251
64653: PPUSH
64654: LD_INT 1
64656: PPUSH
64657: CALL_OW 453
64661: GO 64631
64663: POP
64664: POP
// end ;
64665: LD_VAR 0 2
64669: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
64670: LD_INT 0
64672: PPUSH
64673: PPUSH
64674: PPUSH
64675: PPUSH
64676: PPUSH
64677: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
64678: LD_VAR 0 1
64682: NOT
64683: PUSH
64684: LD_VAR 0 2
64688: NOT
64689: OR
64690: PUSH
64691: LD_VAR 0 1
64695: PPUSH
64696: CALL_OW 314
64700: OR
64701: IFFALSE 64705
// exit ;
64703: GO 65146
// x := GetX ( enemy_unit ) ;
64705: LD_ADDR_VAR 0 7
64709: PUSH
64710: LD_VAR 0 2
64714: PPUSH
64715: CALL_OW 250
64719: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
64720: LD_ADDR_VAR 0 8
64724: PUSH
64725: LD_VAR 0 2
64729: PPUSH
64730: CALL_OW 251
64734: ST_TO_ADDR
// if not x or not y then
64735: LD_VAR 0 7
64739: NOT
64740: PUSH
64741: LD_VAR 0 8
64745: NOT
64746: OR
64747: IFFALSE 64751
// exit ;
64749: GO 65146
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
64751: LD_ADDR_VAR 0 6
64755: PUSH
64756: LD_VAR 0 7
64760: PPUSH
64761: LD_INT 0
64763: PPUSH
64764: LD_INT 4
64766: PPUSH
64767: CALL_OW 272
64771: PUSH
64772: LD_VAR 0 8
64776: PPUSH
64777: LD_INT 0
64779: PPUSH
64780: LD_INT 4
64782: PPUSH
64783: CALL_OW 273
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: LD_VAR 0 7
64796: PPUSH
64797: LD_INT 1
64799: PPUSH
64800: LD_INT 4
64802: PPUSH
64803: CALL_OW 272
64807: PUSH
64808: LD_VAR 0 8
64812: PPUSH
64813: LD_INT 1
64815: PPUSH
64816: LD_INT 4
64818: PPUSH
64819: CALL_OW 273
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PUSH
64828: LD_VAR 0 7
64832: PPUSH
64833: LD_INT 2
64835: PPUSH
64836: LD_INT 4
64838: PPUSH
64839: CALL_OW 272
64843: PUSH
64844: LD_VAR 0 8
64848: PPUSH
64849: LD_INT 2
64851: PPUSH
64852: LD_INT 4
64854: PPUSH
64855: CALL_OW 273
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: PUSH
64864: LD_VAR 0 7
64868: PPUSH
64869: LD_INT 3
64871: PPUSH
64872: LD_INT 4
64874: PPUSH
64875: CALL_OW 272
64879: PUSH
64880: LD_VAR 0 8
64884: PPUSH
64885: LD_INT 3
64887: PPUSH
64888: LD_INT 4
64890: PPUSH
64891: CALL_OW 273
64895: PUSH
64896: EMPTY
64897: LIST
64898: LIST
64899: PUSH
64900: LD_VAR 0 7
64904: PPUSH
64905: LD_INT 4
64907: PPUSH
64908: LD_INT 4
64910: PPUSH
64911: CALL_OW 272
64915: PUSH
64916: LD_VAR 0 8
64920: PPUSH
64921: LD_INT 4
64923: PPUSH
64924: LD_INT 4
64926: PPUSH
64927: CALL_OW 273
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PUSH
64936: LD_VAR 0 7
64940: PPUSH
64941: LD_INT 5
64943: PPUSH
64944: LD_INT 4
64946: PPUSH
64947: CALL_OW 272
64951: PUSH
64952: LD_VAR 0 8
64956: PPUSH
64957: LD_INT 5
64959: PPUSH
64960: LD_INT 4
64962: PPUSH
64963: CALL_OW 273
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: PUSH
64972: EMPTY
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: ST_TO_ADDR
// for i = tmp downto 1 do
64980: LD_ADDR_VAR 0 4
64984: PUSH
64985: DOUBLE
64986: LD_VAR 0 6
64990: INC
64991: ST_TO_ADDR
64992: LD_INT 1
64994: PUSH
64995: FOR_DOWNTO
64996: IFFALSE 65097
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
64998: LD_VAR 0 6
65002: PUSH
65003: LD_VAR 0 4
65007: ARRAY
65008: PUSH
65009: LD_INT 1
65011: ARRAY
65012: PPUSH
65013: LD_VAR 0 6
65017: PUSH
65018: LD_VAR 0 4
65022: ARRAY
65023: PUSH
65024: LD_INT 2
65026: ARRAY
65027: PPUSH
65028: CALL_OW 488
65032: NOT
65033: PUSH
65034: LD_VAR 0 6
65038: PUSH
65039: LD_VAR 0 4
65043: ARRAY
65044: PUSH
65045: LD_INT 1
65047: ARRAY
65048: PPUSH
65049: LD_VAR 0 6
65053: PUSH
65054: LD_VAR 0 4
65058: ARRAY
65059: PUSH
65060: LD_INT 2
65062: ARRAY
65063: PPUSH
65064: CALL_OW 428
65068: PUSH
65069: LD_INT 0
65071: NONEQUAL
65072: OR
65073: IFFALSE 65095
// tmp := Delete ( tmp , i ) ;
65075: LD_ADDR_VAR 0 6
65079: PUSH
65080: LD_VAR 0 6
65084: PPUSH
65085: LD_VAR 0 4
65089: PPUSH
65090: CALL_OW 3
65094: ST_TO_ADDR
65095: GO 64995
65097: POP
65098: POP
// j := GetClosestHex ( unit , tmp ) ;
65099: LD_ADDR_VAR 0 5
65103: PUSH
65104: LD_VAR 0 1
65108: PPUSH
65109: LD_VAR 0 6
65113: PPUSH
65114: CALL 64399 0 2
65118: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
65119: LD_VAR 0 1
65123: PPUSH
65124: LD_VAR 0 5
65128: PUSH
65129: LD_INT 1
65131: ARRAY
65132: PPUSH
65133: LD_VAR 0 5
65137: PUSH
65138: LD_INT 2
65140: ARRAY
65141: PPUSH
65142: CALL_OW 111
// end ;
65146: LD_VAR 0 3
65150: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
65151: LD_INT 0
65153: PPUSH
65154: PPUSH
65155: PPUSH
// uc_side = 0 ;
65156: LD_ADDR_OWVAR 20
65160: PUSH
65161: LD_INT 0
65163: ST_TO_ADDR
// uc_nation = 0 ;
65164: LD_ADDR_OWVAR 21
65168: PUSH
65169: LD_INT 0
65171: ST_TO_ADDR
// InitHc ;
65172: CALL_OW 19
// InitVc ;
65176: CALL_OW 20
// if mastodonts then
65180: LD_VAR 0 6
65184: IFFALSE 65251
// for i = 1 to mastodonts do
65186: LD_ADDR_VAR 0 11
65190: PUSH
65191: DOUBLE
65192: LD_INT 1
65194: DEC
65195: ST_TO_ADDR
65196: LD_VAR 0 6
65200: PUSH
65201: FOR_TO
65202: IFFALSE 65249
// begin vc_chassis := 31 ;
65204: LD_ADDR_OWVAR 37
65208: PUSH
65209: LD_INT 31
65211: ST_TO_ADDR
// vc_control := control_rider ;
65212: LD_ADDR_OWVAR 38
65216: PUSH
65217: LD_INT 4
65219: ST_TO_ADDR
// animal := CreateVehicle ;
65220: LD_ADDR_VAR 0 12
65224: PUSH
65225: CALL_OW 45
65229: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65230: LD_VAR 0 12
65234: PPUSH
65235: LD_VAR 0 8
65239: PPUSH
65240: LD_INT 0
65242: PPUSH
65243: CALL 67320 0 3
// end ;
65247: GO 65201
65249: POP
65250: POP
// if horses then
65251: LD_VAR 0 5
65255: IFFALSE 65322
// for i = 1 to horses do
65257: LD_ADDR_VAR 0 11
65261: PUSH
65262: DOUBLE
65263: LD_INT 1
65265: DEC
65266: ST_TO_ADDR
65267: LD_VAR 0 5
65271: PUSH
65272: FOR_TO
65273: IFFALSE 65320
// begin hc_class := 21 ;
65275: LD_ADDR_OWVAR 28
65279: PUSH
65280: LD_INT 21
65282: ST_TO_ADDR
// hc_gallery :=  ;
65283: LD_ADDR_OWVAR 33
65287: PUSH
65288: LD_STRING 
65290: ST_TO_ADDR
// animal := CreateHuman ;
65291: LD_ADDR_VAR 0 12
65295: PUSH
65296: CALL_OW 44
65300: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65301: LD_VAR 0 12
65305: PPUSH
65306: LD_VAR 0 8
65310: PPUSH
65311: LD_INT 0
65313: PPUSH
65314: CALL 67320 0 3
// end ;
65318: GO 65272
65320: POP
65321: POP
// if birds then
65322: LD_VAR 0 1
65326: IFFALSE 65393
// for i = 1 to birds do
65328: LD_ADDR_VAR 0 11
65332: PUSH
65333: DOUBLE
65334: LD_INT 1
65336: DEC
65337: ST_TO_ADDR
65338: LD_VAR 0 1
65342: PUSH
65343: FOR_TO
65344: IFFALSE 65391
// begin hc_class = 18 ;
65346: LD_ADDR_OWVAR 28
65350: PUSH
65351: LD_INT 18
65353: ST_TO_ADDR
// hc_gallery =  ;
65354: LD_ADDR_OWVAR 33
65358: PUSH
65359: LD_STRING 
65361: ST_TO_ADDR
// animal := CreateHuman ;
65362: LD_ADDR_VAR 0 12
65366: PUSH
65367: CALL_OW 44
65371: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65372: LD_VAR 0 12
65376: PPUSH
65377: LD_VAR 0 8
65381: PPUSH
65382: LD_INT 0
65384: PPUSH
65385: CALL 67320 0 3
// end ;
65389: GO 65343
65391: POP
65392: POP
// if tigers then
65393: LD_VAR 0 2
65397: IFFALSE 65481
// for i = 1 to tigers do
65399: LD_ADDR_VAR 0 11
65403: PUSH
65404: DOUBLE
65405: LD_INT 1
65407: DEC
65408: ST_TO_ADDR
65409: LD_VAR 0 2
65413: PUSH
65414: FOR_TO
65415: IFFALSE 65479
// begin hc_class = class_tiger ;
65417: LD_ADDR_OWVAR 28
65421: PUSH
65422: LD_INT 14
65424: ST_TO_ADDR
// hc_gallery =  ;
65425: LD_ADDR_OWVAR 33
65429: PUSH
65430: LD_STRING 
65432: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
65433: LD_ADDR_OWVAR 35
65437: PUSH
65438: LD_INT 7
65440: NEG
65441: PPUSH
65442: LD_INT 7
65444: PPUSH
65445: CALL_OW 12
65449: ST_TO_ADDR
// animal := CreateHuman ;
65450: LD_ADDR_VAR 0 12
65454: PUSH
65455: CALL_OW 44
65459: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65460: LD_VAR 0 12
65464: PPUSH
65465: LD_VAR 0 8
65469: PPUSH
65470: LD_INT 0
65472: PPUSH
65473: CALL 67320 0 3
// end ;
65477: GO 65414
65479: POP
65480: POP
// if apemans then
65481: LD_VAR 0 3
65485: IFFALSE 65608
// for i = 1 to apemans do
65487: LD_ADDR_VAR 0 11
65491: PUSH
65492: DOUBLE
65493: LD_INT 1
65495: DEC
65496: ST_TO_ADDR
65497: LD_VAR 0 3
65501: PUSH
65502: FOR_TO
65503: IFFALSE 65606
// begin hc_class = class_apeman ;
65505: LD_ADDR_OWVAR 28
65509: PUSH
65510: LD_INT 12
65512: ST_TO_ADDR
// hc_gallery =  ;
65513: LD_ADDR_OWVAR 33
65517: PUSH
65518: LD_STRING 
65520: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
65521: LD_ADDR_OWVAR 35
65525: PUSH
65526: LD_INT 5
65528: NEG
65529: PPUSH
65530: LD_INT 5
65532: PPUSH
65533: CALL_OW 12
65537: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
65538: LD_ADDR_OWVAR 31
65542: PUSH
65543: LD_INT 1
65545: PPUSH
65546: LD_INT 3
65548: PPUSH
65549: CALL_OW 12
65553: PUSH
65554: LD_INT 1
65556: PPUSH
65557: LD_INT 3
65559: PPUSH
65560: CALL_OW 12
65564: PUSH
65565: LD_INT 0
65567: PUSH
65568: LD_INT 0
65570: PUSH
65571: EMPTY
65572: LIST
65573: LIST
65574: LIST
65575: LIST
65576: ST_TO_ADDR
// animal := CreateHuman ;
65577: LD_ADDR_VAR 0 12
65581: PUSH
65582: CALL_OW 44
65586: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65587: LD_VAR 0 12
65591: PPUSH
65592: LD_VAR 0 8
65596: PPUSH
65597: LD_INT 0
65599: PPUSH
65600: CALL 67320 0 3
// end ;
65604: GO 65502
65606: POP
65607: POP
// if enchidnas then
65608: LD_VAR 0 4
65612: IFFALSE 65679
// for i = 1 to enchidnas do
65614: LD_ADDR_VAR 0 11
65618: PUSH
65619: DOUBLE
65620: LD_INT 1
65622: DEC
65623: ST_TO_ADDR
65624: LD_VAR 0 4
65628: PUSH
65629: FOR_TO
65630: IFFALSE 65677
// begin hc_class = 13 ;
65632: LD_ADDR_OWVAR 28
65636: PUSH
65637: LD_INT 13
65639: ST_TO_ADDR
// hc_gallery =  ;
65640: LD_ADDR_OWVAR 33
65644: PUSH
65645: LD_STRING 
65647: ST_TO_ADDR
// animal := CreateHuman ;
65648: LD_ADDR_VAR 0 12
65652: PUSH
65653: CALL_OW 44
65657: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65658: LD_VAR 0 12
65662: PPUSH
65663: LD_VAR 0 8
65667: PPUSH
65668: LD_INT 0
65670: PPUSH
65671: CALL 67320 0 3
// end ;
65675: GO 65629
65677: POP
65678: POP
// if fishes then
65679: LD_VAR 0 7
65683: IFFALSE 65750
// for i = 1 to fishes do
65685: LD_ADDR_VAR 0 11
65689: PUSH
65690: DOUBLE
65691: LD_INT 1
65693: DEC
65694: ST_TO_ADDR
65695: LD_VAR 0 7
65699: PUSH
65700: FOR_TO
65701: IFFALSE 65748
// begin hc_class = 20 ;
65703: LD_ADDR_OWVAR 28
65707: PUSH
65708: LD_INT 20
65710: ST_TO_ADDR
// hc_gallery =  ;
65711: LD_ADDR_OWVAR 33
65715: PUSH
65716: LD_STRING 
65718: ST_TO_ADDR
// animal := CreateHuman ;
65719: LD_ADDR_VAR 0 12
65723: PUSH
65724: CALL_OW 44
65728: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
65729: LD_VAR 0 12
65733: PPUSH
65734: LD_VAR 0 9
65738: PPUSH
65739: LD_INT 0
65741: PPUSH
65742: CALL 67320 0 3
// end ;
65746: GO 65700
65748: POP
65749: POP
// end ;
65750: LD_VAR 0 10
65754: RET
// export function WantHeal ( sci , unit ) ; begin
65755: LD_INT 0
65757: PPUSH
// if GetTaskList ( sci ) > 0 then
65758: LD_VAR 0 1
65762: PPUSH
65763: CALL_OW 437
65767: PUSH
65768: LD_INT 0
65770: GREATER
65771: IFFALSE 65841
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
65773: LD_VAR 0 1
65777: PPUSH
65778: CALL_OW 437
65782: PUSH
65783: LD_INT 1
65785: ARRAY
65786: PUSH
65787: LD_INT 1
65789: ARRAY
65790: PUSH
65791: LD_STRING l
65793: EQUAL
65794: PUSH
65795: LD_VAR 0 1
65799: PPUSH
65800: CALL_OW 437
65804: PUSH
65805: LD_INT 1
65807: ARRAY
65808: PUSH
65809: LD_INT 4
65811: ARRAY
65812: PUSH
65813: LD_VAR 0 2
65817: EQUAL
65818: AND
65819: IFFALSE 65831
// result := true else
65821: LD_ADDR_VAR 0 3
65825: PUSH
65826: LD_INT 1
65828: ST_TO_ADDR
65829: GO 65839
// result := false ;
65831: LD_ADDR_VAR 0 3
65835: PUSH
65836: LD_INT 0
65838: ST_TO_ADDR
// end else
65839: GO 65849
// result := false ;
65841: LD_ADDR_VAR 0 3
65845: PUSH
65846: LD_INT 0
65848: ST_TO_ADDR
// end ;
65849: LD_VAR 0 3
65853: RET
// export function HealTarget ( sci ) ; begin
65854: LD_INT 0
65856: PPUSH
// if not sci then
65857: LD_VAR 0 1
65861: NOT
65862: IFFALSE 65866
// exit ;
65864: GO 65931
// result := 0 ;
65866: LD_ADDR_VAR 0 2
65870: PUSH
65871: LD_INT 0
65873: ST_TO_ADDR
// if GetTaskList ( sci ) then
65874: LD_VAR 0 1
65878: PPUSH
65879: CALL_OW 437
65883: IFFALSE 65931
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
65885: LD_VAR 0 1
65889: PPUSH
65890: CALL_OW 437
65894: PUSH
65895: LD_INT 1
65897: ARRAY
65898: PUSH
65899: LD_INT 1
65901: ARRAY
65902: PUSH
65903: LD_STRING l
65905: EQUAL
65906: IFFALSE 65931
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
65908: LD_ADDR_VAR 0 2
65912: PUSH
65913: LD_VAR 0 1
65917: PPUSH
65918: CALL_OW 437
65922: PUSH
65923: LD_INT 1
65925: ARRAY
65926: PUSH
65927: LD_INT 4
65929: ARRAY
65930: ST_TO_ADDR
// end ;
65931: LD_VAR 0 2
65935: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
65936: LD_INT 0
65938: PPUSH
65939: PPUSH
65940: PPUSH
65941: PPUSH
// if not base_units then
65942: LD_VAR 0 1
65946: NOT
65947: IFFALSE 65951
// exit ;
65949: GO 66038
// result := false ;
65951: LD_ADDR_VAR 0 2
65955: PUSH
65956: LD_INT 0
65958: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
65959: LD_ADDR_VAR 0 5
65963: PUSH
65964: LD_VAR 0 1
65968: PPUSH
65969: LD_INT 21
65971: PUSH
65972: LD_INT 3
65974: PUSH
65975: EMPTY
65976: LIST
65977: LIST
65978: PPUSH
65979: CALL_OW 72
65983: ST_TO_ADDR
// if not tmp then
65984: LD_VAR 0 5
65988: NOT
65989: IFFALSE 65993
// exit ;
65991: GO 66038
// for i in tmp do
65993: LD_ADDR_VAR 0 3
65997: PUSH
65998: LD_VAR 0 5
66002: PUSH
66003: FOR_IN
66004: IFFALSE 66036
// begin result := EnemyInRange ( i , 22 ) ;
66006: LD_ADDR_VAR 0 2
66010: PUSH
66011: LD_VAR 0 3
66015: PPUSH
66016: LD_INT 22
66018: PPUSH
66019: CALL 64274 0 2
66023: ST_TO_ADDR
// if result then
66024: LD_VAR 0 2
66028: IFFALSE 66034
// exit ;
66030: POP
66031: POP
66032: GO 66038
// end ;
66034: GO 66003
66036: POP
66037: POP
// end ;
66038: LD_VAR 0 2
66042: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
66043: LD_INT 0
66045: PPUSH
66046: PPUSH
// if not units then
66047: LD_VAR 0 1
66051: NOT
66052: IFFALSE 66056
// exit ;
66054: GO 66126
// result := [ ] ;
66056: LD_ADDR_VAR 0 3
66060: PUSH
66061: EMPTY
66062: ST_TO_ADDR
// for i in units do
66063: LD_ADDR_VAR 0 4
66067: PUSH
66068: LD_VAR 0 1
66072: PUSH
66073: FOR_IN
66074: IFFALSE 66124
// if GetTag ( i ) = tag then
66076: LD_VAR 0 4
66080: PPUSH
66081: CALL_OW 110
66085: PUSH
66086: LD_VAR 0 2
66090: EQUAL
66091: IFFALSE 66122
// result := Insert ( result , result + 1 , i ) ;
66093: LD_ADDR_VAR 0 3
66097: PUSH
66098: LD_VAR 0 3
66102: PPUSH
66103: LD_VAR 0 3
66107: PUSH
66108: LD_INT 1
66110: PLUS
66111: PPUSH
66112: LD_VAR 0 4
66116: PPUSH
66117: CALL_OW 2
66121: ST_TO_ADDR
66122: GO 66073
66124: POP
66125: POP
// end ;
66126: LD_VAR 0 3
66130: RET
// export function IsDriver ( un ) ; begin
66131: LD_INT 0
66133: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
66134: LD_ADDR_VAR 0 2
66138: PUSH
66139: LD_VAR 0 1
66143: PUSH
66144: LD_INT 55
66146: PUSH
66147: EMPTY
66148: LIST
66149: PPUSH
66150: CALL_OW 69
66154: IN
66155: ST_TO_ADDR
// end ;
66156: LD_VAR 0 2
66160: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
66161: LD_INT 0
66163: PPUSH
66164: PPUSH
// list := [ ] ;
66165: LD_ADDR_VAR 0 5
66169: PUSH
66170: EMPTY
66171: ST_TO_ADDR
// case d of 0 :
66172: LD_VAR 0 3
66176: PUSH
66177: LD_INT 0
66179: DOUBLE
66180: EQUAL
66181: IFTRUE 66185
66183: GO 66318
66185: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
66186: LD_ADDR_VAR 0 5
66190: PUSH
66191: LD_VAR 0 1
66195: PUSH
66196: LD_INT 4
66198: MINUS
66199: PUSH
66200: LD_VAR 0 2
66204: PUSH
66205: LD_INT 4
66207: MINUS
66208: PUSH
66209: LD_INT 2
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: LIST
66216: PUSH
66217: LD_VAR 0 1
66221: PUSH
66222: LD_INT 3
66224: MINUS
66225: PUSH
66226: LD_VAR 0 2
66230: PUSH
66231: LD_INT 1
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: LIST
66238: PUSH
66239: LD_VAR 0 1
66243: PUSH
66244: LD_INT 4
66246: PLUS
66247: PUSH
66248: LD_VAR 0 2
66252: PUSH
66253: LD_INT 4
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: LIST
66260: PUSH
66261: LD_VAR 0 1
66265: PUSH
66266: LD_INT 3
66268: PLUS
66269: PUSH
66270: LD_VAR 0 2
66274: PUSH
66275: LD_INT 3
66277: PLUS
66278: PUSH
66279: LD_INT 5
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: LIST
66286: PUSH
66287: LD_VAR 0 1
66291: PUSH
66292: LD_VAR 0 2
66296: PUSH
66297: LD_INT 4
66299: PLUS
66300: PUSH
66301: LD_INT 0
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: LIST
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: LIST
66313: LIST
66314: LIST
66315: ST_TO_ADDR
// end ; 1 :
66316: GO 67016
66318: LD_INT 1
66320: DOUBLE
66321: EQUAL
66322: IFTRUE 66326
66324: GO 66459
66326: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
66327: LD_ADDR_VAR 0 5
66331: PUSH
66332: LD_VAR 0 1
66336: PUSH
66337: LD_VAR 0 2
66341: PUSH
66342: LD_INT 4
66344: MINUS
66345: PUSH
66346: LD_INT 3
66348: PUSH
66349: EMPTY
66350: LIST
66351: LIST
66352: LIST
66353: PUSH
66354: LD_VAR 0 1
66358: PUSH
66359: LD_INT 3
66361: MINUS
66362: PUSH
66363: LD_VAR 0 2
66367: PUSH
66368: LD_INT 3
66370: MINUS
66371: PUSH
66372: LD_INT 2
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: LIST
66379: PUSH
66380: LD_VAR 0 1
66384: PUSH
66385: LD_INT 4
66387: MINUS
66388: PUSH
66389: LD_VAR 0 2
66393: PUSH
66394: LD_INT 1
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: LIST
66401: PUSH
66402: LD_VAR 0 1
66406: PUSH
66407: LD_VAR 0 2
66411: PUSH
66412: LD_INT 3
66414: PLUS
66415: PUSH
66416: LD_INT 0
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: LIST
66423: PUSH
66424: LD_VAR 0 1
66428: PUSH
66429: LD_INT 4
66431: PLUS
66432: PUSH
66433: LD_VAR 0 2
66437: PUSH
66438: LD_INT 4
66440: PLUS
66441: PUSH
66442: LD_INT 5
66444: PUSH
66445: EMPTY
66446: LIST
66447: LIST
66448: LIST
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: ST_TO_ADDR
// end ; 2 :
66457: GO 67016
66459: LD_INT 2
66461: DOUBLE
66462: EQUAL
66463: IFTRUE 66467
66465: GO 66596
66467: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
66468: LD_ADDR_VAR 0 5
66472: PUSH
66473: LD_VAR 0 1
66477: PUSH
66478: LD_VAR 0 2
66482: PUSH
66483: LD_INT 3
66485: MINUS
66486: PUSH
66487: LD_INT 3
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: LIST
66494: PUSH
66495: LD_VAR 0 1
66499: PUSH
66500: LD_INT 4
66502: PLUS
66503: PUSH
66504: LD_VAR 0 2
66508: PUSH
66509: LD_INT 4
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: LIST
66516: PUSH
66517: LD_VAR 0 1
66521: PUSH
66522: LD_VAR 0 2
66526: PUSH
66527: LD_INT 4
66529: PLUS
66530: PUSH
66531: LD_INT 0
66533: PUSH
66534: EMPTY
66535: LIST
66536: LIST
66537: LIST
66538: PUSH
66539: LD_VAR 0 1
66543: PUSH
66544: LD_INT 3
66546: MINUS
66547: PUSH
66548: LD_VAR 0 2
66552: PUSH
66553: LD_INT 1
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: LIST
66560: PUSH
66561: LD_VAR 0 1
66565: PUSH
66566: LD_INT 4
66568: MINUS
66569: PUSH
66570: LD_VAR 0 2
66574: PUSH
66575: LD_INT 4
66577: MINUS
66578: PUSH
66579: LD_INT 2
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: LIST
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: LIST
66591: LIST
66592: LIST
66593: ST_TO_ADDR
// end ; 3 :
66594: GO 67016
66596: LD_INT 3
66598: DOUBLE
66599: EQUAL
66600: IFTRUE 66604
66602: GO 66737
66604: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
66605: LD_ADDR_VAR 0 5
66609: PUSH
66610: LD_VAR 0 1
66614: PUSH
66615: LD_INT 3
66617: PLUS
66618: PUSH
66619: LD_VAR 0 2
66623: PUSH
66624: LD_INT 4
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: LIST
66631: PUSH
66632: LD_VAR 0 1
66636: PUSH
66637: LD_INT 4
66639: PLUS
66640: PUSH
66641: LD_VAR 0 2
66645: PUSH
66646: LD_INT 4
66648: PLUS
66649: PUSH
66650: LD_INT 5
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: LIST
66657: PUSH
66658: LD_VAR 0 1
66662: PUSH
66663: LD_INT 4
66665: MINUS
66666: PUSH
66667: LD_VAR 0 2
66671: PUSH
66672: LD_INT 1
66674: PUSH
66675: EMPTY
66676: LIST
66677: LIST
66678: LIST
66679: PUSH
66680: LD_VAR 0 1
66684: PUSH
66685: LD_VAR 0 2
66689: PUSH
66690: LD_INT 4
66692: MINUS
66693: PUSH
66694: LD_INT 3
66696: PUSH
66697: EMPTY
66698: LIST
66699: LIST
66700: LIST
66701: PUSH
66702: LD_VAR 0 1
66706: PUSH
66707: LD_INT 3
66709: MINUS
66710: PUSH
66711: LD_VAR 0 2
66715: PUSH
66716: LD_INT 3
66718: MINUS
66719: PUSH
66720: LD_INT 2
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: LIST
66727: PUSH
66728: EMPTY
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: ST_TO_ADDR
// end ; 4 :
66735: GO 67016
66737: LD_INT 4
66739: DOUBLE
66740: EQUAL
66741: IFTRUE 66745
66743: GO 66878
66745: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
66746: LD_ADDR_VAR 0 5
66750: PUSH
66751: LD_VAR 0 1
66755: PUSH
66756: LD_VAR 0 2
66760: PUSH
66761: LD_INT 4
66763: PLUS
66764: PUSH
66765: LD_INT 0
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: LIST
66772: PUSH
66773: LD_VAR 0 1
66777: PUSH
66778: LD_INT 3
66780: PLUS
66781: PUSH
66782: LD_VAR 0 2
66786: PUSH
66787: LD_INT 3
66789: PLUS
66790: PUSH
66791: LD_INT 5
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: LIST
66798: PUSH
66799: LD_VAR 0 1
66803: PUSH
66804: LD_INT 4
66806: PLUS
66807: PUSH
66808: LD_VAR 0 2
66812: PUSH
66813: LD_INT 4
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: LIST
66820: PUSH
66821: LD_VAR 0 1
66825: PUSH
66826: LD_VAR 0 2
66830: PUSH
66831: LD_INT 3
66833: MINUS
66834: PUSH
66835: LD_INT 3
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: LIST
66842: PUSH
66843: LD_VAR 0 1
66847: PUSH
66848: LD_INT 4
66850: MINUS
66851: PUSH
66852: LD_VAR 0 2
66856: PUSH
66857: LD_INT 4
66859: MINUS
66860: PUSH
66861: LD_INT 2
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: LIST
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: LIST
66873: LIST
66874: LIST
66875: ST_TO_ADDR
// end ; 5 :
66876: GO 67016
66878: LD_INT 5
66880: DOUBLE
66881: EQUAL
66882: IFTRUE 66886
66884: GO 67015
66886: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
66887: LD_ADDR_VAR 0 5
66891: PUSH
66892: LD_VAR 0 1
66896: PUSH
66897: LD_INT 4
66899: MINUS
66900: PUSH
66901: LD_VAR 0 2
66905: PUSH
66906: LD_INT 1
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: LIST
66913: PUSH
66914: LD_VAR 0 1
66918: PUSH
66919: LD_VAR 0 2
66923: PUSH
66924: LD_INT 4
66926: MINUS
66927: PUSH
66928: LD_INT 3
66930: PUSH
66931: EMPTY
66932: LIST
66933: LIST
66934: LIST
66935: PUSH
66936: LD_VAR 0 1
66940: PUSH
66941: LD_INT 4
66943: PLUS
66944: PUSH
66945: LD_VAR 0 2
66949: PUSH
66950: LD_INT 4
66952: PLUS
66953: PUSH
66954: LD_INT 5
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: LIST
66961: PUSH
66962: LD_VAR 0 1
66966: PUSH
66967: LD_INT 3
66969: PLUS
66970: PUSH
66971: LD_VAR 0 2
66975: PUSH
66976: LD_INT 4
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: LIST
66983: PUSH
66984: LD_VAR 0 1
66988: PUSH
66989: LD_VAR 0 2
66993: PUSH
66994: LD_INT 3
66996: PLUS
66997: PUSH
66998: LD_INT 0
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: LIST
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: ST_TO_ADDR
// end ; end ;
67013: GO 67016
67015: POP
// result := list ;
67016: LD_ADDR_VAR 0 4
67020: PUSH
67021: LD_VAR 0 5
67025: ST_TO_ADDR
// end ;
67026: LD_VAR 0 4
67030: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
67031: LD_INT 0
67033: PPUSH
67034: PPUSH
67035: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
67036: LD_VAR 0 1
67040: NOT
67041: PUSH
67042: LD_VAR 0 2
67046: PUSH
67047: LD_INT 1
67049: PUSH
67050: LD_INT 2
67052: PUSH
67053: LD_INT 3
67055: PUSH
67056: LD_INT 4
67058: PUSH
67059: EMPTY
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: IN
67065: NOT
67066: OR
67067: IFFALSE 67071
// exit ;
67069: GO 67163
// tmp := [ ] ;
67071: LD_ADDR_VAR 0 5
67075: PUSH
67076: EMPTY
67077: ST_TO_ADDR
// for i in units do
67078: LD_ADDR_VAR 0 4
67082: PUSH
67083: LD_VAR 0 1
67087: PUSH
67088: FOR_IN
67089: IFFALSE 67132
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
67091: LD_ADDR_VAR 0 5
67095: PUSH
67096: LD_VAR 0 5
67100: PPUSH
67101: LD_VAR 0 5
67105: PUSH
67106: LD_INT 1
67108: PLUS
67109: PPUSH
67110: LD_VAR 0 4
67114: PPUSH
67115: LD_VAR 0 2
67119: PPUSH
67120: CALL_OW 259
67124: PPUSH
67125: CALL_OW 2
67129: ST_TO_ADDR
67130: GO 67088
67132: POP
67133: POP
// if not tmp then
67134: LD_VAR 0 5
67138: NOT
67139: IFFALSE 67143
// exit ;
67141: GO 67163
// result := SortListByListDesc ( units , tmp ) ;
67143: LD_ADDR_VAR 0 3
67147: PUSH
67148: LD_VAR 0 1
67152: PPUSH
67153: LD_VAR 0 5
67157: PPUSH
67158: CALL_OW 77
67162: ST_TO_ADDR
// end ;
67163: LD_VAR 0 3
67167: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
67168: LD_INT 0
67170: PPUSH
67171: PPUSH
67172: PPUSH
// x := GetX ( building ) ;
67173: LD_ADDR_VAR 0 4
67177: PUSH
67178: LD_VAR 0 2
67182: PPUSH
67183: CALL_OW 250
67187: ST_TO_ADDR
// y := GetY ( building ) ;
67188: LD_ADDR_VAR 0 5
67192: PUSH
67193: LD_VAR 0 2
67197: PPUSH
67198: CALL_OW 251
67202: ST_TO_ADDR
// if GetTaskList ( unit ) then
67203: LD_VAR 0 1
67207: PPUSH
67208: CALL_OW 437
67212: IFFALSE 67307
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
67214: LD_STRING e
67216: PUSH
67217: LD_VAR 0 1
67221: PPUSH
67222: CALL_OW 437
67226: PUSH
67227: LD_INT 1
67229: ARRAY
67230: PUSH
67231: LD_INT 1
67233: ARRAY
67234: EQUAL
67235: PUSH
67236: LD_VAR 0 4
67240: PUSH
67241: LD_VAR 0 1
67245: PPUSH
67246: CALL_OW 437
67250: PUSH
67251: LD_INT 1
67253: ARRAY
67254: PUSH
67255: LD_INT 2
67257: ARRAY
67258: EQUAL
67259: AND
67260: PUSH
67261: LD_VAR 0 5
67265: PUSH
67266: LD_VAR 0 1
67270: PPUSH
67271: CALL_OW 437
67275: PUSH
67276: LD_INT 1
67278: ARRAY
67279: PUSH
67280: LD_INT 3
67282: ARRAY
67283: EQUAL
67284: AND
67285: IFFALSE 67297
// result := true else
67287: LD_ADDR_VAR 0 3
67291: PUSH
67292: LD_INT 1
67294: ST_TO_ADDR
67295: GO 67305
// result := false ;
67297: LD_ADDR_VAR 0 3
67301: PUSH
67302: LD_INT 0
67304: ST_TO_ADDR
// end else
67305: GO 67315
// result := false ;
67307: LD_ADDR_VAR 0 3
67311: PUSH
67312: LD_INT 0
67314: ST_TO_ADDR
// end ;
67315: LD_VAR 0 3
67319: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
67320: LD_INT 0
67322: PPUSH
67323: PPUSH
67324: PPUSH
67325: PPUSH
// if not unit or not area then
67326: LD_VAR 0 1
67330: NOT
67331: PUSH
67332: LD_VAR 0 2
67336: NOT
67337: OR
67338: IFFALSE 67342
// exit ;
67340: GO 67506
// tmp := AreaToList ( area , i ) ;
67342: LD_ADDR_VAR 0 6
67346: PUSH
67347: LD_VAR 0 2
67351: PPUSH
67352: LD_VAR 0 5
67356: PPUSH
67357: CALL_OW 517
67361: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
67362: LD_ADDR_VAR 0 5
67366: PUSH
67367: DOUBLE
67368: LD_INT 1
67370: DEC
67371: ST_TO_ADDR
67372: LD_VAR 0 6
67376: PUSH
67377: LD_INT 1
67379: ARRAY
67380: PUSH
67381: FOR_TO
67382: IFFALSE 67504
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
67384: LD_ADDR_VAR 0 7
67388: PUSH
67389: LD_VAR 0 6
67393: PUSH
67394: LD_INT 1
67396: ARRAY
67397: PUSH
67398: LD_VAR 0 5
67402: ARRAY
67403: PUSH
67404: LD_VAR 0 6
67408: PUSH
67409: LD_INT 2
67411: ARRAY
67412: PUSH
67413: LD_VAR 0 5
67417: ARRAY
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
67423: LD_VAR 0 7
67427: PUSH
67428: LD_INT 1
67430: ARRAY
67431: PPUSH
67432: LD_VAR 0 7
67436: PUSH
67437: LD_INT 2
67439: ARRAY
67440: PPUSH
67441: CALL_OW 428
67445: PUSH
67446: LD_INT 0
67448: EQUAL
67449: IFFALSE 67502
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
67451: LD_VAR 0 1
67455: PPUSH
67456: LD_VAR 0 7
67460: PUSH
67461: LD_INT 1
67463: ARRAY
67464: PPUSH
67465: LD_VAR 0 7
67469: PUSH
67470: LD_INT 2
67472: ARRAY
67473: PPUSH
67474: LD_VAR 0 3
67478: PPUSH
67479: CALL_OW 48
// result := IsPlaced ( unit ) ;
67483: LD_ADDR_VAR 0 4
67487: PUSH
67488: LD_VAR 0 1
67492: PPUSH
67493: CALL_OW 305
67497: ST_TO_ADDR
// exit ;
67498: POP
67499: POP
67500: GO 67506
// end ; end ;
67502: GO 67381
67504: POP
67505: POP
// end ;
67506: LD_VAR 0 4
67510: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
67511: LD_INT 0
67513: PPUSH
67514: PPUSH
67515: PPUSH
// if not side or side > 8 then
67516: LD_VAR 0 1
67520: NOT
67521: PUSH
67522: LD_VAR 0 1
67526: PUSH
67527: LD_INT 8
67529: GREATER
67530: OR
67531: IFFALSE 67535
// exit ;
67533: GO 67722
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
67535: LD_ADDR_VAR 0 4
67539: PUSH
67540: LD_INT 22
67542: PUSH
67543: LD_VAR 0 1
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: PUSH
67552: LD_INT 21
67554: PUSH
67555: LD_INT 3
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: PUSH
67562: EMPTY
67563: LIST
67564: LIST
67565: PPUSH
67566: CALL_OW 69
67570: ST_TO_ADDR
// if not tmp then
67571: LD_VAR 0 4
67575: NOT
67576: IFFALSE 67580
// exit ;
67578: GO 67722
// enable_addtolog := true ;
67580: LD_ADDR_OWVAR 81
67584: PUSH
67585: LD_INT 1
67587: ST_TO_ADDR
// AddToLog ( [ ) ;
67588: LD_STRING [
67590: PPUSH
67591: CALL_OW 561
// for i in tmp do
67595: LD_ADDR_VAR 0 3
67599: PUSH
67600: LD_VAR 0 4
67604: PUSH
67605: FOR_IN
67606: IFFALSE 67713
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
67608: LD_STRING [
67610: PUSH
67611: LD_VAR 0 3
67615: PPUSH
67616: CALL_OW 266
67620: STR
67621: PUSH
67622: LD_STRING , 
67624: STR
67625: PUSH
67626: LD_VAR 0 3
67630: PPUSH
67631: CALL_OW 250
67635: STR
67636: PUSH
67637: LD_STRING , 
67639: STR
67640: PUSH
67641: LD_VAR 0 3
67645: PPUSH
67646: CALL_OW 251
67650: STR
67651: PUSH
67652: LD_STRING , 
67654: STR
67655: PUSH
67656: LD_VAR 0 3
67660: PPUSH
67661: CALL_OW 254
67665: STR
67666: PUSH
67667: LD_STRING , 
67669: STR
67670: PUSH
67671: LD_VAR 0 3
67675: PPUSH
67676: LD_INT 1
67678: PPUSH
67679: CALL_OW 268
67683: STR
67684: PUSH
67685: LD_STRING , 
67687: STR
67688: PUSH
67689: LD_VAR 0 3
67693: PPUSH
67694: LD_INT 2
67696: PPUSH
67697: CALL_OW 268
67701: STR
67702: PUSH
67703: LD_STRING ],
67705: STR
67706: PPUSH
67707: CALL_OW 561
// end ;
67711: GO 67605
67713: POP
67714: POP
// AddToLog ( ]; ) ;
67715: LD_STRING ];
67717: PPUSH
67718: CALL_OW 561
// end ;
67722: LD_VAR 0 2
67726: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
67727: LD_INT 0
67729: PPUSH
67730: PPUSH
67731: PPUSH
67732: PPUSH
67733: PPUSH
// if not area or not rate or not max then
67734: LD_VAR 0 1
67738: NOT
67739: PUSH
67740: LD_VAR 0 2
67744: NOT
67745: OR
67746: PUSH
67747: LD_VAR 0 4
67751: NOT
67752: OR
67753: IFFALSE 67757
// exit ;
67755: GO 67949
// while 1 do
67757: LD_INT 1
67759: IFFALSE 67949
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
67761: LD_ADDR_VAR 0 9
67765: PUSH
67766: LD_VAR 0 1
67770: PPUSH
67771: LD_INT 1
67773: PPUSH
67774: CALL_OW 287
67778: PUSH
67779: LD_INT 10
67781: MUL
67782: ST_TO_ADDR
// r := rate / 10 ;
67783: LD_ADDR_VAR 0 7
67787: PUSH
67788: LD_VAR 0 2
67792: PUSH
67793: LD_INT 10
67795: DIVREAL
67796: ST_TO_ADDR
// time := 1 1$00 ;
67797: LD_ADDR_VAR 0 8
67801: PUSH
67802: LD_INT 2100
67804: ST_TO_ADDR
// if amount < min then
67805: LD_VAR 0 9
67809: PUSH
67810: LD_VAR 0 3
67814: LESS
67815: IFFALSE 67833
// r := r * 2 else
67817: LD_ADDR_VAR 0 7
67821: PUSH
67822: LD_VAR 0 7
67826: PUSH
67827: LD_INT 2
67829: MUL
67830: ST_TO_ADDR
67831: GO 67859
// if amount > max then
67833: LD_VAR 0 9
67837: PUSH
67838: LD_VAR 0 4
67842: GREATER
67843: IFFALSE 67859
// r := r / 2 ;
67845: LD_ADDR_VAR 0 7
67849: PUSH
67850: LD_VAR 0 7
67854: PUSH
67855: LD_INT 2
67857: DIVREAL
67858: ST_TO_ADDR
// time := time / r ;
67859: LD_ADDR_VAR 0 8
67863: PUSH
67864: LD_VAR 0 8
67868: PUSH
67869: LD_VAR 0 7
67873: DIVREAL
67874: ST_TO_ADDR
// if time < 0 then
67875: LD_VAR 0 8
67879: PUSH
67880: LD_INT 0
67882: LESS
67883: IFFALSE 67900
// time := time * - 1 ;
67885: LD_ADDR_VAR 0 8
67889: PUSH
67890: LD_VAR 0 8
67894: PUSH
67895: LD_INT 1
67897: NEG
67898: MUL
67899: ST_TO_ADDR
// wait ( time ) ;
67900: LD_VAR 0 8
67904: PPUSH
67905: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
67909: LD_INT 35
67911: PPUSH
67912: LD_INT 875
67914: PPUSH
67915: CALL_OW 12
67919: PPUSH
67920: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
67924: LD_INT 1
67926: PPUSH
67927: LD_INT 5
67929: PPUSH
67930: CALL_OW 12
67934: PPUSH
67935: LD_VAR 0 1
67939: PPUSH
67940: LD_INT 1
67942: PPUSH
67943: CALL_OW 55
// end ;
67947: GO 67757
// end ;
67949: LD_VAR 0 5
67953: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
67954: LD_INT 0
67956: PPUSH
67957: PPUSH
67958: PPUSH
67959: PPUSH
67960: PPUSH
67961: PPUSH
67962: PPUSH
67963: PPUSH
// if not turrets or not factories then
67964: LD_VAR 0 1
67968: NOT
67969: PUSH
67970: LD_VAR 0 2
67974: NOT
67975: OR
67976: IFFALSE 67980
// exit ;
67978: GO 68287
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
67980: LD_ADDR_VAR 0 10
67984: PUSH
67985: LD_INT 5
67987: PUSH
67988: LD_INT 6
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PUSH
67995: LD_INT 2
67997: PUSH
67998: LD_INT 4
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 3
68007: PUSH
68008: LD_INT 5
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: LIST
68019: PUSH
68020: LD_INT 24
68022: PUSH
68023: LD_INT 25
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: LD_INT 23
68032: PUSH
68033: LD_INT 27
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 42
68046: PUSH
68047: LD_INT 43
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 44
68056: PUSH
68057: LD_INT 46
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 45
68066: PUSH
68067: LD_INT 47
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: LIST
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: LIST
68083: ST_TO_ADDR
// result := [ ] ;
68084: LD_ADDR_VAR 0 3
68088: PUSH
68089: EMPTY
68090: ST_TO_ADDR
// for i in turrets do
68091: LD_ADDR_VAR 0 4
68095: PUSH
68096: LD_VAR 0 1
68100: PUSH
68101: FOR_IN
68102: IFFALSE 68285
// begin nat := GetNation ( i ) ;
68104: LD_ADDR_VAR 0 7
68108: PUSH
68109: LD_VAR 0 4
68113: PPUSH
68114: CALL_OW 248
68118: ST_TO_ADDR
// weapon := 0 ;
68119: LD_ADDR_VAR 0 8
68123: PUSH
68124: LD_INT 0
68126: ST_TO_ADDR
// if not nat then
68127: LD_VAR 0 7
68131: NOT
68132: IFFALSE 68136
// continue ;
68134: GO 68101
// for j in list [ nat ] do
68136: LD_ADDR_VAR 0 5
68140: PUSH
68141: LD_VAR 0 10
68145: PUSH
68146: LD_VAR 0 7
68150: ARRAY
68151: PUSH
68152: FOR_IN
68153: IFFALSE 68194
// if GetBWeapon ( i ) = j [ 1 ] then
68155: LD_VAR 0 4
68159: PPUSH
68160: CALL_OW 269
68164: PUSH
68165: LD_VAR 0 5
68169: PUSH
68170: LD_INT 1
68172: ARRAY
68173: EQUAL
68174: IFFALSE 68192
// begin weapon := j [ 2 ] ;
68176: LD_ADDR_VAR 0 8
68180: PUSH
68181: LD_VAR 0 5
68185: PUSH
68186: LD_INT 2
68188: ARRAY
68189: ST_TO_ADDR
// break ;
68190: GO 68194
// end ;
68192: GO 68152
68194: POP
68195: POP
// if not weapon then
68196: LD_VAR 0 8
68200: NOT
68201: IFFALSE 68205
// continue ;
68203: GO 68101
// for k in factories do
68205: LD_ADDR_VAR 0 6
68209: PUSH
68210: LD_VAR 0 2
68214: PUSH
68215: FOR_IN
68216: IFFALSE 68281
// begin weapons := AvailableWeaponList ( k ) ;
68218: LD_ADDR_VAR 0 9
68222: PUSH
68223: LD_VAR 0 6
68227: PPUSH
68228: CALL_OW 478
68232: ST_TO_ADDR
// if not weapons then
68233: LD_VAR 0 9
68237: NOT
68238: IFFALSE 68242
// continue ;
68240: GO 68215
// if weapon in weapons then
68242: LD_VAR 0 8
68246: PUSH
68247: LD_VAR 0 9
68251: IN
68252: IFFALSE 68279
// begin result := [ i , weapon ] ;
68254: LD_ADDR_VAR 0 3
68258: PUSH
68259: LD_VAR 0 4
68263: PUSH
68264: LD_VAR 0 8
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: ST_TO_ADDR
// exit ;
68273: POP
68274: POP
68275: POP
68276: POP
68277: GO 68287
// end ; end ;
68279: GO 68215
68281: POP
68282: POP
// end ;
68283: GO 68101
68285: POP
68286: POP
// end ;
68287: LD_VAR 0 3
68291: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
68292: LD_INT 0
68294: PPUSH
// if not side or side > 8 then
68295: LD_VAR 0 3
68299: NOT
68300: PUSH
68301: LD_VAR 0 3
68305: PUSH
68306: LD_INT 8
68308: GREATER
68309: OR
68310: IFFALSE 68314
// exit ;
68312: GO 68373
// if not range then
68314: LD_VAR 0 4
68318: NOT
68319: IFFALSE 68330
// range := - 12 ;
68321: LD_ADDR_VAR 0 4
68325: PUSH
68326: LD_INT 12
68328: NEG
68329: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
68330: LD_VAR 0 1
68334: PPUSH
68335: LD_VAR 0 2
68339: PPUSH
68340: LD_VAR 0 3
68344: PPUSH
68345: LD_VAR 0 4
68349: PPUSH
68350: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
68354: LD_VAR 0 1
68358: PPUSH
68359: LD_VAR 0 2
68363: PPUSH
68364: LD_VAR 0 3
68368: PPUSH
68369: CALL_OW 331
// end ;
68373: LD_VAR 0 5
68377: RET
// export function Video ( mode ) ; begin
68378: LD_INT 0
68380: PPUSH
// ingame_video = mode ;
68381: LD_ADDR_OWVAR 52
68385: PUSH
68386: LD_VAR 0 1
68390: ST_TO_ADDR
// interface_hidden = mode ;
68391: LD_ADDR_OWVAR 54
68395: PUSH
68396: LD_VAR 0 1
68400: ST_TO_ADDR
// end ;
68401: LD_VAR 0 2
68405: RET
// export function Join ( array , element ) ; begin
68406: LD_INT 0
68408: PPUSH
// result := array ^ element ;
68409: LD_ADDR_VAR 0 3
68413: PUSH
68414: LD_VAR 0 1
68418: PUSH
68419: LD_VAR 0 2
68423: ADD
68424: ST_TO_ADDR
// end ;
68425: LD_VAR 0 3
68429: RET
// export function JoinUnion ( array , element ) ; begin
68430: LD_INT 0
68432: PPUSH
// result := array union element ;
68433: LD_ADDR_VAR 0 3
68437: PUSH
68438: LD_VAR 0 1
68442: PUSH
68443: LD_VAR 0 2
68447: UNION
68448: ST_TO_ADDR
// end ;
68449: LD_VAR 0 3
68453: RET
// export function GetBehemoths ( side ) ; begin
68454: LD_INT 0
68456: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
68457: LD_ADDR_VAR 0 2
68461: PUSH
68462: LD_INT 22
68464: PUSH
68465: LD_VAR 0 1
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 31
68476: PUSH
68477: LD_INT 25
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PPUSH
68488: CALL_OW 69
68492: ST_TO_ADDR
// end ;
68493: LD_VAR 0 2
68497: RET
// export function Shuffle ( array ) ; var i , index ; begin
68498: LD_INT 0
68500: PPUSH
68501: PPUSH
68502: PPUSH
// result := [ ] ;
68503: LD_ADDR_VAR 0 2
68507: PUSH
68508: EMPTY
68509: ST_TO_ADDR
// if not array then
68510: LD_VAR 0 1
68514: NOT
68515: IFFALSE 68519
// exit ;
68517: GO 68618
// Randomize ;
68519: CALL_OW 10
// for i = array downto 1 do
68523: LD_ADDR_VAR 0 3
68527: PUSH
68528: DOUBLE
68529: LD_VAR 0 1
68533: INC
68534: ST_TO_ADDR
68535: LD_INT 1
68537: PUSH
68538: FOR_DOWNTO
68539: IFFALSE 68616
// begin index := rand ( 1 , array ) ;
68541: LD_ADDR_VAR 0 4
68545: PUSH
68546: LD_INT 1
68548: PPUSH
68549: LD_VAR 0 1
68553: PPUSH
68554: CALL_OW 12
68558: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
68559: LD_ADDR_VAR 0 2
68563: PUSH
68564: LD_VAR 0 2
68568: PPUSH
68569: LD_VAR 0 2
68573: PUSH
68574: LD_INT 1
68576: PLUS
68577: PPUSH
68578: LD_VAR 0 1
68582: PUSH
68583: LD_VAR 0 4
68587: ARRAY
68588: PPUSH
68589: CALL_OW 2
68593: ST_TO_ADDR
// array := Delete ( array , index ) ;
68594: LD_ADDR_VAR 0 1
68598: PUSH
68599: LD_VAR 0 1
68603: PPUSH
68604: LD_VAR 0 4
68608: PPUSH
68609: CALL_OW 3
68613: ST_TO_ADDR
// end ;
68614: GO 68538
68616: POP
68617: POP
// end ;
68618: LD_VAR 0 2
68622: RET
// export function GetBaseMaterials ( base ) ; begin
68623: LD_INT 0
68625: PPUSH
// result := [ 0 , 0 , 0 ] ;
68626: LD_ADDR_VAR 0 2
68630: PUSH
68631: LD_INT 0
68633: PUSH
68634: LD_INT 0
68636: PUSH
68637: LD_INT 0
68639: PUSH
68640: EMPTY
68641: LIST
68642: LIST
68643: LIST
68644: ST_TO_ADDR
// if not base then
68645: LD_VAR 0 1
68649: NOT
68650: IFFALSE 68654
// exit ;
68652: GO 68703
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
68654: LD_ADDR_VAR 0 2
68658: PUSH
68659: LD_VAR 0 1
68663: PPUSH
68664: LD_INT 1
68666: PPUSH
68667: CALL_OW 275
68671: PUSH
68672: LD_VAR 0 1
68676: PPUSH
68677: LD_INT 2
68679: PPUSH
68680: CALL_OW 275
68684: PUSH
68685: LD_VAR 0 1
68689: PPUSH
68690: LD_INT 3
68692: PPUSH
68693: CALL_OW 275
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: LIST
68702: ST_TO_ADDR
// end ;
68703: LD_VAR 0 2
68707: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
68708: LD_INT 0
68710: PPUSH
68711: PPUSH
// result := array ;
68712: LD_ADDR_VAR 0 3
68716: PUSH
68717: LD_VAR 0 1
68721: ST_TO_ADDR
// if size > 0 then
68722: LD_VAR 0 2
68726: PUSH
68727: LD_INT 0
68729: GREATER
68730: IFFALSE 68776
// for i := array downto size do
68732: LD_ADDR_VAR 0 4
68736: PUSH
68737: DOUBLE
68738: LD_VAR 0 1
68742: INC
68743: ST_TO_ADDR
68744: LD_VAR 0 2
68748: PUSH
68749: FOR_DOWNTO
68750: IFFALSE 68774
// result := Delete ( result , result ) ;
68752: LD_ADDR_VAR 0 3
68756: PUSH
68757: LD_VAR 0 3
68761: PPUSH
68762: LD_VAR 0 3
68766: PPUSH
68767: CALL_OW 3
68771: ST_TO_ADDR
68772: GO 68749
68774: POP
68775: POP
// end ;
68776: LD_VAR 0 3
68780: RET
// export function ComExit ( unit ) ; var tmp ; begin
68781: LD_INT 0
68783: PPUSH
68784: PPUSH
// if not IsInUnit ( unit ) then
68785: LD_VAR 0 1
68789: PPUSH
68790: CALL_OW 310
68794: NOT
68795: IFFALSE 68799
// exit ;
68797: GO 68859
// tmp := IsInUnit ( unit ) ;
68799: LD_ADDR_VAR 0 3
68803: PUSH
68804: LD_VAR 0 1
68808: PPUSH
68809: CALL_OW 310
68813: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
68814: LD_VAR 0 3
68818: PPUSH
68819: CALL_OW 247
68823: PUSH
68824: LD_INT 2
68826: EQUAL
68827: IFFALSE 68840
// ComExitVehicle ( unit ) else
68829: LD_VAR 0 1
68833: PPUSH
68834: CALL_OW 121
68838: GO 68849
// ComExitBuilding ( unit ) ;
68840: LD_VAR 0 1
68844: PPUSH
68845: CALL_OW 122
// result := tmp ;
68849: LD_ADDR_VAR 0 2
68853: PUSH
68854: LD_VAR 0 3
68858: ST_TO_ADDR
// end ;
68859: LD_VAR 0 2
68863: RET
// export function ResetHc ; begin
68864: LD_INT 0
68866: PPUSH
// InitHc ;
68867: CALL_OW 19
// hc_importance := 0 ;
68871: LD_ADDR_OWVAR 32
68875: PUSH
68876: LD_INT 0
68878: ST_TO_ADDR
// end ; end_of_file
68879: LD_VAR 0 1
68883: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
68884: LD_INT 0
68886: PPUSH
68887: PPUSH
68888: PPUSH
// if not mc_bases or not skirmish then
68889: LD_EXP 52
68893: NOT
68894: PUSH
68895: LD_EXP 50
68899: NOT
68900: OR
68901: IFFALSE 68905
// exit ;
68903: GO 69070
// for i = 1 to mc_bases do
68905: LD_ADDR_VAR 0 4
68909: PUSH
68910: DOUBLE
68911: LD_INT 1
68913: DEC
68914: ST_TO_ADDR
68915: LD_EXP 52
68919: PUSH
68920: FOR_TO
68921: IFFALSE 69068
// begin if sci in mc_bases [ i ] then
68923: LD_VAR 0 2
68927: PUSH
68928: LD_EXP 52
68932: PUSH
68933: LD_VAR 0 4
68937: ARRAY
68938: IN
68939: IFFALSE 69066
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
68941: LD_ADDR_EXP 81
68945: PUSH
68946: LD_EXP 81
68950: PPUSH
68951: LD_VAR 0 4
68955: PUSH
68956: LD_EXP 81
68960: PUSH
68961: LD_VAR 0 4
68965: ARRAY
68966: PUSH
68967: LD_INT 1
68969: PLUS
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PPUSH
68975: LD_VAR 0 1
68979: PPUSH
68980: CALL 37482 0 3
68984: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
68985: LD_ADDR_VAR 0 5
68989: PUSH
68990: LD_EXP 52
68994: PUSH
68995: LD_VAR 0 4
68999: ARRAY
69000: PPUSH
69001: LD_INT 2
69003: PUSH
69004: LD_INT 30
69006: PUSH
69007: LD_INT 0
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 30
69016: PUSH
69017: LD_INT 1
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: LIST
69028: PPUSH
69029: CALL_OW 72
69033: PPUSH
69034: LD_VAR 0 1
69038: PPUSH
69039: CALL_OW 74
69043: ST_TO_ADDR
// if tmp then
69044: LD_VAR 0 5
69048: IFFALSE 69064
// ComStandNearbyBuilding ( ape , tmp ) ;
69050: LD_VAR 0 1
69054: PPUSH
69055: LD_VAR 0 5
69059: PPUSH
69060: CALL 34096 0 2
// break ;
69064: GO 69068
// end ; end ;
69066: GO 68920
69068: POP
69069: POP
// end ;
69070: LD_VAR 0 3
69074: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
69075: LD_INT 0
69077: PPUSH
69078: PPUSH
69079: PPUSH
// if not mc_bases or not skirmish then
69080: LD_EXP 52
69084: NOT
69085: PUSH
69086: LD_EXP 50
69090: NOT
69091: OR
69092: IFFALSE 69096
// exit ;
69094: GO 69185
// for i = 1 to mc_bases do
69096: LD_ADDR_VAR 0 4
69100: PUSH
69101: DOUBLE
69102: LD_INT 1
69104: DEC
69105: ST_TO_ADDR
69106: LD_EXP 52
69110: PUSH
69111: FOR_TO
69112: IFFALSE 69183
// begin if building in mc_busy_turret_list [ i ] then
69114: LD_VAR 0 1
69118: PUSH
69119: LD_EXP 62
69123: PUSH
69124: LD_VAR 0 4
69128: ARRAY
69129: IN
69130: IFFALSE 69181
// begin tmp := mc_busy_turret_list [ i ] diff building ;
69132: LD_ADDR_VAR 0 5
69136: PUSH
69137: LD_EXP 62
69141: PUSH
69142: LD_VAR 0 4
69146: ARRAY
69147: PUSH
69148: LD_VAR 0 1
69152: DIFF
69153: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
69154: LD_ADDR_EXP 62
69158: PUSH
69159: LD_EXP 62
69163: PPUSH
69164: LD_VAR 0 4
69168: PPUSH
69169: LD_VAR 0 5
69173: PPUSH
69174: CALL_OW 1
69178: ST_TO_ADDR
// break ;
69179: GO 69183
// end ; end ;
69181: GO 69111
69183: POP
69184: POP
// end ;
69185: LD_VAR 0 3
69189: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
69190: LD_INT 0
69192: PPUSH
69193: PPUSH
69194: PPUSH
// if not mc_bases or not skirmish then
69195: LD_EXP 52
69199: NOT
69200: PUSH
69201: LD_EXP 50
69205: NOT
69206: OR
69207: IFFALSE 69211
// exit ;
69209: GO 69410
// for i = 1 to mc_bases do
69211: LD_ADDR_VAR 0 5
69215: PUSH
69216: DOUBLE
69217: LD_INT 1
69219: DEC
69220: ST_TO_ADDR
69221: LD_EXP 52
69225: PUSH
69226: FOR_TO
69227: IFFALSE 69408
// if building in mc_bases [ i ] then
69229: LD_VAR 0 1
69233: PUSH
69234: LD_EXP 52
69238: PUSH
69239: LD_VAR 0 5
69243: ARRAY
69244: IN
69245: IFFALSE 69406
// begin tmp := mc_bases [ i ] diff building ;
69247: LD_ADDR_VAR 0 6
69251: PUSH
69252: LD_EXP 52
69256: PUSH
69257: LD_VAR 0 5
69261: ARRAY
69262: PUSH
69263: LD_VAR 0 1
69267: DIFF
69268: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
69269: LD_ADDR_EXP 52
69273: PUSH
69274: LD_EXP 52
69278: PPUSH
69279: LD_VAR 0 5
69283: PPUSH
69284: LD_VAR 0 6
69288: PPUSH
69289: CALL_OW 1
69293: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
69294: LD_VAR 0 1
69298: PUSH
69299: LD_EXP 60
69303: PUSH
69304: LD_VAR 0 5
69308: ARRAY
69309: IN
69310: IFFALSE 69349
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
69312: LD_ADDR_EXP 60
69316: PUSH
69317: LD_EXP 60
69321: PPUSH
69322: LD_VAR 0 5
69326: PPUSH
69327: LD_EXP 60
69331: PUSH
69332: LD_VAR 0 5
69336: ARRAY
69337: PUSH
69338: LD_VAR 0 1
69342: DIFF
69343: PPUSH
69344: CALL_OW 1
69348: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
69349: LD_VAR 0 1
69353: PUSH
69354: LD_EXP 61
69358: PUSH
69359: LD_VAR 0 5
69363: ARRAY
69364: IN
69365: IFFALSE 69404
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
69367: LD_ADDR_EXP 61
69371: PUSH
69372: LD_EXP 61
69376: PPUSH
69377: LD_VAR 0 5
69381: PPUSH
69382: LD_EXP 61
69386: PUSH
69387: LD_VAR 0 5
69391: ARRAY
69392: PUSH
69393: LD_VAR 0 1
69397: DIFF
69398: PPUSH
69399: CALL_OW 1
69403: ST_TO_ADDR
// break ;
69404: GO 69408
// end ;
69406: GO 69226
69408: POP
69409: POP
// end ;
69410: LD_VAR 0 4
69414: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
69415: LD_INT 0
69417: PPUSH
69418: PPUSH
69419: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
69420: LD_EXP 52
69424: NOT
69425: PUSH
69426: LD_EXP 50
69430: NOT
69431: OR
69432: PUSH
69433: LD_VAR 0 3
69437: PUSH
69438: LD_EXP 78
69442: IN
69443: NOT
69444: OR
69445: IFFALSE 69449
// exit ;
69447: GO 69572
// for i = 1 to mc_vehicles do
69449: LD_ADDR_VAR 0 6
69453: PUSH
69454: DOUBLE
69455: LD_INT 1
69457: DEC
69458: ST_TO_ADDR
69459: LD_EXP 71
69463: PUSH
69464: FOR_TO
69465: IFFALSE 69570
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
69467: LD_VAR 0 2
69471: PUSH
69472: LD_EXP 71
69476: PUSH
69477: LD_VAR 0 6
69481: ARRAY
69482: IN
69483: PUSH
69484: LD_VAR 0 1
69488: PUSH
69489: LD_EXP 71
69493: PUSH
69494: LD_VAR 0 6
69498: ARRAY
69499: IN
69500: OR
69501: IFFALSE 69568
// begin tmp := mc_vehicles [ i ] diff old ;
69503: LD_ADDR_VAR 0 7
69507: PUSH
69508: LD_EXP 71
69512: PUSH
69513: LD_VAR 0 6
69517: ARRAY
69518: PUSH
69519: LD_VAR 0 2
69523: DIFF
69524: ST_TO_ADDR
// tmp := tmp diff new ;
69525: LD_ADDR_VAR 0 7
69529: PUSH
69530: LD_VAR 0 7
69534: PUSH
69535: LD_VAR 0 1
69539: DIFF
69540: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
69541: LD_ADDR_EXP 71
69545: PUSH
69546: LD_EXP 71
69550: PPUSH
69551: LD_VAR 0 6
69555: PPUSH
69556: LD_VAR 0 7
69560: PPUSH
69561: CALL_OW 1
69565: ST_TO_ADDR
// break ;
69566: GO 69570
// end ;
69568: GO 69464
69570: POP
69571: POP
// end ;
69572: LD_VAR 0 5
69576: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
69577: LD_INT 0
69579: PPUSH
69580: PPUSH
69581: PPUSH
69582: PPUSH
// if not mc_bases or not skirmish then
69583: LD_EXP 52
69587: NOT
69588: PUSH
69589: LD_EXP 50
69593: NOT
69594: OR
69595: IFFALSE 69599
// exit ;
69597: GO 69976
// side := GetSide ( vehicle ) ;
69599: LD_ADDR_VAR 0 5
69603: PUSH
69604: LD_VAR 0 1
69608: PPUSH
69609: CALL_OW 255
69613: ST_TO_ADDR
// for i = 1 to mc_bases do
69614: LD_ADDR_VAR 0 4
69618: PUSH
69619: DOUBLE
69620: LD_INT 1
69622: DEC
69623: ST_TO_ADDR
69624: LD_EXP 52
69628: PUSH
69629: FOR_TO
69630: IFFALSE 69974
// begin if factory in mc_bases [ i ] then
69632: LD_VAR 0 2
69636: PUSH
69637: LD_EXP 52
69641: PUSH
69642: LD_VAR 0 4
69646: ARRAY
69647: IN
69648: IFFALSE 69972
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
69650: LD_EXP 74
69654: PUSH
69655: LD_VAR 0 4
69659: ARRAY
69660: PUSH
69661: LD_EXP 63
69665: PUSH
69666: LD_VAR 0 4
69670: ARRAY
69671: LESS
69672: PUSH
69673: LD_VAR 0 1
69677: PPUSH
69678: CALL_OW 264
69682: PUSH
69683: LD_INT 31
69685: PUSH
69686: LD_INT 32
69688: PUSH
69689: LD_INT 51
69691: PUSH
69692: LD_EXP 96
69696: PUSH
69697: LD_INT 12
69699: PUSH
69700: LD_INT 30
69702: PUSH
69703: LD_EXP 95
69707: PUSH
69708: LD_INT 11
69710: PUSH
69711: LD_INT 53
69713: PUSH
69714: LD_INT 14
69716: PUSH
69717: LD_EXP 99
69721: PUSH
69722: LD_INT 29
69724: PUSH
69725: LD_EXP 97
69729: PUSH
69730: LD_INT 13
69732: PUSH
69733: LD_INT 52
69735: PUSH
69736: LD_INT 48
69738: PUSH
69739: LD_INT 8
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: IN
69761: NOT
69762: AND
69763: IFFALSE 69811
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
69765: LD_ADDR_EXP 74
69769: PUSH
69770: LD_EXP 74
69774: PPUSH
69775: LD_VAR 0 4
69779: PUSH
69780: LD_EXP 74
69784: PUSH
69785: LD_VAR 0 4
69789: ARRAY
69790: PUSH
69791: LD_INT 1
69793: PLUS
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PPUSH
69799: LD_VAR 0 1
69803: PPUSH
69804: CALL 37482 0 3
69808: ST_TO_ADDR
69809: GO 69855
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
69811: LD_ADDR_EXP 71
69815: PUSH
69816: LD_EXP 71
69820: PPUSH
69821: LD_VAR 0 4
69825: PUSH
69826: LD_EXP 71
69830: PUSH
69831: LD_VAR 0 4
69835: ARRAY
69836: PUSH
69837: LD_INT 1
69839: PLUS
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: PPUSH
69845: LD_VAR 0 1
69849: PPUSH
69850: CALL 37482 0 3
69854: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
69855: LD_VAR 0 1
69859: PPUSH
69860: CALL_OW 263
69864: PUSH
69865: LD_INT 2
69867: EQUAL
69868: IFFALSE 69888
// begin repeat wait ( 0 0$1 ) ;
69870: LD_INT 35
69872: PPUSH
69873: CALL_OW 67
// until IsControledBy ( vehicle ) ;
69877: LD_VAR 0 1
69881: PPUSH
69882: CALL_OW 312
69886: IFFALSE 69870
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
69888: LD_VAR 0 1
69892: PPUSH
69893: LD_EXP 76
69897: PUSH
69898: LD_VAR 0 4
69902: ARRAY
69903: PPUSH
69904: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
69908: LD_VAR 0 1
69912: PPUSH
69913: CALL_OW 263
69917: PUSH
69918: LD_INT 1
69920: NONEQUAL
69921: IFFALSE 69925
// break ;
69923: GO 69974
// repeat wait ( 0 0$1 ) ;
69925: LD_INT 35
69927: PPUSH
69928: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
69932: LD_VAR 0 1
69936: PPUSH
69937: LD_EXP 76
69941: PUSH
69942: LD_VAR 0 4
69946: ARRAY
69947: PPUSH
69948: CALL_OW 308
69952: IFFALSE 69925
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
69954: LD_VAR 0 1
69958: PPUSH
69959: CALL_OW 311
69963: PPUSH
69964: CALL_OW 121
// exit ;
69968: POP
69969: POP
69970: GO 69976
// end ; end ;
69972: GO 69629
69974: POP
69975: POP
// end ;
69976: LD_VAR 0 3
69980: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
69981: LD_INT 0
69983: PPUSH
69984: PPUSH
69985: PPUSH
69986: PPUSH
// if not mc_bases or not skirmish then
69987: LD_EXP 52
69991: NOT
69992: PUSH
69993: LD_EXP 50
69997: NOT
69998: OR
69999: IFFALSE 70003
// exit ;
70001: GO 70356
// repeat wait ( 0 0$1 ) ;
70003: LD_INT 35
70005: PPUSH
70006: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
70010: LD_VAR 0 2
70014: PPUSH
70015: LD_VAR 0 3
70019: PPUSH
70020: CALL_OW 284
70024: IFFALSE 70003
// if GetResourceTypeXY ( x , y ) = mat_artefact then
70026: LD_VAR 0 2
70030: PPUSH
70031: LD_VAR 0 3
70035: PPUSH
70036: CALL_OW 283
70040: PUSH
70041: LD_INT 4
70043: EQUAL
70044: IFFALSE 70048
// exit ;
70046: GO 70356
// for i = 1 to mc_bases do
70048: LD_ADDR_VAR 0 7
70052: PUSH
70053: DOUBLE
70054: LD_INT 1
70056: DEC
70057: ST_TO_ADDR
70058: LD_EXP 52
70062: PUSH
70063: FOR_TO
70064: IFFALSE 70354
// begin if mc_crates_area [ i ] then
70066: LD_EXP 70
70070: PUSH
70071: LD_VAR 0 7
70075: ARRAY
70076: IFFALSE 70187
// for j in mc_crates_area [ i ] do
70078: LD_ADDR_VAR 0 8
70082: PUSH
70083: LD_EXP 70
70087: PUSH
70088: LD_VAR 0 7
70092: ARRAY
70093: PUSH
70094: FOR_IN
70095: IFFALSE 70185
// if InArea ( x , y , j ) then
70097: LD_VAR 0 2
70101: PPUSH
70102: LD_VAR 0 3
70106: PPUSH
70107: LD_VAR 0 8
70111: PPUSH
70112: CALL_OW 309
70116: IFFALSE 70183
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
70118: LD_ADDR_EXP 68
70122: PUSH
70123: LD_EXP 68
70127: PPUSH
70128: LD_VAR 0 7
70132: PUSH
70133: LD_EXP 68
70137: PUSH
70138: LD_VAR 0 7
70142: ARRAY
70143: PUSH
70144: LD_INT 1
70146: PLUS
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PPUSH
70152: LD_VAR 0 4
70156: PUSH
70157: LD_VAR 0 2
70161: PUSH
70162: LD_VAR 0 3
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: LIST
70171: PPUSH
70172: CALL 37482 0 3
70176: ST_TO_ADDR
// exit ;
70177: POP
70178: POP
70179: POP
70180: POP
70181: GO 70356
// end ;
70183: GO 70094
70185: POP
70186: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70187: LD_ADDR_VAR 0 9
70191: PUSH
70192: LD_EXP 52
70196: PUSH
70197: LD_VAR 0 7
70201: ARRAY
70202: PPUSH
70203: LD_INT 2
70205: PUSH
70206: LD_INT 30
70208: PUSH
70209: LD_INT 0
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 30
70218: PUSH
70219: LD_INT 1
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: LIST
70230: PPUSH
70231: CALL_OW 72
70235: ST_TO_ADDR
// if not depot then
70236: LD_VAR 0 9
70240: NOT
70241: IFFALSE 70245
// continue ;
70243: GO 70063
// for j in depot do
70245: LD_ADDR_VAR 0 8
70249: PUSH
70250: LD_VAR 0 9
70254: PUSH
70255: FOR_IN
70256: IFFALSE 70350
// if GetDistUnitXY ( j , x , y ) < 30 then
70258: LD_VAR 0 8
70262: PPUSH
70263: LD_VAR 0 2
70267: PPUSH
70268: LD_VAR 0 3
70272: PPUSH
70273: CALL_OW 297
70277: PUSH
70278: LD_INT 30
70280: LESS
70281: IFFALSE 70348
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
70283: LD_ADDR_EXP 68
70287: PUSH
70288: LD_EXP 68
70292: PPUSH
70293: LD_VAR 0 7
70297: PUSH
70298: LD_EXP 68
70302: PUSH
70303: LD_VAR 0 7
70307: ARRAY
70308: PUSH
70309: LD_INT 1
70311: PLUS
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PPUSH
70317: LD_VAR 0 4
70321: PUSH
70322: LD_VAR 0 2
70326: PUSH
70327: LD_VAR 0 3
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: LIST
70336: PPUSH
70337: CALL 37482 0 3
70341: ST_TO_ADDR
// exit ;
70342: POP
70343: POP
70344: POP
70345: POP
70346: GO 70356
// end ;
70348: GO 70255
70350: POP
70351: POP
// end ;
70352: GO 70063
70354: POP
70355: POP
// end ;
70356: LD_VAR 0 6
70360: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
70361: LD_INT 0
70363: PPUSH
70364: PPUSH
70365: PPUSH
70366: PPUSH
// if not mc_bases or not skirmish then
70367: LD_EXP 52
70371: NOT
70372: PUSH
70373: LD_EXP 50
70377: NOT
70378: OR
70379: IFFALSE 70383
// exit ;
70381: GO 70660
// side := GetSide ( lab ) ;
70383: LD_ADDR_VAR 0 4
70387: PUSH
70388: LD_VAR 0 2
70392: PPUSH
70393: CALL_OW 255
70397: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
70398: LD_VAR 0 4
70402: PUSH
70403: LD_EXP 78
70407: IN
70408: NOT
70409: PUSH
70410: LD_EXP 79
70414: NOT
70415: OR
70416: PUSH
70417: LD_EXP 52
70421: NOT
70422: OR
70423: IFFALSE 70427
// exit ;
70425: GO 70660
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
70427: LD_ADDR_EXP 79
70431: PUSH
70432: LD_EXP 79
70436: PPUSH
70437: LD_VAR 0 4
70441: PPUSH
70442: LD_EXP 79
70446: PUSH
70447: LD_VAR 0 4
70451: ARRAY
70452: PUSH
70453: LD_VAR 0 1
70457: DIFF
70458: PPUSH
70459: CALL_OW 1
70463: ST_TO_ADDR
// for i = 1 to mc_bases do
70464: LD_ADDR_VAR 0 5
70468: PUSH
70469: DOUBLE
70470: LD_INT 1
70472: DEC
70473: ST_TO_ADDR
70474: LD_EXP 52
70478: PUSH
70479: FOR_TO
70480: IFFALSE 70658
// begin if lab in mc_bases [ i ] then
70482: LD_VAR 0 2
70486: PUSH
70487: LD_EXP 52
70491: PUSH
70492: LD_VAR 0 5
70496: ARRAY
70497: IN
70498: IFFALSE 70656
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
70500: LD_VAR 0 1
70504: PUSH
70505: LD_INT 11
70507: PUSH
70508: LD_INT 4
70510: PUSH
70511: LD_INT 3
70513: PUSH
70514: LD_INT 2
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: LIST
70521: LIST
70522: IN
70523: PUSH
70524: LD_EXP 82
70528: PUSH
70529: LD_VAR 0 5
70533: ARRAY
70534: AND
70535: IFFALSE 70656
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
70537: LD_ADDR_VAR 0 6
70541: PUSH
70542: LD_EXP 82
70546: PUSH
70547: LD_VAR 0 5
70551: ARRAY
70552: PUSH
70553: LD_INT 1
70555: ARRAY
70556: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
70557: LD_ADDR_EXP 82
70561: PUSH
70562: LD_EXP 82
70566: PPUSH
70567: LD_VAR 0 5
70571: PPUSH
70572: EMPTY
70573: PPUSH
70574: CALL_OW 1
70578: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
70579: LD_VAR 0 6
70583: PPUSH
70584: LD_INT 0
70586: PPUSH
70587: CALL_OW 109
// ComExitBuilding ( tmp ) ;
70591: LD_VAR 0 6
70595: PPUSH
70596: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
70600: LD_ADDR_EXP 81
70604: PUSH
70605: LD_EXP 81
70609: PPUSH
70610: LD_VAR 0 5
70614: PPUSH
70615: LD_EXP 81
70619: PUSH
70620: LD_VAR 0 5
70624: ARRAY
70625: PPUSH
70626: LD_INT 1
70628: PPUSH
70629: LD_VAR 0 6
70633: PPUSH
70634: CALL_OW 2
70638: PPUSH
70639: CALL_OW 1
70643: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
70644: LD_VAR 0 5
70648: PPUSH
70649: LD_INT 112
70651: PPUSH
70652: CALL 11324 0 2
// end ; end ; end ;
70656: GO 70479
70658: POP
70659: POP
// end ;
70660: LD_VAR 0 3
70664: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
70665: LD_INT 0
70667: PPUSH
70668: PPUSH
70669: PPUSH
70670: PPUSH
70671: PPUSH
70672: PPUSH
70673: PPUSH
70674: PPUSH
// if not mc_bases or not skirmish then
70675: LD_EXP 52
70679: NOT
70680: PUSH
70681: LD_EXP 50
70685: NOT
70686: OR
70687: IFFALSE 70691
// exit ;
70689: GO 72062
// for i = 1 to mc_bases do
70691: LD_ADDR_VAR 0 3
70695: PUSH
70696: DOUBLE
70697: LD_INT 1
70699: DEC
70700: ST_TO_ADDR
70701: LD_EXP 52
70705: PUSH
70706: FOR_TO
70707: IFFALSE 72060
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
70709: LD_VAR 0 1
70713: PUSH
70714: LD_EXP 52
70718: PUSH
70719: LD_VAR 0 3
70723: ARRAY
70724: IN
70725: PUSH
70726: LD_VAR 0 1
70730: PUSH
70731: LD_EXP 59
70735: PUSH
70736: LD_VAR 0 3
70740: ARRAY
70741: IN
70742: OR
70743: PUSH
70744: LD_VAR 0 1
70748: PUSH
70749: LD_EXP 74
70753: PUSH
70754: LD_VAR 0 3
70758: ARRAY
70759: IN
70760: OR
70761: PUSH
70762: LD_VAR 0 1
70766: PUSH
70767: LD_EXP 71
70771: PUSH
70772: LD_VAR 0 3
70776: ARRAY
70777: IN
70778: OR
70779: PUSH
70780: LD_VAR 0 1
70784: PUSH
70785: LD_EXP 81
70789: PUSH
70790: LD_VAR 0 3
70794: ARRAY
70795: IN
70796: OR
70797: PUSH
70798: LD_VAR 0 1
70802: PUSH
70803: LD_EXP 82
70807: PUSH
70808: LD_VAR 0 3
70812: ARRAY
70813: IN
70814: OR
70815: IFFALSE 72058
// begin if un in mc_ape [ i ] then
70817: LD_VAR 0 1
70821: PUSH
70822: LD_EXP 81
70826: PUSH
70827: LD_VAR 0 3
70831: ARRAY
70832: IN
70833: IFFALSE 70872
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
70835: LD_ADDR_EXP 81
70839: PUSH
70840: LD_EXP 81
70844: PPUSH
70845: LD_VAR 0 3
70849: PPUSH
70850: LD_EXP 81
70854: PUSH
70855: LD_VAR 0 3
70859: ARRAY
70860: PUSH
70861: LD_VAR 0 1
70865: DIFF
70866: PPUSH
70867: CALL_OW 1
70871: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
70872: LD_VAR 0 1
70876: PUSH
70877: LD_EXP 82
70881: PUSH
70882: LD_VAR 0 3
70886: ARRAY
70887: IN
70888: IFFALSE 70912
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
70890: LD_ADDR_EXP 82
70894: PUSH
70895: LD_EXP 82
70899: PPUSH
70900: LD_VAR 0 3
70904: PPUSH
70905: EMPTY
70906: PPUSH
70907: CALL_OW 1
70911: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
70912: LD_VAR 0 1
70916: PPUSH
70917: CALL_OW 247
70921: PUSH
70922: LD_INT 2
70924: EQUAL
70925: PUSH
70926: LD_VAR 0 1
70930: PPUSH
70931: CALL_OW 110
70935: PUSH
70936: LD_INT 20
70938: EQUAL
70939: PUSH
70940: LD_VAR 0 1
70944: PUSH
70945: LD_EXP 74
70949: PUSH
70950: LD_VAR 0 3
70954: ARRAY
70955: IN
70956: OR
70957: PUSH
70958: LD_VAR 0 1
70962: PPUSH
70963: CALL_OW 264
70967: PUSH
70968: LD_INT 12
70970: PUSH
70971: LD_INT 51
70973: PUSH
70974: LD_EXP 96
70978: PUSH
70979: LD_INT 32
70981: PUSH
70982: LD_INT 13
70984: PUSH
70985: LD_INT 52
70987: PUSH
70988: LD_INT 31
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: LIST
70997: LIST
70998: LIST
70999: IN
71000: OR
71001: AND
71002: IFFALSE 71310
// begin if un in mc_defender [ i ] then
71004: LD_VAR 0 1
71008: PUSH
71009: LD_EXP 74
71013: PUSH
71014: LD_VAR 0 3
71018: ARRAY
71019: IN
71020: IFFALSE 71059
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
71022: LD_ADDR_EXP 74
71026: PUSH
71027: LD_EXP 74
71031: PPUSH
71032: LD_VAR 0 3
71036: PPUSH
71037: LD_EXP 74
71041: PUSH
71042: LD_VAR 0 3
71046: ARRAY
71047: PUSH
71048: LD_VAR 0 1
71052: DIFF
71053: PPUSH
71054: CALL_OW 1
71058: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
71059: LD_ADDR_VAR 0 8
71063: PUSH
71064: LD_VAR 0 3
71068: PPUSH
71069: LD_INT 3
71071: PPUSH
71072: CALL 31380 0 2
71076: ST_TO_ADDR
// if fac then
71077: LD_VAR 0 8
71081: IFFALSE 71310
// begin for j in fac do
71083: LD_ADDR_VAR 0 4
71087: PUSH
71088: LD_VAR 0 8
71092: PUSH
71093: FOR_IN
71094: IFFALSE 71308
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
71096: LD_ADDR_VAR 0 9
71100: PUSH
71101: LD_VAR 0 8
71105: PPUSH
71106: LD_VAR 0 1
71110: PPUSH
71111: CALL_OW 265
71115: PPUSH
71116: LD_VAR 0 1
71120: PPUSH
71121: CALL_OW 262
71125: PPUSH
71126: LD_VAR 0 1
71130: PPUSH
71131: CALL_OW 263
71135: PPUSH
71136: LD_VAR 0 1
71140: PPUSH
71141: CALL_OW 264
71145: PPUSH
71146: CALL 35014 0 5
71150: ST_TO_ADDR
// if components then
71151: LD_VAR 0 9
71155: IFFALSE 71306
// begin if GetWeapon ( un ) = ar_control_tower then
71157: LD_VAR 0 1
71161: PPUSH
71162: CALL_OW 264
71166: PUSH
71167: LD_INT 31
71169: EQUAL
71170: IFFALSE 71287
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
71172: LD_VAR 0 1
71176: PPUSH
71177: CALL_OW 311
71181: PPUSH
71182: LD_INT 0
71184: PPUSH
71185: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
71189: LD_ADDR_EXP 92
71193: PUSH
71194: LD_EXP 92
71198: PPUSH
71199: LD_VAR 0 3
71203: PPUSH
71204: LD_EXP 92
71208: PUSH
71209: LD_VAR 0 3
71213: ARRAY
71214: PUSH
71215: LD_VAR 0 1
71219: PPUSH
71220: CALL_OW 311
71224: DIFF
71225: PPUSH
71226: CALL_OW 1
71230: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
71231: LD_ADDR_VAR 0 7
71235: PUSH
71236: LD_EXP 73
71240: PUSH
71241: LD_VAR 0 3
71245: ARRAY
71246: PPUSH
71247: LD_INT 1
71249: PPUSH
71250: LD_VAR 0 9
71254: PPUSH
71255: CALL_OW 2
71259: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
71260: LD_ADDR_EXP 73
71264: PUSH
71265: LD_EXP 73
71269: PPUSH
71270: LD_VAR 0 3
71274: PPUSH
71275: LD_VAR 0 7
71279: PPUSH
71280: CALL_OW 1
71284: ST_TO_ADDR
// end else
71285: GO 71304
// MC_InsertProduceList ( i , [ components ] ) ;
71287: LD_VAR 0 3
71291: PPUSH
71292: LD_VAR 0 9
71296: PUSH
71297: EMPTY
71298: LIST
71299: PPUSH
71300: CALL 30925 0 2
// break ;
71304: GO 71308
// end ; end ;
71306: GO 71093
71308: POP
71309: POP
// end ; end ; if GetType ( un ) = unit_building then
71310: LD_VAR 0 1
71314: PPUSH
71315: CALL_OW 247
71319: PUSH
71320: LD_INT 3
71322: EQUAL
71323: IFFALSE 71726
// begin btype := GetBType ( un ) ;
71325: LD_ADDR_VAR 0 5
71329: PUSH
71330: LD_VAR 0 1
71334: PPUSH
71335: CALL_OW 266
71339: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
71340: LD_VAR 0 5
71344: PUSH
71345: LD_INT 29
71347: PUSH
71348: LD_INT 30
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: IN
71355: IFFALSE 71428
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
71357: LD_VAR 0 1
71361: PPUSH
71362: CALL_OW 250
71366: PPUSH
71367: LD_VAR 0 1
71371: PPUSH
71372: CALL_OW 251
71376: PPUSH
71377: LD_VAR 0 1
71381: PPUSH
71382: CALL_OW 255
71386: PPUSH
71387: CALL_OW 440
71391: NOT
71392: IFFALSE 71428
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
71394: LD_VAR 0 1
71398: PPUSH
71399: CALL_OW 250
71403: PPUSH
71404: LD_VAR 0 1
71408: PPUSH
71409: CALL_OW 251
71413: PPUSH
71414: LD_VAR 0 1
71418: PPUSH
71419: CALL_OW 255
71423: PPUSH
71424: CALL_OW 441
// end ; if btype = b_warehouse then
71428: LD_VAR 0 5
71432: PUSH
71433: LD_INT 1
71435: EQUAL
71436: IFFALSE 71454
// begin btype := b_depot ;
71438: LD_ADDR_VAR 0 5
71442: PUSH
71443: LD_INT 0
71445: ST_TO_ADDR
// pos := 1 ;
71446: LD_ADDR_VAR 0 6
71450: PUSH
71451: LD_INT 1
71453: ST_TO_ADDR
// end ; if btype = b_factory then
71454: LD_VAR 0 5
71458: PUSH
71459: LD_INT 3
71461: EQUAL
71462: IFFALSE 71480
// begin btype := b_workshop ;
71464: LD_ADDR_VAR 0 5
71468: PUSH
71469: LD_INT 2
71471: ST_TO_ADDR
// pos := 1 ;
71472: LD_ADDR_VAR 0 6
71476: PUSH
71477: LD_INT 1
71479: ST_TO_ADDR
// end ; if btype = b_barracks then
71480: LD_VAR 0 5
71484: PUSH
71485: LD_INT 5
71487: EQUAL
71488: IFFALSE 71498
// btype := b_armoury ;
71490: LD_ADDR_VAR 0 5
71494: PUSH
71495: LD_INT 4
71497: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
71498: LD_VAR 0 5
71502: PUSH
71503: LD_INT 7
71505: PUSH
71506: LD_INT 8
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: IN
71513: IFFALSE 71523
// btype := b_lab ;
71515: LD_ADDR_VAR 0 5
71519: PUSH
71520: LD_INT 6
71522: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
71523: LD_ADDR_EXP 57
71527: PUSH
71528: LD_EXP 57
71532: PPUSH
71533: LD_VAR 0 3
71537: PUSH
71538: LD_EXP 57
71542: PUSH
71543: LD_VAR 0 3
71547: ARRAY
71548: PUSH
71549: LD_INT 1
71551: PLUS
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PPUSH
71557: LD_VAR 0 5
71561: PUSH
71562: LD_VAR 0 1
71566: PPUSH
71567: CALL_OW 250
71571: PUSH
71572: LD_VAR 0 1
71576: PPUSH
71577: CALL_OW 251
71581: PUSH
71582: LD_VAR 0 1
71586: PPUSH
71587: CALL_OW 254
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: LIST
71596: LIST
71597: PPUSH
71598: CALL 37482 0 3
71602: ST_TO_ADDR
// if pos = 1 then
71603: LD_VAR 0 6
71607: PUSH
71608: LD_INT 1
71610: EQUAL
71611: IFFALSE 71726
// begin tmp := mc_build_list [ i ] ;
71613: LD_ADDR_VAR 0 7
71617: PUSH
71618: LD_EXP 57
71622: PUSH
71623: LD_VAR 0 3
71627: ARRAY
71628: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71629: LD_VAR 0 7
71633: PPUSH
71634: LD_INT 2
71636: PUSH
71637: LD_INT 30
71639: PUSH
71640: LD_INT 0
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: PUSH
71647: LD_INT 30
71649: PUSH
71650: LD_INT 1
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: PUSH
71657: EMPTY
71658: LIST
71659: LIST
71660: LIST
71661: PPUSH
71662: CALL_OW 72
71666: IFFALSE 71676
// pos := 2 ;
71668: LD_ADDR_VAR 0 6
71672: PUSH
71673: LD_INT 2
71675: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
71676: LD_ADDR_VAR 0 7
71680: PUSH
71681: LD_VAR 0 7
71685: PPUSH
71686: LD_VAR 0 6
71690: PPUSH
71691: LD_VAR 0 7
71695: PPUSH
71696: CALL 37808 0 3
71700: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
71701: LD_ADDR_EXP 57
71705: PUSH
71706: LD_EXP 57
71710: PPUSH
71711: LD_VAR 0 3
71715: PPUSH
71716: LD_VAR 0 7
71720: PPUSH
71721: CALL_OW 1
71725: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
71726: LD_VAR 0 1
71730: PUSH
71731: LD_EXP 52
71735: PUSH
71736: LD_VAR 0 3
71740: ARRAY
71741: IN
71742: IFFALSE 71781
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
71744: LD_ADDR_EXP 52
71748: PUSH
71749: LD_EXP 52
71753: PPUSH
71754: LD_VAR 0 3
71758: PPUSH
71759: LD_EXP 52
71763: PUSH
71764: LD_VAR 0 3
71768: ARRAY
71769: PUSH
71770: LD_VAR 0 1
71774: DIFF
71775: PPUSH
71776: CALL_OW 1
71780: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
71781: LD_VAR 0 1
71785: PUSH
71786: LD_EXP 59
71790: PUSH
71791: LD_VAR 0 3
71795: ARRAY
71796: IN
71797: IFFALSE 71836
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
71799: LD_ADDR_EXP 59
71803: PUSH
71804: LD_EXP 59
71808: PPUSH
71809: LD_VAR 0 3
71813: PPUSH
71814: LD_EXP 59
71818: PUSH
71819: LD_VAR 0 3
71823: ARRAY
71824: PUSH
71825: LD_VAR 0 1
71829: DIFF
71830: PPUSH
71831: CALL_OW 1
71835: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
71836: LD_VAR 0 1
71840: PUSH
71841: LD_EXP 71
71845: PUSH
71846: LD_VAR 0 3
71850: ARRAY
71851: IN
71852: IFFALSE 71891
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
71854: LD_ADDR_EXP 71
71858: PUSH
71859: LD_EXP 71
71863: PPUSH
71864: LD_VAR 0 3
71868: PPUSH
71869: LD_EXP 71
71873: PUSH
71874: LD_VAR 0 3
71878: ARRAY
71879: PUSH
71880: LD_VAR 0 1
71884: DIFF
71885: PPUSH
71886: CALL_OW 1
71890: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
71891: LD_VAR 0 1
71895: PUSH
71896: LD_EXP 74
71900: PUSH
71901: LD_VAR 0 3
71905: ARRAY
71906: IN
71907: IFFALSE 71946
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
71909: LD_ADDR_EXP 74
71913: PUSH
71914: LD_EXP 74
71918: PPUSH
71919: LD_VAR 0 3
71923: PPUSH
71924: LD_EXP 74
71928: PUSH
71929: LD_VAR 0 3
71933: ARRAY
71934: PUSH
71935: LD_VAR 0 1
71939: DIFF
71940: PPUSH
71941: CALL_OW 1
71945: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
71946: LD_VAR 0 1
71950: PUSH
71951: LD_EXP 61
71955: PUSH
71956: LD_VAR 0 3
71960: ARRAY
71961: IN
71962: IFFALSE 72001
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
71964: LD_ADDR_EXP 61
71968: PUSH
71969: LD_EXP 61
71973: PPUSH
71974: LD_VAR 0 3
71978: PPUSH
71979: LD_EXP 61
71983: PUSH
71984: LD_VAR 0 3
71988: ARRAY
71989: PUSH
71990: LD_VAR 0 1
71994: DIFF
71995: PPUSH
71996: CALL_OW 1
72000: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
72001: LD_VAR 0 1
72005: PUSH
72006: LD_EXP 60
72010: PUSH
72011: LD_VAR 0 3
72015: ARRAY
72016: IN
72017: IFFALSE 72056
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
72019: LD_ADDR_EXP 60
72023: PUSH
72024: LD_EXP 60
72028: PPUSH
72029: LD_VAR 0 3
72033: PPUSH
72034: LD_EXP 60
72038: PUSH
72039: LD_VAR 0 3
72043: ARRAY
72044: PUSH
72045: LD_VAR 0 1
72049: DIFF
72050: PPUSH
72051: CALL_OW 1
72055: ST_TO_ADDR
// end ; break ;
72056: GO 72060
// end ;
72058: GO 70706
72060: POP
72061: POP
// end ;
72062: LD_VAR 0 2
72066: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
72067: LD_INT 0
72069: PPUSH
72070: PPUSH
72071: PPUSH
// if not mc_bases or not skirmish then
72072: LD_EXP 52
72076: NOT
72077: PUSH
72078: LD_EXP 50
72082: NOT
72083: OR
72084: IFFALSE 72088
// exit ;
72086: GO 72303
// for i = 1 to mc_bases do
72088: LD_ADDR_VAR 0 3
72092: PUSH
72093: DOUBLE
72094: LD_INT 1
72096: DEC
72097: ST_TO_ADDR
72098: LD_EXP 52
72102: PUSH
72103: FOR_TO
72104: IFFALSE 72301
// begin if building in mc_construct_list [ i ] then
72106: LD_VAR 0 1
72110: PUSH
72111: LD_EXP 59
72115: PUSH
72116: LD_VAR 0 3
72120: ARRAY
72121: IN
72122: IFFALSE 72299
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
72124: LD_ADDR_EXP 59
72128: PUSH
72129: LD_EXP 59
72133: PPUSH
72134: LD_VAR 0 3
72138: PPUSH
72139: LD_EXP 59
72143: PUSH
72144: LD_VAR 0 3
72148: ARRAY
72149: PUSH
72150: LD_VAR 0 1
72154: DIFF
72155: PPUSH
72156: CALL_OW 1
72160: ST_TO_ADDR
// if building in mc_lab [ i ] then
72161: LD_VAR 0 1
72165: PUSH
72166: LD_EXP 85
72170: PUSH
72171: LD_VAR 0 3
72175: ARRAY
72176: IN
72177: IFFALSE 72232
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
72179: LD_ADDR_EXP 86
72183: PUSH
72184: LD_EXP 86
72188: PPUSH
72189: LD_VAR 0 3
72193: PPUSH
72194: LD_EXP 86
72198: PUSH
72199: LD_VAR 0 3
72203: ARRAY
72204: PPUSH
72205: LD_INT 1
72207: PPUSH
72208: LD_EXP 86
72212: PUSH
72213: LD_VAR 0 3
72217: ARRAY
72218: PPUSH
72219: LD_INT 0
72221: PPUSH
72222: CALL 36900 0 4
72226: PPUSH
72227: CALL_OW 1
72231: ST_TO_ADDR
// if not building in mc_bases [ i ] then
72232: LD_VAR 0 1
72236: PUSH
72237: LD_EXP 52
72241: PUSH
72242: LD_VAR 0 3
72246: ARRAY
72247: IN
72248: NOT
72249: IFFALSE 72295
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
72251: LD_ADDR_EXP 52
72255: PUSH
72256: LD_EXP 52
72260: PPUSH
72261: LD_VAR 0 3
72265: PUSH
72266: LD_EXP 52
72270: PUSH
72271: LD_VAR 0 3
72275: ARRAY
72276: PUSH
72277: LD_INT 1
72279: PLUS
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PPUSH
72285: LD_VAR 0 1
72289: PPUSH
72290: CALL 37482 0 3
72294: ST_TO_ADDR
// exit ;
72295: POP
72296: POP
72297: GO 72303
// end ; end ;
72299: GO 72103
72301: POP
72302: POP
// end ;
72303: LD_VAR 0 2
72307: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
72308: LD_INT 0
72310: PPUSH
72311: PPUSH
72312: PPUSH
72313: PPUSH
72314: PPUSH
72315: PPUSH
72316: PPUSH
// if not mc_bases or not skirmish then
72317: LD_EXP 52
72321: NOT
72322: PUSH
72323: LD_EXP 50
72327: NOT
72328: OR
72329: IFFALSE 72333
// exit ;
72331: GO 72994
// for i = 1 to mc_bases do
72333: LD_ADDR_VAR 0 3
72337: PUSH
72338: DOUBLE
72339: LD_INT 1
72341: DEC
72342: ST_TO_ADDR
72343: LD_EXP 52
72347: PUSH
72348: FOR_TO
72349: IFFALSE 72992
// begin if building in mc_construct_list [ i ] then
72351: LD_VAR 0 1
72355: PUSH
72356: LD_EXP 59
72360: PUSH
72361: LD_VAR 0 3
72365: ARRAY
72366: IN
72367: IFFALSE 72990
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
72369: LD_ADDR_EXP 59
72373: PUSH
72374: LD_EXP 59
72378: PPUSH
72379: LD_VAR 0 3
72383: PPUSH
72384: LD_EXP 59
72388: PUSH
72389: LD_VAR 0 3
72393: ARRAY
72394: PUSH
72395: LD_VAR 0 1
72399: DIFF
72400: PPUSH
72401: CALL_OW 1
72405: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
72406: LD_ADDR_EXP 52
72410: PUSH
72411: LD_EXP 52
72415: PPUSH
72416: LD_VAR 0 3
72420: PUSH
72421: LD_EXP 52
72425: PUSH
72426: LD_VAR 0 3
72430: ARRAY
72431: PUSH
72432: LD_INT 1
72434: PLUS
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PPUSH
72440: LD_VAR 0 1
72444: PPUSH
72445: CALL 37482 0 3
72449: ST_TO_ADDR
// btype := GetBType ( building ) ;
72450: LD_ADDR_VAR 0 5
72454: PUSH
72455: LD_VAR 0 1
72459: PPUSH
72460: CALL_OW 266
72464: ST_TO_ADDR
// side := GetSide ( building ) ;
72465: LD_ADDR_VAR 0 8
72469: PUSH
72470: LD_VAR 0 1
72474: PPUSH
72475: CALL_OW 255
72479: ST_TO_ADDR
// if btype = b_lab then
72480: LD_VAR 0 5
72484: PUSH
72485: LD_INT 6
72487: EQUAL
72488: IFFALSE 72538
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
72490: LD_ADDR_EXP 85
72494: PUSH
72495: LD_EXP 85
72499: PPUSH
72500: LD_VAR 0 3
72504: PUSH
72505: LD_EXP 85
72509: PUSH
72510: LD_VAR 0 3
72514: ARRAY
72515: PUSH
72516: LD_INT 1
72518: PLUS
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PPUSH
72524: LD_VAR 0 1
72528: PPUSH
72529: CALL 37482 0 3
72533: ST_TO_ADDR
// exit ;
72534: POP
72535: POP
72536: GO 72994
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
72538: LD_VAR 0 5
72542: PUSH
72543: LD_INT 0
72545: PUSH
72546: LD_INT 2
72548: PUSH
72549: LD_INT 4
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: LIST
72556: IN
72557: IFFALSE 72681
// begin if btype = b_armoury then
72559: LD_VAR 0 5
72563: PUSH
72564: LD_INT 4
72566: EQUAL
72567: IFFALSE 72577
// btype := b_barracks ;
72569: LD_ADDR_VAR 0 5
72573: PUSH
72574: LD_INT 5
72576: ST_TO_ADDR
// if btype = b_depot then
72577: LD_VAR 0 5
72581: PUSH
72582: LD_INT 0
72584: EQUAL
72585: IFFALSE 72595
// btype := b_warehouse ;
72587: LD_ADDR_VAR 0 5
72591: PUSH
72592: LD_INT 1
72594: ST_TO_ADDR
// if btype = b_workshop then
72595: LD_VAR 0 5
72599: PUSH
72600: LD_INT 2
72602: EQUAL
72603: IFFALSE 72613
// btype := b_factory ;
72605: LD_ADDR_VAR 0 5
72609: PUSH
72610: LD_INT 3
72612: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
72613: LD_VAR 0 5
72617: PPUSH
72618: LD_VAR 0 8
72622: PPUSH
72623: CALL_OW 323
72627: PUSH
72628: LD_INT 1
72630: EQUAL
72631: IFFALSE 72677
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
72633: LD_ADDR_EXP 84
72637: PUSH
72638: LD_EXP 84
72642: PPUSH
72643: LD_VAR 0 3
72647: PUSH
72648: LD_EXP 84
72652: PUSH
72653: LD_VAR 0 3
72657: ARRAY
72658: PUSH
72659: LD_INT 1
72661: PLUS
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PPUSH
72667: LD_VAR 0 1
72671: PPUSH
72672: CALL 37482 0 3
72676: ST_TO_ADDR
// exit ;
72677: POP
72678: POP
72679: GO 72994
// end ; if btype in [ b_bunker , b_turret ] then
72681: LD_VAR 0 5
72685: PUSH
72686: LD_INT 32
72688: PUSH
72689: LD_INT 33
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: IN
72696: IFFALSE 72986
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
72698: LD_ADDR_EXP 60
72702: PUSH
72703: LD_EXP 60
72707: PPUSH
72708: LD_VAR 0 3
72712: PUSH
72713: LD_EXP 60
72717: PUSH
72718: LD_VAR 0 3
72722: ARRAY
72723: PUSH
72724: LD_INT 1
72726: PLUS
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PPUSH
72732: LD_VAR 0 1
72736: PPUSH
72737: CALL 37482 0 3
72741: ST_TO_ADDR
// if btype = b_bunker then
72742: LD_VAR 0 5
72746: PUSH
72747: LD_INT 32
72749: EQUAL
72750: IFFALSE 72986
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
72752: LD_ADDR_EXP 61
72756: PUSH
72757: LD_EXP 61
72761: PPUSH
72762: LD_VAR 0 3
72766: PUSH
72767: LD_EXP 61
72771: PUSH
72772: LD_VAR 0 3
72776: ARRAY
72777: PUSH
72778: LD_INT 1
72780: PLUS
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PPUSH
72786: LD_VAR 0 1
72790: PPUSH
72791: CALL 37482 0 3
72795: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
72796: LD_ADDR_VAR 0 6
72800: PUSH
72801: LD_EXP 52
72805: PUSH
72806: LD_VAR 0 3
72810: ARRAY
72811: PPUSH
72812: LD_INT 25
72814: PUSH
72815: LD_INT 1
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 3
72824: PUSH
72825: LD_INT 54
72827: PUSH
72828: EMPTY
72829: LIST
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PPUSH
72839: CALL_OW 72
72843: ST_TO_ADDR
// if tmp then
72844: LD_VAR 0 6
72848: IFFALSE 72854
// exit ;
72850: POP
72851: POP
72852: GO 72994
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72854: LD_ADDR_VAR 0 6
72858: PUSH
72859: LD_EXP 52
72863: PUSH
72864: LD_VAR 0 3
72868: ARRAY
72869: PPUSH
72870: LD_INT 2
72872: PUSH
72873: LD_INT 30
72875: PUSH
72876: LD_INT 4
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PUSH
72883: LD_INT 30
72885: PUSH
72886: LD_INT 5
72888: PUSH
72889: EMPTY
72890: LIST
72891: LIST
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: LIST
72897: PPUSH
72898: CALL_OW 72
72902: ST_TO_ADDR
// if not tmp then
72903: LD_VAR 0 6
72907: NOT
72908: IFFALSE 72914
// exit ;
72910: POP
72911: POP
72912: GO 72994
// for j in tmp do
72914: LD_ADDR_VAR 0 4
72918: PUSH
72919: LD_VAR 0 6
72923: PUSH
72924: FOR_IN
72925: IFFALSE 72984
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
72927: LD_ADDR_VAR 0 7
72931: PUSH
72932: LD_VAR 0 4
72936: PPUSH
72937: CALL_OW 313
72941: PPUSH
72942: LD_INT 25
72944: PUSH
72945: LD_INT 1
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PPUSH
72952: CALL_OW 72
72956: ST_TO_ADDR
// if units then
72957: LD_VAR 0 7
72961: IFFALSE 72982
// begin ComExitBuilding ( units [ 1 ] ) ;
72963: LD_VAR 0 7
72967: PUSH
72968: LD_INT 1
72970: ARRAY
72971: PPUSH
72972: CALL_OW 122
// exit ;
72976: POP
72977: POP
72978: POP
72979: POP
72980: GO 72994
// end ; end ;
72982: GO 72924
72984: POP
72985: POP
// end ; end ; exit ;
72986: POP
72987: POP
72988: GO 72994
// end ; end ;
72990: GO 72348
72992: POP
72993: POP
// end ;
72994: LD_VAR 0 2
72998: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
72999: LD_INT 0
73001: PPUSH
73002: PPUSH
73003: PPUSH
73004: PPUSH
73005: PPUSH
73006: PPUSH
73007: PPUSH
// if not mc_bases or not skirmish then
73008: LD_EXP 52
73012: NOT
73013: PUSH
73014: LD_EXP 50
73018: NOT
73019: OR
73020: IFFALSE 73024
// exit ;
73022: GO 73255
// btype := GetBType ( building ) ;
73024: LD_ADDR_VAR 0 6
73028: PUSH
73029: LD_VAR 0 1
73033: PPUSH
73034: CALL_OW 266
73038: ST_TO_ADDR
// x := GetX ( building ) ;
73039: LD_ADDR_VAR 0 7
73043: PUSH
73044: LD_VAR 0 1
73048: PPUSH
73049: CALL_OW 250
73053: ST_TO_ADDR
// y := GetY ( building ) ;
73054: LD_ADDR_VAR 0 8
73058: PUSH
73059: LD_VAR 0 1
73063: PPUSH
73064: CALL_OW 251
73068: ST_TO_ADDR
// d := GetDir ( building ) ;
73069: LD_ADDR_VAR 0 9
73073: PUSH
73074: LD_VAR 0 1
73078: PPUSH
73079: CALL_OW 254
73083: ST_TO_ADDR
// for i = 1 to mc_bases do
73084: LD_ADDR_VAR 0 4
73088: PUSH
73089: DOUBLE
73090: LD_INT 1
73092: DEC
73093: ST_TO_ADDR
73094: LD_EXP 52
73098: PUSH
73099: FOR_TO
73100: IFFALSE 73253
// begin if not mc_build_list [ i ] then
73102: LD_EXP 57
73106: PUSH
73107: LD_VAR 0 4
73111: ARRAY
73112: NOT
73113: IFFALSE 73117
// continue ;
73115: GO 73099
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
73117: LD_VAR 0 6
73121: PUSH
73122: LD_VAR 0 7
73126: PUSH
73127: LD_VAR 0 8
73131: PUSH
73132: LD_VAR 0 9
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: LIST
73141: LIST
73142: PPUSH
73143: LD_EXP 57
73147: PUSH
73148: LD_VAR 0 4
73152: ARRAY
73153: PUSH
73154: LD_INT 1
73156: ARRAY
73157: PPUSH
73158: CALL 43651 0 2
73162: IFFALSE 73251
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
73164: LD_ADDR_EXP 57
73168: PUSH
73169: LD_EXP 57
73173: PPUSH
73174: LD_VAR 0 4
73178: PPUSH
73179: LD_EXP 57
73183: PUSH
73184: LD_VAR 0 4
73188: ARRAY
73189: PPUSH
73190: LD_INT 1
73192: PPUSH
73193: CALL_OW 3
73197: PPUSH
73198: CALL_OW 1
73202: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
73203: LD_ADDR_EXP 59
73207: PUSH
73208: LD_EXP 59
73212: PPUSH
73213: LD_VAR 0 4
73217: PUSH
73218: LD_EXP 59
73222: PUSH
73223: LD_VAR 0 4
73227: ARRAY
73228: PUSH
73229: LD_INT 1
73231: PLUS
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PPUSH
73237: LD_VAR 0 1
73241: PPUSH
73242: CALL 37482 0 3
73246: ST_TO_ADDR
// exit ;
73247: POP
73248: POP
73249: GO 73255
// end ; end ;
73251: GO 73099
73253: POP
73254: POP
// end ;
73255: LD_VAR 0 3
73259: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
73260: LD_INT 0
73262: PPUSH
73263: PPUSH
73264: PPUSH
// if not mc_bases or not skirmish then
73265: LD_EXP 52
73269: NOT
73270: PUSH
73271: LD_EXP 50
73275: NOT
73276: OR
73277: IFFALSE 73281
// exit ;
73279: GO 73471
// for i = 1 to mc_bases do
73281: LD_ADDR_VAR 0 4
73285: PUSH
73286: DOUBLE
73287: LD_INT 1
73289: DEC
73290: ST_TO_ADDR
73291: LD_EXP 52
73295: PUSH
73296: FOR_TO
73297: IFFALSE 73384
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
73299: LD_VAR 0 1
73303: PUSH
73304: LD_EXP 60
73308: PUSH
73309: LD_VAR 0 4
73313: ARRAY
73314: IN
73315: PUSH
73316: LD_VAR 0 1
73320: PUSH
73321: LD_EXP 61
73325: PUSH
73326: LD_VAR 0 4
73330: ARRAY
73331: IN
73332: NOT
73333: AND
73334: IFFALSE 73382
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
73336: LD_ADDR_EXP 61
73340: PUSH
73341: LD_EXP 61
73345: PPUSH
73346: LD_VAR 0 4
73350: PUSH
73351: LD_EXP 61
73355: PUSH
73356: LD_VAR 0 4
73360: ARRAY
73361: PUSH
73362: LD_INT 1
73364: PLUS
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PPUSH
73370: LD_VAR 0 1
73374: PPUSH
73375: CALL 37482 0 3
73379: ST_TO_ADDR
// break ;
73380: GO 73384
// end ; end ;
73382: GO 73296
73384: POP
73385: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
73386: LD_VAR 0 1
73390: PPUSH
73391: CALL_OW 257
73395: PUSH
73396: LD_EXP 78
73400: IN
73401: PUSH
73402: LD_VAR 0 1
73406: PPUSH
73407: CALL_OW 266
73411: PUSH
73412: LD_INT 5
73414: EQUAL
73415: AND
73416: PUSH
73417: LD_VAR 0 2
73421: PPUSH
73422: CALL_OW 110
73426: PUSH
73427: LD_INT 18
73429: NONEQUAL
73430: AND
73431: IFFALSE 73471
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
73433: LD_VAR 0 2
73437: PPUSH
73438: CALL_OW 257
73442: PUSH
73443: LD_INT 5
73445: PUSH
73446: LD_INT 8
73448: PUSH
73449: LD_INT 9
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: LIST
73456: IN
73457: IFFALSE 73471
// SetClass ( unit , 1 ) ;
73459: LD_VAR 0 2
73463: PPUSH
73464: LD_INT 1
73466: PPUSH
73467: CALL_OW 336
// end ;
73471: LD_VAR 0 3
73475: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
73476: LD_INT 0
73478: PPUSH
73479: PPUSH
// if not mc_bases or not skirmish then
73480: LD_EXP 52
73484: NOT
73485: PUSH
73486: LD_EXP 50
73490: NOT
73491: OR
73492: IFFALSE 73496
// exit ;
73494: GO 73612
// if GetLives ( abandoned_vehicle ) > 250 then
73496: LD_VAR 0 2
73500: PPUSH
73501: CALL_OW 256
73505: PUSH
73506: LD_INT 250
73508: GREATER
73509: IFFALSE 73513
// exit ;
73511: GO 73612
// for i = 1 to mc_bases do
73513: LD_ADDR_VAR 0 6
73517: PUSH
73518: DOUBLE
73519: LD_INT 1
73521: DEC
73522: ST_TO_ADDR
73523: LD_EXP 52
73527: PUSH
73528: FOR_TO
73529: IFFALSE 73610
// begin if driver in mc_bases [ i ] then
73531: LD_VAR 0 1
73535: PUSH
73536: LD_EXP 52
73540: PUSH
73541: LD_VAR 0 6
73545: ARRAY
73546: IN
73547: IFFALSE 73608
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
73549: LD_VAR 0 1
73553: PPUSH
73554: LD_EXP 52
73558: PUSH
73559: LD_VAR 0 6
73563: ARRAY
73564: PPUSH
73565: LD_INT 2
73567: PUSH
73568: LD_INT 30
73570: PUSH
73571: LD_INT 0
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 30
73580: PUSH
73581: LD_INT 1
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: LIST
73592: PPUSH
73593: CALL_OW 72
73597: PUSH
73598: LD_INT 1
73600: ARRAY
73601: PPUSH
73602: CALL_OW 112
// break ;
73606: GO 73610
// end ; end ;
73608: GO 73528
73610: POP
73611: POP
// end ; end_of_file
73612: LD_VAR 0 5
73616: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
73617: LD_INT 0
73619: PPUSH
73620: PPUSH
73621: PPUSH
73622: PPUSH
73623: PPUSH
73624: PPUSH
73625: PPUSH
73626: PPUSH
73627: PPUSH
73628: PPUSH
73629: PPUSH
73630: PPUSH
73631: PPUSH
73632: PPUSH
73633: PPUSH
73634: PPUSH
73635: PPUSH
73636: PPUSH
73637: PPUSH
73638: PPUSH
73639: PPUSH
73640: PPUSH
73641: PPUSH
73642: PPUSH
73643: PPUSH
73644: PPUSH
73645: PPUSH
73646: PPUSH
73647: PPUSH
73648: PPUSH
73649: PPUSH
73650: PPUSH
73651: PPUSH
73652: PPUSH
// if not list then
73653: LD_VAR 0 1
73657: NOT
73658: IFFALSE 73662
// exit ;
73660: GO 78321
// base := list [ 1 ] ;
73662: LD_ADDR_VAR 0 3
73666: PUSH
73667: LD_VAR 0 1
73671: PUSH
73672: LD_INT 1
73674: ARRAY
73675: ST_TO_ADDR
// group := list [ 2 ] ;
73676: LD_ADDR_VAR 0 4
73680: PUSH
73681: LD_VAR 0 1
73685: PUSH
73686: LD_INT 2
73688: ARRAY
73689: ST_TO_ADDR
// path := list [ 3 ] ;
73690: LD_ADDR_VAR 0 5
73694: PUSH
73695: LD_VAR 0 1
73699: PUSH
73700: LD_INT 3
73702: ARRAY
73703: ST_TO_ADDR
// flags := list [ 4 ] ;
73704: LD_ADDR_VAR 0 6
73708: PUSH
73709: LD_VAR 0 1
73713: PUSH
73714: LD_INT 4
73716: ARRAY
73717: ST_TO_ADDR
// mined := [ ] ;
73718: LD_ADDR_VAR 0 27
73722: PUSH
73723: EMPTY
73724: ST_TO_ADDR
// bombed := [ ] ;
73725: LD_ADDR_VAR 0 28
73729: PUSH
73730: EMPTY
73731: ST_TO_ADDR
// healers := [ ] ;
73732: LD_ADDR_VAR 0 31
73736: PUSH
73737: EMPTY
73738: ST_TO_ADDR
// to_heal := [ ] ;
73739: LD_ADDR_VAR 0 30
73743: PUSH
73744: EMPTY
73745: ST_TO_ADDR
// repairs := [ ] ;
73746: LD_ADDR_VAR 0 33
73750: PUSH
73751: EMPTY
73752: ST_TO_ADDR
// to_repair := [ ] ;
73753: LD_ADDR_VAR 0 32
73757: PUSH
73758: EMPTY
73759: ST_TO_ADDR
// if not group or not path then
73760: LD_VAR 0 4
73764: NOT
73765: PUSH
73766: LD_VAR 0 5
73770: NOT
73771: OR
73772: IFFALSE 73776
// exit ;
73774: GO 78321
// side := GetSide ( group [ 1 ] ) ;
73776: LD_ADDR_VAR 0 35
73780: PUSH
73781: LD_VAR 0 4
73785: PUSH
73786: LD_INT 1
73788: ARRAY
73789: PPUSH
73790: CALL_OW 255
73794: ST_TO_ADDR
// if flags then
73795: LD_VAR 0 6
73799: IFFALSE 73943
// begin f_ignore_area := flags [ 1 ] ;
73801: LD_ADDR_VAR 0 17
73805: PUSH
73806: LD_VAR 0 6
73810: PUSH
73811: LD_INT 1
73813: ARRAY
73814: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
73815: LD_ADDR_VAR 0 18
73819: PUSH
73820: LD_VAR 0 6
73824: PUSH
73825: LD_INT 2
73827: ARRAY
73828: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
73829: LD_ADDR_VAR 0 19
73833: PUSH
73834: LD_VAR 0 6
73838: PUSH
73839: LD_INT 3
73841: ARRAY
73842: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
73843: LD_ADDR_VAR 0 20
73847: PUSH
73848: LD_VAR 0 6
73852: PUSH
73853: LD_INT 4
73855: ARRAY
73856: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
73857: LD_ADDR_VAR 0 21
73861: PUSH
73862: LD_VAR 0 6
73866: PUSH
73867: LD_INT 5
73869: ARRAY
73870: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
73871: LD_ADDR_VAR 0 22
73875: PUSH
73876: LD_VAR 0 6
73880: PUSH
73881: LD_INT 6
73883: ARRAY
73884: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
73885: LD_ADDR_VAR 0 23
73889: PUSH
73890: LD_VAR 0 6
73894: PUSH
73895: LD_INT 7
73897: ARRAY
73898: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
73899: LD_ADDR_VAR 0 24
73903: PUSH
73904: LD_VAR 0 6
73908: PUSH
73909: LD_INT 8
73911: ARRAY
73912: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
73913: LD_ADDR_VAR 0 25
73917: PUSH
73918: LD_VAR 0 6
73922: PUSH
73923: LD_INT 9
73925: ARRAY
73926: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
73927: LD_ADDR_VAR 0 26
73931: PUSH
73932: LD_VAR 0 6
73936: PUSH
73937: LD_INT 10
73939: ARRAY
73940: ST_TO_ADDR
// end else
73941: GO 74023
// begin f_ignore_area := false ;
73943: LD_ADDR_VAR 0 17
73947: PUSH
73948: LD_INT 0
73950: ST_TO_ADDR
// f_capture := false ;
73951: LD_ADDR_VAR 0 18
73955: PUSH
73956: LD_INT 0
73958: ST_TO_ADDR
// f_ignore_civ := false ;
73959: LD_ADDR_VAR 0 19
73963: PUSH
73964: LD_INT 0
73966: ST_TO_ADDR
// f_murder := false ;
73967: LD_ADDR_VAR 0 20
73971: PUSH
73972: LD_INT 0
73974: ST_TO_ADDR
// f_mines := false ;
73975: LD_ADDR_VAR 0 21
73979: PUSH
73980: LD_INT 0
73982: ST_TO_ADDR
// f_repair := false ;
73983: LD_ADDR_VAR 0 22
73987: PUSH
73988: LD_INT 0
73990: ST_TO_ADDR
// f_heal := false ;
73991: LD_ADDR_VAR 0 23
73995: PUSH
73996: LD_INT 0
73998: ST_TO_ADDR
// f_spacetime := false ;
73999: LD_ADDR_VAR 0 24
74003: PUSH
74004: LD_INT 0
74006: ST_TO_ADDR
// f_attack_depot := false ;
74007: LD_ADDR_VAR 0 25
74011: PUSH
74012: LD_INT 0
74014: ST_TO_ADDR
// f_crawl := false ;
74015: LD_ADDR_VAR 0 26
74019: PUSH
74020: LD_INT 0
74022: ST_TO_ADDR
// end ; if f_heal then
74023: LD_VAR 0 23
74027: IFFALSE 74054
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
74029: LD_ADDR_VAR 0 31
74033: PUSH
74034: LD_VAR 0 4
74038: PPUSH
74039: LD_INT 25
74041: PUSH
74042: LD_INT 4
74044: PUSH
74045: EMPTY
74046: LIST
74047: LIST
74048: PPUSH
74049: CALL_OW 72
74053: ST_TO_ADDR
// if f_repair then
74054: LD_VAR 0 22
74058: IFFALSE 74085
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
74060: LD_ADDR_VAR 0 33
74064: PUSH
74065: LD_VAR 0 4
74069: PPUSH
74070: LD_INT 25
74072: PUSH
74073: LD_INT 3
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PPUSH
74080: CALL_OW 72
74084: ST_TO_ADDR
// units_path := [ ] ;
74085: LD_ADDR_VAR 0 16
74089: PUSH
74090: EMPTY
74091: ST_TO_ADDR
// for i = 1 to group do
74092: LD_ADDR_VAR 0 7
74096: PUSH
74097: DOUBLE
74098: LD_INT 1
74100: DEC
74101: ST_TO_ADDR
74102: LD_VAR 0 4
74106: PUSH
74107: FOR_TO
74108: IFFALSE 74137
// units_path := Replace ( units_path , i , path ) ;
74110: LD_ADDR_VAR 0 16
74114: PUSH
74115: LD_VAR 0 16
74119: PPUSH
74120: LD_VAR 0 7
74124: PPUSH
74125: LD_VAR 0 5
74129: PPUSH
74130: CALL_OW 1
74134: ST_TO_ADDR
74135: GO 74107
74137: POP
74138: POP
// repeat for i = group downto 1 do
74139: LD_ADDR_VAR 0 7
74143: PUSH
74144: DOUBLE
74145: LD_VAR 0 4
74149: INC
74150: ST_TO_ADDR
74151: LD_INT 1
74153: PUSH
74154: FOR_DOWNTO
74155: IFFALSE 78277
// begin wait ( 5 ) ;
74157: LD_INT 5
74159: PPUSH
74160: CALL_OW 67
// tmp := [ ] ;
74164: LD_ADDR_VAR 0 14
74168: PUSH
74169: EMPTY
74170: ST_TO_ADDR
// attacking := false ;
74171: LD_ADDR_VAR 0 29
74175: PUSH
74176: LD_INT 0
74178: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
74179: LD_VAR 0 4
74183: PUSH
74184: LD_VAR 0 7
74188: ARRAY
74189: PPUSH
74190: CALL_OW 301
74194: PUSH
74195: LD_VAR 0 4
74199: PUSH
74200: LD_VAR 0 7
74204: ARRAY
74205: NOT
74206: OR
74207: IFFALSE 74316
// begin if GetType ( group [ i ] ) = unit_human then
74209: LD_VAR 0 4
74213: PUSH
74214: LD_VAR 0 7
74218: ARRAY
74219: PPUSH
74220: CALL_OW 247
74224: PUSH
74225: LD_INT 1
74227: EQUAL
74228: IFFALSE 74274
// begin to_heal := to_heal diff group [ i ] ;
74230: LD_ADDR_VAR 0 30
74234: PUSH
74235: LD_VAR 0 30
74239: PUSH
74240: LD_VAR 0 4
74244: PUSH
74245: LD_VAR 0 7
74249: ARRAY
74250: DIFF
74251: ST_TO_ADDR
// healers := healers diff group [ i ] ;
74252: LD_ADDR_VAR 0 31
74256: PUSH
74257: LD_VAR 0 31
74261: PUSH
74262: LD_VAR 0 4
74266: PUSH
74267: LD_VAR 0 7
74271: ARRAY
74272: DIFF
74273: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
74274: LD_ADDR_VAR 0 4
74278: PUSH
74279: LD_VAR 0 4
74283: PPUSH
74284: LD_VAR 0 7
74288: PPUSH
74289: CALL_OW 3
74293: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
74294: LD_ADDR_VAR 0 16
74298: PUSH
74299: LD_VAR 0 16
74303: PPUSH
74304: LD_VAR 0 7
74308: PPUSH
74309: CALL_OW 3
74313: ST_TO_ADDR
// continue ;
74314: GO 74154
// end ; if f_repair then
74316: LD_VAR 0 22
74320: IFFALSE 74809
// begin if GetType ( group [ i ] ) = unit_vehicle then
74322: LD_VAR 0 4
74326: PUSH
74327: LD_VAR 0 7
74331: ARRAY
74332: PPUSH
74333: CALL_OW 247
74337: PUSH
74338: LD_INT 2
74340: EQUAL
74341: IFFALSE 74531
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
74343: LD_VAR 0 4
74347: PUSH
74348: LD_VAR 0 7
74352: ARRAY
74353: PPUSH
74354: CALL_OW 256
74358: PUSH
74359: LD_INT 700
74361: LESS
74362: PUSH
74363: LD_VAR 0 4
74367: PUSH
74368: LD_VAR 0 7
74372: ARRAY
74373: PUSH
74374: LD_VAR 0 32
74378: IN
74379: NOT
74380: AND
74381: IFFALSE 74405
// to_repair := to_repair union group [ i ] ;
74383: LD_ADDR_VAR 0 32
74387: PUSH
74388: LD_VAR 0 32
74392: PUSH
74393: LD_VAR 0 4
74397: PUSH
74398: LD_VAR 0 7
74402: ARRAY
74403: UNION
74404: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
74405: LD_VAR 0 4
74409: PUSH
74410: LD_VAR 0 7
74414: ARRAY
74415: PPUSH
74416: CALL_OW 256
74420: PUSH
74421: LD_INT 1000
74423: EQUAL
74424: PUSH
74425: LD_VAR 0 4
74429: PUSH
74430: LD_VAR 0 7
74434: ARRAY
74435: PUSH
74436: LD_VAR 0 32
74440: IN
74441: AND
74442: IFFALSE 74466
// to_repair := to_repair diff group [ i ] ;
74444: LD_ADDR_VAR 0 32
74448: PUSH
74449: LD_VAR 0 32
74453: PUSH
74454: LD_VAR 0 4
74458: PUSH
74459: LD_VAR 0 7
74463: ARRAY
74464: DIFF
74465: ST_TO_ADDR
// if group [ i ] in to_repair then
74466: LD_VAR 0 4
74470: PUSH
74471: LD_VAR 0 7
74475: ARRAY
74476: PUSH
74477: LD_VAR 0 32
74481: IN
74482: IFFALSE 74529
// begin if not IsInArea ( group [ i ] , f_repair ) then
74484: LD_VAR 0 4
74488: PUSH
74489: LD_VAR 0 7
74493: ARRAY
74494: PPUSH
74495: LD_VAR 0 22
74499: PPUSH
74500: CALL_OW 308
74504: NOT
74505: IFFALSE 74527
// ComMoveToArea ( group [ i ] , f_repair ) ;
74507: LD_VAR 0 4
74511: PUSH
74512: LD_VAR 0 7
74516: ARRAY
74517: PPUSH
74518: LD_VAR 0 22
74522: PPUSH
74523: CALL_OW 113
// continue ;
74527: GO 74154
// end ; end else
74529: GO 74809
// if group [ i ] in repairs then
74531: LD_VAR 0 4
74535: PUSH
74536: LD_VAR 0 7
74540: ARRAY
74541: PUSH
74542: LD_VAR 0 33
74546: IN
74547: IFFALSE 74809
// begin if IsInUnit ( group [ i ] ) then
74549: LD_VAR 0 4
74553: PUSH
74554: LD_VAR 0 7
74558: ARRAY
74559: PPUSH
74560: CALL_OW 310
74564: IFFALSE 74632
// begin z := IsInUnit ( group [ i ] ) ;
74566: LD_ADDR_VAR 0 13
74570: PUSH
74571: LD_VAR 0 4
74575: PUSH
74576: LD_VAR 0 7
74580: ARRAY
74581: PPUSH
74582: CALL_OW 310
74586: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
74587: LD_VAR 0 13
74591: PUSH
74592: LD_VAR 0 32
74596: IN
74597: PUSH
74598: LD_VAR 0 13
74602: PPUSH
74603: LD_VAR 0 22
74607: PPUSH
74608: CALL_OW 308
74612: AND
74613: IFFALSE 74630
// ComExitVehicle ( group [ i ] ) ;
74615: LD_VAR 0 4
74619: PUSH
74620: LD_VAR 0 7
74624: ARRAY
74625: PPUSH
74626: CALL_OW 121
// end else
74630: GO 74809
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
74632: LD_ADDR_VAR 0 13
74636: PUSH
74637: LD_VAR 0 4
74641: PPUSH
74642: LD_INT 95
74644: PUSH
74645: LD_VAR 0 22
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 58
74656: PUSH
74657: EMPTY
74658: LIST
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PPUSH
74664: CALL_OW 72
74668: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
74669: LD_VAR 0 4
74673: PUSH
74674: LD_VAR 0 7
74678: ARRAY
74679: PPUSH
74680: CALL_OW 314
74684: NOT
74685: IFFALSE 74807
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
74687: LD_ADDR_VAR 0 10
74691: PUSH
74692: LD_VAR 0 13
74696: PPUSH
74697: LD_VAR 0 4
74701: PUSH
74702: LD_VAR 0 7
74706: ARRAY
74707: PPUSH
74708: CALL_OW 74
74712: ST_TO_ADDR
// if not x then
74713: LD_VAR 0 10
74717: NOT
74718: IFFALSE 74722
// continue ;
74720: GO 74154
// if GetLives ( x ) < 1000 then
74722: LD_VAR 0 10
74726: PPUSH
74727: CALL_OW 256
74731: PUSH
74732: LD_INT 1000
74734: LESS
74735: IFFALSE 74759
// ComRepairVehicle ( group [ i ] , x ) else
74737: LD_VAR 0 4
74741: PUSH
74742: LD_VAR 0 7
74746: ARRAY
74747: PPUSH
74748: LD_VAR 0 10
74752: PPUSH
74753: CALL_OW 129
74757: GO 74807
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
74759: LD_VAR 0 23
74763: PUSH
74764: LD_VAR 0 4
74768: PUSH
74769: LD_VAR 0 7
74773: ARRAY
74774: PPUSH
74775: CALL_OW 256
74779: PUSH
74780: LD_INT 1000
74782: LESS
74783: AND
74784: NOT
74785: IFFALSE 74807
// ComEnterUnit ( group [ i ] , x ) ;
74787: LD_VAR 0 4
74791: PUSH
74792: LD_VAR 0 7
74796: ARRAY
74797: PPUSH
74798: LD_VAR 0 10
74802: PPUSH
74803: CALL_OW 120
// end ; continue ;
74807: GO 74154
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
74809: LD_VAR 0 23
74813: PUSH
74814: LD_VAR 0 4
74818: PUSH
74819: LD_VAR 0 7
74823: ARRAY
74824: PPUSH
74825: CALL_OW 247
74829: PUSH
74830: LD_INT 1
74832: EQUAL
74833: AND
74834: IFFALSE 75312
// begin if group [ i ] in healers then
74836: LD_VAR 0 4
74840: PUSH
74841: LD_VAR 0 7
74845: ARRAY
74846: PUSH
74847: LD_VAR 0 31
74851: IN
74852: IFFALSE 75125
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
74854: LD_VAR 0 4
74858: PUSH
74859: LD_VAR 0 7
74863: ARRAY
74864: PPUSH
74865: LD_VAR 0 23
74869: PPUSH
74870: CALL_OW 308
74874: NOT
74875: PUSH
74876: LD_VAR 0 4
74880: PUSH
74881: LD_VAR 0 7
74885: ARRAY
74886: PPUSH
74887: CALL_OW 314
74891: NOT
74892: AND
74893: IFFALSE 74917
// ComMoveToArea ( group [ i ] , f_heal ) else
74895: LD_VAR 0 4
74899: PUSH
74900: LD_VAR 0 7
74904: ARRAY
74905: PPUSH
74906: LD_VAR 0 23
74910: PPUSH
74911: CALL_OW 113
74915: GO 75123
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
74917: LD_VAR 0 4
74921: PUSH
74922: LD_VAR 0 7
74926: ARRAY
74927: PPUSH
74928: CALL 65854 0 1
74932: PPUSH
74933: CALL_OW 256
74937: PUSH
74938: LD_INT 1000
74940: EQUAL
74941: IFFALSE 74960
// ComStop ( group [ i ] ) else
74943: LD_VAR 0 4
74947: PUSH
74948: LD_VAR 0 7
74952: ARRAY
74953: PPUSH
74954: CALL_OW 141
74958: GO 75123
// if not HasTask ( group [ i ] ) and to_heal then
74960: LD_VAR 0 4
74964: PUSH
74965: LD_VAR 0 7
74969: ARRAY
74970: PPUSH
74971: CALL_OW 314
74975: NOT
74976: PUSH
74977: LD_VAR 0 30
74981: AND
74982: IFFALSE 75123
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
74984: LD_ADDR_VAR 0 13
74988: PUSH
74989: LD_VAR 0 30
74993: PPUSH
74994: LD_INT 3
74996: PUSH
74997: LD_INT 54
74999: PUSH
75000: EMPTY
75001: LIST
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PPUSH
75007: CALL_OW 72
75011: PPUSH
75012: LD_VAR 0 4
75016: PUSH
75017: LD_VAR 0 7
75021: ARRAY
75022: PPUSH
75023: CALL_OW 74
75027: ST_TO_ADDR
// if z then
75028: LD_VAR 0 13
75032: IFFALSE 75123
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
75034: LD_INT 91
75036: PUSH
75037: LD_VAR 0 13
75041: PUSH
75042: LD_INT 10
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: LIST
75049: PUSH
75050: LD_INT 81
75052: PUSH
75053: LD_VAR 0 13
75057: PPUSH
75058: CALL_OW 255
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PPUSH
75071: CALL_OW 69
75075: PUSH
75076: LD_INT 0
75078: EQUAL
75079: IFFALSE 75103
// ComHeal ( group [ i ] , z ) else
75081: LD_VAR 0 4
75085: PUSH
75086: LD_VAR 0 7
75090: ARRAY
75091: PPUSH
75092: LD_VAR 0 13
75096: PPUSH
75097: CALL_OW 128
75101: GO 75123
// ComMoveToArea ( group [ i ] , f_heal ) ;
75103: LD_VAR 0 4
75107: PUSH
75108: LD_VAR 0 7
75112: ARRAY
75113: PPUSH
75114: LD_VAR 0 23
75118: PPUSH
75119: CALL_OW 113
// end ; continue ;
75123: GO 74154
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
75125: LD_VAR 0 4
75129: PUSH
75130: LD_VAR 0 7
75134: ARRAY
75135: PPUSH
75136: CALL_OW 256
75140: PUSH
75141: LD_INT 700
75143: LESS
75144: PUSH
75145: LD_VAR 0 4
75149: PUSH
75150: LD_VAR 0 7
75154: ARRAY
75155: PUSH
75156: LD_VAR 0 30
75160: IN
75161: NOT
75162: AND
75163: IFFALSE 75187
// to_heal := to_heal union group [ i ] ;
75165: LD_ADDR_VAR 0 30
75169: PUSH
75170: LD_VAR 0 30
75174: PUSH
75175: LD_VAR 0 4
75179: PUSH
75180: LD_VAR 0 7
75184: ARRAY
75185: UNION
75186: ST_TO_ADDR
// if group [ i ] in to_heal then
75187: LD_VAR 0 4
75191: PUSH
75192: LD_VAR 0 7
75196: ARRAY
75197: PUSH
75198: LD_VAR 0 30
75202: IN
75203: IFFALSE 75312
// begin if GetLives ( group [ i ] ) = 1000 then
75205: LD_VAR 0 4
75209: PUSH
75210: LD_VAR 0 7
75214: ARRAY
75215: PPUSH
75216: CALL_OW 256
75220: PUSH
75221: LD_INT 1000
75223: EQUAL
75224: IFFALSE 75250
// to_heal := to_heal diff group [ i ] else
75226: LD_ADDR_VAR 0 30
75230: PUSH
75231: LD_VAR 0 30
75235: PUSH
75236: LD_VAR 0 4
75240: PUSH
75241: LD_VAR 0 7
75245: ARRAY
75246: DIFF
75247: ST_TO_ADDR
75248: GO 75312
// begin if not IsInArea ( group [ i ] , to_heal ) then
75250: LD_VAR 0 4
75254: PUSH
75255: LD_VAR 0 7
75259: ARRAY
75260: PPUSH
75261: LD_VAR 0 30
75265: PPUSH
75266: CALL_OW 308
75270: NOT
75271: IFFALSE 75295
// ComMoveToArea ( group [ i ] , f_heal ) else
75273: LD_VAR 0 4
75277: PUSH
75278: LD_VAR 0 7
75282: ARRAY
75283: PPUSH
75284: LD_VAR 0 23
75288: PPUSH
75289: CALL_OW 113
75293: GO 75310
// ComHold ( group [ i ] ) ;
75295: LD_VAR 0 4
75299: PUSH
75300: LD_VAR 0 7
75304: ARRAY
75305: PPUSH
75306: CALL_OW 140
// continue ;
75310: GO 74154
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
75312: LD_VAR 0 4
75316: PUSH
75317: LD_VAR 0 7
75321: ARRAY
75322: PPUSH
75323: LD_INT 10
75325: PPUSH
75326: CALL 64274 0 2
75330: NOT
75331: PUSH
75332: LD_VAR 0 16
75336: PUSH
75337: LD_VAR 0 7
75341: ARRAY
75342: PUSH
75343: EMPTY
75344: EQUAL
75345: NOT
75346: AND
75347: IFFALSE 75613
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
75349: LD_VAR 0 4
75353: PUSH
75354: LD_VAR 0 7
75358: ARRAY
75359: PPUSH
75360: CALL_OW 262
75364: PUSH
75365: LD_INT 1
75367: PUSH
75368: LD_INT 2
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: IN
75375: IFFALSE 75416
// if GetFuel ( group [ i ] ) < 10 then
75377: LD_VAR 0 4
75381: PUSH
75382: LD_VAR 0 7
75386: ARRAY
75387: PPUSH
75388: CALL_OW 261
75392: PUSH
75393: LD_INT 10
75395: LESS
75396: IFFALSE 75416
// SetFuel ( group [ i ] , 12 ) ;
75398: LD_VAR 0 4
75402: PUSH
75403: LD_VAR 0 7
75407: ARRAY
75408: PPUSH
75409: LD_INT 12
75411: PPUSH
75412: CALL_OW 240
// if units_path [ i ] then
75416: LD_VAR 0 16
75420: PUSH
75421: LD_VAR 0 7
75425: ARRAY
75426: IFFALSE 75611
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
75428: LD_VAR 0 4
75432: PUSH
75433: LD_VAR 0 7
75437: ARRAY
75438: PPUSH
75439: LD_VAR 0 16
75443: PUSH
75444: LD_VAR 0 7
75448: ARRAY
75449: PUSH
75450: LD_INT 1
75452: ARRAY
75453: PUSH
75454: LD_INT 1
75456: ARRAY
75457: PPUSH
75458: LD_VAR 0 16
75462: PUSH
75463: LD_VAR 0 7
75467: ARRAY
75468: PUSH
75469: LD_INT 1
75471: ARRAY
75472: PUSH
75473: LD_INT 2
75475: ARRAY
75476: PPUSH
75477: CALL_OW 297
75481: PUSH
75482: LD_INT 6
75484: GREATER
75485: IFFALSE 75560
// begin if not HasTask ( group [ i ] ) then
75487: LD_VAR 0 4
75491: PUSH
75492: LD_VAR 0 7
75496: ARRAY
75497: PPUSH
75498: CALL_OW 314
75502: NOT
75503: IFFALSE 75558
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
75505: LD_VAR 0 4
75509: PUSH
75510: LD_VAR 0 7
75514: ARRAY
75515: PPUSH
75516: LD_VAR 0 16
75520: PUSH
75521: LD_VAR 0 7
75525: ARRAY
75526: PUSH
75527: LD_INT 1
75529: ARRAY
75530: PUSH
75531: LD_INT 1
75533: ARRAY
75534: PPUSH
75535: LD_VAR 0 16
75539: PUSH
75540: LD_VAR 0 7
75544: ARRAY
75545: PUSH
75546: LD_INT 1
75548: ARRAY
75549: PUSH
75550: LD_INT 2
75552: ARRAY
75553: PPUSH
75554: CALL_OW 114
// end else
75558: GO 75611
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
75560: LD_ADDR_VAR 0 15
75564: PUSH
75565: LD_VAR 0 16
75569: PUSH
75570: LD_VAR 0 7
75574: ARRAY
75575: PPUSH
75576: LD_INT 1
75578: PPUSH
75579: CALL_OW 3
75583: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
75584: LD_ADDR_VAR 0 16
75588: PUSH
75589: LD_VAR 0 16
75593: PPUSH
75594: LD_VAR 0 7
75598: PPUSH
75599: LD_VAR 0 15
75603: PPUSH
75604: CALL_OW 1
75608: ST_TO_ADDR
// continue ;
75609: GO 74154
// end ; end ; end else
75611: GO 78275
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
75613: LD_ADDR_VAR 0 14
75617: PUSH
75618: LD_INT 81
75620: PUSH
75621: LD_VAR 0 4
75625: PUSH
75626: LD_VAR 0 7
75630: ARRAY
75631: PPUSH
75632: CALL_OW 255
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PPUSH
75641: CALL_OW 69
75645: ST_TO_ADDR
// if not tmp then
75646: LD_VAR 0 14
75650: NOT
75651: IFFALSE 75655
// continue ;
75653: GO 74154
// if f_ignore_area then
75655: LD_VAR 0 17
75659: IFFALSE 75747
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
75661: LD_ADDR_VAR 0 15
75665: PUSH
75666: LD_VAR 0 14
75670: PPUSH
75671: LD_INT 3
75673: PUSH
75674: LD_INT 92
75676: PUSH
75677: LD_VAR 0 17
75681: PUSH
75682: LD_INT 1
75684: ARRAY
75685: PUSH
75686: LD_VAR 0 17
75690: PUSH
75691: LD_INT 2
75693: ARRAY
75694: PUSH
75695: LD_VAR 0 17
75699: PUSH
75700: LD_INT 3
75702: ARRAY
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: LIST
75708: LIST
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PPUSH
75714: CALL_OW 72
75718: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
75719: LD_VAR 0 14
75723: PUSH
75724: LD_VAR 0 15
75728: DIFF
75729: IFFALSE 75747
// tmp := tmp diff tmp2 ;
75731: LD_ADDR_VAR 0 14
75735: PUSH
75736: LD_VAR 0 14
75740: PUSH
75741: LD_VAR 0 15
75745: DIFF
75746: ST_TO_ADDR
// end ; if not f_murder then
75747: LD_VAR 0 20
75751: NOT
75752: IFFALSE 75810
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
75754: LD_ADDR_VAR 0 15
75758: PUSH
75759: LD_VAR 0 14
75763: PPUSH
75764: LD_INT 3
75766: PUSH
75767: LD_INT 50
75769: PUSH
75770: EMPTY
75771: LIST
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PPUSH
75777: CALL_OW 72
75781: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
75782: LD_VAR 0 14
75786: PUSH
75787: LD_VAR 0 15
75791: DIFF
75792: IFFALSE 75810
// tmp := tmp diff tmp2 ;
75794: LD_ADDR_VAR 0 14
75798: PUSH
75799: LD_VAR 0 14
75803: PUSH
75804: LD_VAR 0 15
75808: DIFF
75809: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
75810: LD_ADDR_VAR 0 14
75814: PUSH
75815: LD_VAR 0 4
75819: PUSH
75820: LD_VAR 0 7
75824: ARRAY
75825: PPUSH
75826: LD_VAR 0 14
75830: PPUSH
75831: LD_INT 1
75833: PPUSH
75834: LD_INT 1
75836: PPUSH
75837: CALL 37917 0 4
75841: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
75842: LD_VAR 0 4
75846: PUSH
75847: LD_VAR 0 7
75851: ARRAY
75852: PPUSH
75853: CALL_OW 257
75857: PUSH
75858: LD_INT 1
75860: EQUAL
75861: IFFALSE 76309
// begin if WantPlant ( group [ i ] ) then
75863: LD_VAR 0 4
75867: PUSH
75868: LD_VAR 0 7
75872: ARRAY
75873: PPUSH
75874: CALL 37418 0 1
75878: IFFALSE 75882
// continue ;
75880: GO 74154
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
75882: LD_VAR 0 18
75886: PUSH
75887: LD_VAR 0 4
75891: PUSH
75892: LD_VAR 0 7
75896: ARRAY
75897: PPUSH
75898: CALL_OW 310
75902: NOT
75903: AND
75904: PUSH
75905: LD_VAR 0 14
75909: PUSH
75910: LD_INT 1
75912: ARRAY
75913: PUSH
75914: LD_VAR 0 14
75918: PPUSH
75919: LD_INT 21
75921: PUSH
75922: LD_INT 2
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: LD_INT 58
75931: PUSH
75932: EMPTY
75933: LIST
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PPUSH
75939: CALL_OW 72
75943: IN
75944: AND
75945: IFFALSE 75981
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
75947: LD_VAR 0 4
75951: PUSH
75952: LD_VAR 0 7
75956: ARRAY
75957: PPUSH
75958: LD_VAR 0 14
75962: PUSH
75963: LD_INT 1
75965: ARRAY
75966: PPUSH
75967: CALL_OW 120
// attacking := true ;
75971: LD_ADDR_VAR 0 29
75975: PUSH
75976: LD_INT 1
75978: ST_TO_ADDR
// continue ;
75979: GO 74154
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
75981: LD_VAR 0 26
75985: PUSH
75986: LD_VAR 0 4
75990: PUSH
75991: LD_VAR 0 7
75995: ARRAY
75996: PPUSH
75997: CALL_OW 257
76001: PUSH
76002: LD_INT 1
76004: EQUAL
76005: AND
76006: PUSH
76007: LD_VAR 0 4
76011: PUSH
76012: LD_VAR 0 7
76016: ARRAY
76017: PPUSH
76018: CALL_OW 256
76022: PUSH
76023: LD_INT 800
76025: LESS
76026: AND
76027: PUSH
76028: LD_VAR 0 4
76032: PUSH
76033: LD_VAR 0 7
76037: ARRAY
76038: PPUSH
76039: CALL_OW 318
76043: NOT
76044: AND
76045: IFFALSE 76062
// ComCrawl ( group [ i ] ) ;
76047: LD_VAR 0 4
76051: PUSH
76052: LD_VAR 0 7
76056: ARRAY
76057: PPUSH
76058: CALL_OW 137
// if f_mines then
76062: LD_VAR 0 21
76066: IFFALSE 76309
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
76068: LD_VAR 0 14
76072: PUSH
76073: LD_INT 1
76075: ARRAY
76076: PPUSH
76077: CALL_OW 247
76081: PUSH
76082: LD_INT 3
76084: EQUAL
76085: PUSH
76086: LD_VAR 0 14
76090: PUSH
76091: LD_INT 1
76093: ARRAY
76094: PUSH
76095: LD_VAR 0 27
76099: IN
76100: NOT
76101: AND
76102: IFFALSE 76309
// begin x := GetX ( tmp [ 1 ] ) ;
76104: LD_ADDR_VAR 0 10
76108: PUSH
76109: LD_VAR 0 14
76113: PUSH
76114: LD_INT 1
76116: ARRAY
76117: PPUSH
76118: CALL_OW 250
76122: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
76123: LD_ADDR_VAR 0 11
76127: PUSH
76128: LD_VAR 0 14
76132: PUSH
76133: LD_INT 1
76135: ARRAY
76136: PPUSH
76137: CALL_OW 251
76141: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
76142: LD_ADDR_VAR 0 12
76146: PUSH
76147: LD_VAR 0 4
76151: PUSH
76152: LD_VAR 0 7
76156: ARRAY
76157: PPUSH
76158: CALL 64359 0 1
76162: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
76163: LD_VAR 0 4
76167: PUSH
76168: LD_VAR 0 7
76172: ARRAY
76173: PPUSH
76174: LD_VAR 0 10
76178: PPUSH
76179: LD_VAR 0 11
76183: PPUSH
76184: LD_VAR 0 14
76188: PUSH
76189: LD_INT 1
76191: ARRAY
76192: PPUSH
76193: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
76197: LD_VAR 0 4
76201: PUSH
76202: LD_VAR 0 7
76206: ARRAY
76207: PPUSH
76208: LD_VAR 0 10
76212: PPUSH
76213: LD_VAR 0 12
76217: PPUSH
76218: LD_INT 7
76220: PPUSH
76221: CALL_OW 272
76225: PPUSH
76226: LD_VAR 0 11
76230: PPUSH
76231: LD_VAR 0 12
76235: PPUSH
76236: LD_INT 7
76238: PPUSH
76239: CALL_OW 273
76243: PPUSH
76244: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
76248: LD_VAR 0 4
76252: PUSH
76253: LD_VAR 0 7
76257: ARRAY
76258: PPUSH
76259: LD_INT 71
76261: PPUSH
76262: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
76266: LD_ADDR_VAR 0 27
76270: PUSH
76271: LD_VAR 0 27
76275: PPUSH
76276: LD_VAR 0 27
76280: PUSH
76281: LD_INT 1
76283: PLUS
76284: PPUSH
76285: LD_VAR 0 14
76289: PUSH
76290: LD_INT 1
76292: ARRAY
76293: PPUSH
76294: CALL_OW 1
76298: ST_TO_ADDR
// attacking := true ;
76299: LD_ADDR_VAR 0 29
76303: PUSH
76304: LD_INT 1
76306: ST_TO_ADDR
// continue ;
76307: GO 74154
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
76309: LD_VAR 0 4
76313: PUSH
76314: LD_VAR 0 7
76318: ARRAY
76319: PPUSH
76320: CALL_OW 257
76324: PUSH
76325: LD_INT 17
76327: EQUAL
76328: PUSH
76329: LD_VAR 0 4
76333: PUSH
76334: LD_VAR 0 7
76338: ARRAY
76339: PPUSH
76340: CALL_OW 110
76344: PUSH
76345: LD_INT 71
76347: EQUAL
76348: NOT
76349: AND
76350: IFFALSE 76496
// begin attacking := false ;
76352: LD_ADDR_VAR 0 29
76356: PUSH
76357: LD_INT 0
76359: ST_TO_ADDR
// k := 5 ;
76360: LD_ADDR_VAR 0 9
76364: PUSH
76365: LD_INT 5
76367: ST_TO_ADDR
// if tmp < k then
76368: LD_VAR 0 14
76372: PUSH
76373: LD_VAR 0 9
76377: LESS
76378: IFFALSE 76390
// k := tmp ;
76380: LD_ADDR_VAR 0 9
76384: PUSH
76385: LD_VAR 0 14
76389: ST_TO_ADDR
// for j = 1 to k do
76390: LD_ADDR_VAR 0 8
76394: PUSH
76395: DOUBLE
76396: LD_INT 1
76398: DEC
76399: ST_TO_ADDR
76400: LD_VAR 0 9
76404: PUSH
76405: FOR_TO
76406: IFFALSE 76494
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
76408: LD_VAR 0 14
76412: PUSH
76413: LD_VAR 0 8
76417: ARRAY
76418: PUSH
76419: LD_VAR 0 14
76423: PPUSH
76424: LD_INT 58
76426: PUSH
76427: EMPTY
76428: LIST
76429: PPUSH
76430: CALL_OW 72
76434: IN
76435: NOT
76436: IFFALSE 76492
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
76438: LD_VAR 0 4
76442: PUSH
76443: LD_VAR 0 7
76447: ARRAY
76448: PPUSH
76449: LD_VAR 0 14
76453: PUSH
76454: LD_VAR 0 8
76458: ARRAY
76459: PPUSH
76460: CALL_OW 115
// attacking := true ;
76464: LD_ADDR_VAR 0 29
76468: PUSH
76469: LD_INT 1
76471: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
76472: LD_VAR 0 4
76476: PUSH
76477: LD_VAR 0 7
76481: ARRAY
76482: PPUSH
76483: LD_INT 71
76485: PPUSH
76486: CALL_OW 109
// continue ;
76490: GO 76405
// end ; end ;
76492: GO 76405
76494: POP
76495: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
76496: LD_VAR 0 4
76500: PUSH
76501: LD_VAR 0 7
76505: ARRAY
76506: PPUSH
76507: CALL_OW 257
76511: PUSH
76512: LD_INT 8
76514: EQUAL
76515: PUSH
76516: LD_VAR 0 4
76520: PUSH
76521: LD_VAR 0 7
76525: ARRAY
76526: PPUSH
76527: CALL_OW 264
76531: PUSH
76532: LD_INT 28
76534: PUSH
76535: LD_INT 45
76537: PUSH
76538: LD_INT 7
76540: PUSH
76541: LD_INT 47
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: LIST
76548: LIST
76549: IN
76550: OR
76551: IFFALSE 76807
// begin attacking := false ;
76553: LD_ADDR_VAR 0 29
76557: PUSH
76558: LD_INT 0
76560: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
76561: LD_VAR 0 14
76565: PUSH
76566: LD_INT 1
76568: ARRAY
76569: PPUSH
76570: CALL_OW 266
76574: PUSH
76575: LD_INT 32
76577: PUSH
76578: LD_INT 31
76580: PUSH
76581: LD_INT 33
76583: PUSH
76584: LD_INT 4
76586: PUSH
76587: LD_INT 5
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: IN
76597: IFFALSE 76783
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
76599: LD_ADDR_VAR 0 9
76603: PUSH
76604: LD_VAR 0 14
76608: PUSH
76609: LD_INT 1
76611: ARRAY
76612: PPUSH
76613: CALL_OW 266
76617: PPUSH
76618: LD_VAR 0 14
76622: PUSH
76623: LD_INT 1
76625: ARRAY
76626: PPUSH
76627: CALL_OW 250
76631: PPUSH
76632: LD_VAR 0 14
76636: PUSH
76637: LD_INT 1
76639: ARRAY
76640: PPUSH
76641: CALL_OW 251
76645: PPUSH
76646: LD_VAR 0 14
76650: PUSH
76651: LD_INT 1
76653: ARRAY
76654: PPUSH
76655: CALL_OW 254
76659: PPUSH
76660: LD_VAR 0 14
76664: PUSH
76665: LD_INT 1
76667: ARRAY
76668: PPUSH
76669: CALL_OW 248
76673: PPUSH
76674: LD_INT 0
76676: PPUSH
76677: CALL 45729 0 6
76681: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
76682: LD_ADDR_VAR 0 8
76686: PUSH
76687: LD_VAR 0 4
76691: PUSH
76692: LD_VAR 0 7
76696: ARRAY
76697: PPUSH
76698: LD_VAR 0 9
76702: PPUSH
76703: CALL 64399 0 2
76707: ST_TO_ADDR
// if j then
76708: LD_VAR 0 8
76712: IFFALSE 76781
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76714: LD_VAR 0 8
76718: PUSH
76719: LD_INT 1
76721: ARRAY
76722: PPUSH
76723: LD_VAR 0 8
76727: PUSH
76728: LD_INT 2
76730: ARRAY
76731: PPUSH
76732: CALL_OW 488
76736: IFFALSE 76781
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
76738: LD_VAR 0 4
76742: PUSH
76743: LD_VAR 0 7
76747: ARRAY
76748: PPUSH
76749: LD_VAR 0 8
76753: PUSH
76754: LD_INT 1
76756: ARRAY
76757: PPUSH
76758: LD_VAR 0 8
76762: PUSH
76763: LD_INT 2
76765: ARRAY
76766: PPUSH
76767: CALL_OW 116
// attacking := true ;
76771: LD_ADDR_VAR 0 29
76775: PUSH
76776: LD_INT 1
76778: ST_TO_ADDR
// continue ;
76779: GO 74154
// end ; end else
76781: GO 76807
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
76783: LD_VAR 0 4
76787: PUSH
76788: LD_VAR 0 7
76792: ARRAY
76793: PPUSH
76794: LD_VAR 0 14
76798: PUSH
76799: LD_INT 1
76801: ARRAY
76802: PPUSH
76803: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
76807: LD_VAR 0 4
76811: PUSH
76812: LD_VAR 0 7
76816: ARRAY
76817: PPUSH
76818: CALL_OW 265
76822: PUSH
76823: LD_INT 11
76825: EQUAL
76826: IFFALSE 77104
// begin k := 10 ;
76828: LD_ADDR_VAR 0 9
76832: PUSH
76833: LD_INT 10
76835: ST_TO_ADDR
// x := 0 ;
76836: LD_ADDR_VAR 0 10
76840: PUSH
76841: LD_INT 0
76843: ST_TO_ADDR
// if tmp < k then
76844: LD_VAR 0 14
76848: PUSH
76849: LD_VAR 0 9
76853: LESS
76854: IFFALSE 76866
// k := tmp ;
76856: LD_ADDR_VAR 0 9
76860: PUSH
76861: LD_VAR 0 14
76865: ST_TO_ADDR
// for j = k downto 1 do
76866: LD_ADDR_VAR 0 8
76870: PUSH
76871: DOUBLE
76872: LD_VAR 0 9
76876: INC
76877: ST_TO_ADDR
76878: LD_INT 1
76880: PUSH
76881: FOR_DOWNTO
76882: IFFALSE 76957
// begin if GetType ( tmp [ j ] ) = unit_human then
76884: LD_VAR 0 14
76888: PUSH
76889: LD_VAR 0 8
76893: ARRAY
76894: PPUSH
76895: CALL_OW 247
76899: PUSH
76900: LD_INT 1
76902: EQUAL
76903: IFFALSE 76955
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
76905: LD_VAR 0 4
76909: PUSH
76910: LD_VAR 0 7
76914: ARRAY
76915: PPUSH
76916: LD_VAR 0 14
76920: PUSH
76921: LD_VAR 0 8
76925: ARRAY
76926: PPUSH
76927: CALL 64670 0 2
// x := tmp [ j ] ;
76931: LD_ADDR_VAR 0 10
76935: PUSH
76936: LD_VAR 0 14
76940: PUSH
76941: LD_VAR 0 8
76945: ARRAY
76946: ST_TO_ADDR
// attacking := true ;
76947: LD_ADDR_VAR 0 29
76951: PUSH
76952: LD_INT 1
76954: ST_TO_ADDR
// end ; end ;
76955: GO 76881
76957: POP
76958: POP
// if not x then
76959: LD_VAR 0 10
76963: NOT
76964: IFFALSE 77104
// begin attacking := true ;
76966: LD_ADDR_VAR 0 29
76970: PUSH
76971: LD_INT 1
76973: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
76974: LD_VAR 0 4
76978: PUSH
76979: LD_VAR 0 7
76983: ARRAY
76984: PPUSH
76985: CALL_OW 250
76989: PPUSH
76990: LD_VAR 0 4
76994: PUSH
76995: LD_VAR 0 7
76999: ARRAY
77000: PPUSH
77001: CALL_OW 251
77005: PPUSH
77006: CALL_OW 546
77010: PUSH
77011: LD_INT 2
77013: ARRAY
77014: PUSH
77015: LD_VAR 0 14
77019: PUSH
77020: LD_INT 1
77022: ARRAY
77023: PPUSH
77024: CALL_OW 250
77028: PPUSH
77029: LD_VAR 0 14
77033: PUSH
77034: LD_INT 1
77036: ARRAY
77037: PPUSH
77038: CALL_OW 251
77042: PPUSH
77043: CALL_OW 546
77047: PUSH
77048: LD_INT 2
77050: ARRAY
77051: EQUAL
77052: IFFALSE 77080
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
77054: LD_VAR 0 4
77058: PUSH
77059: LD_VAR 0 7
77063: ARRAY
77064: PPUSH
77065: LD_VAR 0 14
77069: PUSH
77070: LD_INT 1
77072: ARRAY
77073: PPUSH
77074: CALL 64670 0 2
77078: GO 77104
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
77080: LD_VAR 0 4
77084: PUSH
77085: LD_VAR 0 7
77089: ARRAY
77090: PPUSH
77091: LD_VAR 0 14
77095: PUSH
77096: LD_INT 1
77098: ARRAY
77099: PPUSH
77100: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
77104: LD_VAR 0 4
77108: PUSH
77109: LD_VAR 0 7
77113: ARRAY
77114: PPUSH
77115: CALL_OW 264
77119: PUSH
77120: LD_INT 29
77122: EQUAL
77123: IFFALSE 77489
// begin if WantsToAttack ( group [ i ] ) in bombed then
77125: LD_VAR 0 4
77129: PUSH
77130: LD_VAR 0 7
77134: ARRAY
77135: PPUSH
77136: CALL_OW 319
77140: PUSH
77141: LD_VAR 0 28
77145: IN
77146: IFFALSE 77150
// continue ;
77148: GO 74154
// k := 8 ;
77150: LD_ADDR_VAR 0 9
77154: PUSH
77155: LD_INT 8
77157: ST_TO_ADDR
// x := 0 ;
77158: LD_ADDR_VAR 0 10
77162: PUSH
77163: LD_INT 0
77165: ST_TO_ADDR
// if tmp < k then
77166: LD_VAR 0 14
77170: PUSH
77171: LD_VAR 0 9
77175: LESS
77176: IFFALSE 77188
// k := tmp ;
77178: LD_ADDR_VAR 0 9
77182: PUSH
77183: LD_VAR 0 14
77187: ST_TO_ADDR
// for j = 1 to k do
77188: LD_ADDR_VAR 0 8
77192: PUSH
77193: DOUBLE
77194: LD_INT 1
77196: DEC
77197: ST_TO_ADDR
77198: LD_VAR 0 9
77202: PUSH
77203: FOR_TO
77204: IFFALSE 77336
// begin if GetType ( tmp [ j ] ) = unit_building then
77206: LD_VAR 0 14
77210: PUSH
77211: LD_VAR 0 8
77215: ARRAY
77216: PPUSH
77217: CALL_OW 247
77221: PUSH
77222: LD_INT 3
77224: EQUAL
77225: IFFALSE 77334
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
77227: LD_VAR 0 14
77231: PUSH
77232: LD_VAR 0 8
77236: ARRAY
77237: PUSH
77238: LD_VAR 0 28
77242: IN
77243: NOT
77244: PUSH
77245: LD_VAR 0 14
77249: PUSH
77250: LD_VAR 0 8
77254: ARRAY
77255: PPUSH
77256: CALL_OW 313
77260: AND
77261: IFFALSE 77334
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
77263: LD_VAR 0 4
77267: PUSH
77268: LD_VAR 0 7
77272: ARRAY
77273: PPUSH
77274: LD_VAR 0 14
77278: PUSH
77279: LD_VAR 0 8
77283: ARRAY
77284: PPUSH
77285: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
77289: LD_ADDR_VAR 0 28
77293: PUSH
77294: LD_VAR 0 28
77298: PPUSH
77299: LD_VAR 0 28
77303: PUSH
77304: LD_INT 1
77306: PLUS
77307: PPUSH
77308: LD_VAR 0 14
77312: PUSH
77313: LD_VAR 0 8
77317: ARRAY
77318: PPUSH
77319: CALL_OW 1
77323: ST_TO_ADDR
// attacking := true ;
77324: LD_ADDR_VAR 0 29
77328: PUSH
77329: LD_INT 1
77331: ST_TO_ADDR
// break ;
77332: GO 77336
// end ; end ;
77334: GO 77203
77336: POP
77337: POP
// if not attacking and f_attack_depot then
77338: LD_VAR 0 29
77342: NOT
77343: PUSH
77344: LD_VAR 0 25
77348: AND
77349: IFFALSE 77444
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77351: LD_ADDR_VAR 0 13
77355: PUSH
77356: LD_VAR 0 14
77360: PPUSH
77361: LD_INT 2
77363: PUSH
77364: LD_INT 30
77366: PUSH
77367: LD_INT 0
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 30
77376: PUSH
77377: LD_INT 1
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: LIST
77388: PPUSH
77389: CALL_OW 72
77393: ST_TO_ADDR
// if z then
77394: LD_VAR 0 13
77398: IFFALSE 77444
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
77400: LD_VAR 0 4
77404: PUSH
77405: LD_VAR 0 7
77409: ARRAY
77410: PPUSH
77411: LD_VAR 0 13
77415: PPUSH
77416: LD_VAR 0 4
77420: PUSH
77421: LD_VAR 0 7
77425: ARRAY
77426: PPUSH
77427: CALL_OW 74
77431: PPUSH
77432: CALL_OW 115
// attacking := true ;
77436: LD_ADDR_VAR 0 29
77440: PUSH
77441: LD_INT 1
77443: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
77444: LD_VAR 0 4
77448: PUSH
77449: LD_VAR 0 7
77453: ARRAY
77454: PPUSH
77455: CALL_OW 256
77459: PUSH
77460: LD_INT 500
77462: LESS
77463: IFFALSE 77489
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
77465: LD_VAR 0 4
77469: PUSH
77470: LD_VAR 0 7
77474: ARRAY
77475: PPUSH
77476: LD_VAR 0 14
77480: PUSH
77481: LD_INT 1
77483: ARRAY
77484: PPUSH
77485: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
77489: LD_VAR 0 4
77493: PUSH
77494: LD_VAR 0 7
77498: ARRAY
77499: PPUSH
77500: CALL_OW 264
77504: PUSH
77505: LD_INT 49
77507: EQUAL
77508: IFFALSE 77629
// begin if not HasTask ( group [ i ] ) then
77510: LD_VAR 0 4
77514: PUSH
77515: LD_VAR 0 7
77519: ARRAY
77520: PPUSH
77521: CALL_OW 314
77525: NOT
77526: IFFALSE 77629
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
77528: LD_ADDR_VAR 0 9
77532: PUSH
77533: LD_INT 81
77535: PUSH
77536: LD_VAR 0 4
77540: PUSH
77541: LD_VAR 0 7
77545: ARRAY
77546: PPUSH
77547: CALL_OW 255
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PPUSH
77556: CALL_OW 69
77560: PPUSH
77561: LD_VAR 0 4
77565: PUSH
77566: LD_VAR 0 7
77570: ARRAY
77571: PPUSH
77572: CALL_OW 74
77576: ST_TO_ADDR
// if k then
77577: LD_VAR 0 9
77581: IFFALSE 77629
// if GetDistUnits ( group [ i ] , k ) > 10 then
77583: LD_VAR 0 4
77587: PUSH
77588: LD_VAR 0 7
77592: ARRAY
77593: PPUSH
77594: LD_VAR 0 9
77598: PPUSH
77599: CALL_OW 296
77603: PUSH
77604: LD_INT 10
77606: GREATER
77607: IFFALSE 77629
// ComMoveUnit ( group [ i ] , k ) ;
77609: LD_VAR 0 4
77613: PUSH
77614: LD_VAR 0 7
77618: ARRAY
77619: PPUSH
77620: LD_VAR 0 9
77624: PPUSH
77625: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
77629: LD_VAR 0 4
77633: PUSH
77634: LD_VAR 0 7
77638: ARRAY
77639: PPUSH
77640: CALL_OW 256
77644: PUSH
77645: LD_INT 250
77647: LESS
77648: PUSH
77649: LD_VAR 0 4
77653: PUSH
77654: LD_VAR 0 7
77658: ARRAY
77659: PUSH
77660: LD_INT 21
77662: PUSH
77663: LD_INT 2
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 23
77672: PUSH
77673: LD_INT 2
77675: PUSH
77676: EMPTY
77677: LIST
77678: LIST
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PPUSH
77684: CALL_OW 69
77688: IN
77689: AND
77690: IFFALSE 77815
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
77692: LD_ADDR_VAR 0 9
77696: PUSH
77697: LD_OWVAR 3
77701: PUSH
77702: LD_VAR 0 4
77706: PUSH
77707: LD_VAR 0 7
77711: ARRAY
77712: DIFF
77713: PPUSH
77714: LD_VAR 0 4
77718: PUSH
77719: LD_VAR 0 7
77723: ARRAY
77724: PPUSH
77725: CALL_OW 74
77729: ST_TO_ADDR
// if not k then
77730: LD_VAR 0 9
77734: NOT
77735: IFFALSE 77739
// continue ;
77737: GO 74154
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
77739: LD_VAR 0 9
77743: PUSH
77744: LD_INT 81
77746: PUSH
77747: LD_VAR 0 4
77751: PUSH
77752: LD_VAR 0 7
77756: ARRAY
77757: PPUSH
77758: CALL_OW 255
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PPUSH
77767: CALL_OW 69
77771: IN
77772: PUSH
77773: LD_VAR 0 9
77777: PPUSH
77778: LD_VAR 0 4
77782: PUSH
77783: LD_VAR 0 7
77787: ARRAY
77788: PPUSH
77789: CALL_OW 296
77793: PUSH
77794: LD_INT 5
77796: LESS
77797: AND
77798: IFFALSE 77815
// ComAutodestruct ( group [ i ] ) ;
77800: LD_VAR 0 4
77804: PUSH
77805: LD_VAR 0 7
77809: ARRAY
77810: PPUSH
77811: CALL 64568 0 1
// end ; if f_attack_depot then
77815: LD_VAR 0 25
77819: IFFALSE 77931
// begin k := 6 ;
77821: LD_ADDR_VAR 0 9
77825: PUSH
77826: LD_INT 6
77828: ST_TO_ADDR
// if tmp < k then
77829: LD_VAR 0 14
77833: PUSH
77834: LD_VAR 0 9
77838: LESS
77839: IFFALSE 77851
// k := tmp ;
77841: LD_ADDR_VAR 0 9
77845: PUSH
77846: LD_VAR 0 14
77850: ST_TO_ADDR
// for j = 1 to k do
77851: LD_ADDR_VAR 0 8
77855: PUSH
77856: DOUBLE
77857: LD_INT 1
77859: DEC
77860: ST_TO_ADDR
77861: LD_VAR 0 9
77865: PUSH
77866: FOR_TO
77867: IFFALSE 77929
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
77869: LD_VAR 0 8
77873: PPUSH
77874: CALL_OW 266
77878: PUSH
77879: LD_INT 0
77881: PUSH
77882: LD_INT 1
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: IN
77889: IFFALSE 77927
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
77891: LD_VAR 0 4
77895: PUSH
77896: LD_VAR 0 7
77900: ARRAY
77901: PPUSH
77902: LD_VAR 0 14
77906: PUSH
77907: LD_VAR 0 8
77911: ARRAY
77912: PPUSH
77913: CALL_OW 115
// attacking := true ;
77917: LD_ADDR_VAR 0 29
77921: PUSH
77922: LD_INT 1
77924: ST_TO_ADDR
// break ;
77925: GO 77929
// end ;
77927: GO 77866
77929: POP
77930: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
77931: LD_VAR 0 4
77935: PUSH
77936: LD_VAR 0 7
77940: ARRAY
77941: PPUSH
77942: CALL_OW 302
77946: PUSH
77947: LD_VAR 0 29
77951: NOT
77952: AND
77953: IFFALSE 78275
// begin if GetTag ( group [ i ] ) = 71 then
77955: LD_VAR 0 4
77959: PUSH
77960: LD_VAR 0 7
77964: ARRAY
77965: PPUSH
77966: CALL_OW 110
77970: PUSH
77971: LD_INT 71
77973: EQUAL
77974: IFFALSE 78015
// begin if HasTask ( group [ i ] ) then
77976: LD_VAR 0 4
77980: PUSH
77981: LD_VAR 0 7
77985: ARRAY
77986: PPUSH
77987: CALL_OW 314
77991: IFFALSE 77997
// continue else
77993: GO 74154
77995: GO 78015
// SetTag ( group [ i ] , 0 ) ;
77997: LD_VAR 0 4
78001: PUSH
78002: LD_VAR 0 7
78006: ARRAY
78007: PPUSH
78008: LD_INT 0
78010: PPUSH
78011: CALL_OW 109
// end ; k := 8 ;
78015: LD_ADDR_VAR 0 9
78019: PUSH
78020: LD_INT 8
78022: ST_TO_ADDR
// x := 0 ;
78023: LD_ADDR_VAR 0 10
78027: PUSH
78028: LD_INT 0
78030: ST_TO_ADDR
// if tmp < k then
78031: LD_VAR 0 14
78035: PUSH
78036: LD_VAR 0 9
78040: LESS
78041: IFFALSE 78053
// k := tmp ;
78043: LD_ADDR_VAR 0 9
78047: PUSH
78048: LD_VAR 0 14
78052: ST_TO_ADDR
// for j = 1 to k do
78053: LD_ADDR_VAR 0 8
78057: PUSH
78058: DOUBLE
78059: LD_INT 1
78061: DEC
78062: ST_TO_ADDR
78063: LD_VAR 0 9
78067: PUSH
78068: FOR_TO
78069: IFFALSE 78167
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
78071: LD_VAR 0 14
78075: PUSH
78076: LD_VAR 0 8
78080: ARRAY
78081: PPUSH
78082: CALL_OW 247
78086: PUSH
78087: LD_INT 1
78089: EQUAL
78090: PUSH
78091: LD_VAR 0 14
78095: PUSH
78096: LD_VAR 0 8
78100: ARRAY
78101: PPUSH
78102: CALL_OW 256
78106: PUSH
78107: LD_INT 250
78109: LESS
78110: PUSH
78111: LD_VAR 0 20
78115: AND
78116: PUSH
78117: LD_VAR 0 20
78121: NOT
78122: PUSH
78123: LD_VAR 0 14
78127: PUSH
78128: LD_VAR 0 8
78132: ARRAY
78133: PPUSH
78134: CALL_OW 256
78138: PUSH
78139: LD_INT 250
78141: GREATEREQUAL
78142: AND
78143: OR
78144: AND
78145: IFFALSE 78165
// begin x := tmp [ j ] ;
78147: LD_ADDR_VAR 0 10
78151: PUSH
78152: LD_VAR 0 14
78156: PUSH
78157: LD_VAR 0 8
78161: ARRAY
78162: ST_TO_ADDR
// break ;
78163: GO 78167
// end ;
78165: GO 78068
78167: POP
78168: POP
// if x then
78169: LD_VAR 0 10
78173: IFFALSE 78197
// ComAttackUnit ( group [ i ] , x ) else
78175: LD_VAR 0 4
78179: PUSH
78180: LD_VAR 0 7
78184: ARRAY
78185: PPUSH
78186: LD_VAR 0 10
78190: PPUSH
78191: CALL_OW 115
78195: GO 78221
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
78197: LD_VAR 0 4
78201: PUSH
78202: LD_VAR 0 7
78206: ARRAY
78207: PPUSH
78208: LD_VAR 0 14
78212: PUSH
78213: LD_INT 1
78215: ARRAY
78216: PPUSH
78217: CALL_OW 115
// if not HasTask ( group [ i ] ) then
78221: LD_VAR 0 4
78225: PUSH
78226: LD_VAR 0 7
78230: ARRAY
78231: PPUSH
78232: CALL_OW 314
78236: NOT
78237: IFFALSE 78275
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
78239: LD_VAR 0 4
78243: PUSH
78244: LD_VAR 0 7
78248: ARRAY
78249: PPUSH
78250: LD_VAR 0 14
78254: PPUSH
78255: LD_VAR 0 4
78259: PUSH
78260: LD_VAR 0 7
78264: ARRAY
78265: PPUSH
78266: CALL_OW 74
78270: PPUSH
78271: CALL_OW 115
// end ; end ; end ;
78275: GO 74154
78277: POP
78278: POP
// wait ( 0 0$2 ) ;
78279: LD_INT 70
78281: PPUSH
78282: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
78286: LD_VAR 0 4
78290: NOT
78291: PUSH
78292: LD_VAR 0 4
78296: PUSH
78297: EMPTY
78298: EQUAL
78299: OR
78300: PUSH
78301: LD_INT 81
78303: PUSH
78304: LD_VAR 0 35
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PPUSH
78313: CALL_OW 69
78317: NOT
78318: OR
78319: IFFALSE 74139
// end ;
78321: LD_VAR 0 2
78325: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
78326: LD_INT 0
78328: PPUSH
78329: PPUSH
78330: PPUSH
78331: PPUSH
78332: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
78333: LD_VAR 0 1
78337: NOT
78338: PUSH
78339: LD_EXP 52
78343: PUSH
78344: LD_VAR 0 1
78348: ARRAY
78349: NOT
78350: OR
78351: PUSH
78352: LD_VAR 0 2
78356: NOT
78357: OR
78358: PUSH
78359: LD_VAR 0 3
78363: NOT
78364: OR
78365: IFFALSE 78369
// exit ;
78367: GO 78882
// side := mc_sides [ base ] ;
78369: LD_ADDR_VAR 0 6
78373: PUSH
78374: LD_EXP 78
78378: PUSH
78379: LD_VAR 0 1
78383: ARRAY
78384: ST_TO_ADDR
// if not side then
78385: LD_VAR 0 6
78389: NOT
78390: IFFALSE 78394
// exit ;
78392: GO 78882
// for i in solds do
78394: LD_ADDR_VAR 0 7
78398: PUSH
78399: LD_VAR 0 2
78403: PUSH
78404: FOR_IN
78405: IFFALSE 78466
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
78407: LD_VAR 0 7
78411: PPUSH
78412: CALL_OW 310
78416: PPUSH
78417: CALL_OW 266
78421: PUSH
78422: LD_INT 32
78424: PUSH
78425: LD_INT 31
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: IN
78432: IFFALSE 78452
// solds := solds diff i else
78434: LD_ADDR_VAR 0 2
78438: PUSH
78439: LD_VAR 0 2
78443: PUSH
78444: LD_VAR 0 7
78448: DIFF
78449: ST_TO_ADDR
78450: GO 78464
// SetTag ( i , 18 ) ;
78452: LD_VAR 0 7
78456: PPUSH
78457: LD_INT 18
78459: PPUSH
78460: CALL_OW 109
78464: GO 78404
78466: POP
78467: POP
// if not solds then
78468: LD_VAR 0 2
78472: NOT
78473: IFFALSE 78477
// exit ;
78475: GO 78882
// repeat wait ( 0 0$1 ) ;
78477: LD_INT 35
78479: PPUSH
78480: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
78484: LD_ADDR_VAR 0 5
78488: PUSH
78489: LD_VAR 0 6
78493: PPUSH
78494: LD_VAR 0 3
78498: PPUSH
78499: CALL 34283 0 2
78503: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
78504: LD_EXP 52
78508: PUSH
78509: LD_VAR 0 1
78513: ARRAY
78514: NOT
78515: PUSH
78516: LD_EXP 52
78520: PUSH
78521: LD_VAR 0 1
78525: ARRAY
78526: PUSH
78527: EMPTY
78528: EQUAL
78529: OR
78530: IFFALSE 78567
// begin for i in solds do
78532: LD_ADDR_VAR 0 7
78536: PUSH
78537: LD_VAR 0 2
78541: PUSH
78542: FOR_IN
78543: IFFALSE 78556
// ComStop ( i ) ;
78545: LD_VAR 0 7
78549: PPUSH
78550: CALL_OW 141
78554: GO 78542
78556: POP
78557: POP
// solds := [ ] ;
78558: LD_ADDR_VAR 0 2
78562: PUSH
78563: EMPTY
78564: ST_TO_ADDR
// exit ;
78565: GO 78882
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
78567: LD_VAR 0 5
78571: NOT
78572: PUSH
78573: LD_VAR 0 5
78577: PUSH
78578: LD_INT 3
78580: GREATER
78581: OR
78582: PUSH
78583: LD_EXP 74
78587: PUSH
78588: LD_VAR 0 1
78592: ARRAY
78593: OR
78594: IFFALSE 78635
// begin for i in solds do
78596: LD_ADDR_VAR 0 7
78600: PUSH
78601: LD_VAR 0 2
78605: PUSH
78606: FOR_IN
78607: IFFALSE 78631
// if HasTask ( i ) then
78609: LD_VAR 0 7
78613: PPUSH
78614: CALL_OW 314
78618: IFFALSE 78629
// ComStop ( i ) ;
78620: LD_VAR 0 7
78624: PPUSH
78625: CALL_OW 141
78629: GO 78606
78631: POP
78632: POP
// break ;
78633: GO 78870
// end ; for i in solds do
78635: LD_ADDR_VAR 0 7
78639: PUSH
78640: LD_VAR 0 2
78644: PUSH
78645: FOR_IN
78646: IFFALSE 78862
// begin if IsInUnit ( i ) then
78648: LD_VAR 0 7
78652: PPUSH
78653: CALL_OW 310
78657: IFFALSE 78668
// ComExitBuilding ( i ) ;
78659: LD_VAR 0 7
78663: PPUSH
78664: CALL_OW 122
// if GetLives ( i ) > 333 then
78668: LD_VAR 0 7
78672: PPUSH
78673: CALL_OW 256
78677: PUSH
78678: LD_INT 333
78680: GREATER
78681: IFFALSE 78709
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
78683: LD_VAR 0 7
78687: PPUSH
78688: LD_VAR 0 5
78692: PPUSH
78693: LD_VAR 0 7
78697: PPUSH
78698: CALL_OW 74
78702: PPUSH
78703: CALL_OW 115
78707: GO 78860
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
78709: LD_ADDR_VAR 0 8
78713: PUSH
78714: LD_EXP 52
78718: PUSH
78719: LD_VAR 0 1
78723: ARRAY
78724: PPUSH
78725: LD_INT 2
78727: PUSH
78728: LD_INT 30
78730: PUSH
78731: LD_INT 0
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 30
78740: PUSH
78741: LD_INT 1
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 30
78750: PUSH
78751: LD_INT 6
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: LIST
78762: LIST
78763: PPUSH
78764: CALL_OW 72
78768: PPUSH
78769: LD_VAR 0 7
78773: PPUSH
78774: CALL_OW 74
78778: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
78779: LD_VAR 0 7
78783: PPUSH
78784: LD_VAR 0 8
78788: PPUSH
78789: CALL_OW 250
78793: PPUSH
78794: LD_INT 3
78796: PPUSH
78797: LD_INT 5
78799: PPUSH
78800: CALL_OW 272
78804: PPUSH
78805: LD_VAR 0 8
78809: PPUSH
78810: CALL_OW 251
78814: PPUSH
78815: LD_INT 3
78817: PPUSH
78818: LD_INT 5
78820: PPUSH
78821: CALL_OW 273
78825: PPUSH
78826: CALL_OW 111
// SetTag ( i , 0 ) ;
78830: LD_VAR 0 7
78834: PPUSH
78835: LD_INT 0
78837: PPUSH
78838: CALL_OW 109
// solds := solds diff i ;
78842: LD_ADDR_VAR 0 2
78846: PUSH
78847: LD_VAR 0 2
78851: PUSH
78852: LD_VAR 0 7
78856: DIFF
78857: ST_TO_ADDR
// continue ;
78858: GO 78645
// end ; end ;
78860: GO 78645
78862: POP
78863: POP
// until solds ;
78864: LD_VAR 0 2
78868: IFFALSE 78477
// MC_Reset ( base , 18 ) ;
78870: LD_VAR 0 1
78874: PPUSH
78875: LD_INT 18
78877: PPUSH
78878: CALL 11324 0 2
// end ;
78882: LD_VAR 0 4
78886: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
78887: LD_INT 0
78889: PPUSH
78890: PPUSH
78891: PPUSH
78892: PPUSH
78893: PPUSH
78894: PPUSH
78895: PPUSH
78896: PPUSH
78897: PPUSH
78898: PPUSH
78899: PPUSH
78900: PPUSH
78901: PPUSH
78902: PPUSH
78903: PPUSH
78904: PPUSH
78905: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
78906: LD_ADDR_VAR 0 13
78910: PUSH
78911: LD_EXP 52
78915: PUSH
78916: LD_VAR 0 1
78920: ARRAY
78921: PPUSH
78922: LD_INT 25
78924: PUSH
78925: LD_INT 3
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PPUSH
78932: CALL_OW 72
78936: ST_TO_ADDR
// if mc_remote_driver [ base ] then
78937: LD_EXP 92
78941: PUSH
78942: LD_VAR 0 1
78946: ARRAY
78947: IFFALSE 78971
// mechs := mechs diff mc_remote_driver [ base ] ;
78949: LD_ADDR_VAR 0 13
78953: PUSH
78954: LD_VAR 0 13
78958: PUSH
78959: LD_EXP 92
78963: PUSH
78964: LD_VAR 0 1
78968: ARRAY
78969: DIFF
78970: ST_TO_ADDR
// for i in mechs do
78971: LD_ADDR_VAR 0 5
78975: PUSH
78976: LD_VAR 0 13
78980: PUSH
78981: FOR_IN
78982: IFFALSE 79017
// if GetTag ( i ) > 0 then
78984: LD_VAR 0 5
78988: PPUSH
78989: CALL_OW 110
78993: PUSH
78994: LD_INT 0
78996: GREATER
78997: IFFALSE 79015
// mechs := mechs diff i ;
78999: LD_ADDR_VAR 0 13
79003: PUSH
79004: LD_VAR 0 13
79008: PUSH
79009: LD_VAR 0 5
79013: DIFF
79014: ST_TO_ADDR
79015: GO 78981
79017: POP
79018: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
79019: LD_ADDR_VAR 0 9
79023: PUSH
79024: LD_EXP 52
79028: PUSH
79029: LD_VAR 0 1
79033: ARRAY
79034: PPUSH
79035: LD_INT 2
79037: PUSH
79038: LD_INT 25
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 25
79050: PUSH
79051: LD_INT 5
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 25
79060: PUSH
79061: LD_INT 8
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 25
79070: PUSH
79071: LD_INT 9
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: LIST
79082: LIST
79083: LIST
79084: PPUSH
79085: CALL_OW 72
79089: ST_TO_ADDR
// if not defenders and not solds then
79090: LD_VAR 0 2
79094: NOT
79095: PUSH
79096: LD_VAR 0 9
79100: NOT
79101: AND
79102: IFFALSE 79106
// exit ;
79104: GO 80732
// depot_under_attack := false ;
79106: LD_ADDR_VAR 0 17
79110: PUSH
79111: LD_INT 0
79113: ST_TO_ADDR
// sold_defenders := [ ] ;
79114: LD_ADDR_VAR 0 18
79118: PUSH
79119: EMPTY
79120: ST_TO_ADDR
// if mechs then
79121: LD_VAR 0 13
79125: IFFALSE 79254
// for i in defenders do
79127: LD_ADDR_VAR 0 5
79131: PUSH
79132: LD_VAR 0 2
79136: PUSH
79137: FOR_IN
79138: IFFALSE 79252
// begin SetTag ( i , 20 ) ;
79140: LD_VAR 0 5
79144: PPUSH
79145: LD_INT 20
79147: PPUSH
79148: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
79152: LD_VAR 0 5
79156: PPUSH
79157: CALL_OW 263
79161: PUSH
79162: LD_INT 1
79164: EQUAL
79165: PUSH
79166: LD_VAR 0 5
79170: PPUSH
79171: CALL_OW 311
79175: NOT
79176: AND
79177: PUSH
79178: LD_VAR 0 13
79182: AND
79183: IFFALSE 79250
// begin un := mechs [ 1 ] ;
79185: LD_ADDR_VAR 0 11
79189: PUSH
79190: LD_VAR 0 13
79194: PUSH
79195: LD_INT 1
79197: ARRAY
79198: ST_TO_ADDR
// ComExitBuilding ( un ) ;
79199: LD_VAR 0 11
79203: PPUSH
79204: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
79208: LD_VAR 0 11
79212: PPUSH
79213: LD_VAR 0 5
79217: PPUSH
79218: CALL_OW 180
// SetTag ( un , 19 ) ;
79222: LD_VAR 0 11
79226: PPUSH
79227: LD_INT 19
79229: PPUSH
79230: CALL_OW 109
// mechs := mechs diff un ;
79234: LD_ADDR_VAR 0 13
79238: PUSH
79239: LD_VAR 0 13
79243: PUSH
79244: LD_VAR 0 11
79248: DIFF
79249: ST_TO_ADDR
// end ; end ;
79250: GO 79137
79252: POP
79253: POP
// if solds then
79254: LD_VAR 0 9
79258: IFFALSE 79317
// for i in solds do
79260: LD_ADDR_VAR 0 5
79264: PUSH
79265: LD_VAR 0 9
79269: PUSH
79270: FOR_IN
79271: IFFALSE 79315
// if not GetTag ( i ) then
79273: LD_VAR 0 5
79277: PPUSH
79278: CALL_OW 110
79282: NOT
79283: IFFALSE 79313
// begin defenders := defenders union i ;
79285: LD_ADDR_VAR 0 2
79289: PUSH
79290: LD_VAR 0 2
79294: PUSH
79295: LD_VAR 0 5
79299: UNION
79300: ST_TO_ADDR
// SetTag ( i , 18 ) ;
79301: LD_VAR 0 5
79305: PPUSH
79306: LD_INT 18
79308: PPUSH
79309: CALL_OW 109
// end ;
79313: GO 79270
79315: POP
79316: POP
// repeat wait ( 0 0$1 ) ;
79317: LD_INT 35
79319: PPUSH
79320: CALL_OW 67
// enemy := mc_scan [ base ] ;
79324: LD_ADDR_VAR 0 3
79328: PUSH
79329: LD_EXP 75
79333: PUSH
79334: LD_VAR 0 1
79338: ARRAY
79339: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
79340: LD_EXP 52
79344: PUSH
79345: LD_VAR 0 1
79349: ARRAY
79350: NOT
79351: PUSH
79352: LD_EXP 52
79356: PUSH
79357: LD_VAR 0 1
79361: ARRAY
79362: PUSH
79363: EMPTY
79364: EQUAL
79365: OR
79366: IFFALSE 79403
// begin for i in defenders do
79368: LD_ADDR_VAR 0 5
79372: PUSH
79373: LD_VAR 0 2
79377: PUSH
79378: FOR_IN
79379: IFFALSE 79392
// ComStop ( i ) ;
79381: LD_VAR 0 5
79385: PPUSH
79386: CALL_OW 141
79390: GO 79378
79392: POP
79393: POP
// defenders := [ ] ;
79394: LD_ADDR_VAR 0 2
79398: PUSH
79399: EMPTY
79400: ST_TO_ADDR
// exit ;
79401: GO 80732
// end ; for i in defenders do
79403: LD_ADDR_VAR 0 5
79407: PUSH
79408: LD_VAR 0 2
79412: PUSH
79413: FOR_IN
79414: IFFALSE 80232
// begin e := NearestUnitToUnit ( enemy , i ) ;
79416: LD_ADDR_VAR 0 14
79420: PUSH
79421: LD_VAR 0 3
79425: PPUSH
79426: LD_VAR 0 5
79430: PPUSH
79431: CALL_OW 74
79435: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79436: LD_ADDR_VAR 0 8
79440: PUSH
79441: LD_EXP 52
79445: PUSH
79446: LD_VAR 0 1
79450: ARRAY
79451: PPUSH
79452: LD_INT 2
79454: PUSH
79455: LD_INT 30
79457: PUSH
79458: LD_INT 0
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 30
79467: PUSH
79468: LD_INT 1
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: LIST
79479: PPUSH
79480: CALL_OW 72
79484: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
79485: LD_ADDR_VAR 0 17
79489: PUSH
79490: LD_VAR 0 8
79494: NOT
79495: PUSH
79496: LD_VAR 0 8
79500: PPUSH
79501: LD_INT 3
79503: PUSH
79504: LD_INT 24
79506: PUSH
79507: LD_INT 600
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PPUSH
79518: CALL_OW 72
79522: OR
79523: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
79524: LD_VAR 0 5
79528: PPUSH
79529: CALL_OW 247
79533: PUSH
79534: LD_INT 2
79536: DOUBLE
79537: EQUAL
79538: IFTRUE 79542
79540: GO 79938
79542: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
79543: LD_VAR 0 5
79547: PPUSH
79548: CALL_OW 256
79552: PUSH
79553: LD_INT 650
79555: GREATER
79556: PUSH
79557: LD_VAR 0 5
79561: PPUSH
79562: LD_VAR 0 14
79566: PPUSH
79567: CALL_OW 296
79571: PUSH
79572: LD_INT 40
79574: LESS
79575: PUSH
79576: LD_VAR 0 14
79580: PPUSH
79581: LD_EXP 77
79585: PUSH
79586: LD_VAR 0 1
79590: ARRAY
79591: PPUSH
79592: CALL_OW 308
79596: OR
79597: AND
79598: IFFALSE 79720
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
79600: LD_VAR 0 5
79604: PPUSH
79605: CALL_OW 262
79609: PUSH
79610: LD_INT 1
79612: EQUAL
79613: PUSH
79614: LD_VAR 0 5
79618: PPUSH
79619: CALL_OW 261
79623: PUSH
79624: LD_INT 30
79626: LESS
79627: AND
79628: PUSH
79629: LD_VAR 0 8
79633: AND
79634: IFFALSE 79704
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
79636: LD_VAR 0 5
79640: PPUSH
79641: LD_VAR 0 8
79645: PPUSH
79646: LD_VAR 0 5
79650: PPUSH
79651: CALL_OW 74
79655: PPUSH
79656: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
79660: LD_VAR 0 5
79664: PPUSH
79665: LD_VAR 0 8
79669: PPUSH
79670: LD_VAR 0 5
79674: PPUSH
79675: CALL_OW 74
79679: PPUSH
79680: CALL_OW 296
79684: PUSH
79685: LD_INT 6
79687: LESS
79688: IFFALSE 79702
// SetFuel ( i , 100 ) ;
79690: LD_VAR 0 5
79694: PPUSH
79695: LD_INT 100
79697: PPUSH
79698: CALL_OW 240
// end else
79702: GO 79718
// ComAttackUnit ( i , e ) ;
79704: LD_VAR 0 5
79708: PPUSH
79709: LD_VAR 0 14
79713: PPUSH
79714: CALL_OW 115
// end else
79718: GO 79821
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
79720: LD_VAR 0 14
79724: PPUSH
79725: LD_EXP 77
79729: PUSH
79730: LD_VAR 0 1
79734: ARRAY
79735: PPUSH
79736: CALL_OW 308
79740: NOT
79741: PUSH
79742: LD_VAR 0 5
79746: PPUSH
79747: LD_VAR 0 14
79751: PPUSH
79752: CALL_OW 296
79756: PUSH
79757: LD_INT 40
79759: GREATEREQUAL
79760: AND
79761: PUSH
79762: LD_VAR 0 5
79766: PPUSH
79767: CALL_OW 256
79771: PUSH
79772: LD_INT 650
79774: LESSEQUAL
79775: OR
79776: PUSH
79777: LD_VAR 0 5
79781: PPUSH
79782: LD_EXP 76
79786: PUSH
79787: LD_VAR 0 1
79791: ARRAY
79792: PPUSH
79793: CALL_OW 308
79797: NOT
79798: AND
79799: IFFALSE 79821
// ComMoveToArea ( i , mc_parking [ base ] ) ;
79801: LD_VAR 0 5
79805: PPUSH
79806: LD_EXP 76
79810: PUSH
79811: LD_VAR 0 1
79815: ARRAY
79816: PPUSH
79817: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
79821: LD_VAR 0 5
79825: PPUSH
79826: CALL_OW 256
79830: PUSH
79831: LD_INT 998
79833: LESS
79834: PUSH
79835: LD_VAR 0 5
79839: PPUSH
79840: CALL_OW 263
79844: PUSH
79845: LD_INT 1
79847: EQUAL
79848: AND
79849: PUSH
79850: LD_VAR 0 5
79854: PPUSH
79855: CALL_OW 311
79859: AND
79860: PUSH
79861: LD_VAR 0 5
79865: PPUSH
79866: LD_EXP 76
79870: PUSH
79871: LD_VAR 0 1
79875: ARRAY
79876: PPUSH
79877: CALL_OW 308
79881: AND
79882: IFFALSE 79936
// begin mech := IsDrivenBy ( i ) ;
79884: LD_ADDR_VAR 0 10
79888: PUSH
79889: LD_VAR 0 5
79893: PPUSH
79894: CALL_OW 311
79898: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
79899: LD_VAR 0 10
79903: PPUSH
79904: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
79908: LD_VAR 0 10
79912: PPUSH
79913: LD_VAR 0 5
79917: PPUSH
79918: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
79922: LD_VAR 0 10
79926: PPUSH
79927: LD_VAR 0 5
79931: PPUSH
79932: CALL_OW 180
// end ; end ; unit_human :
79936: GO 80203
79938: LD_INT 1
79940: DOUBLE
79941: EQUAL
79942: IFTRUE 79946
79944: GO 80202
79946: POP
// begin b := IsInUnit ( i ) ;
79947: LD_ADDR_VAR 0 19
79951: PUSH
79952: LD_VAR 0 5
79956: PPUSH
79957: CALL_OW 310
79961: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
79962: LD_ADDR_VAR 0 20
79966: PUSH
79967: LD_VAR 0 19
79971: NOT
79972: PUSH
79973: LD_VAR 0 19
79977: PPUSH
79978: CALL_OW 266
79982: PUSH
79983: LD_INT 32
79985: PUSH
79986: LD_INT 31
79988: PUSH
79989: EMPTY
79990: LIST
79991: LIST
79992: IN
79993: OR
79994: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
79995: LD_VAR 0 17
79999: PUSH
80000: LD_VAR 0 2
80004: PPUSH
80005: LD_INT 21
80007: PUSH
80008: LD_INT 2
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PPUSH
80015: CALL_OW 72
80019: PUSH
80020: LD_INT 1
80022: LESSEQUAL
80023: OR
80024: PUSH
80025: LD_VAR 0 20
80029: AND
80030: PUSH
80031: LD_VAR 0 5
80035: PUSH
80036: LD_VAR 0 18
80040: IN
80041: NOT
80042: AND
80043: IFFALSE 80136
// begin if b then
80045: LD_VAR 0 19
80049: IFFALSE 80098
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
80051: LD_VAR 0 19
80055: PPUSH
80056: LD_VAR 0 3
80060: PPUSH
80061: LD_VAR 0 19
80065: PPUSH
80066: CALL_OW 74
80070: PPUSH
80071: CALL_OW 296
80075: PUSH
80076: LD_INT 10
80078: LESS
80079: PUSH
80080: LD_VAR 0 19
80084: PPUSH
80085: CALL_OW 461
80089: PUSH
80090: LD_INT 7
80092: NONEQUAL
80093: AND
80094: IFFALSE 80098
// continue ;
80096: GO 79413
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
80098: LD_ADDR_VAR 0 18
80102: PUSH
80103: LD_VAR 0 18
80107: PPUSH
80108: LD_VAR 0 18
80112: PUSH
80113: LD_INT 1
80115: PLUS
80116: PPUSH
80117: LD_VAR 0 5
80121: PPUSH
80122: CALL_OW 1
80126: ST_TO_ADDR
// ComExitBuilding ( i ) ;
80127: LD_VAR 0 5
80131: PPUSH
80132: CALL_OW 122
// end ; if sold_defenders then
80136: LD_VAR 0 18
80140: IFFALSE 80200
// if i in sold_defenders then
80142: LD_VAR 0 5
80146: PUSH
80147: LD_VAR 0 18
80151: IN
80152: IFFALSE 80200
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
80154: LD_VAR 0 5
80158: PPUSH
80159: CALL_OW 314
80163: NOT
80164: PUSH
80165: LD_VAR 0 5
80169: PPUSH
80170: LD_VAR 0 14
80174: PPUSH
80175: CALL_OW 296
80179: PUSH
80180: LD_INT 30
80182: LESS
80183: AND
80184: IFFALSE 80200
// ComAttackUnit ( i , e ) ;
80186: LD_VAR 0 5
80190: PPUSH
80191: LD_VAR 0 14
80195: PPUSH
80196: CALL_OW 115
// end ; end ; end ;
80200: GO 80203
80202: POP
// if IsDead ( i ) then
80203: LD_VAR 0 5
80207: PPUSH
80208: CALL_OW 301
80212: IFFALSE 80230
// defenders := defenders diff i ;
80214: LD_ADDR_VAR 0 2
80218: PUSH
80219: LD_VAR 0 2
80223: PUSH
80224: LD_VAR 0 5
80228: DIFF
80229: ST_TO_ADDR
// end ;
80230: GO 79413
80232: POP
80233: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
80234: LD_VAR 0 3
80238: NOT
80239: PUSH
80240: LD_VAR 0 2
80244: NOT
80245: OR
80246: PUSH
80247: LD_EXP 52
80251: PUSH
80252: LD_VAR 0 1
80256: ARRAY
80257: NOT
80258: OR
80259: IFFALSE 79317
// MC_Reset ( base , 18 ) ;
80261: LD_VAR 0 1
80265: PPUSH
80266: LD_INT 18
80268: PPUSH
80269: CALL 11324 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
80273: LD_ADDR_VAR 0 2
80277: PUSH
80278: LD_VAR 0 2
80282: PUSH
80283: LD_VAR 0 2
80287: PPUSH
80288: LD_INT 2
80290: PUSH
80291: LD_INT 25
80293: PUSH
80294: LD_INT 1
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: LD_INT 25
80303: PUSH
80304: LD_INT 5
80306: PUSH
80307: EMPTY
80308: LIST
80309: LIST
80310: PUSH
80311: LD_INT 25
80313: PUSH
80314: LD_INT 8
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 25
80323: PUSH
80324: LD_INT 9
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: PPUSH
80338: CALL_OW 72
80342: DIFF
80343: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
80344: LD_VAR 0 3
80348: NOT
80349: PUSH
80350: LD_VAR 0 2
80354: PPUSH
80355: LD_INT 21
80357: PUSH
80358: LD_INT 2
80360: PUSH
80361: EMPTY
80362: LIST
80363: LIST
80364: PPUSH
80365: CALL_OW 72
80369: AND
80370: IFFALSE 80708
// begin tmp := FilterByTag ( defenders , 19 ) ;
80372: LD_ADDR_VAR 0 12
80376: PUSH
80377: LD_VAR 0 2
80381: PPUSH
80382: LD_INT 19
80384: PPUSH
80385: CALL 66043 0 2
80389: ST_TO_ADDR
// if tmp then
80390: LD_VAR 0 12
80394: IFFALSE 80464
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
80396: LD_ADDR_VAR 0 12
80400: PUSH
80401: LD_VAR 0 12
80405: PPUSH
80406: LD_INT 25
80408: PUSH
80409: LD_INT 3
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PPUSH
80416: CALL_OW 72
80420: ST_TO_ADDR
// if tmp then
80421: LD_VAR 0 12
80425: IFFALSE 80464
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
80427: LD_ADDR_EXP 64
80431: PUSH
80432: LD_EXP 64
80436: PPUSH
80437: LD_VAR 0 1
80441: PPUSH
80442: LD_EXP 64
80446: PUSH
80447: LD_VAR 0 1
80451: ARRAY
80452: PUSH
80453: LD_VAR 0 12
80457: UNION
80458: PPUSH
80459: CALL_OW 1
80463: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
80464: LD_VAR 0 1
80468: PPUSH
80469: LD_INT 19
80471: PPUSH
80472: CALL 11324 0 2
// repeat wait ( 0 0$1 ) ;
80476: LD_INT 35
80478: PPUSH
80479: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
80483: LD_EXP 52
80487: PUSH
80488: LD_VAR 0 1
80492: ARRAY
80493: NOT
80494: PUSH
80495: LD_EXP 52
80499: PUSH
80500: LD_VAR 0 1
80504: ARRAY
80505: PUSH
80506: EMPTY
80507: EQUAL
80508: OR
80509: IFFALSE 80546
// begin for i in defenders do
80511: LD_ADDR_VAR 0 5
80515: PUSH
80516: LD_VAR 0 2
80520: PUSH
80521: FOR_IN
80522: IFFALSE 80535
// ComStop ( i ) ;
80524: LD_VAR 0 5
80528: PPUSH
80529: CALL_OW 141
80533: GO 80521
80535: POP
80536: POP
// defenders := [ ] ;
80537: LD_ADDR_VAR 0 2
80541: PUSH
80542: EMPTY
80543: ST_TO_ADDR
// exit ;
80544: GO 80732
// end ; for i in defenders do
80546: LD_ADDR_VAR 0 5
80550: PUSH
80551: LD_VAR 0 2
80555: PUSH
80556: FOR_IN
80557: IFFALSE 80646
// begin if not IsInArea ( i , mc_parking [ base ] ) then
80559: LD_VAR 0 5
80563: PPUSH
80564: LD_EXP 76
80568: PUSH
80569: LD_VAR 0 1
80573: ARRAY
80574: PPUSH
80575: CALL_OW 308
80579: NOT
80580: IFFALSE 80604
// ComMoveToArea ( i , mc_parking [ base ] ) else
80582: LD_VAR 0 5
80586: PPUSH
80587: LD_EXP 76
80591: PUSH
80592: LD_VAR 0 1
80596: ARRAY
80597: PPUSH
80598: CALL_OW 113
80602: GO 80644
// if GetControl ( i ) = control_manual then
80604: LD_VAR 0 5
80608: PPUSH
80609: CALL_OW 263
80613: PUSH
80614: LD_INT 1
80616: EQUAL
80617: IFFALSE 80644
// if IsDrivenBy ( i ) then
80619: LD_VAR 0 5
80623: PPUSH
80624: CALL_OW 311
80628: IFFALSE 80644
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
80630: LD_VAR 0 5
80634: PPUSH
80635: CALL_OW 311
80639: PPUSH
80640: CALL_OW 121
// end ;
80644: GO 80556
80646: POP
80647: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
80648: LD_VAR 0 2
80652: PPUSH
80653: LD_INT 95
80655: PUSH
80656: LD_EXP 76
80660: PUSH
80661: LD_VAR 0 1
80665: ARRAY
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PPUSH
80671: CALL_OW 72
80675: PUSH
80676: LD_VAR 0 2
80680: EQUAL
80681: PUSH
80682: LD_EXP 75
80686: PUSH
80687: LD_VAR 0 1
80691: ARRAY
80692: OR
80693: PUSH
80694: LD_EXP 52
80698: PUSH
80699: LD_VAR 0 1
80703: ARRAY
80704: NOT
80705: OR
80706: IFFALSE 80476
// end ; MC_Reset ( base , 19 ) ;
80708: LD_VAR 0 1
80712: PPUSH
80713: LD_INT 19
80715: PPUSH
80716: CALL 11324 0 2
// MC_Reset ( base , 20 ) ;
80720: LD_VAR 0 1
80724: PPUSH
80725: LD_INT 20
80727: PPUSH
80728: CALL 11324 0 2
// end ; end_of_file
80732: LD_VAR 0 4
80736: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
80737: GO 80739
80739: DISABLE
// begin ru_radar := 98 ;
80740: LD_ADDR_EXP 95
80744: PUSH
80745: LD_INT 98
80747: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80748: LD_ADDR_EXP 96
80752: PUSH
80753: LD_INT 89
80755: ST_TO_ADDR
// us_hack := 99 ;
80756: LD_ADDR_EXP 97
80760: PUSH
80761: LD_INT 99
80763: ST_TO_ADDR
// us_artillery := 97 ;
80764: LD_ADDR_EXP 98
80768: PUSH
80769: LD_INT 97
80771: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80772: LD_ADDR_EXP 99
80776: PUSH
80777: LD_INT 91
80779: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
80780: LD_ADDR_EXP 100
80784: PUSH
80785: LD_INT 92
80787: ST_TO_ADDR
// tech_Artillery := 80 ;
80788: LD_ADDR_EXP 101
80792: PUSH
80793: LD_INT 80
80795: ST_TO_ADDR
// tech_RadMat := 81 ;
80796: LD_ADDR_EXP 102
80800: PUSH
80801: LD_INT 81
80803: ST_TO_ADDR
// tech_BasicTools := 82 ;
80804: LD_ADDR_EXP 103
80808: PUSH
80809: LD_INT 82
80811: ST_TO_ADDR
// tech_Cargo := 83 ;
80812: LD_ADDR_EXP 104
80816: PUSH
80817: LD_INT 83
80819: ST_TO_ADDR
// tech_Track := 84 ;
80820: LD_ADDR_EXP 105
80824: PUSH
80825: LD_INT 84
80827: ST_TO_ADDR
// tech_Crane := 85 ;
80828: LD_ADDR_EXP 106
80832: PUSH
80833: LD_INT 85
80835: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80836: LD_ADDR_EXP 107
80840: PUSH
80841: LD_INT 86
80843: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80844: LD_ADDR_EXP 108
80848: PUSH
80849: LD_INT 87
80851: ST_TO_ADDR
// end ;
80852: END
