// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 3645 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , attackers_tmp ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// if Multiplayer then
 124: LD_OWVAR 4
 128: IFFALSE 250
// begin Game_Type := mp_game_type ;
 130: LD_ADDR_EXP 1
 134: PUSH
 135: LD_OWVAR 6
 139: ST_TO_ADDR
// Your_Side := mp_player_side ;
 140: LD_ADDR_OWVAR 2
 144: PUSH
 145: LD_OWVAR 7
 149: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_OWVAR 17
 159: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 160: LD_ADDR_EXP 3
 164: PUSH
 165: LD_OWVAR 15
 169: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 170: LD_ADDR_EXP 4
 174: PUSH
 175: LD_OWVAR 16
 179: ST_TO_ADDR
// Teams := mp_teams ;
 180: LD_ADDR_EXP 5
 184: PUSH
 185: LD_OWVAR 12
 189: ST_TO_ADDR
// for i = 0 to 6 do
 190: LD_ADDR_VAR 0 2
 194: PUSH
 195: DOUBLE
 196: LD_INT 0
 198: DEC
 199: ST_TO_ADDR
 200: LD_INT 6
 202: PUSH
 203: FOR_TO
 204: IFFALSE 246
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 206: LD_ADDR_EXP 16
 210: PUSH
 211: LD_EXP 16
 215: PPUSH
 216: LD_EXP 16
 220: PUSH
 221: LD_INT 1
 223: PLUS
 224: PPUSH
 225: LD_VAR 0 2
 229: PPUSH
 230: CALL_OW 426
 234: PUSH
 235: LD_INT 1
 237: PLUS
 238: PPUSH
 239: CALL_OW 2
 243: ST_TO_ADDR
 244: GO 203
 246: POP
 247: POP
// end else
 248: GO 401
// begin Game_Type := 1 ;
 250: LD_ADDR_EXP 1
 254: PUSH
 255: LD_INT 1
 257: ST_TO_ADDR
// Your_Side := 2 ;
 258: LD_ADDR_OWVAR 2
 262: PUSH
 263: LD_INT 2
 265: ST_TO_ADDR
// Side_Positions := [ 0 , 1 , 0 , 0 , 2 , 0 , 0 , 0 ] ;
 266: LD_ADDR_EXP 2
 270: PUSH
 271: LD_INT 0
 273: PUSH
 274: LD_INT 1
 276: PUSH
 277: LD_INT 0
 279: PUSH
 280: LD_INT 0
 282: PUSH
 283: LD_INT 2
 285: PUSH
 286: LD_INT 0
 288: PUSH
 289: LD_INT 0
 291: PUSH
 292: LD_INT 0
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// Side_Teams := [ 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 ] ;
 305: LD_ADDR_EXP 3
 309: PUSH
 310: LD_INT 0
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 0
 318: PUSH
 319: LD_INT 0
 321: PUSH
 322: LD_INT 1
 324: PUSH
 325: LD_INT 0
 327: PUSH
 328: LD_INT 0
 330: PUSH
 331: LD_INT 0
 333: PUSH
 334: EMPTY
 335: LIST
 336: LIST
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: ST_TO_ADDR
// Side_Nations := [ 0 , 3 , 0 , 0 , 3 , 0 , 0 , 0 ] ;
 344: LD_ADDR_EXP 4
 348: PUSH
 349: LD_INT 0
 351: PUSH
 352: LD_INT 3
 354: PUSH
 355: LD_INT 0
 357: PUSH
 358: LD_INT 0
 360: PUSH
 361: LD_INT 3
 363: PUSH
 364: LD_INT 0
 366: PUSH
 367: LD_INT 0
 369: PUSH
 370: LD_INT 0
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: ST_TO_ADDR
// Teams := [ [ 2 , 5 ] ] ;
 383: LD_ADDR_EXP 5
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: LD_INT 5
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: PUSH
 398: EMPTY
 399: LIST
 400: ST_TO_ADDR
// end ; Side_Start := [ [ 203 , 174 ] , [ 114 , 171 ] , [ 26 , 44 ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 401: LD_ADDR_EXP 7
 405: PUSH
 406: LD_INT 203
 408: PUSH
 409: LD_INT 174
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 114
 418: PUSH
 419: LD_INT 171
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: PUSH
 426: LD_INT 26
 428: PUSH
 429: LD_INT 44
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: PUSH
 436: EMPTY
 437: PUSH
 438: EMPTY
 439: PUSH
 440: EMPTY
 441: PUSH
 442: EMPTY
 443: PUSH
 444: EMPTY
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: ST_TO_ADDR
// Bot_Side := 2 ;
 456: LD_ADDR_EXP 8
 460: PUSH
 461: LD_INT 2
 463: ST_TO_ADDR
// for i = 1 to 8 do
 464: LD_ADDR_VAR 0 2
 468: PUSH
 469: DOUBLE
 470: LD_INT 1
 472: DEC
 473: ST_TO_ADDR
 474: LD_INT 8
 476: PUSH
 477: FOR_TO
 478: IFFALSE 610
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
 480: LD_VAR 0 2
 484: PPUSH
 485: CALL_OW 530
 489: IFFALSE 563
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 491: LD_ADDR_EXP 2
 495: PUSH
 496: LD_EXP 2
 500: PPUSH
 501: LD_VAR 0 2
 505: PPUSH
 506: LD_INT 0
 508: PPUSH
 509: CALL_OW 1
 513: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 514: LD_ADDR_EXP 5
 518: PUSH
 519: LD_EXP 5
 523: PPUSH
 524: LD_EXP 3
 528: PUSH
 529: LD_VAR 0 2
 533: ARRAY
 534: PPUSH
 535: LD_EXP 5
 539: PUSH
 540: LD_EXP 3
 544: PUSH
 545: LD_VAR 0 2
 549: ARRAY
 550: ARRAY
 551: PUSH
 552: LD_VAR 0 2
 556: DIFF
 557: PPUSH
 558: CALL_OW 1
 562: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 3 then
 563: LD_EXP 4
 567: PUSH
 568: LD_VAR 0 2
 572: ARRAY
 573: PUSH
 574: LD_EXP 4
 578: PUSH
 579: LD_INT 3
 581: NONEQUAL
 582: AND
 583: IFFALSE 608
// Side_Nations := Replace ( Side_Nations , i , 3 ) ;
 585: LD_ADDR_EXP 4
 589: PUSH
 590: LD_EXP 4
 594: PPUSH
 595: LD_VAR 0 2
 599: PPUSH
 600: LD_INT 3
 602: PPUSH
 603: CALL_OW 1
 607: ST_TO_ADDR
// end ;
 608: GO 477
 610: POP
 611: POP
// if 2 = bot_side and Side_Positions [ 2 ] then
 612: LD_INT 2
 614: PUSH
 615: LD_EXP 8
 619: EQUAL
 620: PUSH
 621: LD_EXP 2
 625: PUSH
 626: LD_INT 2
 628: ARRAY
 629: AND
 630: IFFALSE 640
// bot_side := 5 ;
 632: LD_ADDR_EXP 8
 636: PUSH
 637: LD_INT 5
 639: ST_TO_ADDR
// if 5 = bot_side and Side_Positions [ 5 ] then
 640: LD_INT 5
 642: PUSH
 643: LD_EXP 8
 647: EQUAL
 648: PUSH
 649: LD_EXP 2
 653: PUSH
 654: LD_INT 5
 656: ARRAY
 657: AND
 658: IFFALSE 668
// bot_side := 8 ;
 660: LD_ADDR_EXP 8
 664: PUSH
 665: LD_INT 8
 667: ST_TO_ADDR
// Team_Game := false ;
 668: LD_ADDR_EXP 6
 672: PUSH
 673: LD_INT 0
 675: ST_TO_ADDR
// for i = 1 to 8 do
 676: LD_ADDR_VAR 0 2
 680: PUSH
 681: DOUBLE
 682: LD_INT 1
 684: DEC
 685: ST_TO_ADDR
 686: LD_INT 8
 688: PUSH
 689: FOR_TO
 690: IFFALSE 716
// if Side_Teams [ i ] then
 692: LD_EXP 3
 696: PUSH
 697: LD_VAR 0 2
 701: ARRAY
 702: IFFALSE 714
// begin Team_Game := true ;
 704: LD_ADDR_EXP 6
 708: PUSH
 709: LD_INT 1
 711: ST_TO_ADDR
// break ;
 712: GO 716
// end ;
 714: GO 689
 716: POP
 717: POP
// for i in Teams do
 718: LD_ADDR_VAR 0 2
 722: PUSH
 723: LD_EXP 5
 727: PUSH
 728: FOR_IN
 729: IFFALSE 809
// for j = 2 to i do
 731: LD_ADDR_VAR 0 3
 735: PUSH
 736: DOUBLE
 737: LD_INT 2
 739: DEC
 740: ST_TO_ADDR
 741: LD_VAR 0 2
 745: PUSH
 746: FOR_TO
 747: IFFALSE 805
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
 749: LD_VAR 0 2
 753: PUSH
 754: LD_VAR 0 3
 758: ARRAY
 759: PPUSH
 760: LD_VAR 0 2
 764: PUSH
 765: LD_INT 1
 767: ARRAY
 768: PPUSH
 769: CALL_OW 343
// SetAttitude ( i [ j ] , i [ 1 ] , att_friend , true ) ;
 773: LD_VAR 0 2
 777: PUSH
 778: LD_VAR 0 3
 782: ARRAY
 783: PPUSH
 784: LD_VAR 0 2
 788: PUSH
 789: LD_INT 1
 791: ARRAY
 792: PPUSH
 793: LD_INT 1
 795: PPUSH
 796: LD_INT 1
 798: PPUSH
 799: CALL_OW 80
// end ;
 803: GO 746
 805: POP
 806: POP
 807: GO 728
 809: POP
 810: POP
// if not Multiplayer then
 811: LD_OWVAR 4
 815: NOT
 816: IFFALSE 853
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 818: LD_ADDR_EXP 16
 822: PUSH
 823: LD_INT 1
 825: PUSH
 826: LD_INT 1
 828: PUSH
 829: LD_INT 1
 831: PUSH
 832: LD_INT 1
 834: PUSH
 835: LD_INT 2
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: ST_TO_ADDR
// number_of_people := [ 9 , 12 , 15 , 24 ] [ definitions [ 1 ] ] ;
 853: LD_ADDR_EXP 10
 857: PUSH
 858: LD_INT 9
 860: PUSH
 861: LD_INT 12
 863: PUSH
 864: LD_INT 15
 866: PUSH
 867: LD_INT 24
 869: PUSH
 870: EMPTY
 871: LIST
 872: LIST
 873: LIST
 874: LIST
 875: PUSH
 876: LD_EXP 16
 880: PUSH
 881: LD_INT 1
 883: ARRAY
 884: ARRAY
 885: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 886: LD_ADDR_EXP 11
 890: PUSH
 891: LD_INT 2
 893: PUSH
 894: LD_INT 4
 896: PUSH
 897: LD_INT 6
 899: PUSH
 900: LD_INT 8
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: PUSH
 909: LD_EXP 16
 913: PUSH
 914: LD_INT 2
 916: ARRAY
 917: ARRAY
 918: ST_TO_ADDR
// crates_spawn := [ 0 0$20 , 0 0$15 , 0 0$10 , 0 0$07 ] [ definitions [ 3 ] ] ;
 919: LD_ADDR_EXP 12
 923: PUSH
 924: LD_INT 700
 926: PUSH
 927: LD_INT 525
 929: PUSH
 930: LD_INT 350
 932: PUSH
 933: LD_INT 245
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PUSH
 942: LD_EXP 16
 946: PUSH
 947: LD_INT 3
 949: ARRAY
 950: ARRAY
 951: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 , 5 5$00 , 3 3$0 ] [ definitions [ 4 ] ] ;
 952: LD_ADDR_EXP 13
 956: PUSH
 957: LD_INT 0
 959: PUSH
 960: LD_INT 10500
 962: PUSH
 963: LD_INT 6300
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: LIST
 970: PUSH
 971: LD_EXP 16
 975: PUSH
 976: LD_INT 4
 978: ARRAY
 979: ARRAY
 980: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 , 15 15$00 , 5 5$0 ] [ definitions [ 4 ] ] ;
 981: LD_ADDR_EXP 14
 985: PUSH
 986: LD_INT 0
 988: PUSH
 989: LD_INT 31500
 991: PUSH
 992: LD_INT 10500
 994: PUSH
 995: EMPTY
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_EXP 16
1004: PUSH
1005: LD_INT 4
1007: ARRAY
1008: ARRAY
1009: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 5 ] ] ;
1010: LD_ADDR_EXP 15
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 3
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 7
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: LD_EXP 16
1037: PUSH
1038: LD_INT 5
1040: ARRAY
1041: ARRAY
1042: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 6 ] ] ;
1043: LD_ADDR_OWVAR 67
1047: PUSH
1048: LD_INT 1
1050: PUSH
1051: LD_INT 2
1053: PUSH
1054: LD_INT 3
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_EXP 16
1066: PUSH
1067: LD_INT 6
1069: ARRAY
1070: ARRAY
1071: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 7 ] ] ;
1072: LD_ADDR_EXP 26
1076: PUSH
1077: LD_INT 0
1079: PUSH
1080: LD_INT 1
1082: PUSH
1083: LD_INT 2
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: PUSH
1091: LD_EXP 16
1095: PUSH
1096: LD_INT 7
1098: ARRAY
1099: ARRAY
1100: ST_TO_ADDR
// queue_codes := [ 11353 , 12244 , 44444 , 12345 , 43413 , 14152 ] ;
1101: LD_ADDR_EXP 23
1105: PUSH
1106: LD_INT 11353
1108: PUSH
1109: LD_INT 12244
1111: PUSH
1112: LD_INT 44444
1114: PUSH
1115: LD_INT 12345
1117: PUSH
1118: LD_INT 43413
1120: PUSH
1121: LD_INT 14152
1123: PUSH
1124: EMPTY
1125: LIST
1126: LIST
1127: LIST
1128: LIST
1129: LIST
1130: LIST
1131: ST_TO_ADDR
// rng := Rand ( 1 , 6 ) ;
1132: LD_ADDR_EXP 24
1136: PUSH
1137: LD_INT 1
1139: PPUSH
1140: LD_INT 6
1142: PPUSH
1143: CALL_OW 12
1147: ST_TO_ADDR
// if bot_side <> 2 then
1148: LD_EXP 8
1152: PUSH
1153: LD_INT 2
1155: NONEQUAL
1156: IFFALSE 1199
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1158: LD_ADDR_VAR 0 2
1162: PUSH
1163: LD_INT 22
1165: PUSH
1166: LD_INT 2
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: PPUSH
1173: CALL_OW 69
1177: PUSH
1178: FOR_IN
1179: IFFALSE 1197
// SetSide ( i , bot_side ) ;
1181: LD_VAR 0 2
1185: PPUSH
1186: LD_EXP 8
1190: PPUSH
1191: CALL_OW 235
1195: GO 1178
1197: POP
1198: POP
// ResetFog ;
1199: CALL_OW 335
// PreparePeople ( ) ;
1203: CALL 2039 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1207: LD_ADDR_EXP 18
1211: PUSH
1212: LD_INT 14
1214: PUSH
1215: LD_INT 15
1217: PUSH
1218: LD_INT 16
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: ST_TO_ADDR
// if amount_of_apeman then
1226: LD_EXP 15
1230: IFFALSE 1280
// for j in apeman_areas do
1232: LD_ADDR_VAR 0 3
1236: PUSH
1237: LD_EXP 18
1241: PUSH
1242: FOR_IN
1243: IFFALSE 1278
// for i = 1 to amount_of_apeman do
1245: LD_ADDR_VAR 0 2
1249: PUSH
1250: DOUBLE
1251: LD_INT 1
1253: DEC
1254: ST_TO_ADDR
1255: LD_EXP 15
1259: PUSH
1260: FOR_TO
1261: IFFALSE 1274
// AddApeman ( j ) ;
1263: LD_VAR 0 3
1267: PPUSH
1268: CALL 2975 0 1
1272: GO 1260
1274: POP
1275: POP
1276: GO 1242
1278: POP
1279: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1280: LD_INT 22
1282: PUSH
1283: LD_OWVAR 2
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: PPUSH
1292: CALL_OW 69
1296: PUSH
1297: LD_INT 1
1299: ARRAY
1300: PPUSH
1301: CALL_OW 87
// disable ( 17 ) ;
1305: LD_INT 17
1307: DISABLE_MARKED
// end ;
1308: LD_VAR 0 1
1312: RET
// every 3 3$40 trigger game_start do
1313: LD_EXP 9
1317: IFFALSE 1373
1319: GO 1321
1321: DISABLE
// begin CreateCratesArea ( tick mod 5 + 1 , kabul_crates , true ) ;
1322: LD_OWVAR 1
1326: PUSH
1327: LD_INT 5
1329: MOD
1330: PUSH
1331: LD_INT 1
1333: PLUS
1334: PPUSH
1335: LD_INT 13
1337: PPUSH
1338: LD_INT 1
1340: PPUSH
1341: CALL_OW 55
// Wait ( 0 0$15 ) ;
1345: LD_INT 525
1347: PPUSH
1348: CALL_OW 67
// CreateCratesAnywhere ( tick mod 5 + 1 , true ) ;
1352: LD_OWVAR 1
1356: PUSH
1357: LD_INT 5
1359: MOD
1360: PUSH
1361: LD_INT 1
1363: PLUS
1364: PPUSH
1365: LD_INT 1
1367: PPUSH
1368: CALL_OW 57
// enable ;
1372: ENABLE
// end ;
1373: END
// every 0 0$01 + 0 0$10 trigger game_start do var cr , cr_queue ;
1374: LD_EXP 9
1378: IFFALSE 2036
1380: GO 1382
1382: DISABLE
1383: LD_INT 0
1385: PPUSH
1386: PPUSH
// begin cr := 1 ;
1387: LD_ADDR_VAR 0 1
1391: PUSH
1392: LD_INT 1
1394: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1395: LD_ADDR_VAR 0 2
1399: PUSH
1400: LD_INT 1
1402: PPUSH
1403: LD_INT 3
1405: PPUSH
1406: CALL_OW 12
1410: PUSH
1411: LD_INT 2
1413: PPUSH
1414: LD_INT 4
1416: PPUSH
1417: CALL_OW 12
1421: PUSH
1422: LD_INT 3
1424: PPUSH
1425: LD_INT 5
1427: PPUSH
1428: CALL_OW 12
1432: PUSH
1433: LD_INT 3
1435: PPUSH
1436: LD_INT 5
1438: PPUSH
1439: CALL_OW 12
1443: PUSH
1444: LD_INT 2
1446: PPUSH
1447: LD_INT 5
1449: PPUSH
1450: CALL_OW 12
1454: PUSH
1455: LD_INT 1
1457: PPUSH
1458: LD_INT 5
1460: PPUSH
1461: CALL_OW 12
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: ST_TO_ADDR
// while ( true ) do
1474: LD_INT 1
1476: IFFALSE 2036
// begin Wait ( crates_spawn * cr + ( tick mod 35 * 60 ) ) ;
1478: LD_EXP 12
1482: PUSH
1483: LD_VAR 0 1
1487: MUL
1488: PUSH
1489: LD_OWVAR 1
1493: PUSH
1494: LD_INT 35
1496: MOD
1497: PUSH
1498: LD_INT 60
1500: MUL
1501: PLUS
1502: PPUSH
1503: CALL_OW 67
// if cr mod 3 = 0 then
1507: LD_VAR 0 1
1511: PUSH
1512: LD_INT 3
1514: MOD
1515: PUSH
1516: LD_INT 0
1518: EQUAL
1519: IFFALSE 1672
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1521: LD_VAR 0 2
1525: PUSH
1526: LD_VAR 0 1
1530: PUSH
1531: LD_VAR 0 2
1535: MOD
1536: PUSH
1537: LD_INT 1
1539: PLUS
1540: ARRAY
1541: PPUSH
1542: LD_INT 17
1544: PPUSH
1545: LD_INT 1
1547: PPUSH
1548: CALL_OW 55
// Wait ( crates_spawn ) ;
1552: LD_EXP 12
1556: PPUSH
1557: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1561: LD_VAR 0 2
1565: PUSH
1566: LD_VAR 0 1
1570: PUSH
1571: LD_VAR 0 2
1575: MOD
1576: PUSH
1577: LD_INT 1
1579: PLUS
1580: ARRAY
1581: PPUSH
1582: LD_INT 18
1584: PPUSH
1585: LD_INT 1
1587: PPUSH
1588: CALL_OW 55
// Wait ( crates_spawn ) ;
1592: LD_EXP 12
1596: PPUSH
1597: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1601: LD_VAR 0 2
1605: PUSH
1606: LD_VAR 0 1
1610: PUSH
1611: LD_VAR 0 2
1615: MOD
1616: PUSH
1617: LD_INT 1
1619: PLUS
1620: ARRAY
1621: PPUSH
1622: LD_INT 19
1624: PPUSH
1625: LD_INT 1
1627: PPUSH
1628: CALL_OW 55
// Wait ( crates_spawn ) ;
1632: LD_EXP 12
1636: PPUSH
1637: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1641: LD_VAR 0 2
1645: PUSH
1646: LD_VAR 0 1
1650: PUSH
1651: LD_VAR 0 2
1655: MOD
1656: PUSH
1657: LD_INT 1
1659: PLUS
1660: ARRAY
1661: PPUSH
1662: LD_INT 17
1664: PPUSH
1665: LD_INT 1
1667: PPUSH
1668: CALL_OW 55
// end ; if cr mod 3 = 1 then
1672: LD_VAR 0 1
1676: PUSH
1677: LD_INT 3
1679: MOD
1680: PUSH
1681: LD_INT 1
1683: EQUAL
1684: IFFALSE 1837
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1686: LD_VAR 0 2
1690: PUSH
1691: LD_VAR 0 1
1695: PUSH
1696: LD_VAR 0 2
1700: MOD
1701: PUSH
1702: LD_INT 1
1704: PLUS
1705: ARRAY
1706: PPUSH
1707: LD_INT 18
1709: PPUSH
1710: LD_INT 1
1712: PPUSH
1713: CALL_OW 55
// Wait ( crates_spawn ) ;
1717: LD_EXP 12
1721: PPUSH
1722: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1726: LD_VAR 0 2
1730: PUSH
1731: LD_VAR 0 1
1735: PUSH
1736: LD_VAR 0 2
1740: MOD
1741: PUSH
1742: LD_INT 1
1744: PLUS
1745: ARRAY
1746: PPUSH
1747: LD_INT 17
1749: PPUSH
1750: LD_INT 1
1752: PPUSH
1753: CALL_OW 55
// Wait ( crates_spawn ) ;
1757: LD_EXP 12
1761: PPUSH
1762: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1766: LD_VAR 0 2
1770: PUSH
1771: LD_VAR 0 1
1775: PUSH
1776: LD_VAR 0 2
1780: MOD
1781: PUSH
1782: LD_INT 1
1784: PLUS
1785: ARRAY
1786: PPUSH
1787: LD_INT 19
1789: PPUSH
1790: LD_INT 1
1792: PPUSH
1793: CALL_OW 55
// Wait ( crates_spawn ) ;
1797: LD_EXP 12
1801: PPUSH
1802: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1806: LD_VAR 0 2
1810: PUSH
1811: LD_VAR 0 1
1815: PUSH
1816: LD_VAR 0 2
1820: MOD
1821: PUSH
1822: LD_INT 1
1824: PLUS
1825: ARRAY
1826: PPUSH
1827: LD_INT 18
1829: PPUSH
1830: LD_INT 1
1832: PPUSH
1833: CALL_OW 55
// end ; if cr mod 3 = 2 then
1837: LD_VAR 0 1
1841: PUSH
1842: LD_INT 3
1844: MOD
1845: PUSH
1846: LD_INT 2
1848: EQUAL
1849: IFFALSE 2002
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1851: LD_VAR 0 2
1855: PUSH
1856: LD_VAR 0 1
1860: PUSH
1861: LD_VAR 0 2
1865: MOD
1866: PUSH
1867: LD_INT 1
1869: PLUS
1870: ARRAY
1871: PPUSH
1872: LD_INT 19
1874: PPUSH
1875: LD_INT 1
1877: PPUSH
1878: CALL_OW 55
// Wait ( crates_spawn ) ;
1882: LD_EXP 12
1886: PPUSH
1887: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1891: LD_VAR 0 2
1895: PUSH
1896: LD_VAR 0 1
1900: PUSH
1901: LD_VAR 0 2
1905: MOD
1906: PUSH
1907: LD_INT 1
1909: PLUS
1910: ARRAY
1911: PPUSH
1912: LD_INT 18
1914: PPUSH
1915: LD_INT 1
1917: PPUSH
1918: CALL_OW 55
// Wait ( crates_spawn ) ;
1922: LD_EXP 12
1926: PPUSH
1927: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1931: LD_VAR 0 2
1935: PUSH
1936: LD_VAR 0 1
1940: PUSH
1941: LD_VAR 0 2
1945: MOD
1946: PUSH
1947: LD_INT 1
1949: PLUS
1950: ARRAY
1951: PPUSH
1952: LD_INT 17
1954: PPUSH
1955: LD_INT 1
1957: PPUSH
1958: CALL_OW 55
// Wait ( crates_spawn ) ;
1962: LD_EXP 12
1966: PPUSH
1967: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1971: LD_VAR 0 2
1975: PUSH
1976: LD_VAR 0 1
1980: PUSH
1981: LD_VAR 0 2
1985: MOD
1986: PUSH
1987: LD_INT 1
1989: PLUS
1990: ARRAY
1991: PPUSH
1992: LD_INT 19
1994: PPUSH
1995: LD_INT 1
1997: PPUSH
1998: CALL_OW 55
// end ; cr := cr + 1 ;
2002: LD_ADDR_VAR 0 1
2006: PUSH
2007: LD_VAR 0 1
2011: PUSH
2012: LD_INT 1
2014: PLUS
2015: ST_TO_ADDR
// if cr > 150 then
2016: LD_VAR 0 1
2020: PUSH
2021: LD_INT 150
2023: GREATER
2024: IFFALSE 2034
// cr := 43 ;
2026: LD_ADDR_VAR 0 1
2030: PUSH
2031: LD_INT 43
2033: ST_TO_ADDR
// end ;
2034: GO 1474
// end ; end_of_file
2036: PPOPN 2
2038: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
2039: LD_INT 0
2041: PPUSH
2042: PPUSH
2043: PPUSH
2044: PPUSH
2045: PPUSH
2046: PPUSH
2047: PPUSH
2048: PPUSH
2049: PPUSH
// to_copy := [ ] ;
2050: LD_ADDR_VAR 0 5
2054: PUSH
2055: EMPTY
2056: ST_TO_ADDR
// for i = 1 to 8 do
2057: LD_ADDR_VAR 0 2
2061: PUSH
2062: DOUBLE
2063: LD_INT 1
2065: DEC
2066: ST_TO_ADDR
2067: LD_INT 8
2069: PUSH
2070: FOR_TO
2071: IFFALSE 2968
// begin if Side_Positions [ i ] then
2073: LD_EXP 2
2077: PUSH
2078: LD_VAR 0 2
2082: ARRAY
2083: IFFALSE 2966
// begin uc_side := i ;
2085: LD_ADDR_OWVAR 20
2089: PUSH
2090: LD_VAR 0 2
2094: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
2095: LD_ADDR_OWVAR 21
2099: PUSH
2100: LD_EXP 4
2104: PUSH
2105: LD_VAR 0 2
2109: ARRAY
2110: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
2111: LD_ADDR_VAR 0 6
2115: PUSH
2116: LD_EXP 7
2120: PUSH
2121: LD_EXP 2
2125: PUSH
2126: LD_VAR 0 2
2130: ARRAY
2131: ARRAY
2132: PUSH
2133: LD_INT 1
2135: ARRAY
2136: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
2137: LD_ADDR_VAR 0 7
2141: PUSH
2142: LD_EXP 7
2146: PUSH
2147: LD_EXP 2
2151: PUSH
2152: LD_VAR 0 2
2156: ARRAY
2157: ARRAY
2158: PUSH
2159: LD_INT 2
2161: ARRAY
2162: ST_TO_ADDR
// hc_importance := 100 ;
2163: LD_ADDR_OWVAR 32
2167: PUSH
2168: LD_INT 100
2170: ST_TO_ADDR
// if Multiplayer then
2171: LD_OWVAR 4
2175: IFFALSE 2233
// begin hc_name := mp_sides_players_names [ uc_side ] ;
2177: LD_ADDR_OWVAR 26
2181: PUSH
2182: LD_OWVAR 19
2186: PUSH
2187: LD_OWVAR 20
2191: ARRAY
2192: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2193: LD_ADDR_OWVAR 33
2197: PUSH
2198: LD_STRING MULTIAVATARS
2200: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
2201: LD_ADDR_OWVAR 34
2205: PUSH
2206: LD_OWVAR 20
2210: PPUSH
2211: CALL_OW 525
2215: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
2216: LD_ADDR_OWVAR 27
2220: PUSH
2221: LD_OWVAR 20
2225: PPUSH
2226: CALL_OW 526
2230: ST_TO_ADDR
// end else
2231: GO 2265
// begin hc_name :=  ;
2233: LD_ADDR_OWVAR 26
2237: PUSH
2238: LD_STRING 
2240: ST_TO_ADDR
// hc_gallery :=  ;
2241: LD_ADDR_OWVAR 33
2245: PUSH
2246: LD_STRING 
2248: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
2249: LD_ADDR_OWVAR 27
2253: PUSH
2254: LD_INT 1
2256: PPUSH
2257: LD_INT 2
2259: PPUSH
2260: CALL_OW 12
2264: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
2265: LD_OWVAR 27
2269: PPUSH
2270: LD_INT 1
2272: PPUSH
2273: LD_EXP 11
2277: PPUSH
2278: CALL_OW 380
// un := CreateHuman ;
2282: LD_ADDR_VAR 0 4
2286: PUSH
2287: CALL_OW 44
2291: ST_TO_ADDR
// if not to_copy then
2292: LD_VAR 0 5
2296: NOT
2297: IFFALSE 2324
// to_copy := Replace ( to_copy , 1 , un ) else
2299: LD_ADDR_VAR 0 5
2303: PUSH
2304: LD_VAR 0 5
2308: PPUSH
2309: LD_INT 1
2311: PPUSH
2312: LD_VAR 0 4
2316: PPUSH
2317: CALL_OW 1
2321: ST_TO_ADDR
2322: GO 2400
// begin CopySkills ( to_copy [ 1 ] , un ) ;
2324: LD_VAR 0 5
2328: PUSH
2329: LD_INT 1
2331: ARRAY
2332: PPUSH
2333: LD_VAR 0 4
2337: PPUSH
2338: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
2342: LD_VAR 0 4
2346: PPUSH
2347: LD_INT 2
2349: PPUSH
2350: LD_VAR 0 5
2354: PUSH
2355: LD_INT 1
2357: ARRAY
2358: PPUSH
2359: LD_INT 2
2361: PPUSH
2362: CALL_OW 260
2366: PPUSH
2367: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
2371: LD_VAR 0 4
2375: PPUSH
2376: LD_INT 1
2378: PPUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_INT 1
2386: ARRAY
2387: PPUSH
2388: LD_INT 1
2390: PPUSH
2391: CALL_OW 260
2395: PPUSH
2396: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2400: LD_VAR 0 4
2404: PPUSH
2405: LD_VAR 0 6
2409: PPUSH
2410: LD_VAR 0 7
2414: PPUSH
2415: LD_INT 10
2417: PPUSH
2418: LD_INT 0
2420: PPUSH
2421: CALL_OW 50
// hc_importance := 0 ;
2425: LD_ADDR_OWVAR 32
2429: PUSH
2430: LD_INT 0
2432: ST_TO_ADDR
// hc_name :=  ;
2433: LD_ADDR_OWVAR 26
2437: PUSH
2438: LD_STRING 
2440: ST_TO_ADDR
// hc_gallery :=  ;
2441: LD_ADDR_OWVAR 33
2445: PUSH
2446: LD_STRING 
2448: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
2449: LD_ADDR_VAR 0 9
2453: PUSH
2454: LD_EXP 10
2458: PUSH
2459: LD_INT 1
2461: MINUS
2462: PUSH
2463: LD_INT 4
2465: DIVREAL
2466: ST_TO_ADDR
// c := 1 ;
2467: LD_ADDR_VAR 0 8
2471: PUSH
2472: LD_INT 1
2474: ST_TO_ADDR
// for j = 2 to number_of_people do
2475: LD_ADDR_VAR 0 3
2479: PUSH
2480: DOUBLE
2481: LD_INT 2
2483: DEC
2484: ST_TO_ADDR
2485: LD_EXP 10
2489: PUSH
2490: FOR_TO
2491: IFFALSE 2702
// begin PrepareHuman ( false , c , skill_level ) ;
2493: LD_INT 0
2495: PPUSH
2496: LD_VAR 0 8
2500: PPUSH
2501: LD_EXP 11
2505: PPUSH
2506: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
2510: LD_VAR 0 3
2514: PUSH
2515: LD_INT 1
2517: MINUS
2518: PUSH
2519: LD_VAR 0 9
2523: MOD
2524: PUSH
2525: LD_INT 0
2527: EQUAL
2528: IFFALSE 2544
// c := c + 1 ;
2530: LD_ADDR_VAR 0 8
2534: PUSH
2535: LD_VAR 0 8
2539: PUSH
2540: LD_INT 1
2542: PLUS
2543: ST_TO_ADDR
// un := CreateHuman ;
2544: LD_ADDR_VAR 0 4
2548: PUSH
2549: CALL_OW 44
2553: ST_TO_ADDR
// if to_copy < j then
2554: LD_VAR 0 5
2558: PUSH
2559: LD_VAR 0 3
2563: LESS
2564: IFFALSE 2593
// to_copy := Replace ( to_copy , j , un ) else
2566: LD_ADDR_VAR 0 5
2570: PUSH
2571: LD_VAR 0 5
2575: PPUSH
2576: LD_VAR 0 3
2580: PPUSH
2581: LD_VAR 0 4
2585: PPUSH
2586: CALL_OW 1
2590: ST_TO_ADDR
2591: GO 2675
// begin CopySkills ( to_copy [ j ] , un ) ;
2593: LD_VAR 0 5
2597: PUSH
2598: LD_VAR 0 3
2602: ARRAY
2603: PPUSH
2604: LD_VAR 0 4
2608: PPUSH
2609: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
2613: LD_VAR 0 4
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_VAR 0 5
2625: PUSH
2626: LD_VAR 0 3
2630: ARRAY
2631: PPUSH
2632: LD_INT 2
2634: PPUSH
2635: CALL_OW 260
2639: PPUSH
2640: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
2644: LD_VAR 0 4
2648: PPUSH
2649: LD_INT 1
2651: PPUSH
2652: LD_VAR 0 5
2656: PUSH
2657: LD_VAR 0 3
2661: ARRAY
2662: PPUSH
2663: LD_INT 1
2665: PPUSH
2666: CALL_OW 260
2670: PPUSH
2671: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2675: LD_VAR 0 4
2679: PPUSH
2680: LD_VAR 0 6
2684: PPUSH
2685: LD_VAR 0 7
2689: PPUSH
2690: LD_INT 10
2692: PPUSH
2693: LD_INT 0
2695: PPUSH
2696: CALL_OW 50
// end ;
2700: GO 2490
2702: POP
2703: POP
// if handicap then
2704: LD_EXP 26
2708: IFFALSE 2966
// begin if handicap = 1 then
2710: LD_EXP 26
2714: PUSH
2715: LD_INT 1
2717: EQUAL
2718: IFFALSE 2797
// for j = 1 to 2 do
2720: LD_ADDR_VAR 0 3
2724: PUSH
2725: DOUBLE
2726: LD_INT 1
2728: DEC
2729: ST_TO_ADDR
2730: LD_INT 2
2732: PUSH
2733: FOR_TO
2734: IFFALSE 2795
// begin vc_chassis := ru_medium_tracked ;
2736: LD_ADDR_OWVAR 37
2740: PUSH
2741: LD_INT 22
2743: ST_TO_ADDR
// vc_engine := engine_siberite ;
2744: LD_ADDR_OWVAR 39
2748: PUSH
2749: LD_INT 3
2751: ST_TO_ADDR
// vc_control := control_manual ;
2752: LD_ADDR_OWVAR 38
2756: PUSH
2757: LD_INT 1
2759: ST_TO_ADDR
// vc_weapon := ru_gun ;
2760: LD_ADDR_OWVAR 40
2764: PUSH
2765: LD_INT 44
2767: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2768: CALL_OW 45
2772: PPUSH
2773: LD_VAR 0 6
2777: PPUSH
2778: LD_VAR 0 7
2782: PPUSH
2783: LD_INT 13
2785: PPUSH
2786: LD_INT 0
2788: PPUSH
2789: CALL_OW 50
// end ;
2793: GO 2733
2795: POP
2796: POP
// if handicap = 2 then
2797: LD_EXP 26
2801: PUSH
2802: LD_INT 2
2804: EQUAL
2805: IFFALSE 2966
// begin for j = 1 to 2 do
2807: LD_ADDR_VAR 0 3
2811: PUSH
2812: DOUBLE
2813: LD_INT 1
2815: DEC
2816: ST_TO_ADDR
2817: LD_INT 2
2819: PUSH
2820: FOR_TO
2821: IFFALSE 2882
// begin vc_chassis := ru_heavy_tracked ;
2823: LD_ADDR_OWVAR 37
2827: PUSH
2828: LD_INT 24
2830: ST_TO_ADDR
// vc_engine := engine_siberite ;
2831: LD_ADDR_OWVAR 39
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// vc_control := control_manual ;
2839: LD_ADDR_OWVAR 38
2843: PUSH
2844: LD_INT 1
2846: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 46
2854: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2855: CALL_OW 45
2859: PPUSH
2860: LD_VAR 0 6
2864: PPUSH
2865: LD_VAR 0 7
2869: PPUSH
2870: LD_INT 13
2872: PPUSH
2873: LD_INT 0
2875: PPUSH
2876: CALL_OW 50
// end ;
2880: GO 2820
2882: POP
2883: POP
// vc_chassis := ru_medium_tracked ;
2884: LD_ADDR_OWVAR 37
2888: PUSH
2889: LD_INT 22
2891: ST_TO_ADDR
// vc_engine := engine_siberite ;
2892: LD_ADDR_OWVAR 39
2896: PUSH
2897: LD_INT 3
2899: ST_TO_ADDR
// vc_control := control_computer ;
2900: LD_ADDR_OWVAR 38
2904: PUSH
2905: LD_INT 3
2907: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2908: LD_ADDR_OWVAR 40
2912: PUSH
2913: LD_INT 51
2915: ST_TO_ADDR
// un := CreateVehicle ;
2916: LD_ADDR_VAR 0 4
2920: PUSH
2921: CALL_OW 45
2925: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , 13 , false ) ;
2926: LD_VAR 0 4
2930: PPUSH
2931: LD_VAR 0 6
2935: PPUSH
2936: LD_VAR 0 7
2940: PPUSH
2941: LD_INT 13
2943: PPUSH
2944: LD_INT 0
2946: PPUSH
2947: CALL_OW 50
// SetCargo ( un , mat_cans , 100 ) ;
2951: LD_VAR 0 4
2955: PPUSH
2956: LD_INT 1
2958: PPUSH
2959: LD_INT 100
2961: PPUSH
2962: CALL_OW 290
// end ; end ; end ; end ;
2966: GO 2070
2968: POP
2969: POP
// end ;
2970: LD_VAR 0 1
2974: RET
// export function AddApeman ( area ) ; begin
2975: LD_INT 0
2977: PPUSH
// uc_nation := 0 ;
2978: LD_ADDR_OWVAR 21
2982: PUSH
2983: LD_INT 0
2985: ST_TO_ADDR
// uc_side := 0 ;
2986: LD_ADDR_OWVAR 20
2990: PUSH
2991: LD_INT 0
2993: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
2994: LD_ADDR_OWVAR 35
2998: PUSH
2999: LD_INT 10
3001: NEG
3002: PPUSH
3003: LD_INT 15
3005: PPUSH
3006: CALL_OW 12
3010: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
3011: LD_INT 0
3013: PPUSH
3014: LD_INT 12
3016: PPUSH
3017: LD_INT 0
3019: PPUSH
3020: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3024: LD_ADDR_OWVAR 29
3028: PUSH
3029: LD_INT 10
3031: PUSH
3032: LD_INT 12
3034: PUSH
3035: EMPTY
3036: LIST
3037: LIST
3038: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
3039: CALL_OW 44
3043: PPUSH
3044: LD_VAR 0 1
3048: PPUSH
3049: LD_INT 0
3051: PPUSH
3052: CALL_OW 49
// end ;
3056: LD_VAR 0 2
3060: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
3061: LD_INT 0
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
// r := 100 ;
3067: LD_ADDR_VAR 0 5
3071: PUSH
3072: LD_INT 100
3074: ST_TO_ADDR
// x := 0 ;
3075: LD_ADDR_VAR 0 6
3079: PUSH
3080: LD_INT 0
3082: ST_TO_ADDR
// while ( x < n ) do
3083: LD_VAR 0 6
3087: PUSH
3088: LD_VAR 0 2
3092: LESS
3093: IFFALSE 3408
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
3095: LD_ADDR_VAR 0 4
3099: PUSH
3100: DOUBLE
3101: LD_INT 1
3103: DEC
3104: ST_TO_ADDR
3105: LD_VAR 0 1
3109: PPUSH
3110: LD_INT 0
3112: PPUSH
3113: CALL_OW 517
3117: PUSH
3118: LD_INT 1
3120: ARRAY
3121: PUSH
3122: FOR_TO
3123: IFFALSE 3404
// begin if r > 50 then
3125: LD_VAR 0 5
3129: PUSH
3130: LD_INT 50
3132: GREATER
3133: IFFALSE 3380
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
3135: LD_VAR 0 1
3139: PPUSH
3140: LD_INT 0
3142: PPUSH
3143: CALL_OW 517
3147: PUSH
3148: LD_INT 1
3150: ARRAY
3151: PUSH
3152: LD_VAR 0 4
3156: ARRAY
3157: PPUSH
3158: LD_VAR 0 1
3162: PPUSH
3163: LD_INT 0
3165: PPUSH
3166: CALL_OW 517
3170: PUSH
3171: LD_INT 2
3173: ARRAY
3174: PUSH
3175: LD_VAR 0 4
3179: ARRAY
3180: PPUSH
3181: CALL_OW 458
3185: NOT
3186: IFFALSE 3364
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
3188: LD_VAR 0 1
3192: PPUSH
3193: LD_INT 0
3195: PPUSH
3196: CALL_OW 517
3200: PUSH
3201: LD_INT 1
3203: ARRAY
3204: PUSH
3205: LD_VAR 0 4
3209: ARRAY
3210: PPUSH
3211: LD_VAR 0 1
3215: PPUSH
3216: LD_INT 0
3218: PPUSH
3219: CALL_OW 517
3223: PUSH
3224: LD_INT 2
3226: ARRAY
3227: PUSH
3228: LD_VAR 0 4
3232: ARRAY
3233: PPUSH
3234: LD_EXP 8
3238: PPUSH
3239: LD_INT 0
3241: PPUSH
3242: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
3246: LD_ADDR_EXP 17
3250: PUSH
3251: LD_EXP 17
3255: PPUSH
3256: LD_EXP 17
3260: PUSH
3261: LD_INT 1
3263: PLUS
3264: PPUSH
3265: LD_VAR 0 1
3269: PPUSH
3270: LD_INT 0
3272: PPUSH
3273: CALL_OW 517
3277: PUSH
3278: LD_INT 1
3280: ARRAY
3281: PUSH
3282: LD_VAR 0 4
3286: ARRAY
3287: PPUSH
3288: CALL_OW 2
3292: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
3293: LD_ADDR_EXP 17
3297: PUSH
3298: LD_EXP 17
3302: PPUSH
3303: LD_EXP 17
3307: PUSH
3308: LD_INT 1
3310: PLUS
3311: PPUSH
3312: LD_VAR 0 1
3316: PPUSH
3317: LD_INT 0
3319: PPUSH
3320: CALL_OW 517
3324: PUSH
3325: LD_INT 2
3327: ARRAY
3328: PUSH
3329: LD_VAR 0 4
3333: ARRAY
3334: PPUSH
3335: CALL_OW 2
3339: ST_TO_ADDR
// r := 0 ;
3340: LD_ADDR_VAR 0 5
3344: PUSH
3345: LD_INT 0
3347: ST_TO_ADDR
// x := x + 1 ;
3348: LD_ADDR_VAR 0 6
3352: PUSH
3353: LD_VAR 0 6
3357: PUSH
3358: LD_INT 1
3360: PLUS
3361: ST_TO_ADDR
// end else
3362: GO 3378
// r := r + 35 ;
3364: LD_ADDR_VAR 0 5
3368: PUSH
3369: LD_VAR 0 5
3373: PUSH
3374: LD_INT 35
3376: PLUS
3377: ST_TO_ADDR
// end else
3378: GO 3402
// r := r + rand ( 10 , 25 ) ;
3380: LD_ADDR_VAR 0 5
3384: PUSH
3385: LD_VAR 0 5
3389: PUSH
3390: LD_INT 10
3392: PPUSH
3393: LD_INT 25
3395: PPUSH
3396: CALL_OW 12
3400: PLUS
3401: ST_TO_ADDR
// end ;
3402: GO 3122
3404: POP
3405: POP
3406: GO 3083
// end ;
3408: LD_VAR 0 3
3412: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
3413: LD_INT 0
3415: PPUSH
3416: PPUSH
3417: PPUSH
// if not GetControl ( veh ) = control_manual then
3418: LD_VAR 0 1
3422: PPUSH
3423: CALL_OW 263
3427: PUSH
3428: LD_INT 1
3430: EQUAL
3431: NOT
3432: IFFALSE 3444
// result := false else
3434: LD_ADDR_VAR 0 2
3438: PUSH
3439: LD_INT 0
3441: ST_TO_ADDR
3442: GO 3589
// if veh in FilterAllUnits ( [ f_empty ] ) then
3444: LD_VAR 0 1
3448: PUSH
3449: LD_INT 58
3451: PUSH
3452: EMPTY
3453: LIST
3454: PPUSH
3455: CALL_OW 69
3459: IN
3460: IFFALSE 3472
// result := false else
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: LD_INT 0
3469: ST_TO_ADDR
3470: GO 3589
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3472: LD_ADDR_VAR 0 4
3476: PUSH
3477: LD_INT 22
3479: PUSH
3480: LD_VAR 0 1
3484: PPUSH
3485: CALL_OW 255
3489: PUSH
3490: EMPTY
3491: LIST
3492: LIST
3493: PUSH
3494: LD_INT 55
3496: PUSH
3497: EMPTY
3498: LIST
3499: PUSH
3500: EMPTY
3501: LIST
3502: LIST
3503: PPUSH
3504: CALL_OW 69
3508: ST_TO_ADDR
// if not filter then
3509: LD_VAR 0 4
3513: NOT
3514: IFFALSE 3526
// result := false else
3516: LD_ADDR_VAR 0 2
3520: PUSH
3521: LD_INT 0
3523: ST_TO_ADDR
3524: GO 3589
// for i = 1 to filter do
3526: LD_ADDR_VAR 0 3
3530: PUSH
3531: DOUBLE
3532: LD_INT 1
3534: DEC
3535: ST_TO_ADDR
3536: LD_VAR 0 4
3540: PUSH
3541: FOR_TO
3542: IFFALSE 3587
// if IsDriver ( filter [ i ] ) = veh then
3544: LD_VAR 0 4
3548: PUSH
3549: LD_VAR 0 3
3553: ARRAY
3554: PPUSH
3555: CALL 3594 0 1
3559: PUSH
3560: LD_VAR 0 1
3564: EQUAL
3565: IFFALSE 3585
// begin result := filter [ i ] ;
3567: LD_ADDR_VAR 0 2
3571: PUSH
3572: LD_VAR 0 4
3576: PUSH
3577: LD_VAR 0 3
3581: ARRAY
3582: ST_TO_ADDR
// break ;
3583: GO 3587
// end ;
3585: GO 3541
3587: POP
3588: POP
// end ; end ;
3589: LD_VAR 0 2
3593: RET
// export function IsDriver ( unit ) ; begin
3594: LD_INT 0
3596: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
3597: LD_VAR 0 1
3601: PUSH
3602: LD_INT 55
3604: PUSH
3605: EMPTY
3606: LIST
3607: PPUSH
3608: CALL_OW 69
3612: IN
3613: IFFALSE 3632
// result := IsInUnit ( unit ) else
3615: LD_ADDR_VAR 0 2
3619: PUSH
3620: LD_VAR 0 1
3624: PPUSH
3625: CALL_OW 310
3629: ST_TO_ADDR
3630: GO 3640
// result := false ;
3632: LD_ADDR_VAR 0 2
3636: PUSH
3637: LD_INT 0
3639: ST_TO_ADDR
// end ; end_of_file
3640: LD_VAR 0 2
3644: RET
// export function InitBot ; var i , ct , hex , side , un , veh , weapons , skill ; begin
3645: LD_INT 0
3647: PPUSH
3648: PPUSH
3649: PPUSH
3650: PPUSH
3651: PPUSH
3652: PPUSH
3653: PPUSH
3654: PPUSH
3655: PPUSH
// side := Bot_Side ;
3656: LD_ADDR_VAR 0 5
3660: PUSH
3661: LD_EXP 8
3665: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
3666: LD_ADDR_VAR 0 9
3670: PUSH
3671: LD_INT 4
3673: PUSH
3674: LD_INT 6
3676: PUSH
3677: LD_INT 8
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: LIST
3684: PUSH
3685: LD_OWVAR 67
3689: ARRAY
3690: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
3691: LD_ADDR_VAR 0 8
3695: PUSH
3696: LD_INT 27
3698: PUSH
3699: LD_INT 28
3701: PUSH
3702: LD_INT 25
3704: PUSH
3705: LD_INT 26
3707: PUSH
3708: EMPTY
3709: LIST
3710: LIST
3711: LIST
3712: LIST
3713: ST_TO_ADDR
// veh_counter := [ 4 , 5 , 6 ] [ Difficulty ] ;
3714: LD_ADDR_EXP 22
3718: PUSH
3719: LD_INT 4
3721: PUSH
3722: LD_INT 5
3724: PUSH
3725: LD_INT 6
3727: PUSH
3728: EMPTY
3729: LIST
3730: LIST
3731: LIST
3732: PUSH
3733: LD_OWVAR 67
3737: ARRAY
3738: ST_TO_ADDR
// ct := [ ] ;
3739: LD_ADDR_VAR 0 3
3743: PUSH
3744: EMPTY
3745: ST_TO_ADDR
// patrols := [ ] ;
3746: LD_ADDR_EXP 19
3750: PUSH
3751: EMPTY
3752: ST_TO_ADDR
// attackers := [ ] ;
3753: LD_ADDR_EXP 20
3757: PUSH
3758: EMPTY
3759: ST_TO_ADDR
// attackers_tmp := [ ] ;
3760: LD_ADDR_EXP 27
3764: PUSH
3765: EMPTY
3766: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
3767: LD_ADDR_EXP 21
3771: PUSH
3772: LD_INT 14
3774: PUSH
3775: LD_INT 1
3777: PUSH
3778: LD_INT 2
3780: PUSH
3781: LD_INT 27
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: LIST
3788: LIST
3789: PUSH
3790: LD_INT 14
3792: PUSH
3793: LD_INT 1
3795: PUSH
3796: LD_INT 2
3798: PUSH
3799: LD_INT 25
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: LIST
3806: LIST
3807: PUSH
3808: LD_INT 14
3810: PUSH
3811: LD_INT 1
3813: PUSH
3814: LD_INT 2
3816: PUSH
3817: LD_INT 28
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 14
3828: PUSH
3829: LD_INT 1
3831: PUSH
3832: LD_INT 2
3834: PUSH
3835: LD_INT 29
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: LIST
3842: LIST
3843: PUSH
3844: LD_INT 14
3846: PUSH
3847: LD_INT 1
3849: PUSH
3850: LD_INT 2
3852: PUSH
3853: LD_INT 27
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: LIST
3860: LIST
3861: PUSH
3862: EMPTY
3863: LIST
3864: LIST
3865: LIST
3866: LIST
3867: LIST
3868: ST_TO_ADDR
// SetBName ( ar_dep , newkabul ) ;
3869: LD_INT 2
3871: PPUSH
3872: LD_STRING newkabul
3874: PPUSH
3875: CALL_OW 500
// SetResourceType ( GetBase ( ar_dep ) , mat_cans , 90000 ) ;
3879: LD_INT 2
3881: PPUSH
3882: CALL_OW 274
3886: PPUSH
3887: LD_INT 1
3889: PPUSH
3890: LD_INT 90000
3892: PPUSH
3893: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_oil , 9000 ) ;
3897: LD_INT 2
3899: PPUSH
3900: CALL_OW 274
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: LD_INT 9000
3910: PPUSH
3911: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_siberit , 3000 ) ;
3915: LD_INT 2
3917: PPUSH
3918: CALL_OW 274
3922: PPUSH
3923: LD_INT 3
3925: PPUSH
3926: LD_INT 3000
3928: PPUSH
3929: CALL_OW 277
// if Difficulty > 1 then
3933: LD_OWVAR 67
3937: PUSH
3938: LD_INT 1
3940: GREATER
3941: IFFALSE 3958
// SetTech ( 5 , side , state_researched ) ;
3943: LD_INT 5
3945: PPUSH
3946: LD_VAR 0 5
3950: PPUSH
3951: LD_INT 2
3953: PPUSH
3954: CALL_OW 322
// SetTech ( tech_mortar , side , state_researched ) ;
3958: LD_INT 41
3960: PPUSH
3961: LD_VAR 0 5
3965: PPUSH
3966: LD_INT 2
3968: PPUSH
3969: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
3973: LD_INT 51
3975: PPUSH
3976: LD_VAR 0 5
3980: PPUSH
3981: LD_INT 2
3983: PPUSH
3984: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
3988: LD_INT 52
3990: PPUSH
3991: LD_VAR 0 5
3995: PPUSH
3996: LD_INT 2
3998: PPUSH
3999: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
4003: LD_INT 53
4005: PPUSH
4006: LD_VAR 0 5
4010: PPUSH
4011: LD_INT 2
4013: PPUSH
4014: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
4018: LD_INT 60
4020: PPUSH
4021: LD_VAR 0 5
4025: PPUSH
4026: LD_INT 2
4028: PPUSH
4029: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
4033: LD_INT 61
4035: PPUSH
4036: LD_VAR 0 5
4040: PPUSH
4041: LD_INT 2
4043: PPUSH
4044: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
4048: LD_INT 62
4050: PPUSH
4051: LD_VAR 0 5
4055: PPUSH
4056: LD_INT 2
4058: PPUSH
4059: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4063: LD_ADDR_VAR 0 2
4067: PUSH
4068: LD_INT 22
4070: PUSH
4071: LD_VAR 0 5
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: LD_INT 21
4082: PUSH
4083: LD_INT 3
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: PPUSH
4094: CALL_OW 69
4098: PUSH
4099: FOR_IN
4100: IFFALSE 4133
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 6
4109: PUSH
4110: LD_INT 8
4112: PUSH
4113: LD_INT 10
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_OWVAR 67
4125: ARRAY
4126: PPUSH
4127: CALL_OW 241
4131: GO 4099
4133: POP
4134: POP
// if Difficulty > 1 then
4135: LD_OWVAR 67
4139: PUSH
4140: LD_INT 1
4142: GREATER
4143: IFFALSE 4152
// RemoveEnvironmentArea ( forest_road ) ;
4145: LD_INT 11
4147: PPUSH
4148: CALL_OW 355
// PlaceMines ( mine_west_zone , [ 10 , 15 , 20 ] [ Difficulty ] ) ;
4152: LD_INT 4
4154: PPUSH
4155: LD_INT 10
4157: PUSH
4158: LD_INT 15
4160: PUSH
4161: LD_INT 20
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: PUSH
4169: LD_OWVAR 67
4173: ARRAY
4174: PPUSH
4175: CALL 3061 0 2
// PlaceMines ( mine_east_zone , [ 7 , 14 , 18 ] [ Difficulty ] ) ;
4179: LD_INT 5
4181: PPUSH
4182: LD_INT 7
4184: PUSH
4185: LD_INT 14
4187: PUSH
4188: LD_INT 18
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: LIST
4195: PUSH
4196: LD_OWVAR 67
4200: ARRAY
4201: PPUSH
4202: CALL 3061 0 2
// PlaceMines ( mine_south_zone , [ 5 , 11 , 17 ] [ Difficulty ] ) ;
4206: LD_INT 7
4208: PPUSH
4209: LD_INT 5
4211: PUSH
4212: LD_INT 11
4214: PUSH
4215: LD_INT 17
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: LIST
4222: PUSH
4223: LD_OWVAR 67
4227: ARRAY
4228: PPUSH
4229: CALL 3061 0 2
// PlaceMines ( mine_high_zone , [ 0 , 3 , 5 ] [ Difficulty ] ) ;
4233: LD_INT 6
4235: PPUSH
4236: LD_INT 0
4238: PUSH
4239: LD_INT 3
4241: PUSH
4242: LD_INT 5
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: LIST
4249: PUSH
4250: LD_OWVAR 67
4254: ARRAY
4255: PPUSH
4256: CALL 3061 0 2
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
4260: LD_INT 8
4262: PPUSH
4263: LD_INT 2
4265: PUSH
4266: LD_INT 5
4268: PUSH
4269: LD_INT 8
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: LIST
4276: PUSH
4277: LD_OWVAR 67
4281: ARRAY
4282: PPUSH
4283: CALL 3061 0 2
// PlaceMines ( mine_southpass_zone , [ 0 , 2 , 4 ] [ Difficulty ] ) ;
4287: LD_INT 9
4289: PPUSH
4290: LD_INT 0
4292: PUSH
4293: LD_INT 2
4295: PUSH
4296: LD_INT 4
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_OWVAR 67
4308: ARRAY
4309: PPUSH
4310: CALL 3061 0 2
// PlaceMines ( mine_oileast_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4314: LD_INT 10
4316: PPUSH
4317: LD_INT 0
4319: PUSH
4320: LD_INT 1
4322: PUSH
4323: LD_INT 1
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: LIST
4330: PUSH
4331: LD_OWVAR 67
4335: ARRAY
4336: PPUSH
4337: CALL 3061 0 2
// PlaceMines ( mine_oilwest_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4341: LD_INT 12
4343: PPUSH
4344: LD_INT 0
4346: PUSH
4347: LD_INT 1
4349: PUSH
4350: LD_INT 1
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: LIST
4357: PUSH
4358: LD_OWVAR 67
4362: ARRAY
4363: PPUSH
4364: CALL 3061 0 2
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
4368: LD_ADDR_VAR 0 2
4372: PUSH
4373: DOUBLE
4374: LD_INT 1
4376: DEC
4377: ST_TO_ADDR
4378: LD_INT 8
4380: PUSH
4381: LD_INT 11
4383: PUSH
4384: LD_INT 14
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: LIST
4391: PUSH
4392: LD_OWVAR 67
4396: ARRAY
4397: PUSH
4398: FOR_TO
4399: IFFALSE 4574
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
4401: LD_ADDR_VAR 0 4
4405: PUSH
4406: LD_INT 134
4408: PPUSH
4409: LD_INT 73
4411: PPUSH
4412: LD_INT 10
4414: PPUSH
4415: LD_INT 0
4417: PPUSH
4418: CALL_OW 17
4422: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
4423: LD_VAR 0 4
4427: PUSH
4428: LD_INT 1
4430: ARRAY
4431: PPUSH
4432: LD_VAR 0 4
4436: PUSH
4437: LD_INT 2
4439: ARRAY
4440: PPUSH
4441: CALL_OW 428
4445: PUSH
4446: LD_INT 0
4448: EQUAL
4449: PUSH
4450: LD_VAR 0 4
4454: PUSH
4455: LD_INT 1
4457: ARRAY
4458: PPUSH
4459: LD_VAR 0 4
4463: PUSH
4464: LD_INT 2
4466: ARRAY
4467: PPUSH
4468: CALL_OW 458
4472: NOT
4473: AND
4474: IFFALSE 4572
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
4476: LD_ADDR_EXP 17
4480: PUSH
4481: LD_EXP 17
4485: PPUSH
4486: LD_EXP 17
4490: PUSH
4491: LD_INT 1
4493: PLUS
4494: PPUSH
4495: LD_VAR 0 4
4499: PUSH
4500: LD_INT 1
4502: ARRAY
4503: PPUSH
4504: CALL_OW 2
4508: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
4509: LD_ADDR_EXP 17
4513: PUSH
4514: LD_EXP 17
4518: PPUSH
4519: LD_EXP 17
4523: PUSH
4524: LD_INT 1
4526: PLUS
4527: PPUSH
4528: LD_VAR 0 4
4532: PUSH
4533: LD_INT 2
4535: ARRAY
4536: PPUSH
4537: CALL_OW 2
4541: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
4542: LD_VAR 0 4
4546: PUSH
4547: LD_INT 1
4549: ARRAY
4550: PPUSH
4551: LD_VAR 0 4
4555: PUSH
4556: LD_INT 2
4558: ARRAY
4559: PPUSH
4560: LD_EXP 8
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: CALL_OW 454
// end ; end ;
4572: GO 4398
4574: POP
4575: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4576: LD_ADDR_VAR 0 2
4580: PUSH
4581: LD_INT 22
4583: PUSH
4584: LD_VAR 0 5
4588: PUSH
4589: EMPTY
4590: LIST
4591: LIST
4592: PUSH
4593: LD_INT 30
4595: PUSH
4596: LD_INT 32
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: PPUSH
4607: CALL_OW 69
4611: PUSH
4612: FOR_IN
4613: IFFALSE 4645
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
4615: LD_VAR 0 2
4619: PPUSH
4620: LD_VAR 0 8
4624: PUSH
4625: LD_INT 1
4627: PPUSH
4628: LD_VAR 0 8
4632: PPUSH
4633: CALL_OW 12
4637: ARRAY
4638: PPUSH
4639: CALL_OW 431
4643: GO 4612
4645: POP
4646: POP
// uc_side := side ;
4647: LD_ADDR_OWVAR 20
4651: PUSH
4652: LD_VAR 0 5
4656: ST_TO_ADDR
// uc_nation := 2 ;
4657: LD_ADDR_OWVAR 21
4661: PUSH
4662: LD_INT 2
4664: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
4665: LD_ADDR_VAR 0 2
4669: PUSH
4670: DOUBLE
4671: LD_INT 1
4673: DEC
4674: ST_TO_ADDR
4675: LD_INT 1
4677: PUSH
4678: LD_OWVAR 67
4682: PLUS
4683: PUSH
4684: FOR_TO
4685: IFFALSE 4775
// begin vc_chassis := ar_half_tracked ;
4687: LD_ADDR_OWVAR 37
4691: PUSH
4692: LD_INT 14
4694: ST_TO_ADDR
// vc_engine := engine_combustion ;
4695: LD_ADDR_OWVAR 39
4699: PUSH
4700: LD_INT 1
4702: ST_TO_ADDR
// vc_control := control_manual ;
4703: LD_ADDR_OWVAR 38
4707: PUSH
4708: LD_INT 1
4710: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4711: LD_ADDR_OWVAR 40
4715: PUSH
4716: LD_INT 31
4718: ST_TO_ADDR
// veh := CreateVehicle ;
4719: LD_ADDR_VAR 0 7
4723: PUSH
4724: CALL_OW 45
4728: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
4729: LD_VAR 0 7
4733: PPUSH
4734: LD_INT 3
4736: PPUSH
4737: LD_INT 0
4739: PPUSH
4740: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
4744: LD_INT 0
4746: PPUSH
4747: LD_INT 3
4749: PPUSH
4750: LD_VAR 0 9
4754: PPUSH
4755: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4759: CALL_OW 44
4763: PPUSH
4764: LD_VAR 0 7
4768: PPUSH
4769: CALL_OW 52
// end ;
4773: GO 4684
4775: POP
4776: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4777: LD_ADDR_VAR 0 2
4781: PUSH
4782: LD_INT 22
4784: PUSH
4785: LD_VAR 0 5
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: LD_INT 30
4796: PUSH
4797: LD_INT 32
4799: PUSH
4800: EMPTY
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PPUSH
4808: CALL_OW 69
4812: PUSH
4813: FOR_IN
4814: IFFALSE 4847
// begin PrepareHuman ( false , 1 , skill ) ;
4816: LD_INT 0
4818: PPUSH
4819: LD_INT 1
4821: PPUSH
4822: LD_VAR 0 9
4826: PPUSH
4827: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4831: CALL_OW 44
4835: PPUSH
4836: LD_VAR 0 2
4840: PPUSH
4841: CALL_OW 52
// end ;
4845: GO 4813
4847: POP
4848: POP
// for i = 1 to 4 do
4849: LD_ADDR_VAR 0 2
4853: PUSH
4854: DOUBLE
4855: LD_INT 1
4857: DEC
4858: ST_TO_ADDR
4859: LD_INT 4
4861: PUSH
4862: FOR_TO
4863: IFFALSE 4894
// begin PrepareHuman ( false , 2 , skill ) ;
4865: LD_INT 0
4867: PPUSH
4868: LD_INT 2
4870: PPUSH
4871: LD_VAR 0 9
4875: PPUSH
4876: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_dep ) ;
4880: CALL_OW 44
4884: PPUSH
4885: LD_INT 2
4887: PPUSH
4888: CALL_OW 52
// end ;
4892: GO 4862
4894: POP
4895: POP
// for i = 1 to 6 do
4896: LD_ADDR_VAR 0 2
4900: PUSH
4901: DOUBLE
4902: LD_INT 1
4904: DEC
4905: ST_TO_ADDR
4906: LD_INT 6
4908: PUSH
4909: FOR_TO
4910: IFFALSE 4941
// begin PrepareHuman ( false , 3 , skill ) ;
4912: LD_INT 0
4914: PPUSH
4915: LD_INT 3
4917: PPUSH
4918: LD_VAR 0 9
4922: PPUSH
4923: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac ) ;
4927: CALL_OW 44
4931: PPUSH
4932: LD_INT 12
4934: PPUSH
4935: CALL_OW 52
// end ;
4939: GO 4909
4941: POP
4942: POP
// for i = 1 to 4 do
4943: LD_ADDR_VAR 0 2
4947: PUSH
4948: DOUBLE
4949: LD_INT 1
4951: DEC
4952: ST_TO_ADDR
4953: LD_INT 4
4955: PUSH
4956: FOR_TO
4957: IFFALSE 5014
// begin PrepareHuman ( false , 4 , skill ) ;
4959: LD_INT 0
4961: PPUSH
4962: LD_INT 4
4964: PPUSH
4965: LD_VAR 0 9
4969: PPUSH
4970: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
4974: CALL_OW 44
4978: PPUSH
4979: LD_INT 30
4981: PUSH
4982: LD_INT 8
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PPUSH
4989: CALL_OW 69
4993: PUSH
4994: LD_VAR 0 2
4998: PUSH
4999: LD_INT 2
5001: MOD
5002: PUSH
5003: LD_INT 1
5005: PLUS
5006: ARRAY
5007: PPUSH
5008: CALL_OW 52
// end ;
5012: GO 4956
5014: POP
5015: POP
// PrepareHuman ( false , class_mortar , skill ) ;
5016: LD_INT 0
5018: PPUSH
5019: LD_INT 8
5021: PPUSH
5022: LD_VAR 0 9
5026: PPUSH
5027: CALL_OW 380
// un := CreateHuman ;
5031: LD_ADDR_VAR 0 6
5035: PUSH
5036: CALL_OW 44
5040: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5041: LD_VAR 0 6
5045: PPUSH
5046: LD_INT 2
5048: PPUSH
5049: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
5053: LD_VAR 0 6
5057: PPUSH
5058: LD_INT 31
5060: PPUSH
5061: CALL_OW 52
// for i = 1 to 4 do
5065: LD_ADDR_VAR 0 2
5069: PUSH
5070: DOUBLE
5071: LD_INT 1
5073: DEC
5074: ST_TO_ADDR
5075: LD_INT 4
5077: PUSH
5078: FOR_TO
5079: IFFALSE 5135
// begin uc_nation := 0 ;
5081: LD_ADDR_OWVAR 21
5085: PUSH
5086: LD_INT 0
5088: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5089: LD_INT 0
5091: PPUSH
5092: LD_INT 16
5094: PPUSH
5095: LD_INT 1
5097: PPUSH
5098: CALL_OW 380
// un := CreateHuman ;
5102: LD_ADDR_VAR 0 6
5106: PUSH
5107: CALL_OW 44
5111: ST_TO_ADDR
// PlaceUnitXYR ( un , 106 , 46 , 8 , false ) ;
5112: LD_VAR 0 6
5116: PPUSH
5117: LD_INT 106
5119: PPUSH
5120: LD_INT 46
5122: PPUSH
5123: LD_INT 8
5125: PPUSH
5126: LD_INT 0
5128: PPUSH
5129: CALL_OW 50
// end ;
5133: GO 5078
5135: POP
5136: POP
// for i = 1 to 2 * Difficulty do
5137: LD_ADDR_VAR 0 2
5141: PUSH
5142: DOUBLE
5143: LD_INT 1
5145: DEC
5146: ST_TO_ADDR
5147: LD_INT 2
5149: PUSH
5150: LD_OWVAR 67
5154: MUL
5155: PUSH
5156: FOR_TO
5157: IFFALSE 5197
// begin uc_nation := 0 ;
5159: LD_ADDR_OWVAR 21
5163: PUSH
5164: LD_INT 0
5166: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_soldier , 3 ) ;
5167: LD_INT 0
5169: PPUSH
5170: LD_INT 15
5172: PPUSH
5173: LD_INT 3
5175: PPUSH
5176: CALL_OW 380
// PlaceUnitArea ( CreateHuman , ap1 , false ) ;
5180: CALL_OW 44
5184: PPUSH
5185: LD_INT 20
5187: PPUSH
5188: LD_INT 0
5190: PPUSH
5191: CALL_OW 49
// end ;
5195: GO 5156
5197: POP
5198: POP
// for i = 1 to 4 * Difficulty do
5199: LD_ADDR_VAR 0 2
5203: PUSH
5204: DOUBLE
5205: LD_INT 1
5207: DEC
5208: ST_TO_ADDR
5209: LD_INT 4
5211: PUSH
5212: LD_OWVAR 67
5216: MUL
5217: PUSH
5218: FOR_TO
5219: IFFALSE 5293
// begin uc_nation := 0 ;
5221: LD_ADDR_OWVAR 21
5225: PUSH
5226: LD_INT 0
5228: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
5229: LD_INT 0
5231: PPUSH
5232: LD_INT 17
5234: PPUSH
5235: LD_INT 3
5237: PPUSH
5238: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
5242: LD_ADDR_OWVAR 29
5246: PUSH
5247: LD_INT 11
5249: PUSH
5250: LD_INT 13
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: ST_TO_ADDR
// un := CreateHuman ;
5257: LD_ADDR_VAR 0 6
5261: PUSH
5262: CALL_OW 44
5266: ST_TO_ADDR
// PlaceUnitArea ( un , ap2 , false ) ;
5267: LD_VAR 0 6
5271: PPUSH
5272: LD_INT 21
5274: PPUSH
5275: LD_INT 0
5277: PPUSH
5278: CALL_OW 49
// ComHold ( un ) ;
5282: LD_VAR 0 6
5286: PPUSH
5287: CALL_OW 140
// end ;
5291: GO 5218
5293: POP
5294: POP
// end ;
5295: LD_VAR 0 1
5299: RET
// every 12 12$00 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) do var i , tmp , p ;
5300: LD_INT 22
5302: PUSH
5303: LD_EXP 8
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PUSH
5312: LD_INT 30
5314: PUSH
5315: LD_INT 3
5317: PUSH
5318: EMPTY
5319: LIST
5320: LIST
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: PPUSH
5326: CALL_OW 69
5330: IFFALSE 5598
5332: GO 5334
5334: DISABLE
5335: LD_INT 0
5337: PPUSH
5338: PPUSH
5339: PPUSH
// begin enable ;
5340: ENABLE
// tmp := queue_codes [ rng ] ;
5341: LD_ADDR_VAR 0 2
5345: PUSH
5346: LD_EXP 23
5350: PUSH
5351: LD_EXP 24
5355: ARRAY
5356: ST_TO_ADDR
// p := 1 ;
5357: LD_ADDR_VAR 0 3
5361: PUSH
5362: LD_INT 1
5364: ST_TO_ADDR
// for i = 1 to veh_counter do
5365: LD_ADDR_VAR 0 1
5369: PUSH
5370: DOUBLE
5371: LD_INT 1
5373: DEC
5374: ST_TO_ADDR
5375: LD_EXP 22
5379: PUSH
5380: FOR_TO
5381: IFFALSE 5562
// begin AddComConstruct ( FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) [ 1 ] , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
5383: LD_INT 22
5385: PUSH
5386: LD_EXP 8
5390: PUSH
5391: EMPTY
5392: LIST
5393: LIST
5394: PUSH
5395: LD_INT 30
5397: PUSH
5398: LD_INT 3
5400: PUSH
5401: EMPTY
5402: LIST
5403: LIST
5404: PUSH
5405: EMPTY
5406: LIST
5407: LIST
5408: PPUSH
5409: CALL_OW 69
5413: PUSH
5414: LD_INT 1
5416: ARRAY
5417: PPUSH
5418: LD_EXP 21
5422: PUSH
5423: LD_VAR 0 2
5427: PUSH
5428: LD_INT 10
5430: MOD
5431: ARRAY
5432: PUSH
5433: LD_INT 1
5435: ARRAY
5436: PPUSH
5437: LD_EXP 21
5441: PUSH
5442: LD_VAR 0 2
5446: PUSH
5447: LD_INT 10
5449: MOD
5450: ARRAY
5451: PUSH
5452: LD_INT 2
5454: ARRAY
5455: PPUSH
5456: LD_EXP 21
5460: PUSH
5461: LD_VAR 0 2
5465: PUSH
5466: LD_INT 10
5468: MOD
5469: ARRAY
5470: PUSH
5471: LD_INT 3
5473: ARRAY
5474: PPUSH
5475: LD_EXP 21
5479: PUSH
5480: LD_VAR 0 2
5484: PUSH
5485: LD_INT 10
5487: MOD
5488: ARRAY
5489: PUSH
5490: LD_INT 4
5492: ARRAY
5493: PPUSH
5494: CALL_OW 185
// tmp := tmp / 10 ;
5498: LD_ADDR_VAR 0 2
5502: PUSH
5503: LD_VAR 0 2
5507: PUSH
5508: LD_INT 10
5510: DIVREAL
5511: ST_TO_ADDR
// p := p + 1 ;
5512: LD_ADDR_VAR 0 3
5516: PUSH
5517: LD_VAR 0 3
5521: PUSH
5522: LD_INT 1
5524: PLUS
5525: ST_TO_ADDR
// if p > 5 then
5526: LD_VAR 0 3
5530: PUSH
5531: LD_INT 5
5533: GREATER
5534: IFFALSE 5560
// begin p := 1 ;
5536: LD_ADDR_VAR 0 3
5540: PUSH
5541: LD_INT 1
5543: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
5544: LD_ADDR_VAR 0 2
5548: PUSH
5549: LD_EXP 23
5553: PUSH
5554: LD_EXP 24
5558: ARRAY
5559: ST_TO_ADDR
// end ; end ;
5560: GO 5380
5562: POP
5563: POP
// rng := rng + 1 ;
5564: LD_ADDR_EXP 24
5568: PUSH
5569: LD_EXP 24
5573: PUSH
5574: LD_INT 1
5576: PLUS
5577: ST_TO_ADDR
// if rng > queue_codes then
5578: LD_EXP 24
5582: PUSH
5583: LD_EXP 23
5587: GREATER
5588: IFFALSE 5598
// rng := 1 ;
5590: LD_ADDR_EXP 24
5594: PUSH
5595: LD_INT 1
5597: ST_TO_ADDR
// end ;
5598: PPOPN 3
5600: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
5601: LD_INT 25
5603: PUSH
5604: LD_INT 17
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 69
5615: IFFALSE 5718
5617: GO 5619
5619: DISABLE
5620: LD_INT 0
5622: PPUSH
5623: PPUSH
// begin enable ;
5624: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
5625: LD_ADDR_VAR 0 1
5629: PUSH
5630: LD_INT 25
5632: PUSH
5633: LD_INT 17
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: PPUSH
5640: CALL_OW 69
5644: PUSH
5645: FOR_IN
5646: IFFALSE 5716
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
5648: LD_ADDR_VAR 0 2
5652: PUSH
5653: LD_INT 81
5655: PUSH
5656: LD_EXP 8
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: PPUSH
5665: CALL_OW 69
5669: PPUSH
5670: LD_VAR 0 1
5674: PPUSH
5675: CALL_OW 74
5679: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
5680: LD_VAR 0 1
5684: PPUSH
5685: LD_VAR 0 2
5689: PPUSH
5690: CALL_OW 296
5694: PUSH
5695: LD_INT 15
5697: LESS
5698: IFFALSE 5714
// ComAttackUnit ( i , un ) ;
5700: LD_VAR 0 1
5704: PPUSH
5705: LD_VAR 0 2
5709: PPUSH
5710: CALL_OW 115
// end ;
5714: GO 5645
5716: POP
5717: POP
// end ;
5718: PPOPN 2
5720: END
// every 0 0$01 trigger attackers marked 17 do var i ;
5721: LD_EXP 20
5725: IFFALSE 5819
5727: GO 5729
5729: DISABLE
5730: LD_INT 0
5732: PPUSH
// begin enable ;
5733: ENABLE
// if target = 0 then
5734: LD_EXP 25
5738: PUSH
5739: LD_INT 0
5741: EQUAL
5742: IFFALSE 5766
// target := FilterAllUnits ( [ f_enemy , bot_side ] ) ;
5744: LD_ADDR_EXP 25
5748: PUSH
5749: LD_INT 81
5751: PUSH
5752: LD_EXP 8
5756: PUSH
5757: EMPTY
5758: LIST
5759: LIST
5760: PPUSH
5761: CALL_OW 69
5765: ST_TO_ADDR
// for i in attackers do
5766: LD_ADDR_VAR 0 1
5770: PUSH
5771: LD_EXP 20
5775: PUSH
5776: FOR_IN
5777: IFFALSE 5817
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , target ] ) , i ) ) ;
5779: LD_VAR 0 1
5783: PPUSH
5784: LD_INT 22
5786: PUSH
5787: LD_EXP 25
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PPUSH
5796: CALL_OW 69
5800: PPUSH
5801: LD_VAR 0 1
5805: PPUSH
5806: CALL_OW 74
5810: PPUSH
5811: CALL_OW 115
5815: GO 5776
5817: POP
5818: POP
// end ;
5819: PPOPN 1
5821: END
// every 0 0$01 trigger not attackers marked 17 do
5822: LD_EXP 20
5826: NOT
5827: IFFALSE 5836
5829: GO 5831
5831: DISABLE
// begin enable ;
5832: ENABLE
// disable ( 17 ) ;
5833: LD_INT 17
5835: DISABLE_MARKED
// end ;
5836: END
// every 3 3$00 trigger veh_counter <= attackers do var max , i ;
5837: LD_EXP 22
5841: PUSH
5842: LD_EXP 20
5846: LESSEQUAL
5847: IFFALSE 5956
5849: GO 5851
5851: DISABLE
5852: LD_INT 0
5854: PPUSH
5855: PPUSH
// begin enable ;
5856: ENABLE
// enable ( 17 ) ;
5857: LD_INT 17
5859: ENABLE_MARKED
// max := 1 ;
5860: LD_ADDR_VAR 0 1
5864: PUSH
5865: LD_INT 1
5867: ST_TO_ADDR
// for i = 1 to 8 do
5868: LD_ADDR_VAR 0 2
5872: PUSH
5873: DOUBLE
5874: LD_INT 1
5876: DEC
5877: ST_TO_ADDR
5878: LD_INT 8
5880: PUSH
5881: FOR_TO
5882: IFFALSE 5954
// if i <> bot_side then
5884: LD_VAR 0 2
5888: PUSH
5889: LD_EXP 8
5893: NONEQUAL
5894: IFFALSE 5952
// begin if max < FilterAllUnits ( [ f_side , i ] ) then
5896: LD_VAR 0 1
5900: PUSH
5901: LD_INT 22
5903: PUSH
5904: LD_VAR 0 2
5908: PUSH
5909: EMPTY
5910: LIST
5911: LIST
5912: PPUSH
5913: CALL_OW 69
5917: LESS
5918: IFFALSE 5952
// begin max := FilterAllUnits ( [ f_side , i ] ) ;
5920: LD_ADDR_VAR 0 1
5924: PUSH
5925: LD_INT 22
5927: PUSH
5928: LD_VAR 0 2
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: PPUSH
5937: CALL_OW 69
5941: ST_TO_ADDR
// target := i ;
5942: LD_ADDR_EXP 25
5946: PUSH
5947: LD_VAR 0 2
5951: ST_TO_ADDR
// end ; end ;
5952: GO 5881
5954: POP
5955: POP
// end ;
5956: PPOPN 2
5958: END
// every 0 0$01 trigger game_start and tick >= 30 30$00 do
5959: LD_EXP 9
5963: PUSH
5964: LD_OWVAR 1
5968: PUSH
5969: LD_INT 63000
5971: GREATEREQUAL
5972: AND
5973: IFFALSE 5992
5975: GO 5977
5977: DISABLE
// begin veh_counter := veh_counter + 1 ;
5978: LD_ADDR_EXP 22
5982: PUSH
5983: LD_EXP 22
5987: PUSH
5988: LD_INT 1
5990: PLUS
5991: ST_TO_ADDR
// end ;
5992: END
// every 0 0$01 trigger game_start and tick >= 50 50$00 do
5993: LD_EXP 9
5997: PUSH
5998: LD_OWVAR 1
6002: PUSH
6003: LD_INT 105000
6005: GREATEREQUAL
6006: AND
6007: IFFALSE 6026
6009: GO 6011
6011: DISABLE
// begin veh_counter := veh_counter + 2 ;
6012: LD_ADDR_EXP 22
6016: PUSH
6017: LD_EXP 22
6021: PUSH
6022: LD_INT 2
6024: PLUS
6025: ST_TO_ADDR
// end ;
6026: END
// every 0 0$01 trigger game_start and tick >= 80 80$00 do
6027: LD_EXP 9
6031: PUSH
6032: LD_OWVAR 1
6036: PUSH
6037: LD_INT 168000
6039: GREATEREQUAL
6040: AND
6041: IFFALSE 6060
6043: GO 6045
6045: DISABLE
// begin veh_counter := veh_counter + 3 ;
6046: LD_ADDR_EXP 22
6050: PUSH
6051: LD_EXP 22
6055: PUSH
6056: LD_INT 3
6058: PLUS
6059: ST_TO_ADDR
// end ;
6060: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
6061: LD_INT 22
6063: PUSH
6064: LD_EXP 8
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: PUSH
6073: LD_INT 33
6075: PUSH
6076: LD_INT 2
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 69
6091: IFFALSE 6307
6093: GO 6095
6095: DISABLE
6096: LD_INT 0
6098: PPUSH
6099: PPUSH
6100: PPUSH
6101: PPUSH
6102: PPUSH
6103: PPUSH
6104: PPUSH
// begin enable ;
6105: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
6106: LD_ADDR_VAR 0 4
6110: PUSH
6111: LD_INT 22
6113: PUSH
6114: LD_EXP 8
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: PUSH
6123: LD_INT 33
6125: PUSH
6126: LD_INT 2
6128: PUSH
6129: EMPTY
6130: LIST
6131: LIST
6132: PUSH
6133: LD_INT 3
6135: PUSH
6136: LD_INT 61
6138: PUSH
6139: EMPTY
6140: LIST
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: LIST
6150: PPUSH
6151: CALL_OW 69
6155: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
6156: LD_ADDR_VAR 0 3
6160: PUSH
6161: LD_INT 22
6163: PUSH
6164: LD_EXP 8
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: PUSH
6173: LD_INT 34
6175: PUSH
6176: LD_INT 31
6178: PUSH
6179: EMPTY
6180: LIST
6181: LIST
6182: PUSH
6183: EMPTY
6184: LIST
6185: LIST
6186: PPUSH
6187: CALL_OW 69
6191: ST_TO_ADDR
// best := 10 ;
6192: LD_ADDR_VAR 0 5
6196: PUSH
6197: LD_INT 10
6199: ST_TO_ADDR
// best_mechanic := - 1 ;
6200: LD_ADDR_VAR 0 6
6204: PUSH
6205: LD_INT 1
6207: NEG
6208: ST_TO_ADDR
// if vehs then
6209: LD_VAR 0 4
6213: IFFALSE 6307
// begin for j in cts do
6215: LD_ADDR_VAR 0 2
6219: PUSH
6220: LD_VAR 0 3
6224: PUSH
6225: FOR_IN
6226: IFFALSE 6287
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
6228: LD_ADDR_VAR 0 7
6232: PUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: CALL 3413 0 1
6242: PPUSH
6243: CALL_OW 432
6247: ST_TO_ADDR
// if p < best then
6248: LD_VAR 0 7
6252: PUSH
6253: LD_VAR 0 5
6257: LESS
6258: IFFALSE 6285
// begin best := p ;
6260: LD_ADDR_VAR 0 5
6264: PUSH
6265: LD_VAR 0 7
6269: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
6270: LD_ADDR_VAR 0 6
6274: PUSH
6275: LD_VAR 0 2
6279: PPUSH
6280: CALL 3413 0 1
6284: ST_TO_ADDR
// end ; end ;
6285: GO 6225
6287: POP
6288: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
6289: LD_VAR 0 4
6293: PUSH
6294: LD_INT 1
6296: ARRAY
6297: PPUSH
6298: LD_VAR 0 6
6302: PPUSH
6303: CALL_OW 135
// end ; end ;
6307: PPOPN 7
6309: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
6310: GO 6312
6312: DISABLE
6313: LD_INT 0
6315: PPUSH
6316: PPUSH
6317: PPUSH
6318: PPUSH
6319: PPUSH
6320: PPUSH
6321: PPUSH
// begin enable ;
6322: ENABLE
// b := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6323: LD_ADDR_VAR 0 6
6327: PUSH
6328: LD_INT 22
6330: PUSH
6331: LD_EXP 8
6335: PUSH
6336: EMPTY
6337: LIST
6338: LIST
6339: PUSH
6340: LD_INT 21
6342: PUSH
6343: LD_INT 3
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: PUSH
6350: LD_INT 3
6352: PUSH
6353: LD_INT 24
6355: PUSH
6356: LD_INT 1000
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: PPUSH
6372: CALL_OW 69
6376: ST_TO_ADDR
// h := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6377: LD_ADDR_VAR 0 3
6381: PUSH
6382: LD_INT 22
6384: PUSH
6385: LD_EXP 8
6389: PUSH
6390: EMPTY
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 2
6396: PUSH
6397: LD_INT 25
6399: PUSH
6400: LD_INT 1
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 25
6409: PUSH
6410: LD_INT 2
6412: PUSH
6413: EMPTY
6414: LIST
6415: LIST
6416: PUSH
6417: LD_INT 25
6419: PUSH
6420: LD_INT 3
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: LIST
6431: LIST
6432: PUSH
6433: LD_INT 3
6435: PUSH
6436: LD_INT 24
6438: PUSH
6439: LD_INT 750
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: LIST
6454: PPUSH
6455: CALL_OW 69
6459: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ;
6460: LD_ADDR_VAR 0 4
6464: PUSH
6465: LD_INT 22
6467: PUSH
6468: LD_EXP 8
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: PUSH
6477: LD_INT 25
6479: PUSH
6480: LD_INT 4
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: PPUSH
6491: CALL_OW 69
6495: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
6496: LD_ADDR_VAR 0 5
6500: PUSH
6501: LD_INT 22
6503: PUSH
6504: LD_EXP 8
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 25
6515: PUSH
6516: LD_INT 2
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: PUSH
6523: EMPTY
6524: LIST
6525: LIST
6526: PPUSH
6527: CALL_OW 69
6531: ST_TO_ADDR
// if not h and not b then
6532: LD_VAR 0 3
6536: NOT
6537: PUSH
6538: LD_VAR 0 6
6542: NOT
6543: AND
6544: IFFALSE 6828
// begin if sci then
6546: LD_VAR 0 4
6550: IFFALSE 6687
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
6552: LD_VAR 0 4
6556: PPUSH
6557: LD_INT 3
6559: PUSH
6560: LD_INT 54
6562: PUSH
6563: EMPTY
6564: LIST
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PPUSH
6570: CALL_OW 72
6574: PUSH
6575: LD_INT 22
6577: PUSH
6578: LD_EXP 8
6582: PUSH
6583: EMPTY
6584: LIST
6585: LIST
6586: PUSH
6587: LD_INT 30
6589: PUSH
6590: LD_INT 8
6592: PUSH
6593: EMPTY
6594: LIST
6595: LIST
6596: PUSH
6597: EMPTY
6598: LIST
6599: LIST
6600: PPUSH
6601: CALL_OW 69
6605: AND
6606: IFFALSE 6687
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
6608: LD_ADDR_VAR 0 2
6612: PUSH
6613: LD_VAR 0 4
6617: PPUSH
6618: LD_INT 3
6620: PUSH
6621: LD_INT 54
6623: PUSH
6624: EMPTY
6625: LIST
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: PPUSH
6631: CALL_OW 72
6635: PUSH
6636: FOR_IN
6637: IFFALSE 6685
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6639: LD_VAR 0 2
6643: PPUSH
6644: LD_INT 22
6646: PUSH
6647: LD_EXP 8
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: PUSH
6656: LD_INT 30
6658: PUSH
6659: LD_INT 8
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: PPUSH
6670: CALL_OW 69
6674: PUSH
6675: LD_INT 1
6677: ARRAY
6678: PPUSH
6679: CALL_OW 120
6683: GO 6636
6685: POP
6686: POP
// if eng then
6687: LD_VAR 0 5
6691: IFFALSE 6828
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
6693: LD_VAR 0 5
6697: PPUSH
6698: LD_INT 3
6700: PUSH
6701: LD_INT 54
6703: PUSH
6704: EMPTY
6705: LIST
6706: PUSH
6707: EMPTY
6708: LIST
6709: LIST
6710: PPUSH
6711: CALL_OW 72
6715: PUSH
6716: LD_INT 22
6718: PUSH
6719: LD_EXP 8
6723: PUSH
6724: EMPTY
6725: LIST
6726: LIST
6727: PUSH
6728: LD_INT 30
6730: PUSH
6731: LD_INT 1
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PUSH
6738: EMPTY
6739: LIST
6740: LIST
6741: PPUSH
6742: CALL_OW 69
6746: AND
6747: IFFALSE 6828
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
6749: LD_ADDR_VAR 0 2
6753: PUSH
6754: LD_VAR 0 5
6758: PPUSH
6759: LD_INT 3
6761: PUSH
6762: LD_INT 54
6764: PUSH
6765: EMPTY
6766: LIST
6767: PUSH
6768: EMPTY
6769: LIST
6770: LIST
6771: PPUSH
6772: CALL_OW 72
6776: PUSH
6777: FOR_IN
6778: IFFALSE 6826
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6780: LD_VAR 0 2
6784: PPUSH
6785: LD_INT 22
6787: PUSH
6788: LD_EXP 8
6792: PUSH
6793: EMPTY
6794: LIST
6795: LIST
6796: PUSH
6797: LD_INT 30
6799: PUSH
6800: LD_INT 1
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PPUSH
6811: CALL_OW 69
6815: PUSH
6816: LD_INT 1
6818: ARRAY
6819: PPUSH
6820: CALL_OW 120
6824: GO 6777
6826: POP
6827: POP
// end ; p := 1 ;
6828: LD_ADDR_VAR 0 7
6832: PUSH
6833: LD_INT 1
6835: ST_TO_ADDR
// if b and eng then
6836: LD_VAR 0 6
6840: PUSH
6841: LD_VAR 0 5
6845: AND
6846: IFFALSE 6980
// for j in eng do
6848: LD_ADDR_VAR 0 2
6852: PUSH
6853: LD_VAR 0 5
6857: PUSH
6858: FOR_IN
6859: IFFALSE 6978
// begin if IsInUnit ( j ) then
6861: LD_VAR 0 2
6865: PPUSH
6866: CALL_OW 310
6870: IFFALSE 6883
// ComExitBuilding ( j ) else
6872: LD_VAR 0 2
6876: PPUSH
6877: CALL_OW 122
6881: GO 6976
// if not HasTask ( j ) and GetLives ( j ) > 750 then
6883: LD_VAR 0 2
6887: PPUSH
6888: CALL_OW 314
6892: NOT
6893: PUSH
6894: LD_VAR 0 2
6898: PPUSH
6899: CALL_OW 256
6903: PUSH
6904: LD_INT 750
6906: GREATER
6907: AND
6908: IFFALSE 6976
// begin if b > p then
6910: LD_VAR 0 6
6914: PUSH
6915: LD_VAR 0 7
6919: GREATER
6920: IFFALSE 6958
// begin ComRepairBuilding ( j , b [ p ] ) ;
6922: LD_VAR 0 2
6926: PPUSH
6927: LD_VAR 0 6
6931: PUSH
6932: LD_VAR 0 7
6936: ARRAY
6937: PPUSH
6938: CALL_OW 130
// p := p + 1 ;
6942: LD_ADDR_VAR 0 7
6946: PUSH
6947: LD_VAR 0 7
6951: PUSH
6952: LD_INT 1
6954: PLUS
6955: ST_TO_ADDR
// end else
6956: GO 6976
// ComRepairBuilding ( j , b [ 1 ] ) ;
6958: LD_VAR 0 2
6962: PPUSH
6963: LD_VAR 0 6
6967: PUSH
6968: LD_INT 1
6970: ARRAY
6971: PPUSH
6972: CALL_OW 130
// end ; end ;
6976: GO 6858
6978: POP
6979: POP
// if h and sci then
6980: LD_VAR 0 3
6984: PUSH
6985: LD_VAR 0 4
6989: AND
6990: IFFALSE 7129
// for i in h do
6992: LD_ADDR_VAR 0 1
6996: PUSH
6997: LD_VAR 0 3
7001: PUSH
7002: FOR_IN
7003: IFFALSE 7127
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
7005: LD_VAR 0 1
7009: PPUSH
7010: LD_INT 108
7012: PPUSH
7013: LD_INT 42
7015: PPUSH
7016: CALL_OW 297
7020: PUSH
7021: LD_INT 10
7023: GREATER
7024: IFFALSE 7043
// ComMoveXY ( i , 108 , 42 ) else
7026: LD_VAR 0 1
7030: PPUSH
7031: LD_INT 108
7033: PPUSH
7034: LD_INT 42
7036: PPUSH
7037: CALL_OW 111
7041: GO 7125
// begin for j in sci do
7043: LD_ADDR_VAR 0 2
7047: PUSH
7048: LD_VAR 0 4
7052: PUSH
7053: FOR_IN
7054: IFFALSE 7123
// begin if GetTag ( j ) > 0 then
7056: LD_VAR 0 2
7060: PPUSH
7061: CALL_OW 110
7065: PUSH
7066: LD_INT 0
7068: GREATER
7069: IFFALSE 7073
// continue ;
7071: GO 7053
// if IsInUnit ( j ) then
7073: LD_VAR 0 2
7077: PPUSH
7078: CALL_OW 310
7082: IFFALSE 7095
// ComExitBuilding ( j ) else
7084: LD_VAR 0 2
7088: PPUSH
7089: CALL_OW 122
7093: GO 7121
// if not HasTask ( j ) then
7095: LD_VAR 0 2
7099: PPUSH
7100: CALL_OW 314
7104: NOT
7105: IFFALSE 7121
// ComHeal ( j , h ) ;
7107: LD_VAR 0 2
7111: PPUSH
7112: LD_VAR 0 3
7116: PPUSH
7117: CALL_OW 128
// end ;
7121: GO 7053
7123: POP
7124: POP
// end ;
7125: GO 7002
7127: POP
7128: POP
// end ;
7129: PPOPN 7
7131: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 155 , 88 ) and GetBType ( HexInfo ( 155 , 88 ) = b_siberite_mine ) do var sci , p ;
7132: LD_INT 155
7134: PPUSH
7135: LD_INT 88
7137: PPUSH
7138: CALL_OW 428
7142: PUSH
7143: LD_INT 155
7145: PPUSH
7146: LD_INT 88
7148: PPUSH
7149: CALL_OW 428
7153: PUSH
7154: LD_INT 30
7156: EQUAL
7157: PPUSH
7158: CALL_OW 266
7162: AND
7163: IFFALSE 7412
7165: GO 7167
7167: DISABLE
7168: LD_INT 0
7170: PPUSH
7171: PPUSH
// begin p := GetSide ( HexInfo ( 155 , 88 ) ) ;
7172: LD_ADDR_VAR 0 2
7176: PUSH
7177: LD_INT 155
7179: PPUSH
7180: LD_INT 88
7182: PPUSH
7183: CALL_OW 428
7187: PPUSH
7188: CALL_OW 255
7192: ST_TO_ADDR
// Wait ( [ 5 5$30 , 6 6$33 , 6 6$21 , 8 8$44 , 9 9$31 , 4 4$33 , 9 9$01 , 5 5$01 ] [ p ] ) ;
7193: LD_INT 11550
7195: PUSH
7196: LD_INT 13755
7198: PUSH
7199: LD_INT 13335
7201: PUSH
7202: LD_INT 18340
7204: PUSH
7205: LD_INT 19985
7207: PUSH
7208: LD_INT 9555
7210: PUSH
7211: LD_INT 18935
7213: PUSH
7214: LD_INT 10535
7216: PUSH
7217: EMPTY
7218: LIST
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: LIST
7226: PUSH
7227: LD_VAR 0 2
7231: ARRAY
7232: PPUSH
7233: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7237: LD_INT 22
7239: PUSH
7240: LD_EXP 8
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: PUSH
7249: LD_INT 25
7251: PUSH
7252: LD_INT 4
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PPUSH
7263: CALL_OW 69
7267: PUSH
7268: LD_INT 0
7270: EQUAL
7271: IFFALSE 7275
// exit ;
7273: GO 7412
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ 1 ] ;
7275: LD_ADDR_VAR 0 1
7279: PUSH
7280: LD_INT 22
7282: PUSH
7283: LD_EXP 8
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: PUSH
7292: LD_INT 25
7294: PUSH
7295: LD_INT 4
7297: PUSH
7298: EMPTY
7299: LIST
7300: LIST
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PPUSH
7306: CALL_OW 69
7310: PUSH
7311: LD_INT 1
7313: ARRAY
7314: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7315: LD_VAR 0 1
7319: PPUSH
7320: LD_INT 1
7322: PPUSH
7323: CALL_OW 109
// ComExitBuilding ( sci ) ;
7327: LD_VAR 0 1
7331: PPUSH
7332: CALL_OW 122
// AddComMoveXY ( sci , 126 , 59 ) ;
7336: LD_VAR 0 1
7340: PPUSH
7341: LD_INT 126
7343: PPUSH
7344: LD_INT 59
7346: PPUSH
7347: CALL_OW 171
// if p mod 2 = 0 then
7351: LD_VAR 0 2
7355: PUSH
7356: LD_INT 2
7358: MOD
7359: PUSH
7360: LD_INT 0
7362: EQUAL
7363: IFFALSE 7382
// AddComMoveXY ( sci , 148 , 66 ) else
7365: LD_VAR 0 1
7369: PPUSH
7370: LD_INT 148
7372: PPUSH
7373: LD_INT 66
7375: PPUSH
7376: CALL_OW 171
7380: GO 7397
// AddComMoveXY ( sci , 135 , 84 ) ;
7382: LD_VAR 0 1
7386: PPUSH
7387: LD_INT 135
7389: PPUSH
7390: LD_INT 84
7392: PPUSH
7393: CALL_OW 171
// AddComContaminate ( sci , 155 , 88 ) ;
7397: LD_VAR 0 1
7401: PPUSH
7402: LD_INT 155
7404: PPUSH
7405: LD_INT 88
7407: PPUSH
7408: CALL_OW 218
// end ;
7412: PPOPN 2
7414: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 33 , 10 ) and GetBType ( HexInfo ( 33 , 10 ) = b_siberite_mine ) do var sci , p ;
7415: LD_INT 33
7417: PPUSH
7418: LD_INT 10
7420: PPUSH
7421: CALL_OW 428
7425: PUSH
7426: LD_INT 33
7428: PPUSH
7429: LD_INT 10
7431: PPUSH
7432: CALL_OW 428
7436: PUSH
7437: LD_INT 30
7439: EQUAL
7440: PPUSH
7441: CALL_OW 266
7445: AND
7446: IFFALSE 7697
7448: GO 7450
7450: DISABLE
7451: LD_INT 0
7453: PPUSH
7454: PPUSH
// begin p := GetSide ( HexInfo ( 33 , 10 ) ) ;
7455: LD_ADDR_VAR 0 2
7459: PUSH
7460: LD_INT 33
7462: PPUSH
7463: LD_INT 10
7465: PPUSH
7466: CALL_OW 428
7470: PPUSH
7471: CALL_OW 255
7475: ST_TO_ADDR
// Wait ( [ 4 4$30 , 5 5$33 , 3 3$21 , 4 4$44 , 3 3$31 , 5 5$33 , 3 3$01 , 8 8$01 ] [ p ] ) ;
7476: LD_INT 9450
7478: PUSH
7479: LD_INT 11655
7481: PUSH
7482: LD_INT 7035
7484: PUSH
7485: LD_INT 9940
7487: PUSH
7488: LD_INT 7385
7490: PUSH
7491: LD_INT 11655
7493: PUSH
7494: LD_INT 6335
7496: PUSH
7497: LD_INT 16835
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: LIST
7507: LIST
7508: LIST
7509: PUSH
7510: LD_VAR 0 2
7514: ARRAY
7515: PPUSH
7516: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7520: LD_INT 22
7522: PUSH
7523: LD_EXP 8
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PUSH
7532: LD_INT 25
7534: PUSH
7535: LD_INT 4
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PPUSH
7546: CALL_OW 69
7550: PUSH
7551: LD_INT 0
7553: EQUAL
7554: IFFALSE 7558
// exit ;
7556: GO 7697
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ sci ] ;
7558: LD_ADDR_VAR 0 1
7562: PUSH
7563: LD_INT 22
7565: PUSH
7566: LD_EXP 8
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 25
7577: PUSH
7578: LD_INT 4
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PPUSH
7589: CALL_OW 69
7593: PUSH
7594: LD_VAR 0 1
7598: ARRAY
7599: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7600: LD_VAR 0 1
7604: PPUSH
7605: LD_INT 1
7607: PPUSH
7608: CALL_OW 109
// ComExitBuilding ( sci ) ;
7612: LD_VAR 0 1
7616: PPUSH
7617: CALL_OW 122
// AddComMoveXY ( sci , 67 , 13 ) ;
7621: LD_VAR 0 1
7625: PPUSH
7626: LD_INT 67
7628: PPUSH
7629: LD_INT 13
7631: PPUSH
7632: CALL_OW 171
// if p mod 2 = 0 then
7636: LD_VAR 0 2
7640: PUSH
7641: LD_INT 2
7643: MOD
7644: PUSH
7645: LD_INT 0
7647: EQUAL
7648: IFFALSE 7667
// AddComMoveXY ( sci , 37 , 3 ) else
7650: LD_VAR 0 1
7654: PPUSH
7655: LD_INT 37
7657: PPUSH
7658: LD_INT 3
7660: PPUSH
7661: CALL_OW 171
7665: GO 7682
// AddComMoveXY ( sci , 45 , 20 ) ;
7667: LD_VAR 0 1
7671: PPUSH
7672: LD_INT 45
7674: PPUSH
7675: LD_INT 20
7677: PPUSH
7678: CALL_OW 171
// AddComContaminate ( sci , 33 , 10 ) ;
7682: LD_VAR 0 1
7686: PPUSH
7687: LD_INT 33
7689: PPUSH
7690: LD_INT 10
7692: PPUSH
7693: CALL_OW 218
// end ;
7697: PPOPN 2
7699: END
// every 0 0$01 trigger mines_list do var i , p ;
7700: LD_EXP 17
7704: IFFALSE 7930
7706: GO 7708
7708: DISABLE
7709: LD_INT 0
7711: PPUSH
7712: PPUSH
// begin enable ;
7713: ENABLE
// p := 1 ;
7714: LD_ADDR_VAR 0 2
7718: PUSH
7719: LD_INT 1
7721: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
7722: LD_ADDR_VAR 0 1
7726: PUSH
7727: DOUBLE
7728: LD_INT 1
7730: DEC
7731: ST_TO_ADDR
7732: LD_EXP 17
7736: PUSH
7737: LD_INT 2
7739: DIVREAL
7740: PUSH
7741: FOR_TO
7742: IFFALSE 7928
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
7744: LD_EXP 17
7748: PUSH
7749: LD_VAR 0 2
7753: ARRAY
7754: PPUSH
7755: LD_EXP 17
7759: PUSH
7760: LD_VAR 0 2
7764: PUSH
7765: LD_INT 1
7767: PLUS
7768: ARRAY
7769: PPUSH
7770: CALL_OW 428
7774: PUSH
7775: LD_INT 0
7777: GREATER
7778: IFFALSE 7912
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
7780: LD_EXP 17
7784: PUSH
7785: LD_VAR 0 2
7789: ARRAY
7790: PPUSH
7791: LD_EXP 17
7795: PUSH
7796: LD_VAR 0 2
7800: PUSH
7801: LD_INT 1
7803: PLUS
7804: ARRAY
7805: PPUSH
7806: CALL_OW 428
7810: PPUSH
7811: CALL_OW 255
7815: PUSH
7816: LD_EXP 8
7820: NONEQUAL
7821: IFFALSE 7912
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
7823: LD_EXP 17
7827: PUSH
7828: LD_VAR 0 2
7832: ARRAY
7833: PPUSH
7834: LD_EXP 17
7838: PUSH
7839: LD_VAR 0 2
7843: PUSH
7844: LD_INT 1
7846: PLUS
7847: ARRAY
7848: PPUSH
7849: LD_EXP 8
7853: PPUSH
7854: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
7858: LD_ADDR_EXP 17
7862: PUSH
7863: LD_EXP 17
7867: PPUSH
7868: LD_VAR 0 2
7872: PPUSH
7873: CALL_OW 3
7877: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
7878: LD_ADDR_EXP 17
7882: PUSH
7883: LD_EXP 17
7887: PPUSH
7888: LD_VAR 0 2
7892: PPUSH
7893: CALL_OW 3
7897: ST_TO_ADDR
// p := p - 2 ;
7898: LD_ADDR_VAR 0 2
7902: PUSH
7903: LD_VAR 0 2
7907: PUSH
7908: LD_INT 2
7910: MINUS
7911: ST_TO_ADDR
// end ; p := p + 2 ;
7912: LD_ADDR_VAR 0 2
7916: PUSH
7917: LD_VAR 0 2
7921: PUSH
7922: LD_INT 2
7924: PLUS
7925: ST_TO_ADDR
// end ;
7926: GO 7741
7928: POP
7929: POP
// end ;
7930: PPOPN 2
7932: END
// every 0 0$03 do var i , p , skr , filter , dep ;
7933: GO 7935
7935: DISABLE
7936: LD_INT 0
7938: PPUSH
7939: PPUSH
7940: PPUSH
7941: PPUSH
7942: PPUSH
// begin enable ;
7943: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) ;
7944: LD_ADDR_VAR 0 4
7948: PUSH
7949: LD_INT 50
7951: PUSH
7952: EMPTY
7953: LIST
7954: PUSH
7955: LD_INT 22
7957: PUSH
7958: LD_EXP 8
7962: PUSH
7963: EMPTY
7964: LIST
7965: LIST
7966: PUSH
7967: LD_INT 25
7969: PUSH
7970: LD_INT 16
7972: PUSH
7973: EMPTY
7974: LIST
7975: LIST
7976: PUSH
7977: EMPTY
7978: LIST
7979: LIST
7980: LIST
7981: PPUSH
7982: CALL_OW 69
7986: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7987: LD_ADDR_VAR 0 5
7991: PUSH
7992: LD_INT 22
7994: PUSH
7995: LD_EXP 8
7999: PUSH
8000: EMPTY
8001: LIST
8002: LIST
8003: PUSH
8004: LD_INT 2
8006: PUSH
8007: LD_INT 30
8009: PUSH
8010: LD_INT 0
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: PUSH
8017: LD_INT 30
8019: PUSH
8020: LD_INT 1
8022: PUSH
8023: EMPTY
8024: LIST
8025: LIST
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: PUSH
8032: EMPTY
8033: LIST
8034: LIST
8035: PPUSH
8036: CALL_OW 69
8040: ST_TO_ADDR
// skr := GetListOfCratesInArea ( kabul_crates ) ;
8041: LD_ADDR_VAR 0 3
8045: PUSH
8046: LD_INT 13
8048: PPUSH
8049: CALL_OW 435
8053: ST_TO_ADDR
// if filter and skr then
8054: LD_VAR 0 4
8058: PUSH
8059: LD_VAR 0 3
8063: AND
8064: IFFALSE 8121
// for i = 1 to filter do
8066: LD_ADDR_VAR 0 1
8070: PUSH
8071: DOUBLE
8072: LD_INT 1
8074: DEC
8075: ST_TO_ADDR
8076: LD_VAR 0 4
8080: PUSH
8081: FOR_TO
8082: IFFALSE 8119
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
8084: LD_VAR 0 4
8088: PUSH
8089: LD_VAR 0 1
8093: ARRAY
8094: PPUSH
8095: LD_VAR 0 3
8099: PUSH
8100: LD_INT 1
8102: ARRAY
8103: PPUSH
8104: LD_VAR 0 3
8108: PUSH
8109: LD_INT 2
8111: ARRAY
8112: PPUSH
8113: CALL_OW 117
8117: GO 8081
8119: POP
8120: POP
// end ; end_of_file
8121: PPOPN 5
8123: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
8124: LD_INT 0
8126: PPUSH
8127: PPUSH
8128: PPUSH
8129: PPUSH
// begin if un in attackers then
8130: LD_VAR 0 1
8134: PUSH
8135: LD_EXP 20
8139: IN
8140: IFFALSE 8158
// attackers := attackers diff un ;
8142: LD_ADDR_EXP 20
8146: PUSH
8147: LD_EXP 20
8151: PUSH
8152: LD_VAR 0 1
8156: DIFF
8157: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
8158: LD_VAR 0 1
8162: PPUSH
8163: CALL_OW 255
8167: PUSH
8168: LD_EXP 8
8172: NONEQUAL
8173: PUSH
8174: LD_VAR 0 1
8178: PPUSH
8179: CALL_OW 255
8183: PUSH
8184: LD_INT 0
8186: GREATER
8187: AND
8188: PUSH
8189: LD_VAR 0 1
8193: PUSH
8194: LD_INT 21
8196: PUSH
8197: LD_INT 1
8199: PUSH
8200: EMPTY
8201: LIST
8202: LIST
8203: PPUSH
8204: CALL_OW 69
8208: IN
8209: AND
8210: IFFALSE 8388
// begin if respawning_time_min > 0 0$00 then
8212: LD_EXP 13
8216: PUSH
8217: LD_INT 0
8219: GREATER
8220: IFFALSE 8388
// begin s := GetSide ( un ) ;
8222: LD_ADDR_VAR 0 4
8226: PUSH
8227: LD_VAR 0 1
8231: PPUSH
8232: CALL_OW 255
8236: ST_TO_ADDR
// n := GetNation ( un ) ;
8237: LD_ADDR_VAR 0 5
8241: PUSH
8242: LD_VAR 0 1
8246: PPUSH
8247: CALL_OW 248
8251: ST_TO_ADDR
// cl := GetClass ( un ) ;
8252: LD_ADDR_VAR 0 3
8256: PUSH
8257: LD_VAR 0 1
8261: PPUSH
8262: CALL_OW 257
8266: ST_TO_ADDR
// wait ( respawning_time_min ) ;
8267: LD_EXP 13
8271: PPUSH
8272: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) ) ;
8276: LD_EXP 14
8280: PUSH
8281: LD_INT 350
8283: PUSH
8284: LD_OWVAR 1
8288: MUL
8289: PUSH
8290: LD_INT 10
8292: MOD
8293: PUSH
8294: LD_INT 1
8296: PLUS
8297: MINUS
8298: PPUSH
8299: CALL_OW 67
// uc_side := s ;
8303: LD_ADDR_OWVAR 20
8307: PUSH
8308: LD_VAR 0 4
8312: ST_TO_ADDR
// uc_nation := n ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_VAR 0 5
8322: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
8323: LD_INT 0
8325: PPUSH
8326: LD_VAR 0 3
8330: PPUSH
8331: LD_EXP 11
8335: PUSH
8336: LD_INT 2
8338: MINUS
8339: PPUSH
8340: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
8344: CALL_OW 44
8348: PPUSH
8349: LD_INT 17
8351: PUSH
8352: LD_INT 19
8354: PUSH
8355: LD_INT 18
8357: PUSH
8358: LD_INT 19
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: PUSH
8367: LD_VAR 0 3
8371: PUSH
8372: LD_INT 4
8374: MOD
8375: PUSH
8376: LD_INT 1
8378: PLUS
8379: ARRAY
8380: PPUSH
8381: LD_INT 1
8383: PPUSH
8384: CALL_OW 49
// end ; end ; end ;
8388: PPOPN 5
8390: END
// on UnitGoesToRed ( un ) do begin if GetControl ( un ) = control_remote then
8391: LD_VAR 0 1
8395: PPUSH
8396: CALL_OW 263
8400: PUSH
8401: LD_INT 2
8403: EQUAL
8404: IFFALSE 8415
// ComUnlink ( un ) ;
8406: LD_VAR 0 1
8410: PPUSH
8411: CALL_OW 136
// end ;
8415: PPOPN 1
8417: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
8418: LD_VAR 0 1
8422: PPUSH
8423: CALL_OW 255
8427: PUSH
8428: LD_EXP 8
8432: EQUAL
8433: IFFALSE 8464
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
8435: LD_ADDR_EXP 20
8439: PUSH
8440: LD_EXP 20
8444: PPUSH
8445: LD_EXP 20
8449: PUSH
8450: LD_INT 1
8452: PLUS
8453: PPUSH
8454: LD_VAR 0 1
8458: PPUSH
8459: CALL_OW 2
8463: ST_TO_ADDR
// end ;
8464: PPOPN 2
8466: END
// on LeaveBuilding ( b , un ) do var i , arm ;
8467: LD_INT 0
8469: PPUSH
8470: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
8471: LD_VAR 0 1
8475: PPUSH
8476: CALL_OW 255
8480: PUSH
8481: LD_EXP 8
8485: EQUAL
8486: PUSH
8487: LD_VAR 0 1
8491: PPUSH
8492: CALL_OW 266
8496: PUSH
8497: LD_INT 32
8499: EQUAL
8500: AND
8501: IFFALSE 8599
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
8503: LD_ADDR_VAR 0 4
8507: PUSH
8508: LD_INT 22
8510: PUSH
8511: LD_EXP 8
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: PUSH
8520: LD_INT 30
8522: PUSH
8523: LD_INT 5
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PPUSH
8534: CALL_OW 69
8538: ST_TO_ADDR
// for i in arm do
8539: LD_ADDR_VAR 0 3
8543: PUSH
8544: LD_VAR 0 4
8548: PUSH
8549: FOR_IN
8550: IFFALSE 8597
// if UnitsInside ( i ) < 6 then
8552: LD_VAR 0 3
8556: PPUSH
8557: CALL_OW 313
8561: PUSH
8562: LD_INT 6
8564: LESS
8565: IFFALSE 8595
// begin ComEnterUnit ( un , i ) ;
8567: LD_VAR 0 2
8571: PPUSH
8572: LD_VAR 0 3
8576: PPUSH
8577: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
8581: LD_VAR 0 2
8585: PPUSH
8586: LD_INT 8
8588: PPUSH
8589: CALL_OW 183
// break ;
8593: GO 8597
// end ;
8595: GO 8549
8597: POP
8598: POP
// end ; end ; end_of_file
8599: PPOPN 4
8601: END
// every 2 2$0 do
8602: GO 8604
8604: DISABLE
// begin Anticheatcheck ;
8605: CALL_OW 514
// enable ;
8609: ENABLE
// end ; end_of_file
8610: END
// every 10 do
8611: GO 8613
8613: DISABLE
// begin if not multiplayer then
8614: LD_OWVAR 4
8618: NOT
8619: IFFALSE 8623
// exit ;
8621: GO 8708
// if tick < 100 then
8623: LD_OWVAR 1
8627: PUSH
8628: LD_INT 100
8630: LESS
8631: IFFALSE 8651
// begin if tick mod 10 = 0 then
8633: LD_OWVAR 1
8637: PUSH
8638: LD_INT 10
8640: MOD
8641: PUSH
8642: LD_INT 0
8644: EQUAL
8645: IFFALSE 8651
// MultiplayerCRC ;
8647: CALL_OW 361
// end ; if ( tick >= 100 ) then
8651: LD_OWVAR 1
8655: PUSH
8656: LD_INT 100
8658: GREATEREQUAL
8659: IFFALSE 8679
// if tick mod 20 = 0 then
8661: LD_OWVAR 1
8665: PUSH
8666: LD_INT 20
8668: MOD
8669: PUSH
8670: LD_INT 0
8672: EQUAL
8673: IFFALSE 8679
// MultiplayerCRC ;
8675: CALL_OW 361
// if ( tick >= 100 ) then
8679: LD_OWVAR 1
8683: PUSH
8684: LD_INT 100
8686: GREATEREQUAL
8687: IFFALSE 8707
// if tick mod 30 = 0 then
8689: LD_OWVAR 1
8693: PUSH
8694: LD_INT 30
8696: MOD
8697: PUSH
8698: LD_INT 0
8700: EQUAL
8701: IFFALSE 8707
// DebugLogAll ;
8703: CALL_OW 360
// enable ;
8707: ENABLE
// end ; end_of_file
8708: END
// export ExtraStrings ; export function ShowTimer ; var AllStrings ; begin
8709: LD_INT 0
8711: PPUSH
8712: PPUSH
// AllStrings := [ #Multi1x1-Time , tick ] ;
8713: LD_ADDR_VAR 0 2
8717: PUSH
8718: LD_STRING #Multi1x1-Time
8720: PUSH
8721: LD_OWVAR 1
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: ST_TO_ADDR
// if ( ExtraStrings ) then
8730: LD_EXP 28
8734: IFFALSE 8756
// AllStrings := AllStrings ^  ^ ExtraStrings ;
8736: LD_ADDR_VAR 0 2
8740: PUSH
8741: LD_VAR 0 2
8745: PUSH
8746: LD_STRING 
8748: ADD
8749: PUSH
8750: LD_EXP 28
8754: ADD
8755: ST_TO_ADDR
// Display_Strings := AllStrings ;
8756: LD_ADDR_OWVAR 47
8760: PUSH
8761: LD_VAR 0 2
8765: ST_TO_ADDR
// end ;
8766: LD_VAR 0 1
8770: RET
// every 0 0$1 do
8771: GO 8773
8773: DISABLE
// begin ShowTimer ;
8774: CALL 8709 0 0
// enable ;
8778: ENABLE
// end ;
8779: END
