// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 3639 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , attackers_tmp ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// if Multiplayer then
 124: LD_OWVAR 4
 128: IFFALSE 250
// begin Game_Type := mp_game_type ;
 130: LD_ADDR_EXP 1
 134: PUSH
 135: LD_OWVAR 6
 139: ST_TO_ADDR
// Your_Side := mp_player_side ;
 140: LD_ADDR_OWVAR 2
 144: PUSH
 145: LD_OWVAR 7
 149: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_OWVAR 17
 159: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 160: LD_ADDR_EXP 3
 164: PUSH
 165: LD_OWVAR 15
 169: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 170: LD_ADDR_EXP 4
 174: PUSH
 175: LD_OWVAR 16
 179: ST_TO_ADDR
// Teams := mp_teams ;
 180: LD_ADDR_EXP 5
 184: PUSH
 185: LD_OWVAR 12
 189: ST_TO_ADDR
// for i = 0 to 6 do
 190: LD_ADDR_VAR 0 2
 194: PUSH
 195: DOUBLE
 196: LD_INT 0
 198: DEC
 199: ST_TO_ADDR
 200: LD_INT 6
 202: PUSH
 203: FOR_TO
 204: IFFALSE 246
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 206: LD_ADDR_EXP 16
 210: PUSH
 211: LD_EXP 16
 215: PPUSH
 216: LD_EXP 16
 220: PUSH
 221: LD_INT 1
 223: PLUS
 224: PPUSH
 225: LD_VAR 0 2
 229: PPUSH
 230: CALL_OW 426
 234: PUSH
 235: LD_INT 1
 237: PLUS
 238: PPUSH
 239: CALL_OW 2
 243: ST_TO_ADDR
 244: GO 203
 246: POP
 247: POP
// end else
 248: GO 401
// begin Game_Type := 1 ;
 250: LD_ADDR_EXP 1
 254: PUSH
 255: LD_INT 1
 257: ST_TO_ADDR
// Your_Side := 2 ;
 258: LD_ADDR_OWVAR 2
 262: PUSH
 263: LD_INT 2
 265: ST_TO_ADDR
// Side_Positions := [ 0 , 1 , 0 , 0 , 2 , 0 , 0 , 0 ] ;
 266: LD_ADDR_EXP 2
 270: PUSH
 271: LD_INT 0
 273: PUSH
 274: LD_INT 1
 276: PUSH
 277: LD_INT 0
 279: PUSH
 280: LD_INT 0
 282: PUSH
 283: LD_INT 2
 285: PUSH
 286: LD_INT 0
 288: PUSH
 289: LD_INT 0
 291: PUSH
 292: LD_INT 0
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// Side_Teams := [ 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 ] ;
 305: LD_ADDR_EXP 3
 309: PUSH
 310: LD_INT 0
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 0
 318: PUSH
 319: LD_INT 0
 321: PUSH
 322: LD_INT 1
 324: PUSH
 325: LD_INT 0
 327: PUSH
 328: LD_INT 0
 330: PUSH
 331: LD_INT 0
 333: PUSH
 334: EMPTY
 335: LIST
 336: LIST
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: ST_TO_ADDR
// Side_Nations := [ 0 , 3 , 0 , 0 , 3 , 0 , 0 , 0 ] ;
 344: LD_ADDR_EXP 4
 348: PUSH
 349: LD_INT 0
 351: PUSH
 352: LD_INT 3
 354: PUSH
 355: LD_INT 0
 357: PUSH
 358: LD_INT 0
 360: PUSH
 361: LD_INT 3
 363: PUSH
 364: LD_INT 0
 366: PUSH
 367: LD_INT 0
 369: PUSH
 370: LD_INT 0
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: ST_TO_ADDR
// Teams := [ [ 2 , 5 ] ] ;
 383: LD_ADDR_EXP 5
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: LD_INT 5
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: PUSH
 398: EMPTY
 399: LIST
 400: ST_TO_ADDR
// end ; Side_Start := [ [ 203 , 174 ] , [ 114 , 171 ] , [ 26 , 44 ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 401: LD_ADDR_EXP 7
 405: PUSH
 406: LD_INT 203
 408: PUSH
 409: LD_INT 174
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 114
 418: PUSH
 419: LD_INT 171
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: PUSH
 426: LD_INT 26
 428: PUSH
 429: LD_INT 44
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: PUSH
 436: EMPTY
 437: PUSH
 438: EMPTY
 439: PUSH
 440: EMPTY
 441: PUSH
 442: EMPTY
 443: PUSH
 444: EMPTY
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: ST_TO_ADDR
// Bot_Side := 2 ;
 456: LD_ADDR_EXP 8
 460: PUSH
 461: LD_INT 2
 463: ST_TO_ADDR
// for i = 1 to 8 do
 464: LD_ADDR_VAR 0 2
 468: PUSH
 469: DOUBLE
 470: LD_INT 1
 472: DEC
 473: ST_TO_ADDR
 474: LD_INT 8
 476: PUSH
 477: FOR_TO
 478: IFFALSE 610
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
 480: LD_VAR 0 2
 484: PPUSH
 485: CALL_OW 530
 489: IFFALSE 563
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 491: LD_ADDR_EXP 2
 495: PUSH
 496: LD_EXP 2
 500: PPUSH
 501: LD_VAR 0 2
 505: PPUSH
 506: LD_INT 0
 508: PPUSH
 509: CALL_OW 1
 513: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 514: LD_ADDR_EXP 5
 518: PUSH
 519: LD_EXP 5
 523: PPUSH
 524: LD_EXP 3
 528: PUSH
 529: LD_VAR 0 2
 533: ARRAY
 534: PPUSH
 535: LD_EXP 5
 539: PUSH
 540: LD_EXP 3
 544: PUSH
 545: LD_VAR 0 2
 549: ARRAY
 550: ARRAY
 551: PUSH
 552: LD_VAR 0 2
 556: DIFF
 557: PPUSH
 558: CALL_OW 1
 562: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 3 then
 563: LD_EXP 4
 567: PUSH
 568: LD_VAR 0 2
 572: ARRAY
 573: PUSH
 574: LD_EXP 4
 578: PUSH
 579: LD_INT 3
 581: NONEQUAL
 582: AND
 583: IFFALSE 608
// Side_Nations := Replace ( Side_Nations , i , 3 ) ;
 585: LD_ADDR_EXP 4
 589: PUSH
 590: LD_EXP 4
 594: PPUSH
 595: LD_VAR 0 2
 599: PPUSH
 600: LD_INT 3
 602: PPUSH
 603: CALL_OW 1
 607: ST_TO_ADDR
// end ;
 608: GO 477
 610: POP
 611: POP
// if 2 = bot_side and Side_Positions [ 2 ] then
 612: LD_INT 2
 614: PUSH
 615: LD_EXP 8
 619: EQUAL
 620: PUSH
 621: LD_EXP 2
 625: PUSH
 626: LD_INT 2
 628: ARRAY
 629: AND
 630: IFFALSE 640
// bot_side := 5 ;
 632: LD_ADDR_EXP 8
 636: PUSH
 637: LD_INT 5
 639: ST_TO_ADDR
// if 5 = bot_side and Side_Positions [ 5 ] then
 640: LD_INT 5
 642: PUSH
 643: LD_EXP 8
 647: EQUAL
 648: PUSH
 649: LD_EXP 2
 653: PUSH
 654: LD_INT 5
 656: ARRAY
 657: AND
 658: IFFALSE 668
// bot_side := 8 ;
 660: LD_ADDR_EXP 8
 664: PUSH
 665: LD_INT 8
 667: ST_TO_ADDR
// Team_Game := false ;
 668: LD_ADDR_EXP 6
 672: PUSH
 673: LD_INT 0
 675: ST_TO_ADDR
// for i = 1 to 8 do
 676: LD_ADDR_VAR 0 2
 680: PUSH
 681: DOUBLE
 682: LD_INT 1
 684: DEC
 685: ST_TO_ADDR
 686: LD_INT 8
 688: PUSH
 689: FOR_TO
 690: IFFALSE 716
// if Side_Teams [ i ] then
 692: LD_EXP 3
 696: PUSH
 697: LD_VAR 0 2
 701: ARRAY
 702: IFFALSE 714
// begin Team_Game := true ;
 704: LD_ADDR_EXP 6
 708: PUSH
 709: LD_INT 1
 711: ST_TO_ADDR
// break ;
 712: GO 716
// end ;
 714: GO 689
 716: POP
 717: POP
// for i in Teams do
 718: LD_ADDR_VAR 0 2
 722: PUSH
 723: LD_EXP 5
 727: PUSH
 728: FOR_IN
 729: IFFALSE 809
// for j = 2 to i do
 731: LD_ADDR_VAR 0 3
 735: PUSH
 736: DOUBLE
 737: LD_INT 2
 739: DEC
 740: ST_TO_ADDR
 741: LD_VAR 0 2
 745: PUSH
 746: FOR_TO
 747: IFFALSE 805
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
 749: LD_VAR 0 2
 753: PUSH
 754: LD_VAR 0 3
 758: ARRAY
 759: PPUSH
 760: LD_VAR 0 2
 764: PUSH
 765: LD_INT 1
 767: ARRAY
 768: PPUSH
 769: CALL_OW 343
// SetAttitude ( i [ j ] , i [ 1 ] , att_friend , true ) ;
 773: LD_VAR 0 2
 777: PUSH
 778: LD_VAR 0 3
 782: ARRAY
 783: PPUSH
 784: LD_VAR 0 2
 788: PUSH
 789: LD_INT 1
 791: ARRAY
 792: PPUSH
 793: LD_INT 1
 795: PPUSH
 796: LD_INT 1
 798: PPUSH
 799: CALL_OW 80
// end ;
 803: GO 746
 805: POP
 806: POP
 807: GO 728
 809: POP
 810: POP
// if not Multiplayer then
 811: LD_OWVAR 4
 815: NOT
 816: IFFALSE 853
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 818: LD_ADDR_EXP 16
 822: PUSH
 823: LD_INT 1
 825: PUSH
 826: LD_INT 1
 828: PUSH
 829: LD_INT 1
 831: PUSH
 832: LD_INT 1
 834: PUSH
 835: LD_INT 2
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: ST_TO_ADDR
// number_of_people := [ 9 , 12 , 15 , 24 ] [ definitions [ 1 ] ] ;
 853: LD_ADDR_EXP 10
 857: PUSH
 858: LD_INT 9
 860: PUSH
 861: LD_INT 12
 863: PUSH
 864: LD_INT 15
 866: PUSH
 867: LD_INT 24
 869: PUSH
 870: EMPTY
 871: LIST
 872: LIST
 873: LIST
 874: LIST
 875: PUSH
 876: LD_EXP 16
 880: PUSH
 881: LD_INT 1
 883: ARRAY
 884: ARRAY
 885: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 886: LD_ADDR_EXP 11
 890: PUSH
 891: LD_INT 2
 893: PUSH
 894: LD_INT 4
 896: PUSH
 897: LD_INT 6
 899: PUSH
 900: LD_INT 8
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: PUSH
 909: LD_EXP 16
 913: PUSH
 914: LD_INT 2
 916: ARRAY
 917: ARRAY
 918: ST_TO_ADDR
// crates_spawn := [ 0 0$30 , 0 0$25 , 0 0$20 , 0 0$17 ] [ definitions [ 3 ] ] ;
 919: LD_ADDR_EXP 12
 923: PUSH
 924: LD_INT 1050
 926: PUSH
 927: LD_INT 875
 929: PUSH
 930: LD_INT 700
 932: PUSH
 933: LD_INT 595
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PUSH
 942: LD_EXP 16
 946: PUSH
 947: LD_INT 3
 949: ARRAY
 950: ARRAY
 951: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 , 5 5$00 , 3 3$0 ] [ definitions [ 4 ] ] ;
 952: LD_ADDR_EXP 13
 956: PUSH
 957: LD_INT 0
 959: PUSH
 960: LD_INT 10500
 962: PUSH
 963: LD_INT 6300
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: LIST
 970: PUSH
 971: LD_EXP 16
 975: PUSH
 976: LD_INT 4
 978: ARRAY
 979: ARRAY
 980: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 , 15 15$00 , 5 5$0 ] [ definitions [ 4 ] ] ;
 981: LD_ADDR_EXP 14
 985: PUSH
 986: LD_INT 0
 988: PUSH
 989: LD_INT 31500
 991: PUSH
 992: LD_INT 10500
 994: PUSH
 995: EMPTY
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_EXP 16
1004: PUSH
1005: LD_INT 4
1007: ARRAY
1008: ARRAY
1009: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 5 ] ] ;
1010: LD_ADDR_EXP 15
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 3
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 7
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: LD_EXP 16
1037: PUSH
1038: LD_INT 5
1040: ARRAY
1041: ARRAY
1042: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 6 ] ] ;
1043: LD_ADDR_OWVAR 67
1047: PUSH
1048: LD_INT 1
1050: PUSH
1051: LD_INT 2
1053: PUSH
1054: LD_INT 3
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_EXP 16
1066: PUSH
1067: LD_INT 6
1069: ARRAY
1070: ARRAY
1071: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 7 ] ] ;
1072: LD_ADDR_EXP 26
1076: PUSH
1077: LD_INT 0
1079: PUSH
1080: LD_INT 1
1082: PUSH
1083: LD_INT 2
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: PUSH
1091: LD_EXP 16
1095: PUSH
1096: LD_INT 7
1098: ARRAY
1099: ARRAY
1100: ST_TO_ADDR
// queue_codes := [ 11353 , 12244 , 44444 , 12345 , 43413 , 14152 ] ;
1101: LD_ADDR_EXP 23
1105: PUSH
1106: LD_INT 11353
1108: PUSH
1109: LD_INT 12244
1111: PUSH
1112: LD_INT 44444
1114: PUSH
1115: LD_INT 12345
1117: PUSH
1118: LD_INT 43413
1120: PUSH
1121: LD_INT 14152
1123: PUSH
1124: EMPTY
1125: LIST
1126: LIST
1127: LIST
1128: LIST
1129: LIST
1130: LIST
1131: ST_TO_ADDR
// rng := Rand ( 1 , 6 ) ;
1132: LD_ADDR_EXP 24
1136: PUSH
1137: LD_INT 1
1139: PPUSH
1140: LD_INT 6
1142: PPUSH
1143: CALL_OW 12
1147: ST_TO_ADDR
// if bot_side <> 2 then
1148: LD_EXP 8
1152: PUSH
1153: LD_INT 2
1155: NONEQUAL
1156: IFFALSE 1199
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1158: LD_ADDR_VAR 0 2
1162: PUSH
1163: LD_INT 22
1165: PUSH
1166: LD_INT 2
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: PPUSH
1173: CALL_OW 69
1177: PUSH
1178: FOR_IN
1179: IFFALSE 1197
// SetSide ( i , bot_side ) ;
1181: LD_VAR 0 2
1185: PPUSH
1186: LD_EXP 8
1190: PPUSH
1191: CALL_OW 235
1195: GO 1178
1197: POP
1198: POP
// ResetFog ;
1199: CALL_OW 335
// PreparePeople ( ) ;
1203: CALL 2033 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1207: LD_ADDR_EXP 18
1211: PUSH
1212: LD_INT 14
1214: PUSH
1215: LD_INT 15
1217: PUSH
1218: LD_INT 16
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: ST_TO_ADDR
// if amount_of_apeman then
1226: LD_EXP 15
1230: IFFALSE 1280
// for j in apeman_areas do
1232: LD_ADDR_VAR 0 3
1236: PUSH
1237: LD_EXP 18
1241: PUSH
1242: FOR_IN
1243: IFFALSE 1278
// for i = 1 to amount_of_apeman do
1245: LD_ADDR_VAR 0 2
1249: PUSH
1250: DOUBLE
1251: LD_INT 1
1253: DEC
1254: ST_TO_ADDR
1255: LD_EXP 15
1259: PUSH
1260: FOR_TO
1261: IFFALSE 1274
// AddApeman ( j ) ;
1263: LD_VAR 0 3
1267: PPUSH
1268: CALL 2969 0 1
1272: GO 1260
1274: POP
1275: POP
1276: GO 1242
1278: POP
1279: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1280: LD_INT 22
1282: PUSH
1283: LD_OWVAR 2
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: PPUSH
1292: CALL_OW 69
1296: PUSH
1297: LD_INT 1
1299: ARRAY
1300: PPUSH
1301: CALL_OW 87
// disable ( 17 ) ;
1305: LD_INT 17
1307: DISABLE_MARKED
// end ;
1308: LD_VAR 0 1
1312: RET
// every 3 3$40 trigger game_start do
1313: LD_EXP 9
1317: IFFALSE 1373
1319: GO 1321
1321: DISABLE
// begin CreateCratesArea ( tick mod 5 + 1 , kabul_crates , true ) ;
1322: LD_OWVAR 1
1326: PUSH
1327: LD_INT 5
1329: MOD
1330: PUSH
1331: LD_INT 1
1333: PLUS
1334: PPUSH
1335: LD_INT 13
1337: PPUSH
1338: LD_INT 1
1340: PPUSH
1341: CALL_OW 55
// Wait ( 0 0$15 ) ;
1345: LD_INT 525
1347: PPUSH
1348: CALL_OW 67
// CreateCratesAnywhere ( tick mod 5 + 1 , true ) ;
1352: LD_OWVAR 1
1356: PUSH
1357: LD_INT 5
1359: MOD
1360: PUSH
1361: LD_INT 1
1363: PLUS
1364: PPUSH
1365: LD_INT 1
1367: PPUSH
1368: CALL_OW 57
// enable ;
1372: ENABLE
// end ;
1373: END
// every 0 0$01 + 0 0$10 trigger game_start do var cr , cr_queue ;
1374: LD_EXP 9
1378: IFFALSE 2030
1380: GO 1382
1382: DISABLE
1383: LD_INT 0
1385: PPUSH
1386: PPUSH
// begin cr := 1 ;
1387: LD_ADDR_VAR 0 1
1391: PUSH
1392: LD_INT 1
1394: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1395: LD_ADDR_VAR 0 2
1399: PUSH
1400: LD_INT 1
1402: PPUSH
1403: LD_INT 3
1405: PPUSH
1406: CALL_OW 12
1410: PUSH
1411: LD_INT 2
1413: PPUSH
1414: LD_INT 4
1416: PPUSH
1417: CALL_OW 12
1421: PUSH
1422: LD_INT 3
1424: PPUSH
1425: LD_INT 5
1427: PPUSH
1428: CALL_OW 12
1432: PUSH
1433: LD_INT 3
1435: PPUSH
1436: LD_INT 5
1438: PPUSH
1439: CALL_OW 12
1443: PUSH
1444: LD_INT 2
1446: PPUSH
1447: LD_INT 5
1449: PPUSH
1450: CALL_OW 12
1454: PUSH
1455: LD_INT 1
1457: PPUSH
1458: LD_INT 5
1460: PPUSH
1461: CALL_OW 12
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: ST_TO_ADDR
// while ( true ) do
1474: LD_INT 1
1476: IFFALSE 2030
// begin Wait ( crates_spawn + ( tick mod 35 * 60 ) ) ;
1478: LD_EXP 12
1482: PUSH
1483: LD_OWVAR 1
1487: PUSH
1488: LD_INT 35
1490: MOD
1491: PUSH
1492: LD_INT 60
1494: MUL
1495: PLUS
1496: PPUSH
1497: CALL_OW 67
// if cr mod 3 = 0 then
1501: LD_VAR 0 1
1505: PUSH
1506: LD_INT 3
1508: MOD
1509: PUSH
1510: LD_INT 0
1512: EQUAL
1513: IFFALSE 1666
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1515: LD_VAR 0 2
1519: PUSH
1520: LD_VAR 0 1
1524: PUSH
1525: LD_VAR 0 2
1529: MOD
1530: PUSH
1531: LD_INT 1
1533: PLUS
1534: ARRAY
1535: PPUSH
1536: LD_INT 17
1538: PPUSH
1539: LD_INT 1
1541: PPUSH
1542: CALL_OW 55
// Wait ( crates_spawn ) ;
1546: LD_EXP 12
1550: PPUSH
1551: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1555: LD_VAR 0 2
1559: PUSH
1560: LD_VAR 0 1
1564: PUSH
1565: LD_VAR 0 2
1569: MOD
1570: PUSH
1571: LD_INT 1
1573: PLUS
1574: ARRAY
1575: PPUSH
1576: LD_INT 18
1578: PPUSH
1579: LD_INT 1
1581: PPUSH
1582: CALL_OW 55
// Wait ( crates_spawn ) ;
1586: LD_EXP 12
1590: PPUSH
1591: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1595: LD_VAR 0 2
1599: PUSH
1600: LD_VAR 0 1
1604: PUSH
1605: LD_VAR 0 2
1609: MOD
1610: PUSH
1611: LD_INT 1
1613: PLUS
1614: ARRAY
1615: PPUSH
1616: LD_INT 19
1618: PPUSH
1619: LD_INT 1
1621: PPUSH
1622: CALL_OW 55
// Wait ( crates_spawn ) ;
1626: LD_EXP 12
1630: PPUSH
1631: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1635: LD_VAR 0 2
1639: PUSH
1640: LD_VAR 0 1
1644: PUSH
1645: LD_VAR 0 2
1649: MOD
1650: PUSH
1651: LD_INT 1
1653: PLUS
1654: ARRAY
1655: PPUSH
1656: LD_INT 17
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: CALL_OW 55
// end ; if cr mod 3 = 1 then
1666: LD_VAR 0 1
1670: PUSH
1671: LD_INT 3
1673: MOD
1674: PUSH
1675: LD_INT 1
1677: EQUAL
1678: IFFALSE 1831
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1680: LD_VAR 0 2
1684: PUSH
1685: LD_VAR 0 1
1689: PUSH
1690: LD_VAR 0 2
1694: MOD
1695: PUSH
1696: LD_INT 1
1698: PLUS
1699: ARRAY
1700: PPUSH
1701: LD_INT 18
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL_OW 55
// Wait ( crates_spawn ) ;
1711: LD_EXP 12
1715: PPUSH
1716: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1720: LD_VAR 0 2
1724: PUSH
1725: LD_VAR 0 1
1729: PUSH
1730: LD_VAR 0 2
1734: MOD
1735: PUSH
1736: LD_INT 1
1738: PLUS
1739: ARRAY
1740: PPUSH
1741: LD_INT 17
1743: PPUSH
1744: LD_INT 1
1746: PPUSH
1747: CALL_OW 55
// Wait ( crates_spawn ) ;
1751: LD_EXP 12
1755: PPUSH
1756: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1760: LD_VAR 0 2
1764: PUSH
1765: LD_VAR 0 1
1769: PUSH
1770: LD_VAR 0 2
1774: MOD
1775: PUSH
1776: LD_INT 1
1778: PLUS
1779: ARRAY
1780: PPUSH
1781: LD_INT 19
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: CALL_OW 55
// Wait ( crates_spawn ) ;
1791: LD_EXP 12
1795: PPUSH
1796: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1800: LD_VAR 0 2
1804: PUSH
1805: LD_VAR 0 1
1809: PUSH
1810: LD_VAR 0 2
1814: MOD
1815: PUSH
1816: LD_INT 1
1818: PLUS
1819: ARRAY
1820: PPUSH
1821: LD_INT 18
1823: PPUSH
1824: LD_INT 1
1826: PPUSH
1827: CALL_OW 55
// end ; if cr mod 3 = 2 then
1831: LD_VAR 0 1
1835: PUSH
1836: LD_INT 3
1838: MOD
1839: PUSH
1840: LD_INT 2
1842: EQUAL
1843: IFFALSE 1996
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1845: LD_VAR 0 2
1849: PUSH
1850: LD_VAR 0 1
1854: PUSH
1855: LD_VAR 0 2
1859: MOD
1860: PUSH
1861: LD_INT 1
1863: PLUS
1864: ARRAY
1865: PPUSH
1866: LD_INT 19
1868: PPUSH
1869: LD_INT 1
1871: PPUSH
1872: CALL_OW 55
// Wait ( crates_spawn ) ;
1876: LD_EXP 12
1880: PPUSH
1881: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1885: LD_VAR 0 2
1889: PUSH
1890: LD_VAR 0 1
1894: PUSH
1895: LD_VAR 0 2
1899: MOD
1900: PUSH
1901: LD_INT 1
1903: PLUS
1904: ARRAY
1905: PPUSH
1906: LD_INT 18
1908: PPUSH
1909: LD_INT 1
1911: PPUSH
1912: CALL_OW 55
// Wait ( crates_spawn ) ;
1916: LD_EXP 12
1920: PPUSH
1921: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1925: LD_VAR 0 2
1929: PUSH
1930: LD_VAR 0 1
1934: PUSH
1935: LD_VAR 0 2
1939: MOD
1940: PUSH
1941: LD_INT 1
1943: PLUS
1944: ARRAY
1945: PPUSH
1946: LD_INT 17
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: CALL_OW 55
// Wait ( crates_spawn ) ;
1956: LD_EXP 12
1960: PPUSH
1961: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1965: LD_VAR 0 2
1969: PUSH
1970: LD_VAR 0 1
1974: PUSH
1975: LD_VAR 0 2
1979: MOD
1980: PUSH
1981: LD_INT 1
1983: PLUS
1984: ARRAY
1985: PPUSH
1986: LD_INT 19
1988: PPUSH
1989: LD_INT 1
1991: PPUSH
1992: CALL_OW 55
// end ; cr := cr + 1 ;
1996: LD_ADDR_VAR 0 1
2000: PUSH
2001: LD_VAR 0 1
2005: PUSH
2006: LD_INT 1
2008: PLUS
2009: ST_TO_ADDR
// if cr > 150 then
2010: LD_VAR 0 1
2014: PUSH
2015: LD_INT 150
2017: GREATER
2018: IFFALSE 2028
// cr := 43 ;
2020: LD_ADDR_VAR 0 1
2024: PUSH
2025: LD_INT 43
2027: ST_TO_ADDR
// end ;
2028: GO 1474
// end ; end_of_file
2030: PPOPN 2
2032: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
2033: LD_INT 0
2035: PPUSH
2036: PPUSH
2037: PPUSH
2038: PPUSH
2039: PPUSH
2040: PPUSH
2041: PPUSH
2042: PPUSH
2043: PPUSH
// to_copy := [ ] ;
2044: LD_ADDR_VAR 0 5
2048: PUSH
2049: EMPTY
2050: ST_TO_ADDR
// for i = 1 to 8 do
2051: LD_ADDR_VAR 0 2
2055: PUSH
2056: DOUBLE
2057: LD_INT 1
2059: DEC
2060: ST_TO_ADDR
2061: LD_INT 8
2063: PUSH
2064: FOR_TO
2065: IFFALSE 2962
// begin if Side_Positions [ i ] then
2067: LD_EXP 2
2071: PUSH
2072: LD_VAR 0 2
2076: ARRAY
2077: IFFALSE 2960
// begin uc_side := i ;
2079: LD_ADDR_OWVAR 20
2083: PUSH
2084: LD_VAR 0 2
2088: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
2089: LD_ADDR_OWVAR 21
2093: PUSH
2094: LD_EXP 4
2098: PUSH
2099: LD_VAR 0 2
2103: ARRAY
2104: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
2105: LD_ADDR_VAR 0 6
2109: PUSH
2110: LD_EXP 7
2114: PUSH
2115: LD_EXP 2
2119: PUSH
2120: LD_VAR 0 2
2124: ARRAY
2125: ARRAY
2126: PUSH
2127: LD_INT 1
2129: ARRAY
2130: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
2131: LD_ADDR_VAR 0 7
2135: PUSH
2136: LD_EXP 7
2140: PUSH
2141: LD_EXP 2
2145: PUSH
2146: LD_VAR 0 2
2150: ARRAY
2151: ARRAY
2152: PUSH
2153: LD_INT 2
2155: ARRAY
2156: ST_TO_ADDR
// hc_importance := 100 ;
2157: LD_ADDR_OWVAR 32
2161: PUSH
2162: LD_INT 100
2164: ST_TO_ADDR
// if Multiplayer then
2165: LD_OWVAR 4
2169: IFFALSE 2227
// begin hc_name := mp_sides_players_names [ uc_side ] ;
2171: LD_ADDR_OWVAR 26
2175: PUSH
2176: LD_OWVAR 19
2180: PUSH
2181: LD_OWVAR 20
2185: ARRAY
2186: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2187: LD_ADDR_OWVAR 33
2191: PUSH
2192: LD_STRING MULTIAVATARS
2194: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
2195: LD_ADDR_OWVAR 34
2199: PUSH
2200: LD_OWVAR 20
2204: PPUSH
2205: CALL_OW 525
2209: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
2210: LD_ADDR_OWVAR 27
2214: PUSH
2215: LD_OWVAR 20
2219: PPUSH
2220: CALL_OW 526
2224: ST_TO_ADDR
// end else
2225: GO 2259
// begin hc_name :=  ;
2227: LD_ADDR_OWVAR 26
2231: PUSH
2232: LD_STRING 
2234: ST_TO_ADDR
// hc_gallery :=  ;
2235: LD_ADDR_OWVAR 33
2239: PUSH
2240: LD_STRING 
2242: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
2243: LD_ADDR_OWVAR 27
2247: PUSH
2248: LD_INT 1
2250: PPUSH
2251: LD_INT 2
2253: PPUSH
2254: CALL_OW 12
2258: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
2259: LD_OWVAR 27
2263: PPUSH
2264: LD_INT 1
2266: PPUSH
2267: LD_EXP 11
2271: PPUSH
2272: CALL_OW 380
// un := CreateHuman ;
2276: LD_ADDR_VAR 0 4
2280: PUSH
2281: CALL_OW 44
2285: ST_TO_ADDR
// if not to_copy then
2286: LD_VAR 0 5
2290: NOT
2291: IFFALSE 2318
// to_copy := Replace ( to_copy , 1 , un ) else
2293: LD_ADDR_VAR 0 5
2297: PUSH
2298: LD_VAR 0 5
2302: PPUSH
2303: LD_INT 1
2305: PPUSH
2306: LD_VAR 0 4
2310: PPUSH
2311: CALL_OW 1
2315: ST_TO_ADDR
2316: GO 2394
// begin CopySkills ( to_copy [ 1 ] , un ) ;
2318: LD_VAR 0 5
2322: PUSH
2323: LD_INT 1
2325: ARRAY
2326: PPUSH
2327: LD_VAR 0 4
2331: PPUSH
2332: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
2336: LD_VAR 0 4
2340: PPUSH
2341: LD_INT 2
2343: PPUSH
2344: LD_VAR 0 5
2348: PUSH
2349: LD_INT 1
2351: ARRAY
2352: PPUSH
2353: LD_INT 2
2355: PPUSH
2356: CALL_OW 260
2360: PPUSH
2361: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
2365: LD_VAR 0 4
2369: PPUSH
2370: LD_INT 1
2372: PPUSH
2373: LD_VAR 0 5
2377: PUSH
2378: LD_INT 1
2380: ARRAY
2381: PPUSH
2382: LD_INT 1
2384: PPUSH
2385: CALL_OW 260
2389: PPUSH
2390: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2394: LD_VAR 0 4
2398: PPUSH
2399: LD_VAR 0 6
2403: PPUSH
2404: LD_VAR 0 7
2408: PPUSH
2409: LD_INT 10
2411: PPUSH
2412: LD_INT 0
2414: PPUSH
2415: CALL_OW 50
// hc_importance := 0 ;
2419: LD_ADDR_OWVAR 32
2423: PUSH
2424: LD_INT 0
2426: ST_TO_ADDR
// hc_name :=  ;
2427: LD_ADDR_OWVAR 26
2431: PUSH
2432: LD_STRING 
2434: ST_TO_ADDR
// hc_gallery :=  ;
2435: LD_ADDR_OWVAR 33
2439: PUSH
2440: LD_STRING 
2442: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
2443: LD_ADDR_VAR 0 9
2447: PUSH
2448: LD_EXP 10
2452: PUSH
2453: LD_INT 1
2455: MINUS
2456: PUSH
2457: LD_INT 4
2459: DIVREAL
2460: ST_TO_ADDR
// c := 1 ;
2461: LD_ADDR_VAR 0 8
2465: PUSH
2466: LD_INT 1
2468: ST_TO_ADDR
// for j = 2 to number_of_people do
2469: LD_ADDR_VAR 0 3
2473: PUSH
2474: DOUBLE
2475: LD_INT 2
2477: DEC
2478: ST_TO_ADDR
2479: LD_EXP 10
2483: PUSH
2484: FOR_TO
2485: IFFALSE 2696
// begin PrepareHuman ( false , c , skill_level ) ;
2487: LD_INT 0
2489: PPUSH
2490: LD_VAR 0 8
2494: PPUSH
2495: LD_EXP 11
2499: PPUSH
2500: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
2504: LD_VAR 0 3
2508: PUSH
2509: LD_INT 1
2511: MINUS
2512: PUSH
2513: LD_VAR 0 9
2517: MOD
2518: PUSH
2519: LD_INT 0
2521: EQUAL
2522: IFFALSE 2538
// c := c + 1 ;
2524: LD_ADDR_VAR 0 8
2528: PUSH
2529: LD_VAR 0 8
2533: PUSH
2534: LD_INT 1
2536: PLUS
2537: ST_TO_ADDR
// un := CreateHuman ;
2538: LD_ADDR_VAR 0 4
2542: PUSH
2543: CALL_OW 44
2547: ST_TO_ADDR
// if to_copy < j then
2548: LD_VAR 0 5
2552: PUSH
2553: LD_VAR 0 3
2557: LESS
2558: IFFALSE 2587
// to_copy := Replace ( to_copy , j , un ) else
2560: LD_ADDR_VAR 0 5
2564: PUSH
2565: LD_VAR 0 5
2569: PPUSH
2570: LD_VAR 0 3
2574: PPUSH
2575: LD_VAR 0 4
2579: PPUSH
2580: CALL_OW 1
2584: ST_TO_ADDR
2585: GO 2669
// begin CopySkills ( to_copy [ j ] , un ) ;
2587: LD_VAR 0 5
2591: PUSH
2592: LD_VAR 0 3
2596: ARRAY
2597: PPUSH
2598: LD_VAR 0 4
2602: PPUSH
2603: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
2607: LD_VAR 0 4
2611: PPUSH
2612: LD_INT 2
2614: PPUSH
2615: LD_VAR 0 5
2619: PUSH
2620: LD_VAR 0 3
2624: ARRAY
2625: PPUSH
2626: LD_INT 2
2628: PPUSH
2629: CALL_OW 260
2633: PPUSH
2634: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
2638: LD_VAR 0 4
2642: PPUSH
2643: LD_INT 1
2645: PPUSH
2646: LD_VAR 0 5
2650: PUSH
2651: LD_VAR 0 3
2655: ARRAY
2656: PPUSH
2657: LD_INT 1
2659: PPUSH
2660: CALL_OW 260
2664: PPUSH
2665: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2669: LD_VAR 0 4
2673: PPUSH
2674: LD_VAR 0 6
2678: PPUSH
2679: LD_VAR 0 7
2683: PPUSH
2684: LD_INT 10
2686: PPUSH
2687: LD_INT 0
2689: PPUSH
2690: CALL_OW 50
// end ;
2694: GO 2484
2696: POP
2697: POP
// if handicap then
2698: LD_EXP 26
2702: IFFALSE 2960
// begin if handicap = 1 then
2704: LD_EXP 26
2708: PUSH
2709: LD_INT 1
2711: EQUAL
2712: IFFALSE 2791
// for j = 1 to 2 do
2714: LD_ADDR_VAR 0 3
2718: PUSH
2719: DOUBLE
2720: LD_INT 1
2722: DEC
2723: ST_TO_ADDR
2724: LD_INT 2
2726: PUSH
2727: FOR_TO
2728: IFFALSE 2789
// begin vc_chassis := ru_medium_tracked ;
2730: LD_ADDR_OWVAR 37
2734: PUSH
2735: LD_INT 22
2737: ST_TO_ADDR
// vc_engine := engine_siberite ;
2738: LD_ADDR_OWVAR 39
2742: PUSH
2743: LD_INT 3
2745: ST_TO_ADDR
// vc_control := control_manual ;
2746: LD_ADDR_OWVAR 38
2750: PUSH
2751: LD_INT 1
2753: ST_TO_ADDR
// vc_weapon := ru_gun ;
2754: LD_ADDR_OWVAR 40
2758: PUSH
2759: LD_INT 44
2761: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2762: CALL_OW 45
2766: PPUSH
2767: LD_VAR 0 6
2771: PPUSH
2772: LD_VAR 0 7
2776: PPUSH
2777: LD_INT 13
2779: PPUSH
2780: LD_INT 0
2782: PPUSH
2783: CALL_OW 50
// end ;
2787: GO 2727
2789: POP
2790: POP
// if handicap = 2 then
2791: LD_EXP 26
2795: PUSH
2796: LD_INT 2
2798: EQUAL
2799: IFFALSE 2960
// begin for j = 1 to 2 do
2801: LD_ADDR_VAR 0 3
2805: PUSH
2806: DOUBLE
2807: LD_INT 1
2809: DEC
2810: ST_TO_ADDR
2811: LD_INT 2
2813: PUSH
2814: FOR_TO
2815: IFFALSE 2876
// begin vc_chassis := ru_heavy_tracked ;
2817: LD_ADDR_OWVAR 37
2821: PUSH
2822: LD_INT 24
2824: ST_TO_ADDR
// vc_engine := engine_siberite ;
2825: LD_ADDR_OWVAR 39
2829: PUSH
2830: LD_INT 3
2832: ST_TO_ADDR
// vc_control := control_manual ;
2833: LD_ADDR_OWVAR 38
2837: PUSH
2838: LD_INT 1
2840: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
2841: LD_ADDR_OWVAR 40
2845: PUSH
2846: LD_INT 46
2848: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2849: CALL_OW 45
2853: PPUSH
2854: LD_VAR 0 6
2858: PPUSH
2859: LD_VAR 0 7
2863: PPUSH
2864: LD_INT 13
2866: PPUSH
2867: LD_INT 0
2869: PPUSH
2870: CALL_OW 50
// end ;
2874: GO 2814
2876: POP
2877: POP
// vc_chassis := ru_medium_tracked ;
2878: LD_ADDR_OWVAR 37
2882: PUSH
2883: LD_INT 22
2885: ST_TO_ADDR
// vc_engine := engine_siberite ;
2886: LD_ADDR_OWVAR 39
2890: PUSH
2891: LD_INT 3
2893: ST_TO_ADDR
// vc_control := control_computer ;
2894: LD_ADDR_OWVAR 38
2898: PUSH
2899: LD_INT 3
2901: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2902: LD_ADDR_OWVAR 40
2906: PUSH
2907: LD_INT 51
2909: ST_TO_ADDR
// un := CreateVehicle ;
2910: LD_ADDR_VAR 0 4
2914: PUSH
2915: CALL_OW 45
2919: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , 13 , false ) ;
2920: LD_VAR 0 4
2924: PPUSH
2925: LD_VAR 0 6
2929: PPUSH
2930: LD_VAR 0 7
2934: PPUSH
2935: LD_INT 13
2937: PPUSH
2938: LD_INT 0
2940: PPUSH
2941: CALL_OW 50
// SetCargo ( un , mat_cans , 100 ) ;
2945: LD_VAR 0 4
2949: PPUSH
2950: LD_INT 1
2952: PPUSH
2953: LD_INT 100
2955: PPUSH
2956: CALL_OW 290
// end ; end ; end ; end ;
2960: GO 2064
2962: POP
2963: POP
// end ;
2964: LD_VAR 0 1
2968: RET
// export function AddApeman ( area ) ; begin
2969: LD_INT 0
2971: PPUSH
// uc_nation := 0 ;
2972: LD_ADDR_OWVAR 21
2976: PUSH
2977: LD_INT 0
2979: ST_TO_ADDR
// uc_side := 0 ;
2980: LD_ADDR_OWVAR 20
2984: PUSH
2985: LD_INT 0
2987: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
2988: LD_ADDR_OWVAR 35
2992: PUSH
2993: LD_INT 10
2995: NEG
2996: PPUSH
2997: LD_INT 15
2999: PPUSH
3000: CALL_OW 12
3004: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
3005: LD_INT 0
3007: PPUSH
3008: LD_INT 12
3010: PPUSH
3011: LD_INT 0
3013: PPUSH
3014: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3018: LD_ADDR_OWVAR 29
3022: PUSH
3023: LD_INT 10
3025: PUSH
3026: LD_INT 12
3028: PUSH
3029: EMPTY
3030: LIST
3031: LIST
3032: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
3033: CALL_OW 44
3037: PPUSH
3038: LD_VAR 0 1
3042: PPUSH
3043: LD_INT 0
3045: PPUSH
3046: CALL_OW 49
// end ;
3050: LD_VAR 0 2
3054: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
3055: LD_INT 0
3057: PPUSH
3058: PPUSH
3059: PPUSH
3060: PPUSH
// r := 100 ;
3061: LD_ADDR_VAR 0 5
3065: PUSH
3066: LD_INT 100
3068: ST_TO_ADDR
// x := 0 ;
3069: LD_ADDR_VAR 0 6
3073: PUSH
3074: LD_INT 0
3076: ST_TO_ADDR
// while ( x < n ) do
3077: LD_VAR 0 6
3081: PUSH
3082: LD_VAR 0 2
3086: LESS
3087: IFFALSE 3402
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
3089: LD_ADDR_VAR 0 4
3093: PUSH
3094: DOUBLE
3095: LD_INT 1
3097: DEC
3098: ST_TO_ADDR
3099: LD_VAR 0 1
3103: PPUSH
3104: LD_INT 0
3106: PPUSH
3107: CALL_OW 517
3111: PUSH
3112: LD_INT 1
3114: ARRAY
3115: PUSH
3116: FOR_TO
3117: IFFALSE 3398
// begin if r > 50 then
3119: LD_VAR 0 5
3123: PUSH
3124: LD_INT 50
3126: GREATER
3127: IFFALSE 3374
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
3129: LD_VAR 0 1
3133: PPUSH
3134: LD_INT 0
3136: PPUSH
3137: CALL_OW 517
3141: PUSH
3142: LD_INT 1
3144: ARRAY
3145: PUSH
3146: LD_VAR 0 4
3150: ARRAY
3151: PPUSH
3152: LD_VAR 0 1
3156: PPUSH
3157: LD_INT 0
3159: PPUSH
3160: CALL_OW 517
3164: PUSH
3165: LD_INT 2
3167: ARRAY
3168: PUSH
3169: LD_VAR 0 4
3173: ARRAY
3174: PPUSH
3175: CALL_OW 458
3179: NOT
3180: IFFALSE 3358
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
3182: LD_VAR 0 1
3186: PPUSH
3187: LD_INT 0
3189: PPUSH
3190: CALL_OW 517
3194: PUSH
3195: LD_INT 1
3197: ARRAY
3198: PUSH
3199: LD_VAR 0 4
3203: ARRAY
3204: PPUSH
3205: LD_VAR 0 1
3209: PPUSH
3210: LD_INT 0
3212: PPUSH
3213: CALL_OW 517
3217: PUSH
3218: LD_INT 2
3220: ARRAY
3221: PUSH
3222: LD_VAR 0 4
3226: ARRAY
3227: PPUSH
3228: LD_EXP 8
3232: PPUSH
3233: LD_INT 0
3235: PPUSH
3236: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
3240: LD_ADDR_EXP 17
3244: PUSH
3245: LD_EXP 17
3249: PPUSH
3250: LD_EXP 17
3254: PUSH
3255: LD_INT 1
3257: PLUS
3258: PPUSH
3259: LD_VAR 0 1
3263: PPUSH
3264: LD_INT 0
3266: PPUSH
3267: CALL_OW 517
3271: PUSH
3272: LD_INT 1
3274: ARRAY
3275: PUSH
3276: LD_VAR 0 4
3280: ARRAY
3281: PPUSH
3282: CALL_OW 2
3286: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
3287: LD_ADDR_EXP 17
3291: PUSH
3292: LD_EXP 17
3296: PPUSH
3297: LD_EXP 17
3301: PUSH
3302: LD_INT 1
3304: PLUS
3305: PPUSH
3306: LD_VAR 0 1
3310: PPUSH
3311: LD_INT 0
3313: PPUSH
3314: CALL_OW 517
3318: PUSH
3319: LD_INT 2
3321: ARRAY
3322: PUSH
3323: LD_VAR 0 4
3327: ARRAY
3328: PPUSH
3329: CALL_OW 2
3333: ST_TO_ADDR
// r := 0 ;
3334: LD_ADDR_VAR 0 5
3338: PUSH
3339: LD_INT 0
3341: ST_TO_ADDR
// x := x + 1 ;
3342: LD_ADDR_VAR 0 6
3346: PUSH
3347: LD_VAR 0 6
3351: PUSH
3352: LD_INT 1
3354: PLUS
3355: ST_TO_ADDR
// end else
3356: GO 3372
// r := r + 35 ;
3358: LD_ADDR_VAR 0 5
3362: PUSH
3363: LD_VAR 0 5
3367: PUSH
3368: LD_INT 35
3370: PLUS
3371: ST_TO_ADDR
// end else
3372: GO 3396
// r := r + rand ( 10 , 25 ) ;
3374: LD_ADDR_VAR 0 5
3378: PUSH
3379: LD_VAR 0 5
3383: PUSH
3384: LD_INT 10
3386: PPUSH
3387: LD_INT 25
3389: PPUSH
3390: CALL_OW 12
3394: PLUS
3395: ST_TO_ADDR
// end ;
3396: GO 3116
3398: POP
3399: POP
3400: GO 3077
// end ;
3402: LD_VAR 0 3
3406: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
3407: LD_INT 0
3409: PPUSH
3410: PPUSH
3411: PPUSH
// if not GetControl ( veh ) = control_manual then
3412: LD_VAR 0 1
3416: PPUSH
3417: CALL_OW 263
3421: PUSH
3422: LD_INT 1
3424: EQUAL
3425: NOT
3426: IFFALSE 3438
// result := false else
3428: LD_ADDR_VAR 0 2
3432: PUSH
3433: LD_INT 0
3435: ST_TO_ADDR
3436: GO 3583
// if veh in FilterAllUnits ( [ f_empty ] ) then
3438: LD_VAR 0 1
3442: PUSH
3443: LD_INT 58
3445: PUSH
3446: EMPTY
3447: LIST
3448: PPUSH
3449: CALL_OW 69
3453: IN
3454: IFFALSE 3466
// result := false else
3456: LD_ADDR_VAR 0 2
3460: PUSH
3461: LD_INT 0
3463: ST_TO_ADDR
3464: GO 3583
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3466: LD_ADDR_VAR 0 4
3470: PUSH
3471: LD_INT 22
3473: PUSH
3474: LD_VAR 0 1
3478: PPUSH
3479: CALL_OW 255
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 55
3490: PUSH
3491: EMPTY
3492: LIST
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PPUSH
3498: CALL_OW 69
3502: ST_TO_ADDR
// if not filter then
3503: LD_VAR 0 4
3507: NOT
3508: IFFALSE 3520
// result := false else
3510: LD_ADDR_VAR 0 2
3514: PUSH
3515: LD_INT 0
3517: ST_TO_ADDR
3518: GO 3583
// for i = 1 to filter do
3520: LD_ADDR_VAR 0 3
3524: PUSH
3525: DOUBLE
3526: LD_INT 1
3528: DEC
3529: ST_TO_ADDR
3530: LD_VAR 0 4
3534: PUSH
3535: FOR_TO
3536: IFFALSE 3581
// if IsDriver ( filter [ i ] ) = veh then
3538: LD_VAR 0 4
3542: PUSH
3543: LD_VAR 0 3
3547: ARRAY
3548: PPUSH
3549: CALL 3588 0 1
3553: PUSH
3554: LD_VAR 0 1
3558: EQUAL
3559: IFFALSE 3579
// begin result := filter [ i ] ;
3561: LD_ADDR_VAR 0 2
3565: PUSH
3566: LD_VAR 0 4
3570: PUSH
3571: LD_VAR 0 3
3575: ARRAY
3576: ST_TO_ADDR
// break ;
3577: GO 3581
// end ;
3579: GO 3535
3581: POP
3582: POP
// end ; end ;
3583: LD_VAR 0 2
3587: RET
// export function IsDriver ( unit ) ; begin
3588: LD_INT 0
3590: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
3591: LD_VAR 0 1
3595: PUSH
3596: LD_INT 55
3598: PUSH
3599: EMPTY
3600: LIST
3601: PPUSH
3602: CALL_OW 69
3606: IN
3607: IFFALSE 3626
// result := IsInUnit ( unit ) else
3609: LD_ADDR_VAR 0 2
3613: PUSH
3614: LD_VAR 0 1
3618: PPUSH
3619: CALL_OW 310
3623: ST_TO_ADDR
3624: GO 3634
// result := false ;
3626: LD_ADDR_VAR 0 2
3630: PUSH
3631: LD_INT 0
3633: ST_TO_ADDR
// end ; end_of_file
3634: LD_VAR 0 2
3638: RET
// export function InitBot ; var i , ct , hex , side , un , veh , weapons , skill ; begin
3639: LD_INT 0
3641: PPUSH
3642: PPUSH
3643: PPUSH
3644: PPUSH
3645: PPUSH
3646: PPUSH
3647: PPUSH
3648: PPUSH
3649: PPUSH
// side := Bot_Side ;
3650: LD_ADDR_VAR 0 5
3654: PUSH
3655: LD_EXP 8
3659: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
3660: LD_ADDR_VAR 0 9
3664: PUSH
3665: LD_INT 4
3667: PUSH
3668: LD_INT 6
3670: PUSH
3671: LD_INT 8
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: LIST
3678: PUSH
3679: LD_OWVAR 67
3683: ARRAY
3684: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
3685: LD_ADDR_VAR 0 8
3689: PUSH
3690: LD_INT 27
3692: PUSH
3693: LD_INT 28
3695: PUSH
3696: LD_INT 25
3698: PUSH
3699: LD_INT 26
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: LIST
3706: LIST
3707: ST_TO_ADDR
// veh_counter := [ 4 , 5 , 6 ] [ Difficulty ] ;
3708: LD_ADDR_EXP 22
3712: PUSH
3713: LD_INT 4
3715: PUSH
3716: LD_INT 5
3718: PUSH
3719: LD_INT 6
3721: PUSH
3722: EMPTY
3723: LIST
3724: LIST
3725: LIST
3726: PUSH
3727: LD_OWVAR 67
3731: ARRAY
3732: ST_TO_ADDR
// ct := [ ] ;
3733: LD_ADDR_VAR 0 3
3737: PUSH
3738: EMPTY
3739: ST_TO_ADDR
// patrols := [ ] ;
3740: LD_ADDR_EXP 19
3744: PUSH
3745: EMPTY
3746: ST_TO_ADDR
// attackers := [ ] ;
3747: LD_ADDR_EXP 20
3751: PUSH
3752: EMPTY
3753: ST_TO_ADDR
// attackers_tmp := [ ] ;
3754: LD_ADDR_EXP 27
3758: PUSH
3759: EMPTY
3760: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
3761: LD_ADDR_EXP 21
3765: PUSH
3766: LD_INT 14
3768: PUSH
3769: LD_INT 1
3771: PUSH
3772: LD_INT 2
3774: PUSH
3775: LD_INT 27
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 14
3786: PUSH
3787: LD_INT 1
3789: PUSH
3790: LD_INT 2
3792: PUSH
3793: LD_INT 25
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: PUSH
3802: LD_INT 14
3804: PUSH
3805: LD_INT 1
3807: PUSH
3808: LD_INT 2
3810: PUSH
3811: LD_INT 28
3813: PUSH
3814: EMPTY
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: PUSH
3820: LD_INT 14
3822: PUSH
3823: LD_INT 1
3825: PUSH
3826: LD_INT 2
3828: PUSH
3829: LD_INT 29
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: LIST
3836: LIST
3837: PUSH
3838: LD_INT 14
3840: PUSH
3841: LD_INT 1
3843: PUSH
3844: LD_INT 2
3846: PUSH
3847: LD_INT 27
3849: PUSH
3850: EMPTY
3851: LIST
3852: LIST
3853: LIST
3854: LIST
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: LIST
3860: LIST
3861: LIST
3862: ST_TO_ADDR
// SetBName ( ar_dep , newkabul ) ;
3863: LD_INT 2
3865: PPUSH
3866: LD_STRING newkabul
3868: PPUSH
3869: CALL_OW 500
// SetResourceType ( GetBase ( ar_dep ) , mat_cans , 90000 ) ;
3873: LD_INT 2
3875: PPUSH
3876: CALL_OW 274
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_INT 90000
3886: PPUSH
3887: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_oil , 9000 ) ;
3891: LD_INT 2
3893: PPUSH
3894: CALL_OW 274
3898: PPUSH
3899: LD_INT 2
3901: PPUSH
3902: LD_INT 9000
3904: PPUSH
3905: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_siberit , 3000 ) ;
3909: LD_INT 2
3911: PPUSH
3912: CALL_OW 274
3916: PPUSH
3917: LD_INT 3
3919: PPUSH
3920: LD_INT 3000
3922: PPUSH
3923: CALL_OW 277
// if Difficulty > 1 then
3927: LD_OWVAR 67
3931: PUSH
3932: LD_INT 1
3934: GREATER
3935: IFFALSE 3952
// SetTech ( 5 , side , state_researched ) ;
3937: LD_INT 5
3939: PPUSH
3940: LD_VAR 0 5
3944: PPUSH
3945: LD_INT 2
3947: PPUSH
3948: CALL_OW 322
// SetTech ( tech_mortar , side , state_researched ) ;
3952: LD_INT 41
3954: PPUSH
3955: LD_VAR 0 5
3959: PPUSH
3960: LD_INT 2
3962: PPUSH
3963: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
3967: LD_INT 51
3969: PPUSH
3970: LD_VAR 0 5
3974: PPUSH
3975: LD_INT 2
3977: PPUSH
3978: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
3982: LD_INT 52
3984: PPUSH
3985: LD_VAR 0 5
3989: PPUSH
3990: LD_INT 2
3992: PPUSH
3993: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
3997: LD_INT 53
3999: PPUSH
4000: LD_VAR 0 5
4004: PPUSH
4005: LD_INT 2
4007: PPUSH
4008: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
4012: LD_INT 60
4014: PPUSH
4015: LD_VAR 0 5
4019: PPUSH
4020: LD_INT 2
4022: PPUSH
4023: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
4027: LD_INT 61
4029: PPUSH
4030: LD_VAR 0 5
4034: PPUSH
4035: LD_INT 2
4037: PPUSH
4038: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
4042: LD_INT 62
4044: PPUSH
4045: LD_VAR 0 5
4049: PPUSH
4050: LD_INT 2
4052: PPUSH
4053: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4057: LD_ADDR_VAR 0 2
4061: PUSH
4062: LD_INT 22
4064: PUSH
4065: LD_VAR 0 5
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: PUSH
4074: LD_INT 21
4076: PUSH
4077: LD_INT 3
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: PPUSH
4088: CALL_OW 69
4092: PUSH
4093: FOR_IN
4094: IFFALSE 4127
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
4096: LD_VAR 0 2
4100: PPUSH
4101: LD_INT 6
4103: PUSH
4104: LD_INT 8
4106: PUSH
4107: LD_INT 10
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: LIST
4114: PUSH
4115: LD_OWVAR 67
4119: ARRAY
4120: PPUSH
4121: CALL_OW 241
4125: GO 4093
4127: POP
4128: POP
// if Difficulty > 1 then
4129: LD_OWVAR 67
4133: PUSH
4134: LD_INT 1
4136: GREATER
4137: IFFALSE 4146
// RemoveEnvironmentArea ( forest_road ) ;
4139: LD_INT 11
4141: PPUSH
4142: CALL_OW 355
// PlaceMines ( mine_west_zone , [ 10 , 15 , 20 ] [ Difficulty ] ) ;
4146: LD_INT 4
4148: PPUSH
4149: LD_INT 10
4151: PUSH
4152: LD_INT 15
4154: PUSH
4155: LD_INT 20
4157: PUSH
4158: EMPTY
4159: LIST
4160: LIST
4161: LIST
4162: PUSH
4163: LD_OWVAR 67
4167: ARRAY
4168: PPUSH
4169: CALL 3055 0 2
// PlaceMines ( mine_east_zone , [ 7 , 14 , 18 ] [ Difficulty ] ) ;
4173: LD_INT 5
4175: PPUSH
4176: LD_INT 7
4178: PUSH
4179: LD_INT 14
4181: PUSH
4182: LD_INT 18
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: LIST
4189: PUSH
4190: LD_OWVAR 67
4194: ARRAY
4195: PPUSH
4196: CALL 3055 0 2
// PlaceMines ( mine_south_zone , [ 5 , 11 , 17 ] [ Difficulty ] ) ;
4200: LD_INT 7
4202: PPUSH
4203: LD_INT 5
4205: PUSH
4206: LD_INT 11
4208: PUSH
4209: LD_INT 17
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: LIST
4216: PUSH
4217: LD_OWVAR 67
4221: ARRAY
4222: PPUSH
4223: CALL 3055 0 2
// PlaceMines ( mine_high_zone , [ 0 , 3 , 5 ] [ Difficulty ] ) ;
4227: LD_INT 6
4229: PPUSH
4230: LD_INT 0
4232: PUSH
4233: LD_INT 3
4235: PUSH
4236: LD_INT 5
4238: PUSH
4239: EMPTY
4240: LIST
4241: LIST
4242: LIST
4243: PUSH
4244: LD_OWVAR 67
4248: ARRAY
4249: PPUSH
4250: CALL 3055 0 2
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
4254: LD_INT 8
4256: PPUSH
4257: LD_INT 2
4259: PUSH
4260: LD_INT 5
4262: PUSH
4263: LD_INT 8
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: LIST
4270: PUSH
4271: LD_OWVAR 67
4275: ARRAY
4276: PPUSH
4277: CALL 3055 0 2
// PlaceMines ( mine_southpass_zone , [ 0 , 2 , 4 ] [ Difficulty ] ) ;
4281: LD_INT 9
4283: PPUSH
4284: LD_INT 0
4286: PUSH
4287: LD_INT 2
4289: PUSH
4290: LD_INT 4
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: LD_OWVAR 67
4302: ARRAY
4303: PPUSH
4304: CALL 3055 0 2
// PlaceMines ( mine_oileast_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4308: LD_INT 10
4310: PPUSH
4311: LD_INT 0
4313: PUSH
4314: LD_INT 1
4316: PUSH
4317: LD_INT 1
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: LIST
4324: PUSH
4325: LD_OWVAR 67
4329: ARRAY
4330: PPUSH
4331: CALL 3055 0 2
// PlaceMines ( mine_oilwest_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4335: LD_INT 12
4337: PPUSH
4338: LD_INT 0
4340: PUSH
4341: LD_INT 1
4343: PUSH
4344: LD_INT 1
4346: PUSH
4347: EMPTY
4348: LIST
4349: LIST
4350: LIST
4351: PUSH
4352: LD_OWVAR 67
4356: ARRAY
4357: PPUSH
4358: CALL 3055 0 2
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
4362: LD_ADDR_VAR 0 2
4366: PUSH
4367: DOUBLE
4368: LD_INT 1
4370: DEC
4371: ST_TO_ADDR
4372: LD_INT 8
4374: PUSH
4375: LD_INT 11
4377: PUSH
4378: LD_INT 14
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: LIST
4385: PUSH
4386: LD_OWVAR 67
4390: ARRAY
4391: PUSH
4392: FOR_TO
4393: IFFALSE 4568
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
4395: LD_ADDR_VAR 0 4
4399: PUSH
4400: LD_INT 134
4402: PPUSH
4403: LD_INT 73
4405: PPUSH
4406: LD_INT 10
4408: PPUSH
4409: LD_INT 0
4411: PPUSH
4412: CALL_OW 17
4416: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
4417: LD_VAR 0 4
4421: PUSH
4422: LD_INT 1
4424: ARRAY
4425: PPUSH
4426: LD_VAR 0 4
4430: PUSH
4431: LD_INT 2
4433: ARRAY
4434: PPUSH
4435: CALL_OW 428
4439: PUSH
4440: LD_INT 0
4442: EQUAL
4443: PUSH
4444: LD_VAR 0 4
4448: PUSH
4449: LD_INT 1
4451: ARRAY
4452: PPUSH
4453: LD_VAR 0 4
4457: PUSH
4458: LD_INT 2
4460: ARRAY
4461: PPUSH
4462: CALL_OW 458
4466: NOT
4467: AND
4468: IFFALSE 4566
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
4470: LD_ADDR_EXP 17
4474: PUSH
4475: LD_EXP 17
4479: PPUSH
4480: LD_EXP 17
4484: PUSH
4485: LD_INT 1
4487: PLUS
4488: PPUSH
4489: LD_VAR 0 4
4493: PUSH
4494: LD_INT 1
4496: ARRAY
4497: PPUSH
4498: CALL_OW 2
4502: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
4503: LD_ADDR_EXP 17
4507: PUSH
4508: LD_EXP 17
4512: PPUSH
4513: LD_EXP 17
4517: PUSH
4518: LD_INT 1
4520: PLUS
4521: PPUSH
4522: LD_VAR 0 4
4526: PUSH
4527: LD_INT 2
4529: ARRAY
4530: PPUSH
4531: CALL_OW 2
4535: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
4536: LD_VAR 0 4
4540: PUSH
4541: LD_INT 1
4543: ARRAY
4544: PPUSH
4545: LD_VAR 0 4
4549: PUSH
4550: LD_INT 2
4552: ARRAY
4553: PPUSH
4554: LD_EXP 8
4558: PPUSH
4559: LD_INT 0
4561: PPUSH
4562: CALL_OW 454
// end ; end ;
4566: GO 4392
4568: POP
4569: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4570: LD_ADDR_VAR 0 2
4574: PUSH
4575: LD_INT 22
4577: PUSH
4578: LD_VAR 0 5
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PUSH
4587: LD_INT 30
4589: PUSH
4590: LD_INT 32
4592: PUSH
4593: EMPTY
4594: LIST
4595: LIST
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: PPUSH
4601: CALL_OW 69
4605: PUSH
4606: FOR_IN
4607: IFFALSE 4639
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
4609: LD_VAR 0 2
4613: PPUSH
4614: LD_VAR 0 8
4618: PUSH
4619: LD_INT 1
4621: PPUSH
4622: LD_VAR 0 8
4626: PPUSH
4627: CALL_OW 12
4631: ARRAY
4632: PPUSH
4633: CALL_OW 431
4637: GO 4606
4639: POP
4640: POP
// uc_side := side ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_VAR 0 5
4650: ST_TO_ADDR
// uc_nation := 2 ;
4651: LD_ADDR_OWVAR 21
4655: PUSH
4656: LD_INT 2
4658: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
4659: LD_ADDR_VAR 0 2
4663: PUSH
4664: DOUBLE
4665: LD_INT 1
4667: DEC
4668: ST_TO_ADDR
4669: LD_INT 1
4671: PUSH
4672: LD_OWVAR 67
4676: PLUS
4677: PUSH
4678: FOR_TO
4679: IFFALSE 4769
// begin vc_chassis := ar_half_tracked ;
4681: LD_ADDR_OWVAR 37
4685: PUSH
4686: LD_INT 14
4688: ST_TO_ADDR
// vc_engine := engine_combustion ;
4689: LD_ADDR_OWVAR 39
4693: PUSH
4694: LD_INT 1
4696: ST_TO_ADDR
// vc_control := control_manual ;
4697: LD_ADDR_OWVAR 38
4701: PUSH
4702: LD_INT 1
4704: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4705: LD_ADDR_OWVAR 40
4709: PUSH
4710: LD_INT 31
4712: ST_TO_ADDR
// veh := CreateVehicle ;
4713: LD_ADDR_VAR 0 7
4717: PUSH
4718: CALL_OW 45
4722: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
4723: LD_VAR 0 7
4727: PPUSH
4728: LD_INT 3
4730: PPUSH
4731: LD_INT 0
4733: PPUSH
4734: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
4738: LD_INT 0
4740: PPUSH
4741: LD_INT 3
4743: PPUSH
4744: LD_VAR 0 9
4748: PPUSH
4749: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4753: CALL_OW 44
4757: PPUSH
4758: LD_VAR 0 7
4762: PPUSH
4763: CALL_OW 52
// end ;
4767: GO 4678
4769: POP
4770: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4771: LD_ADDR_VAR 0 2
4775: PUSH
4776: LD_INT 22
4778: PUSH
4779: LD_VAR 0 5
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: PUSH
4788: LD_INT 30
4790: PUSH
4791: LD_INT 32
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: PPUSH
4802: CALL_OW 69
4806: PUSH
4807: FOR_IN
4808: IFFALSE 4841
// begin PrepareHuman ( false , 1 , skill ) ;
4810: LD_INT 0
4812: PPUSH
4813: LD_INT 1
4815: PPUSH
4816: LD_VAR 0 9
4820: PPUSH
4821: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4825: CALL_OW 44
4829: PPUSH
4830: LD_VAR 0 2
4834: PPUSH
4835: CALL_OW 52
// end ;
4839: GO 4807
4841: POP
4842: POP
// for i = 1 to 4 do
4843: LD_ADDR_VAR 0 2
4847: PUSH
4848: DOUBLE
4849: LD_INT 1
4851: DEC
4852: ST_TO_ADDR
4853: LD_INT 4
4855: PUSH
4856: FOR_TO
4857: IFFALSE 4888
// begin PrepareHuman ( false , 2 , skill ) ;
4859: LD_INT 0
4861: PPUSH
4862: LD_INT 2
4864: PPUSH
4865: LD_VAR 0 9
4869: PPUSH
4870: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_dep ) ;
4874: CALL_OW 44
4878: PPUSH
4879: LD_INT 2
4881: PPUSH
4882: CALL_OW 52
// end ;
4886: GO 4856
4888: POP
4889: POP
// for i = 1 to 6 do
4890: LD_ADDR_VAR 0 2
4894: PUSH
4895: DOUBLE
4896: LD_INT 1
4898: DEC
4899: ST_TO_ADDR
4900: LD_INT 6
4902: PUSH
4903: FOR_TO
4904: IFFALSE 4935
// begin PrepareHuman ( false , 3 , skill ) ;
4906: LD_INT 0
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: LD_VAR 0 9
4916: PPUSH
4917: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac ) ;
4921: CALL_OW 44
4925: PPUSH
4926: LD_INT 12
4928: PPUSH
4929: CALL_OW 52
// end ;
4933: GO 4903
4935: POP
4936: POP
// for i = 1 to 4 do
4937: LD_ADDR_VAR 0 2
4941: PUSH
4942: DOUBLE
4943: LD_INT 1
4945: DEC
4946: ST_TO_ADDR
4947: LD_INT 4
4949: PUSH
4950: FOR_TO
4951: IFFALSE 5008
// begin PrepareHuman ( false , 4 , skill ) ;
4953: LD_INT 0
4955: PPUSH
4956: LD_INT 4
4958: PPUSH
4959: LD_VAR 0 9
4963: PPUSH
4964: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
4968: CALL_OW 44
4972: PPUSH
4973: LD_INT 30
4975: PUSH
4976: LD_INT 8
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: PPUSH
4983: CALL_OW 69
4987: PUSH
4988: LD_VAR 0 2
4992: PUSH
4993: LD_INT 2
4995: MOD
4996: PUSH
4997: LD_INT 1
4999: PLUS
5000: ARRAY
5001: PPUSH
5002: CALL_OW 52
// end ;
5006: GO 4950
5008: POP
5009: POP
// PrepareHuman ( false , class_mortar , skill ) ;
5010: LD_INT 0
5012: PPUSH
5013: LD_INT 8
5015: PPUSH
5016: LD_VAR 0 9
5020: PPUSH
5021: CALL_OW 380
// un := CreateHuman ;
5025: LD_ADDR_VAR 0 6
5029: PUSH
5030: CALL_OW 44
5034: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5035: LD_VAR 0 6
5039: PPUSH
5040: LD_INT 2
5042: PPUSH
5043: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
5047: LD_VAR 0 6
5051: PPUSH
5052: LD_INT 31
5054: PPUSH
5055: CALL_OW 52
// for i = 1 to 4 do
5059: LD_ADDR_VAR 0 2
5063: PUSH
5064: DOUBLE
5065: LD_INT 1
5067: DEC
5068: ST_TO_ADDR
5069: LD_INT 4
5071: PUSH
5072: FOR_TO
5073: IFFALSE 5129
// begin uc_nation := 0 ;
5075: LD_ADDR_OWVAR 21
5079: PUSH
5080: LD_INT 0
5082: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5083: LD_INT 0
5085: PPUSH
5086: LD_INT 16
5088: PPUSH
5089: LD_INT 1
5091: PPUSH
5092: CALL_OW 380
// un := CreateHuman ;
5096: LD_ADDR_VAR 0 6
5100: PUSH
5101: CALL_OW 44
5105: ST_TO_ADDR
// PlaceUnitXYR ( un , 106 , 46 , 8 , false ) ;
5106: LD_VAR 0 6
5110: PPUSH
5111: LD_INT 106
5113: PPUSH
5114: LD_INT 46
5116: PPUSH
5117: LD_INT 8
5119: PPUSH
5120: LD_INT 0
5122: PPUSH
5123: CALL_OW 50
// end ;
5127: GO 5072
5129: POP
5130: POP
// for i = 1 to 2 * Difficulty do
5131: LD_ADDR_VAR 0 2
5135: PUSH
5136: DOUBLE
5137: LD_INT 1
5139: DEC
5140: ST_TO_ADDR
5141: LD_INT 2
5143: PUSH
5144: LD_OWVAR 67
5148: MUL
5149: PUSH
5150: FOR_TO
5151: IFFALSE 5191
// begin uc_nation := 0 ;
5153: LD_ADDR_OWVAR 21
5157: PUSH
5158: LD_INT 0
5160: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_soldier , 3 ) ;
5161: LD_INT 0
5163: PPUSH
5164: LD_INT 15
5166: PPUSH
5167: LD_INT 3
5169: PPUSH
5170: CALL_OW 380
// PlaceUnitArea ( CreateHuman , ap1 , false ) ;
5174: CALL_OW 44
5178: PPUSH
5179: LD_INT 20
5181: PPUSH
5182: LD_INT 0
5184: PPUSH
5185: CALL_OW 49
// end ;
5189: GO 5150
5191: POP
5192: POP
// for i = 1 to 4 * Difficulty do
5193: LD_ADDR_VAR 0 2
5197: PUSH
5198: DOUBLE
5199: LD_INT 1
5201: DEC
5202: ST_TO_ADDR
5203: LD_INT 4
5205: PUSH
5206: LD_OWVAR 67
5210: MUL
5211: PUSH
5212: FOR_TO
5213: IFFALSE 5287
// begin uc_nation := 0 ;
5215: LD_ADDR_OWVAR 21
5219: PUSH
5220: LD_INT 0
5222: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
5223: LD_INT 0
5225: PPUSH
5226: LD_INT 17
5228: PPUSH
5229: LD_INT 3
5231: PPUSH
5232: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
5236: LD_ADDR_OWVAR 29
5240: PUSH
5241: LD_INT 11
5243: PUSH
5244: LD_INT 13
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: ST_TO_ADDR
// un := CreateHuman ;
5251: LD_ADDR_VAR 0 6
5255: PUSH
5256: CALL_OW 44
5260: ST_TO_ADDR
// PlaceUnitArea ( un , ap2 , false ) ;
5261: LD_VAR 0 6
5265: PPUSH
5266: LD_INT 21
5268: PPUSH
5269: LD_INT 0
5271: PPUSH
5272: CALL_OW 49
// ComHold ( un ) ;
5276: LD_VAR 0 6
5280: PPUSH
5281: CALL_OW 140
// end ;
5285: GO 5212
5287: POP
5288: POP
// end ;
5289: LD_VAR 0 1
5293: RET
// every 12 12$00 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) do var i , tmp , p ;
5294: LD_INT 22
5296: PUSH
5297: LD_EXP 8
5301: PUSH
5302: EMPTY
5303: LIST
5304: LIST
5305: PUSH
5306: LD_INT 30
5308: PUSH
5309: LD_INT 3
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: PPUSH
5320: CALL_OW 69
5324: IFFALSE 5592
5326: GO 5328
5328: DISABLE
5329: LD_INT 0
5331: PPUSH
5332: PPUSH
5333: PPUSH
// begin enable ;
5334: ENABLE
// tmp := queue_codes [ rng ] ;
5335: LD_ADDR_VAR 0 2
5339: PUSH
5340: LD_EXP 23
5344: PUSH
5345: LD_EXP 24
5349: ARRAY
5350: ST_TO_ADDR
// p := 1 ;
5351: LD_ADDR_VAR 0 3
5355: PUSH
5356: LD_INT 1
5358: ST_TO_ADDR
// for i = 1 to veh_counter do
5359: LD_ADDR_VAR 0 1
5363: PUSH
5364: DOUBLE
5365: LD_INT 1
5367: DEC
5368: ST_TO_ADDR
5369: LD_EXP 22
5373: PUSH
5374: FOR_TO
5375: IFFALSE 5556
// begin AddComConstruct ( FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) [ 1 ] , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
5377: LD_INT 22
5379: PUSH
5380: LD_EXP 8
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: LD_INT 30
5391: PUSH
5392: LD_INT 3
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: PPUSH
5403: CALL_OW 69
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: PPUSH
5412: LD_EXP 21
5416: PUSH
5417: LD_VAR 0 2
5421: PUSH
5422: LD_INT 10
5424: MOD
5425: ARRAY
5426: PUSH
5427: LD_INT 1
5429: ARRAY
5430: PPUSH
5431: LD_EXP 21
5435: PUSH
5436: LD_VAR 0 2
5440: PUSH
5441: LD_INT 10
5443: MOD
5444: ARRAY
5445: PUSH
5446: LD_INT 2
5448: ARRAY
5449: PPUSH
5450: LD_EXP 21
5454: PUSH
5455: LD_VAR 0 2
5459: PUSH
5460: LD_INT 10
5462: MOD
5463: ARRAY
5464: PUSH
5465: LD_INT 3
5467: ARRAY
5468: PPUSH
5469: LD_EXP 21
5473: PUSH
5474: LD_VAR 0 2
5478: PUSH
5479: LD_INT 10
5481: MOD
5482: ARRAY
5483: PUSH
5484: LD_INT 4
5486: ARRAY
5487: PPUSH
5488: CALL_OW 185
// tmp := tmp / 10 ;
5492: LD_ADDR_VAR 0 2
5496: PUSH
5497: LD_VAR 0 2
5501: PUSH
5502: LD_INT 10
5504: DIVREAL
5505: ST_TO_ADDR
// p := p + 1 ;
5506: LD_ADDR_VAR 0 3
5510: PUSH
5511: LD_VAR 0 3
5515: PUSH
5516: LD_INT 1
5518: PLUS
5519: ST_TO_ADDR
// if p > 5 then
5520: LD_VAR 0 3
5524: PUSH
5525: LD_INT 5
5527: GREATER
5528: IFFALSE 5554
// begin p := 1 ;
5530: LD_ADDR_VAR 0 3
5534: PUSH
5535: LD_INT 1
5537: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
5538: LD_ADDR_VAR 0 2
5542: PUSH
5543: LD_EXP 23
5547: PUSH
5548: LD_EXP 24
5552: ARRAY
5553: ST_TO_ADDR
// end ; end ;
5554: GO 5374
5556: POP
5557: POP
// rng := rng + 1 ;
5558: LD_ADDR_EXP 24
5562: PUSH
5563: LD_EXP 24
5567: PUSH
5568: LD_INT 1
5570: PLUS
5571: ST_TO_ADDR
// if rng > queue_codes then
5572: LD_EXP 24
5576: PUSH
5577: LD_EXP 23
5581: GREATER
5582: IFFALSE 5592
// rng := 1 ;
5584: LD_ADDR_EXP 24
5588: PUSH
5589: LD_INT 1
5591: ST_TO_ADDR
// end ;
5592: PPOPN 3
5594: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
5595: LD_INT 25
5597: PUSH
5598: LD_INT 17
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PPUSH
5605: CALL_OW 69
5609: IFFALSE 5712
5611: GO 5613
5613: DISABLE
5614: LD_INT 0
5616: PPUSH
5617: PPUSH
// begin enable ;
5618: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
5619: LD_ADDR_VAR 0 1
5623: PUSH
5624: LD_INT 25
5626: PUSH
5627: LD_INT 17
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PPUSH
5634: CALL_OW 69
5638: PUSH
5639: FOR_IN
5640: IFFALSE 5710
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
5642: LD_ADDR_VAR 0 2
5646: PUSH
5647: LD_INT 81
5649: PUSH
5650: LD_EXP 8
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: PPUSH
5659: CALL_OW 69
5663: PPUSH
5664: LD_VAR 0 1
5668: PPUSH
5669: CALL_OW 74
5673: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
5674: LD_VAR 0 1
5678: PPUSH
5679: LD_VAR 0 2
5683: PPUSH
5684: CALL_OW 296
5688: PUSH
5689: LD_INT 15
5691: LESS
5692: IFFALSE 5708
// ComAttackUnit ( i , un ) ;
5694: LD_VAR 0 1
5698: PPUSH
5699: LD_VAR 0 2
5703: PPUSH
5704: CALL_OW 115
// end ;
5708: GO 5639
5710: POP
5711: POP
// end ;
5712: PPOPN 2
5714: END
// every 0 0$01 trigger attackers marked 17 do var i ;
5715: LD_EXP 20
5719: IFFALSE 5813
5721: GO 5723
5723: DISABLE
5724: LD_INT 0
5726: PPUSH
// begin enable ;
5727: ENABLE
// if target = 0 then
5728: LD_EXP 25
5732: PUSH
5733: LD_INT 0
5735: EQUAL
5736: IFFALSE 5760
// target := FilterAllUnits ( [ f_enemy , bot_side ] ) ;
5738: LD_ADDR_EXP 25
5742: PUSH
5743: LD_INT 81
5745: PUSH
5746: LD_EXP 8
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PPUSH
5755: CALL_OW 69
5759: ST_TO_ADDR
// for i in attackers do
5760: LD_ADDR_VAR 0 1
5764: PUSH
5765: LD_EXP 20
5769: PUSH
5770: FOR_IN
5771: IFFALSE 5811
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , target ] ) , i ) ) ;
5773: LD_VAR 0 1
5777: PPUSH
5778: LD_INT 22
5780: PUSH
5781: LD_EXP 25
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PPUSH
5790: CALL_OW 69
5794: PPUSH
5795: LD_VAR 0 1
5799: PPUSH
5800: CALL_OW 74
5804: PPUSH
5805: CALL_OW 115
5809: GO 5770
5811: POP
5812: POP
// end ;
5813: PPOPN 1
5815: END
// every 0 0$01 trigger not attackers marked 17 do
5816: LD_EXP 20
5820: NOT
5821: IFFALSE 5830
5823: GO 5825
5825: DISABLE
// begin enable ;
5826: ENABLE
// disable ( 17 ) ;
5827: LD_INT 17
5829: DISABLE_MARKED
// end ;
5830: END
// every 3 3$00 trigger veh_counter <= attackers do var max , i ;
5831: LD_EXP 22
5835: PUSH
5836: LD_EXP 20
5840: LESSEQUAL
5841: IFFALSE 5950
5843: GO 5845
5845: DISABLE
5846: LD_INT 0
5848: PPUSH
5849: PPUSH
// begin enable ;
5850: ENABLE
// enable ( 17 ) ;
5851: LD_INT 17
5853: ENABLE_MARKED
// max := 1 ;
5854: LD_ADDR_VAR 0 1
5858: PUSH
5859: LD_INT 1
5861: ST_TO_ADDR
// for i = 1 to 8 do
5862: LD_ADDR_VAR 0 2
5866: PUSH
5867: DOUBLE
5868: LD_INT 1
5870: DEC
5871: ST_TO_ADDR
5872: LD_INT 8
5874: PUSH
5875: FOR_TO
5876: IFFALSE 5948
// if i <> bot_side then
5878: LD_VAR 0 2
5882: PUSH
5883: LD_EXP 8
5887: NONEQUAL
5888: IFFALSE 5946
// begin if max < FilterAllUnits ( [ f_side , i ] ) then
5890: LD_VAR 0 1
5894: PUSH
5895: LD_INT 22
5897: PUSH
5898: LD_VAR 0 2
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PPUSH
5907: CALL_OW 69
5911: LESS
5912: IFFALSE 5946
// begin max := FilterAllUnits ( [ f_side , i ] ) ;
5914: LD_ADDR_VAR 0 1
5918: PUSH
5919: LD_INT 22
5921: PUSH
5922: LD_VAR 0 2
5926: PUSH
5927: EMPTY
5928: LIST
5929: LIST
5930: PPUSH
5931: CALL_OW 69
5935: ST_TO_ADDR
// target := i ;
5936: LD_ADDR_EXP 25
5940: PUSH
5941: LD_VAR 0 2
5945: ST_TO_ADDR
// end ; end ;
5946: GO 5875
5948: POP
5949: POP
// end ;
5950: PPOPN 2
5952: END
// every 0 0$01 trigger game_start and tick >= 30 30$00 do
5953: LD_EXP 9
5957: PUSH
5958: LD_OWVAR 1
5962: PUSH
5963: LD_INT 63000
5965: GREATEREQUAL
5966: AND
5967: IFFALSE 5986
5969: GO 5971
5971: DISABLE
// begin veh_counter := veh_counter + 1 ;
5972: LD_ADDR_EXP 22
5976: PUSH
5977: LD_EXP 22
5981: PUSH
5982: LD_INT 1
5984: PLUS
5985: ST_TO_ADDR
// end ;
5986: END
// every 0 0$01 trigger game_start and tick >= 50 50$00 do
5987: LD_EXP 9
5991: PUSH
5992: LD_OWVAR 1
5996: PUSH
5997: LD_INT 105000
5999: GREATEREQUAL
6000: AND
6001: IFFALSE 6020
6003: GO 6005
6005: DISABLE
// begin veh_counter := veh_counter + 2 ;
6006: LD_ADDR_EXP 22
6010: PUSH
6011: LD_EXP 22
6015: PUSH
6016: LD_INT 2
6018: PLUS
6019: ST_TO_ADDR
// end ;
6020: END
// every 0 0$01 trigger game_start and tick >= 80 80$00 do
6021: LD_EXP 9
6025: PUSH
6026: LD_OWVAR 1
6030: PUSH
6031: LD_INT 168000
6033: GREATEREQUAL
6034: AND
6035: IFFALSE 6054
6037: GO 6039
6039: DISABLE
// begin veh_counter := veh_counter + 3 ;
6040: LD_ADDR_EXP 22
6044: PUSH
6045: LD_EXP 22
6049: PUSH
6050: LD_INT 3
6052: PLUS
6053: ST_TO_ADDR
// end ;
6054: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
6055: LD_INT 22
6057: PUSH
6058: LD_EXP 8
6062: PUSH
6063: EMPTY
6064: LIST
6065: LIST
6066: PUSH
6067: LD_INT 33
6069: PUSH
6070: LD_INT 2
6072: PUSH
6073: EMPTY
6074: LIST
6075: LIST
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: PPUSH
6081: CALL_OW 69
6085: IFFALSE 6301
6087: GO 6089
6089: DISABLE
6090: LD_INT 0
6092: PPUSH
6093: PPUSH
6094: PPUSH
6095: PPUSH
6096: PPUSH
6097: PPUSH
6098: PPUSH
// begin enable ;
6099: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
6100: LD_ADDR_VAR 0 4
6104: PUSH
6105: LD_INT 22
6107: PUSH
6108: LD_EXP 8
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: PUSH
6117: LD_INT 33
6119: PUSH
6120: LD_INT 2
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: PUSH
6127: LD_INT 3
6129: PUSH
6130: LD_INT 61
6132: PUSH
6133: EMPTY
6134: LIST
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: LIST
6144: PPUSH
6145: CALL_OW 69
6149: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
6150: LD_ADDR_VAR 0 3
6154: PUSH
6155: LD_INT 22
6157: PUSH
6158: LD_EXP 8
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: PUSH
6167: LD_INT 34
6169: PUSH
6170: LD_INT 31
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: PPUSH
6181: CALL_OW 69
6185: ST_TO_ADDR
// best := 10 ;
6186: LD_ADDR_VAR 0 5
6190: PUSH
6191: LD_INT 10
6193: ST_TO_ADDR
// best_mechanic := - 1 ;
6194: LD_ADDR_VAR 0 6
6198: PUSH
6199: LD_INT 1
6201: NEG
6202: ST_TO_ADDR
// if vehs then
6203: LD_VAR 0 4
6207: IFFALSE 6301
// begin for j in cts do
6209: LD_ADDR_VAR 0 2
6213: PUSH
6214: LD_VAR 0 3
6218: PUSH
6219: FOR_IN
6220: IFFALSE 6281
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
6222: LD_ADDR_VAR 0 7
6226: PUSH
6227: LD_VAR 0 2
6231: PPUSH
6232: CALL 3407 0 1
6236: PPUSH
6237: CALL_OW 432
6241: ST_TO_ADDR
// if p < best then
6242: LD_VAR 0 7
6246: PUSH
6247: LD_VAR 0 5
6251: LESS
6252: IFFALSE 6279
// begin best := p ;
6254: LD_ADDR_VAR 0 5
6258: PUSH
6259: LD_VAR 0 7
6263: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
6264: LD_ADDR_VAR 0 6
6268: PUSH
6269: LD_VAR 0 2
6273: PPUSH
6274: CALL 3407 0 1
6278: ST_TO_ADDR
// end ; end ;
6279: GO 6219
6281: POP
6282: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
6283: LD_VAR 0 4
6287: PUSH
6288: LD_INT 1
6290: ARRAY
6291: PPUSH
6292: LD_VAR 0 6
6296: PPUSH
6297: CALL_OW 135
// end ; end ;
6301: PPOPN 7
6303: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
6304: GO 6306
6306: DISABLE
6307: LD_INT 0
6309: PPUSH
6310: PPUSH
6311: PPUSH
6312: PPUSH
6313: PPUSH
6314: PPUSH
6315: PPUSH
// begin enable ;
6316: ENABLE
// b := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6317: LD_ADDR_VAR 0 6
6321: PUSH
6322: LD_INT 22
6324: PUSH
6325: LD_EXP 8
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PUSH
6334: LD_INT 21
6336: PUSH
6337: LD_INT 3
6339: PUSH
6340: EMPTY
6341: LIST
6342: LIST
6343: PUSH
6344: LD_INT 3
6346: PUSH
6347: LD_INT 24
6349: PUSH
6350: LD_INT 1000
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: PUSH
6361: EMPTY
6362: LIST
6363: LIST
6364: LIST
6365: PPUSH
6366: CALL_OW 69
6370: ST_TO_ADDR
// h := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6371: LD_ADDR_VAR 0 3
6375: PUSH
6376: LD_INT 22
6378: PUSH
6379: LD_EXP 8
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: PUSH
6388: LD_INT 2
6390: PUSH
6391: LD_INT 25
6393: PUSH
6394: LD_INT 1
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: PUSH
6401: LD_INT 25
6403: PUSH
6404: LD_INT 2
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: PUSH
6411: LD_INT 25
6413: PUSH
6414: LD_INT 3
6416: PUSH
6417: EMPTY
6418: LIST
6419: LIST
6420: PUSH
6421: EMPTY
6422: LIST
6423: LIST
6424: LIST
6425: LIST
6426: PUSH
6427: LD_INT 3
6429: PUSH
6430: LD_INT 24
6432: PUSH
6433: LD_INT 750
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: LIST
6448: PPUSH
6449: CALL_OW 69
6453: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ;
6454: LD_ADDR_VAR 0 4
6458: PUSH
6459: LD_INT 22
6461: PUSH
6462: LD_EXP 8
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: LD_INT 25
6473: PUSH
6474: LD_INT 4
6476: PUSH
6477: EMPTY
6478: LIST
6479: LIST
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: PPUSH
6485: CALL_OW 69
6489: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
6490: LD_ADDR_VAR 0 5
6494: PUSH
6495: LD_INT 22
6497: PUSH
6498: LD_EXP 8
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: PUSH
6507: LD_INT 25
6509: PUSH
6510: LD_INT 2
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: PUSH
6517: EMPTY
6518: LIST
6519: LIST
6520: PPUSH
6521: CALL_OW 69
6525: ST_TO_ADDR
// if not h and not b then
6526: LD_VAR 0 3
6530: NOT
6531: PUSH
6532: LD_VAR 0 6
6536: NOT
6537: AND
6538: IFFALSE 6822
// begin if sci then
6540: LD_VAR 0 4
6544: IFFALSE 6681
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
6546: LD_VAR 0 4
6550: PPUSH
6551: LD_INT 3
6553: PUSH
6554: LD_INT 54
6556: PUSH
6557: EMPTY
6558: LIST
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PPUSH
6564: CALL_OW 72
6568: PUSH
6569: LD_INT 22
6571: PUSH
6572: LD_EXP 8
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: LD_INT 30
6583: PUSH
6584: LD_INT 8
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: PPUSH
6595: CALL_OW 69
6599: AND
6600: IFFALSE 6681
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
6602: LD_ADDR_VAR 0 2
6606: PUSH
6607: LD_VAR 0 4
6611: PPUSH
6612: LD_INT 3
6614: PUSH
6615: LD_INT 54
6617: PUSH
6618: EMPTY
6619: LIST
6620: PUSH
6621: EMPTY
6622: LIST
6623: LIST
6624: PPUSH
6625: CALL_OW 72
6629: PUSH
6630: FOR_IN
6631: IFFALSE 6679
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6633: LD_VAR 0 2
6637: PPUSH
6638: LD_INT 22
6640: PUSH
6641: LD_EXP 8
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: PUSH
6650: LD_INT 30
6652: PUSH
6653: LD_INT 8
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: PPUSH
6664: CALL_OW 69
6668: PUSH
6669: LD_INT 1
6671: ARRAY
6672: PPUSH
6673: CALL_OW 120
6677: GO 6630
6679: POP
6680: POP
// if eng then
6681: LD_VAR 0 5
6685: IFFALSE 6822
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
6687: LD_VAR 0 5
6691: PPUSH
6692: LD_INT 3
6694: PUSH
6695: LD_INT 54
6697: PUSH
6698: EMPTY
6699: LIST
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: PPUSH
6705: CALL_OW 72
6709: PUSH
6710: LD_INT 22
6712: PUSH
6713: LD_EXP 8
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: PUSH
6722: LD_INT 30
6724: PUSH
6725: LD_INT 1
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: PUSH
6732: EMPTY
6733: LIST
6734: LIST
6735: PPUSH
6736: CALL_OW 69
6740: AND
6741: IFFALSE 6822
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
6743: LD_ADDR_VAR 0 2
6747: PUSH
6748: LD_VAR 0 5
6752: PPUSH
6753: LD_INT 3
6755: PUSH
6756: LD_INT 54
6758: PUSH
6759: EMPTY
6760: LIST
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: PPUSH
6766: CALL_OW 72
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6820
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_INT 22
6781: PUSH
6782: LD_EXP 8
6786: PUSH
6787: EMPTY
6788: LIST
6789: LIST
6790: PUSH
6791: LD_INT 30
6793: PUSH
6794: LD_INT 1
6796: PUSH
6797: EMPTY
6798: LIST
6799: LIST
6800: PUSH
6801: EMPTY
6802: LIST
6803: LIST
6804: PPUSH
6805: CALL_OW 69
6809: PUSH
6810: LD_INT 1
6812: ARRAY
6813: PPUSH
6814: CALL_OW 120
6818: GO 6771
6820: POP
6821: POP
// end ; p := 1 ;
6822: LD_ADDR_VAR 0 7
6826: PUSH
6827: LD_INT 1
6829: ST_TO_ADDR
// if b and eng then
6830: LD_VAR 0 6
6834: PUSH
6835: LD_VAR 0 5
6839: AND
6840: IFFALSE 6974
// for j in eng do
6842: LD_ADDR_VAR 0 2
6846: PUSH
6847: LD_VAR 0 5
6851: PUSH
6852: FOR_IN
6853: IFFALSE 6972
// begin if IsInUnit ( j ) then
6855: LD_VAR 0 2
6859: PPUSH
6860: CALL_OW 310
6864: IFFALSE 6877
// ComExitBuilding ( j ) else
6866: LD_VAR 0 2
6870: PPUSH
6871: CALL_OW 122
6875: GO 6970
// if not HasTask ( j ) and GetLives ( j ) > 750 then
6877: LD_VAR 0 2
6881: PPUSH
6882: CALL_OW 314
6886: NOT
6887: PUSH
6888: LD_VAR 0 2
6892: PPUSH
6893: CALL_OW 256
6897: PUSH
6898: LD_INT 750
6900: GREATER
6901: AND
6902: IFFALSE 6970
// begin if b > p then
6904: LD_VAR 0 6
6908: PUSH
6909: LD_VAR 0 7
6913: GREATER
6914: IFFALSE 6952
// begin ComRepairBuilding ( j , b [ p ] ) ;
6916: LD_VAR 0 2
6920: PPUSH
6921: LD_VAR 0 6
6925: PUSH
6926: LD_VAR 0 7
6930: ARRAY
6931: PPUSH
6932: CALL_OW 130
// p := p + 1 ;
6936: LD_ADDR_VAR 0 7
6940: PUSH
6941: LD_VAR 0 7
6945: PUSH
6946: LD_INT 1
6948: PLUS
6949: ST_TO_ADDR
// end else
6950: GO 6970
// ComRepairBuilding ( j , b [ 1 ] ) ;
6952: LD_VAR 0 2
6956: PPUSH
6957: LD_VAR 0 6
6961: PUSH
6962: LD_INT 1
6964: ARRAY
6965: PPUSH
6966: CALL_OW 130
// end ; end ;
6970: GO 6852
6972: POP
6973: POP
// if h and sci then
6974: LD_VAR 0 3
6978: PUSH
6979: LD_VAR 0 4
6983: AND
6984: IFFALSE 7123
// for i in h do
6986: LD_ADDR_VAR 0 1
6990: PUSH
6991: LD_VAR 0 3
6995: PUSH
6996: FOR_IN
6997: IFFALSE 7121
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
6999: LD_VAR 0 1
7003: PPUSH
7004: LD_INT 108
7006: PPUSH
7007: LD_INT 42
7009: PPUSH
7010: CALL_OW 297
7014: PUSH
7015: LD_INT 10
7017: GREATER
7018: IFFALSE 7037
// ComMoveXY ( i , 108 , 42 ) else
7020: LD_VAR 0 1
7024: PPUSH
7025: LD_INT 108
7027: PPUSH
7028: LD_INT 42
7030: PPUSH
7031: CALL_OW 111
7035: GO 7119
// begin for j in sci do
7037: LD_ADDR_VAR 0 2
7041: PUSH
7042: LD_VAR 0 4
7046: PUSH
7047: FOR_IN
7048: IFFALSE 7117
// begin if GetTag ( j ) > 0 then
7050: LD_VAR 0 2
7054: PPUSH
7055: CALL_OW 110
7059: PUSH
7060: LD_INT 0
7062: GREATER
7063: IFFALSE 7067
// continue ;
7065: GO 7047
// if IsInUnit ( j ) then
7067: LD_VAR 0 2
7071: PPUSH
7072: CALL_OW 310
7076: IFFALSE 7089
// ComExitBuilding ( j ) else
7078: LD_VAR 0 2
7082: PPUSH
7083: CALL_OW 122
7087: GO 7115
// if not HasTask ( j ) then
7089: LD_VAR 0 2
7093: PPUSH
7094: CALL_OW 314
7098: NOT
7099: IFFALSE 7115
// ComHeal ( j , h ) ;
7101: LD_VAR 0 2
7105: PPUSH
7106: LD_VAR 0 3
7110: PPUSH
7111: CALL_OW 128
// end ;
7115: GO 7047
7117: POP
7118: POP
// end ;
7119: GO 6996
7121: POP
7122: POP
// end ;
7123: PPOPN 7
7125: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 155 , 88 ) and GetBType ( HexInfo ( 155 , 88 ) = b_siberite_mine ) do var sci , p ;
7126: LD_INT 155
7128: PPUSH
7129: LD_INT 88
7131: PPUSH
7132: CALL_OW 428
7136: PUSH
7137: LD_INT 155
7139: PPUSH
7140: LD_INT 88
7142: PPUSH
7143: CALL_OW 428
7147: PUSH
7148: LD_INT 30
7150: EQUAL
7151: PPUSH
7152: CALL_OW 266
7156: AND
7157: IFFALSE 7406
7159: GO 7161
7161: DISABLE
7162: LD_INT 0
7164: PPUSH
7165: PPUSH
// begin p := GetSide ( HexInfo ( 155 , 88 ) ) ;
7166: LD_ADDR_VAR 0 2
7170: PUSH
7171: LD_INT 155
7173: PPUSH
7174: LD_INT 88
7176: PPUSH
7177: CALL_OW 428
7181: PPUSH
7182: CALL_OW 255
7186: ST_TO_ADDR
// Wait ( [ 5 5$30 , 6 6$33 , 6 6$21 , 8 8$44 , 9 9$31 , 4 4$33 , 9 9$01 , 5 5$01 ] [ p ] ) ;
7187: LD_INT 11550
7189: PUSH
7190: LD_INT 13755
7192: PUSH
7193: LD_INT 13335
7195: PUSH
7196: LD_INT 18340
7198: PUSH
7199: LD_INT 19985
7201: PUSH
7202: LD_INT 9555
7204: PUSH
7205: LD_INT 18935
7207: PUSH
7208: LD_INT 10535
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: LIST
7215: LIST
7216: LIST
7217: LIST
7218: LIST
7219: LIST
7220: PUSH
7221: LD_VAR 0 2
7225: ARRAY
7226: PPUSH
7227: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7231: LD_INT 22
7233: PUSH
7234: LD_EXP 8
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: PUSH
7243: LD_INT 25
7245: PUSH
7246: LD_INT 4
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PPUSH
7257: CALL_OW 69
7261: PUSH
7262: LD_INT 0
7264: EQUAL
7265: IFFALSE 7269
// exit ;
7267: GO 7406
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ 1 ] ;
7269: LD_ADDR_VAR 0 1
7273: PUSH
7274: LD_INT 22
7276: PUSH
7277: LD_EXP 8
7281: PUSH
7282: EMPTY
7283: LIST
7284: LIST
7285: PUSH
7286: LD_INT 25
7288: PUSH
7289: LD_INT 4
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: EMPTY
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL_OW 69
7304: PUSH
7305: LD_INT 1
7307: ARRAY
7308: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7309: LD_VAR 0 1
7313: PPUSH
7314: LD_INT 1
7316: PPUSH
7317: CALL_OW 109
// ComExitBuilding ( sci ) ;
7321: LD_VAR 0 1
7325: PPUSH
7326: CALL_OW 122
// AddComMoveXY ( sci , 126 , 59 ) ;
7330: LD_VAR 0 1
7334: PPUSH
7335: LD_INT 126
7337: PPUSH
7338: LD_INT 59
7340: PPUSH
7341: CALL_OW 171
// if p mod 2 = 0 then
7345: LD_VAR 0 2
7349: PUSH
7350: LD_INT 2
7352: MOD
7353: PUSH
7354: LD_INT 0
7356: EQUAL
7357: IFFALSE 7376
// AddComMoveXY ( sci , 148 , 66 ) else
7359: LD_VAR 0 1
7363: PPUSH
7364: LD_INT 148
7366: PPUSH
7367: LD_INT 66
7369: PPUSH
7370: CALL_OW 171
7374: GO 7391
// AddComMoveXY ( sci , 135 , 84 ) ;
7376: LD_VAR 0 1
7380: PPUSH
7381: LD_INT 135
7383: PPUSH
7384: LD_INT 84
7386: PPUSH
7387: CALL_OW 171
// AddComContaminate ( sci , 155 , 88 ) ;
7391: LD_VAR 0 1
7395: PPUSH
7396: LD_INT 155
7398: PPUSH
7399: LD_INT 88
7401: PPUSH
7402: CALL_OW 218
// end ;
7406: PPOPN 2
7408: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 33 , 10 ) and GetBType ( HexInfo ( 33 , 10 ) = b_siberite_mine ) do var sci , p ;
7409: LD_INT 33
7411: PPUSH
7412: LD_INT 10
7414: PPUSH
7415: CALL_OW 428
7419: PUSH
7420: LD_INT 33
7422: PPUSH
7423: LD_INT 10
7425: PPUSH
7426: CALL_OW 428
7430: PUSH
7431: LD_INT 30
7433: EQUAL
7434: PPUSH
7435: CALL_OW 266
7439: AND
7440: IFFALSE 7691
7442: GO 7444
7444: DISABLE
7445: LD_INT 0
7447: PPUSH
7448: PPUSH
// begin p := GetSide ( HexInfo ( 33 , 10 ) ) ;
7449: LD_ADDR_VAR 0 2
7453: PUSH
7454: LD_INT 33
7456: PPUSH
7457: LD_INT 10
7459: PPUSH
7460: CALL_OW 428
7464: PPUSH
7465: CALL_OW 255
7469: ST_TO_ADDR
// Wait ( [ 4 4$30 , 5 5$33 , 3 3$21 , 4 4$44 , 3 3$31 , 5 5$33 , 3 3$01 , 8 8$01 ] [ p ] ) ;
7470: LD_INT 9450
7472: PUSH
7473: LD_INT 11655
7475: PUSH
7476: LD_INT 7035
7478: PUSH
7479: LD_INT 9940
7481: PUSH
7482: LD_INT 7385
7484: PUSH
7485: LD_INT 11655
7487: PUSH
7488: LD_INT 6335
7490: PUSH
7491: LD_INT 16835
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: PUSH
7504: LD_VAR 0 2
7508: ARRAY
7509: PPUSH
7510: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7514: LD_INT 22
7516: PUSH
7517: LD_EXP 8
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 25
7528: PUSH
7529: LD_INT 4
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PPUSH
7540: CALL_OW 69
7544: PUSH
7545: LD_INT 0
7547: EQUAL
7548: IFFALSE 7552
// exit ;
7550: GO 7691
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ sci ] ;
7552: LD_ADDR_VAR 0 1
7556: PUSH
7557: LD_INT 22
7559: PUSH
7560: LD_EXP 8
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 25
7571: PUSH
7572: LD_INT 4
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PUSH
7579: EMPTY
7580: LIST
7581: LIST
7582: PPUSH
7583: CALL_OW 69
7587: PUSH
7588: LD_VAR 0 1
7592: ARRAY
7593: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7594: LD_VAR 0 1
7598: PPUSH
7599: LD_INT 1
7601: PPUSH
7602: CALL_OW 109
// ComExitBuilding ( sci ) ;
7606: LD_VAR 0 1
7610: PPUSH
7611: CALL_OW 122
// AddComMoveXY ( sci , 67 , 13 ) ;
7615: LD_VAR 0 1
7619: PPUSH
7620: LD_INT 67
7622: PPUSH
7623: LD_INT 13
7625: PPUSH
7626: CALL_OW 171
// if p mod 2 = 0 then
7630: LD_VAR 0 2
7634: PUSH
7635: LD_INT 2
7637: MOD
7638: PUSH
7639: LD_INT 0
7641: EQUAL
7642: IFFALSE 7661
// AddComMoveXY ( sci , 37 , 3 ) else
7644: LD_VAR 0 1
7648: PPUSH
7649: LD_INT 37
7651: PPUSH
7652: LD_INT 3
7654: PPUSH
7655: CALL_OW 171
7659: GO 7676
// AddComMoveXY ( sci , 45 , 20 ) ;
7661: LD_VAR 0 1
7665: PPUSH
7666: LD_INT 45
7668: PPUSH
7669: LD_INT 20
7671: PPUSH
7672: CALL_OW 171
// AddComContaminate ( sci , 33 , 10 ) ;
7676: LD_VAR 0 1
7680: PPUSH
7681: LD_INT 33
7683: PPUSH
7684: LD_INT 10
7686: PPUSH
7687: CALL_OW 218
// end ;
7691: PPOPN 2
7693: END
// every 0 0$01 trigger mines_list do var i , p ;
7694: LD_EXP 17
7698: IFFALSE 7924
7700: GO 7702
7702: DISABLE
7703: LD_INT 0
7705: PPUSH
7706: PPUSH
// begin enable ;
7707: ENABLE
// p := 1 ;
7708: LD_ADDR_VAR 0 2
7712: PUSH
7713: LD_INT 1
7715: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
7716: LD_ADDR_VAR 0 1
7720: PUSH
7721: DOUBLE
7722: LD_INT 1
7724: DEC
7725: ST_TO_ADDR
7726: LD_EXP 17
7730: PUSH
7731: LD_INT 2
7733: DIVREAL
7734: PUSH
7735: FOR_TO
7736: IFFALSE 7922
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
7738: LD_EXP 17
7742: PUSH
7743: LD_VAR 0 2
7747: ARRAY
7748: PPUSH
7749: LD_EXP 17
7753: PUSH
7754: LD_VAR 0 2
7758: PUSH
7759: LD_INT 1
7761: PLUS
7762: ARRAY
7763: PPUSH
7764: CALL_OW 428
7768: PUSH
7769: LD_INT 0
7771: GREATER
7772: IFFALSE 7906
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
7774: LD_EXP 17
7778: PUSH
7779: LD_VAR 0 2
7783: ARRAY
7784: PPUSH
7785: LD_EXP 17
7789: PUSH
7790: LD_VAR 0 2
7794: PUSH
7795: LD_INT 1
7797: PLUS
7798: ARRAY
7799: PPUSH
7800: CALL_OW 428
7804: PPUSH
7805: CALL_OW 255
7809: PUSH
7810: LD_EXP 8
7814: NONEQUAL
7815: IFFALSE 7906
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
7817: LD_EXP 17
7821: PUSH
7822: LD_VAR 0 2
7826: ARRAY
7827: PPUSH
7828: LD_EXP 17
7832: PUSH
7833: LD_VAR 0 2
7837: PUSH
7838: LD_INT 1
7840: PLUS
7841: ARRAY
7842: PPUSH
7843: LD_EXP 8
7847: PPUSH
7848: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
7852: LD_ADDR_EXP 17
7856: PUSH
7857: LD_EXP 17
7861: PPUSH
7862: LD_VAR 0 2
7866: PPUSH
7867: CALL_OW 3
7871: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
7872: LD_ADDR_EXP 17
7876: PUSH
7877: LD_EXP 17
7881: PPUSH
7882: LD_VAR 0 2
7886: PPUSH
7887: CALL_OW 3
7891: ST_TO_ADDR
// p := p - 2 ;
7892: LD_ADDR_VAR 0 2
7896: PUSH
7897: LD_VAR 0 2
7901: PUSH
7902: LD_INT 2
7904: MINUS
7905: ST_TO_ADDR
// end ; p := p + 2 ;
7906: LD_ADDR_VAR 0 2
7910: PUSH
7911: LD_VAR 0 2
7915: PUSH
7916: LD_INT 2
7918: PLUS
7919: ST_TO_ADDR
// end ;
7920: GO 7735
7922: POP
7923: POP
// end ;
7924: PPOPN 2
7926: END
// every 0 0$03 do var i , p , skr , filter , dep ;
7927: GO 7929
7929: DISABLE
7930: LD_INT 0
7932: PPUSH
7933: PPUSH
7934: PPUSH
7935: PPUSH
7936: PPUSH
// begin enable ;
7937: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) ;
7938: LD_ADDR_VAR 0 4
7942: PUSH
7943: LD_INT 50
7945: PUSH
7946: EMPTY
7947: LIST
7948: PUSH
7949: LD_INT 22
7951: PUSH
7952: LD_EXP 8
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: PUSH
7961: LD_INT 25
7963: PUSH
7964: LD_INT 16
7966: PUSH
7967: EMPTY
7968: LIST
7969: LIST
7970: PUSH
7971: EMPTY
7972: LIST
7973: LIST
7974: LIST
7975: PPUSH
7976: CALL_OW 69
7980: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7981: LD_ADDR_VAR 0 5
7985: PUSH
7986: LD_INT 22
7988: PUSH
7989: LD_EXP 8
7993: PUSH
7994: EMPTY
7995: LIST
7996: LIST
7997: PUSH
7998: LD_INT 2
8000: PUSH
8001: LD_INT 30
8003: PUSH
8004: LD_INT 0
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: LD_INT 30
8013: PUSH
8014: LD_INT 1
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PUSH
8021: EMPTY
8022: LIST
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: ST_TO_ADDR
// skr := GetListOfCratesInArea ( kabul_crates ) ;
8035: LD_ADDR_VAR 0 3
8039: PUSH
8040: LD_INT 13
8042: PPUSH
8043: CALL_OW 435
8047: ST_TO_ADDR
// if filter and skr then
8048: LD_VAR 0 4
8052: PUSH
8053: LD_VAR 0 3
8057: AND
8058: IFFALSE 8115
// for i = 1 to filter do
8060: LD_ADDR_VAR 0 1
8064: PUSH
8065: DOUBLE
8066: LD_INT 1
8068: DEC
8069: ST_TO_ADDR
8070: LD_VAR 0 4
8074: PUSH
8075: FOR_TO
8076: IFFALSE 8113
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
8078: LD_VAR 0 4
8082: PUSH
8083: LD_VAR 0 1
8087: ARRAY
8088: PPUSH
8089: LD_VAR 0 3
8093: PUSH
8094: LD_INT 1
8096: ARRAY
8097: PPUSH
8098: LD_VAR 0 3
8102: PUSH
8103: LD_INT 2
8105: ARRAY
8106: PPUSH
8107: CALL_OW 117
8111: GO 8075
8113: POP
8114: POP
// end ; end_of_file
8115: PPOPN 5
8117: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
8118: LD_INT 0
8120: PPUSH
8121: PPUSH
8122: PPUSH
8123: PPUSH
// begin if un in attackers then
8124: LD_VAR 0 1
8128: PUSH
8129: LD_EXP 20
8133: IN
8134: IFFALSE 8152
// attackers := attackers diff un ;
8136: LD_ADDR_EXP 20
8140: PUSH
8141: LD_EXP 20
8145: PUSH
8146: LD_VAR 0 1
8150: DIFF
8151: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
8152: LD_VAR 0 1
8156: PPUSH
8157: CALL_OW 255
8161: PUSH
8162: LD_EXP 8
8166: NONEQUAL
8167: PUSH
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 255
8177: PUSH
8178: LD_INT 0
8180: GREATER
8181: AND
8182: PUSH
8183: LD_VAR 0 1
8187: PUSH
8188: LD_INT 21
8190: PUSH
8191: LD_INT 1
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: PPUSH
8198: CALL_OW 69
8202: IN
8203: AND
8204: IFFALSE 8382
// begin if respawning_time_min > 0 0$00 then
8206: LD_EXP 13
8210: PUSH
8211: LD_INT 0
8213: GREATER
8214: IFFALSE 8382
// begin s := GetSide ( un ) ;
8216: LD_ADDR_VAR 0 4
8220: PUSH
8221: LD_VAR 0 1
8225: PPUSH
8226: CALL_OW 255
8230: ST_TO_ADDR
// n := GetNation ( un ) ;
8231: LD_ADDR_VAR 0 5
8235: PUSH
8236: LD_VAR 0 1
8240: PPUSH
8241: CALL_OW 248
8245: ST_TO_ADDR
// cl := GetClass ( un ) ;
8246: LD_ADDR_VAR 0 3
8250: PUSH
8251: LD_VAR 0 1
8255: PPUSH
8256: CALL_OW 257
8260: ST_TO_ADDR
// wait ( respawning_time_min ) ;
8261: LD_EXP 13
8265: PPUSH
8266: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) ) ;
8270: LD_EXP 14
8274: PUSH
8275: LD_INT 350
8277: PUSH
8278: LD_OWVAR 1
8282: MUL
8283: PUSH
8284: LD_INT 10
8286: MOD
8287: PUSH
8288: LD_INT 1
8290: PLUS
8291: MINUS
8292: PPUSH
8293: CALL_OW 67
// uc_side := s ;
8297: LD_ADDR_OWVAR 20
8301: PUSH
8302: LD_VAR 0 4
8306: ST_TO_ADDR
// uc_nation := n ;
8307: LD_ADDR_OWVAR 21
8311: PUSH
8312: LD_VAR 0 5
8316: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
8317: LD_INT 0
8319: PPUSH
8320: LD_VAR 0 3
8324: PPUSH
8325: LD_EXP 11
8329: PUSH
8330: LD_INT 2
8332: MINUS
8333: PPUSH
8334: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
8338: CALL_OW 44
8342: PPUSH
8343: LD_INT 17
8345: PUSH
8346: LD_INT 19
8348: PUSH
8349: LD_INT 18
8351: PUSH
8352: LD_INT 19
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: PUSH
8361: LD_VAR 0 3
8365: PUSH
8366: LD_INT 4
8368: MOD
8369: PUSH
8370: LD_INT 1
8372: PLUS
8373: ARRAY
8374: PPUSH
8375: LD_INT 1
8377: PPUSH
8378: CALL_OW 49
// end ; end ; end ;
8382: PPOPN 5
8384: END
// on UnitGoesToRed ( un ) do begin if GetControl ( un ) = control_remote then
8385: LD_VAR 0 1
8389: PPUSH
8390: CALL_OW 263
8394: PUSH
8395: LD_INT 2
8397: EQUAL
8398: IFFALSE 8409
// ComUnlink ( un ) ;
8400: LD_VAR 0 1
8404: PPUSH
8405: CALL_OW 136
// end ;
8409: PPOPN 1
8411: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 255
8421: PUSH
8422: LD_EXP 8
8426: EQUAL
8427: IFFALSE 8458
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
8429: LD_ADDR_EXP 20
8433: PUSH
8434: LD_EXP 20
8438: PPUSH
8439: LD_EXP 20
8443: PUSH
8444: LD_INT 1
8446: PLUS
8447: PPUSH
8448: LD_VAR 0 1
8452: PPUSH
8453: CALL_OW 2
8457: ST_TO_ADDR
// end ;
8458: PPOPN 2
8460: END
// on LeaveBuilding ( b , un ) do var i , arm ;
8461: LD_INT 0
8463: PPUSH
8464: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
8465: LD_VAR 0 1
8469: PPUSH
8470: CALL_OW 255
8474: PUSH
8475: LD_EXP 8
8479: EQUAL
8480: PUSH
8481: LD_VAR 0 1
8485: PPUSH
8486: CALL_OW 266
8490: PUSH
8491: LD_INT 32
8493: EQUAL
8494: AND
8495: IFFALSE 8593
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
8497: LD_ADDR_VAR 0 4
8501: PUSH
8502: LD_INT 22
8504: PUSH
8505: LD_EXP 8
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: LD_INT 30
8516: PUSH
8517: LD_INT 5
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: PPUSH
8528: CALL_OW 69
8532: ST_TO_ADDR
// for i in arm do
8533: LD_ADDR_VAR 0 3
8537: PUSH
8538: LD_VAR 0 4
8542: PUSH
8543: FOR_IN
8544: IFFALSE 8591
// if UnitsInside ( i ) < 6 then
8546: LD_VAR 0 3
8550: PPUSH
8551: CALL_OW 313
8555: PUSH
8556: LD_INT 6
8558: LESS
8559: IFFALSE 8589
// begin ComEnterUnit ( un , i ) ;
8561: LD_VAR 0 2
8565: PPUSH
8566: LD_VAR 0 3
8570: PPUSH
8571: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
8575: LD_VAR 0 2
8579: PPUSH
8580: LD_INT 8
8582: PPUSH
8583: CALL_OW 183
// break ;
8587: GO 8591
// end ;
8589: GO 8543
8591: POP
8592: POP
// end ; end ; end_of_file
8593: PPOPN 4
8595: END
// every 2 2$0 do
8596: GO 8598
8598: DISABLE
// begin Anticheatcheck ;
8599: CALL_OW 514
// enable ;
8603: ENABLE
// end ; end_of_file
8604: END
// every 10 do
8605: GO 8607
8607: DISABLE
// begin if not multiplayer then
8608: LD_OWVAR 4
8612: NOT
8613: IFFALSE 8617
// exit ;
8615: GO 8702
// if tick < 100 then
8617: LD_OWVAR 1
8621: PUSH
8622: LD_INT 100
8624: LESS
8625: IFFALSE 8645
// begin if tick mod 10 = 0 then
8627: LD_OWVAR 1
8631: PUSH
8632: LD_INT 10
8634: MOD
8635: PUSH
8636: LD_INT 0
8638: EQUAL
8639: IFFALSE 8645
// MultiplayerCRC ;
8641: CALL_OW 361
// end ; if ( tick >= 100 ) then
8645: LD_OWVAR 1
8649: PUSH
8650: LD_INT 100
8652: GREATEREQUAL
8653: IFFALSE 8673
// if tick mod 20 = 0 then
8655: LD_OWVAR 1
8659: PUSH
8660: LD_INT 20
8662: MOD
8663: PUSH
8664: LD_INT 0
8666: EQUAL
8667: IFFALSE 8673
// MultiplayerCRC ;
8669: CALL_OW 361
// if ( tick >= 100 ) then
8673: LD_OWVAR 1
8677: PUSH
8678: LD_INT 100
8680: GREATEREQUAL
8681: IFFALSE 8701
// if tick mod 30 = 0 then
8683: LD_OWVAR 1
8687: PUSH
8688: LD_INT 30
8690: MOD
8691: PUSH
8692: LD_INT 0
8694: EQUAL
8695: IFFALSE 8701
// DebugLogAll ;
8697: CALL_OW 360
// enable ;
8701: ENABLE
// end ; end_of_file
8702: END
// export ExtraStrings ; export function ShowTimer ; var AllStrings ; begin
8703: LD_INT 0
8705: PPUSH
8706: PPUSH
// AllStrings := [ #Multi1x1-Time , tick ] ;
8707: LD_ADDR_VAR 0 2
8711: PUSH
8712: LD_STRING #Multi1x1-Time
8714: PUSH
8715: LD_OWVAR 1
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: ST_TO_ADDR
// if ( ExtraStrings ) then
8724: LD_EXP 28
8728: IFFALSE 8750
// AllStrings := AllStrings ^  ^ ExtraStrings ;
8730: LD_ADDR_VAR 0 2
8734: PUSH
8735: LD_VAR 0 2
8739: PUSH
8740: LD_STRING 
8742: ADD
8743: PUSH
8744: LD_EXP 28
8748: ADD
8749: ST_TO_ADDR
// Display_Strings := AllStrings ;
8750: LD_ADDR_OWVAR 47
8754: PUSH
8755: LD_VAR 0 2
8759: ST_TO_ADDR
// end ;
8760: LD_VAR 0 1
8764: RET
// every 0 0$1 do
8765: GO 8767
8767: DISABLE
// begin ShowTimer ;
8768: CALL 8703 0 0
// enable ;
8772: ENABLE
// end ;
8773: END
