// export function MCF_Get ( side , filter ) ; begin
   0: LD_INT 0
   2: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
   3: LD_ADDR_VAR 0 3
   7: PUSH
   8: LD_INT 22
  10: PUSH
  11: LD_VAR 0 1
  15: PUSH
  16: EMPTY
  17: LIST
  18: LIST
  19: PUSH
  20: LD_VAR 0 2
  24: PUSH
  25: EMPTY
  26: LIST
  27: LIST
  28: PPUSH
  29: CALL_OW 69
  33: ST_TO_ADDR
// end ;
  34: LD_VAR 0 3
  38: RET
// export function MCF_Lab ( side ) ; begin
  39: LD_INT 0
  41: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
  42: LD_ADDR_VAR 0 2
  46: PUSH
  47: LD_INT 22
  49: PUSH
  50: LD_VAR 0 1
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 8
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: PUSH
  69: EMPTY
  70: LIST
  71: LIST
  72: PPUSH
  73: CALL_OW 69
  77: ST_TO_ADDR
// end ;
  78: LD_VAR 0 2
  82: RET
// export function MCF_Class ( side , class , filter ) ; begin
  83: LD_INT 0
  85: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
  86: LD_ADDR_VAR 0 4
  90: PUSH
  91: LD_INT 22
  93: PUSH
  94: LD_VAR 0 1
  98: PUSH
  99: EMPTY
 100: LIST
 101: LIST
 102: PUSH
 103: LD_INT 25
 105: PUSH
 106: LD_VAR 0 2
 110: PUSH
 111: EMPTY
 112: LIST
 113: LIST
 114: PUSH
 115: LD_VAR 0 3
 119: PUSH
 120: EMPTY
 121: LIST
 122: LIST
 123: LIST
 124: PPUSH
 125: CALL_OW 69
 129: ST_TO_ADDR
// end ;
 130: LD_VAR 0 4
 134: RET
// export function MCF_All ( side , filter ) ; begin
 135: LD_INT 0
 137: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
 138: LD_ADDR_VAR 0 3
 142: PUSH
 143: LD_INT 22
 145: PUSH
 146: LD_VAR 0 1
 150: PUSH
 151: EMPTY
 152: LIST
 153: LIST
 154: PUSH
 155: LD_INT 2
 157: PUSH
 158: LD_INT 25
 160: PUSH
 161: LD_INT 1
 163: PUSH
 164: EMPTY
 165: LIST
 166: LIST
 167: PUSH
 168: LD_INT 25
 170: PUSH
 171: LD_INT 2
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: PUSH
 178: LD_INT 25
 180: PUSH
 181: LD_INT 3
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PUSH
 188: LD_INT 25
 190: PUSH
 191: LD_INT 4
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: PUSH
 198: EMPTY
 199: LIST
 200: LIST
 201: LIST
 202: LIST
 203: LIST
 204: PUSH
 205: LD_VAR 0 2
 209: PUSH
 210: EMPTY
 211: LIST
 212: LIST
 213: LIST
 214: PPUSH
 215: CALL_OW 69
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 3
 224: RET
// export function MCF_Dist ( side , point , filter ) ; begin
 225: LD_INT 0
 227: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
 228: LD_ADDR_VAR 0 4
 232: PUSH
 233: LD_INT 22
 235: PUSH
 236: LD_VAR 0 1
 240: PUSH
 241: EMPTY
 242: LIST
 243: LIST
 244: PUSH
 245: LD_INT 92
 247: PUSH
 248: LD_VAR 0 2
 252: PUSH
 253: LD_INT 1
 255: ARRAY
 256: PUSH
 257: LD_VAR 0 2
 261: PUSH
 262: LD_INT 2
 264: ARRAY
 265: PUSH
 266: LD_VAR 0 2
 270: PUSH
 271: LD_INT 3
 273: ARRAY
 274: PUSH
 275: EMPTY
 276: LIST
 277: LIST
 278: LIST
 279: LIST
 280: PUSH
 281: LD_VAR 0 3
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: LIST
 290: PPUSH
 291: CALL_OW 69
 295: ST_TO_ADDR
// end ;
 296: LD_VAR 0 4
 300: RET
// export function MCF_Vehicle ( side , filter ) ; begin
 301: LD_INT 0
 303: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
 304: LD_ADDR_VAR 0 3
 308: PUSH
 309: LD_INT 22
 311: PUSH
 312: LD_VAR 0 1
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 21
 323: PUSH
 324: LD_INT 2
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: LD_VAR 0 2
 335: PUSH
 336: EMPTY
 337: LIST
 338: LIST
 339: LIST
 340: PPUSH
 341: CALL_OW 69
 345: ST_TO_ADDR
// end ;
 346: LD_VAR 0 3
 350: RET
// export function MCF_Cargo ( side ) ; begin
 351: LD_INT 0
 353: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
 354: LD_ADDR_VAR 0 2
 358: PUSH
 359: LD_VAR 0 1
 363: PPUSH
 364: LD_INT 2
 366: PUSH
 367: LD_INT 34
 369: PUSH
 370: LD_INT 12
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: PUSH
 377: LD_INT 34
 379: PUSH
 380: LD_INT 32
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: PUSH
 387: LD_INT 34
 389: PUSH
 390: LD_INT 51
 392: PUSH
 393: EMPTY
 394: LIST
 395: LIST
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: PPUSH
 403: CALL 301 0 2
 407: ST_TO_ADDR
// end ;
 408: LD_VAR 0 2
 412: RET
// export function MCF_Ape ( side ) ; begin
 413: LD_INT 0
 415: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
 416: LD_ADDR_VAR 0 2
 420: PUSH
 421: LD_INT 22
 423: PUSH
 424: LD_VAR 0 1
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 2
 435: PUSH
 436: LD_INT 25
 438: PUSH
 439: LD_INT 12
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: PUSH
 446: LD_INT 25
 448: PUSH
 449: LD_INT 15
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 25
 458: PUSH
 459: LD_INT 16
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: PUSH
 466: LD_INT 25
 468: PUSH
 469: LD_INT 17
 471: PUSH
 472: EMPTY
 473: LIST
 474: LIST
 475: PUSH
 476: EMPTY
 477: LIST
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: ST_TO_ADDR
// end ;
 492: LD_VAR 0 2
 496: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
 497: LD_INT 0
 499: PPUSH
 500: PPUSH
 501: PPUSH
 502: PPUSH
// result := [ ] ;
 503: LD_ADDR_VAR 0 3
 507: PUSH
 508: EMPTY
 509: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_VAR 0 1
 519: PPUSH
 520: CALL 413 0 1
 524: ST_TO_ADDR
// case type of 0 , normal :
 525: LD_VAR 0 2
 529: PUSH
 530: LD_INT 0
 532: DOUBLE
 533: EQUAL
 534: IFTRUE 544
 536: LD_STRING normal
 538: DOUBLE
 539: EQUAL
 540: IFTRUE 544
 542: GO 555
 544: POP
// cl := class_apeman ; 1 , soldier :
 545: LD_ADDR_VAR 0 5
 549: PUSH
 550: LD_INT 12
 552: ST_TO_ADDR
 553: GO 631
 555: LD_INT 1
 557: DOUBLE
 558: EQUAL
 559: IFTRUE 569
 561: LD_STRING soldier
 563: DOUBLE
 564: EQUAL
 565: IFTRUE 569
 567: GO 580
 569: POP
// cl := class_apeman_soldier ; 2 , engineer :
 570: LD_ADDR_VAR 0 5
 574: PUSH
 575: LD_INT 15
 577: ST_TO_ADDR
 578: GO 631
 580: LD_INT 2
 582: DOUBLE
 583: EQUAL
 584: IFTRUE 594
 586: LD_STRING engineer
 588: DOUBLE
 589: EQUAL
 590: IFTRUE 594
 592: GO 605
 594: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
 595: LD_ADDR_VAR 0 5
 599: PUSH
 600: LD_INT 16
 602: ST_TO_ADDR
 603: GO 631
 605: LD_INT 3
 607: DOUBLE
 608: EQUAL
 609: IFTRUE 619
 611: LD_STRING kamikaze
 613: DOUBLE
 614: EQUAL
 615: IFTRUE 619
 617: GO 630
 619: POP
// cl := class_apeman_kamikaze ; end ;
 620: LD_ADDR_VAR 0 5
 624: PUSH
 625: LD_INT 17
 627: ST_TO_ADDR
 628: GO 631
 630: POP
// for i = 1 to tmp do
 631: LD_ADDR_VAR 0 6
 635: PUSH
 636: DOUBLE
 637: LD_INT 1
 639: DEC
 640: ST_TO_ADDR
 641: LD_VAR 0 4
 645: PUSH
 646: FOR_TO
 647: IFFALSE 696
// if GetClass ( tmp [ i ] ) = cl then
 649: LD_VAR 0 4
 653: PUSH
 654: LD_VAR 0 6
 658: ARRAY
 659: PPUSH
 660: CALL_OW 257
 664: PUSH
 665: LD_VAR 0 5
 669: EQUAL
 670: IFFALSE 694
// result := result ^ tmp [ i ] ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_VAR 0 3
 681: PUSH
 682: LD_VAR 0 4
 686: PUSH
 687: LD_VAR 0 6
 691: ARRAY
 692: ADD
 693: ST_TO_ADDR
 694: GO 646
 696: POP
 697: POP
// end ;
 698: LD_VAR 0 3
 702: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
 709: LD_ADDR_VAR 0 5
 713: PUSH
 714: LD_INT 22
 716: PUSH
 717: LD_VAR 0 1
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: PUSH
 726: LD_VAR 0 3
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: PPUSH
 735: CALL_OW 69
 739: ST_TO_ADDR
// r := [ ] ;
 740: LD_ADDR_VAR 0 6
 744: PUSH
 745: EMPTY
 746: ST_TO_ADDR
// if tmp then
 747: LD_VAR 0 5
 751: IFFALSE 820
// for i = 1 to tmp do
 753: LD_ADDR_VAR 0 7
 757: PUSH
 758: DOUBLE
 759: LD_INT 1
 761: DEC
 762: ST_TO_ADDR
 763: LD_VAR 0 5
 767: PUSH
 768: FOR_TO
 769: IFFALSE 818
// if GetTag ( tmp [ i ] ) = tag then
 771: LD_VAR 0 5
 775: PUSH
 776: LD_VAR 0 7
 780: ARRAY
 781: PPUSH
 782: CALL_OW 110
 786: PUSH
 787: LD_VAR 0 2
 791: EQUAL
 792: IFFALSE 816
// r := r ^ tmp [ i ] ;
 794: LD_ADDR_VAR 0 6
 798: PUSH
 799: LD_VAR 0 6
 803: PUSH
 804: LD_VAR 0 5
 808: PUSH
 809: LD_VAR 0 7
 813: ARRAY
 814: ADD
 815: ST_TO_ADDR
 816: GO 768
 818: POP
 819: POP
// result := r ;
 820: LD_ADDR_VAR 0 4
 824: PUSH
 825: LD_VAR 0 6
 829: ST_TO_ADDR
// end ;
 830: LD_VAR 0 4
 834: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
 835: LD_INT 0
 837: PPUSH
 838: PPUSH
 839: PPUSH
// tmp := plist ;
 840: LD_ADDR_VAR 0 5
 844: PUSH
 845: LD_VAR 0 2
 849: ST_TO_ADDR
// if tmp then
 850: LD_VAR 0 5
 854: IFFALSE 931
// begin for i = 1 to tmp do
 856: LD_ADDR_VAR 0 6
 860: PUSH
 861: DOUBLE
 862: LD_INT 1
 864: DEC
 865: ST_TO_ADDR
 866: LD_VAR 0 5
 870: PUSH
 871: FOR_TO
 872: IFFALSE 919
// if GetTag ( tmp [ i ] ) <> tag then
 874: LD_VAR 0 5
 878: PUSH
 879: LD_VAR 0 6
 883: ARRAY
 884: PPUSH
 885: CALL_OW 110
 889: PUSH
 890: LD_VAR 0 3
 894: NONEQUAL
 895: IFFALSE 917
// SetTag ( tmp [ i ] , tag ) ;
 897: LD_VAR 0 5
 901: PUSH
 902: LD_VAR 0 6
 906: ARRAY
 907: PPUSH
 908: LD_VAR 0 3
 912: PPUSH
 913: CALL_OW 109
 917: GO 871
 919: POP
 920: POP
// result := true ;
 921: LD_ADDR_VAR 0 4
 925: PUSH
 926: LD_INT 1
 928: ST_TO_ADDR
// end else
 929: GO 939
// result := false ;
 931: LD_ADDR_VAR 0 4
 935: PUSH
 936: LD_INT 0
 938: ST_TO_ADDR
// end ;
 939: LD_VAR 0 4
 943: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
 944: LD_INT 0
 946: PPUSH
 947: PPUSH
 948: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
 949: LD_ADDR_VAR 0 4
 953: PUSH
 954: LD_VAR 0 1
 958: PPUSH
 959: LD_VAR 0 2
 963: PPUSH
 964: EMPTY
 965: PPUSH
 966: CALL 703 0 3
 970: ST_TO_ADDR
// if tmp then
 971: LD_VAR 0 4
 975: IFFALSE 1027
// begin for i = 1 to tmp do
 977: LD_ADDR_VAR 0 5
 981: PUSH
 982: DOUBLE
 983: LD_INT 1
 985: DEC
 986: ST_TO_ADDR
 987: LD_VAR 0 4
 991: PUSH
 992: FOR_TO
 993: IFFALSE 1015
// SetTag ( tmp [ i ] , 0 ) ;
 995: LD_VAR 0 4
 999: PUSH
1000: LD_VAR 0 5
1004: ARRAY
1005: PPUSH
1006: LD_INT 0
1008: PPUSH
1009: CALL_OW 109
1013: GO 992
1015: POP
1016: POP
// result := true ;
1017: LD_ADDR_VAR 0 3
1021: PUSH
1022: LD_INT 1
1024: ST_TO_ADDR
// end else
1025: GO 1035
// result := false ;
1027: LD_ADDR_VAR 0 3
1031: PUSH
1032: LD_INT 0
1034: ST_TO_ADDR
// end ;
1035: LD_VAR 0 3
1039: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
1040: LD_INT 0
1042: PPUSH
1043: PPUSH
1044: PPUSH
1045: PPUSH
1046: PPUSH
// sort_list := [ ] ;
1047: LD_ADDR_VAR 0 5
1051: PUSH
1052: EMPTY
1053: ST_TO_ADDR
// for i = 1 to list do
1054: LD_ADDR_VAR 0 3
1058: PUSH
1059: DOUBLE
1060: LD_INT 1
1062: DEC
1063: ST_TO_ADDR
1064: LD_VAR 0 1
1068: PUSH
1069: FOR_TO
1070: IFFALSE 1232
// begin if i = 1 then
1072: LD_VAR 0 3
1076: PUSH
1077: LD_INT 1
1079: EQUAL
1080: IFFALSE 1106
// sort_list := sort_list ^ list [ i ] else
1082: LD_ADDR_VAR 0 5
1086: PUSH
1087: LD_VAR 0 5
1091: PUSH
1092: LD_VAR 0 1
1096: PUSH
1097: LD_VAR 0 3
1101: ARRAY
1102: ADD
1103: ST_TO_ADDR
1104: GO 1230
// begin for j = 1 to sort_list do
1106: LD_ADDR_VAR 0 4
1110: PUSH
1111: DOUBLE
1112: LD_INT 1
1114: DEC
1115: ST_TO_ADDR
1116: LD_VAR 0 5
1120: PUSH
1121: FOR_TO
1122: IFFALSE 1199
// begin add := false ;
1124: LD_ADDR_VAR 0 6
1128: PUSH
1129: LD_INT 0
1131: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
1132: LD_VAR 0 1
1136: PUSH
1137: LD_VAR 0 3
1141: ARRAY
1142: PUSH
1143: LD_VAR 0 5
1147: PUSH
1148: LD_VAR 0 4
1152: ARRAY
1153: LESS
1154: IFFALSE 1197
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
1156: LD_ADDR_VAR 0 5
1160: PUSH
1161: LD_VAR 0 5
1165: PPUSH
1166: LD_VAR 0 4
1170: PPUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_VAR 0 3
1180: ARRAY
1181: PPUSH
1182: CALL_OW 2
1186: ST_TO_ADDR
// add := true ;
1187: LD_ADDR_VAR 0 6
1191: PUSH
1192: LD_INT 1
1194: ST_TO_ADDR
// break ;
1195: GO 1199
// end ; end ;
1197: GO 1121
1199: POP
1200: POP
// if not add then
1201: LD_VAR 0 6
1205: NOT
1206: IFFALSE 1230
// sort_list := sort_list ^ list [ i ] ;
1208: LD_ADDR_VAR 0 5
1212: PUSH
1213: LD_VAR 0 5
1217: PUSH
1218: LD_VAR 0 1
1222: PUSH
1223: LD_VAR 0 3
1227: ARRAY
1228: ADD
1229: ST_TO_ADDR
// end ; end ;
1230: GO 1069
1232: POP
1233: POP
// result := sort_list ;
1234: LD_ADDR_VAR 0 2
1238: PUSH
1239: LD_VAR 0 5
1243: ST_TO_ADDR
// end ;
1244: LD_VAR 0 2
1248: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
1253: PPUSH
1254: PPUSH
1255: PPUSH
// sort_list := [ ] ;
1256: LD_ADDR_VAR 0 5
1260: PUSH
1261: EMPTY
1262: ST_TO_ADDR
// for i = 1 to list do
1263: LD_ADDR_VAR 0 3
1267: PUSH
1268: DOUBLE
1269: LD_INT 1
1271: DEC
1272: ST_TO_ADDR
1273: LD_VAR 0 1
1277: PUSH
1278: FOR_TO
1279: IFFALSE 1441
// begin if i = 1 then
1281: LD_VAR 0 3
1285: PUSH
1286: LD_INT 1
1288: EQUAL
1289: IFFALSE 1315
// sort_list := sort_list ^ list [ i ] else
1291: LD_ADDR_VAR 0 5
1295: PUSH
1296: LD_VAR 0 5
1300: PUSH
1301: LD_VAR 0 1
1305: PUSH
1306: LD_VAR 0 3
1310: ARRAY
1311: ADD
1312: ST_TO_ADDR
1313: GO 1439
// begin for j = 1 to sort_list do
1315: LD_ADDR_VAR 0 4
1319: PUSH
1320: DOUBLE
1321: LD_INT 1
1323: DEC
1324: ST_TO_ADDR
1325: LD_VAR 0 5
1329: PUSH
1330: FOR_TO
1331: IFFALSE 1408
// begin add := false ;
1333: LD_ADDR_VAR 0 6
1337: PUSH
1338: LD_INT 0
1340: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
1341: LD_VAR 0 1
1345: PUSH
1346: LD_VAR 0 3
1350: ARRAY
1351: PUSH
1352: LD_VAR 0 5
1356: PUSH
1357: LD_VAR 0 4
1361: ARRAY
1362: GREATER
1363: IFFALSE 1406
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
1365: LD_ADDR_VAR 0 5
1369: PUSH
1370: LD_VAR 0 5
1374: PPUSH
1375: LD_VAR 0 4
1379: PPUSH
1380: LD_VAR 0 1
1384: PUSH
1385: LD_VAR 0 3
1389: ARRAY
1390: PPUSH
1391: CALL_OW 2
1395: ST_TO_ADDR
// add := true ;
1396: LD_ADDR_VAR 0 6
1400: PUSH
1401: LD_INT 1
1403: ST_TO_ADDR
// break ;
1404: GO 1408
// end ; end ;
1406: GO 1330
1408: POP
1409: POP
// if not add then
1410: LD_VAR 0 6
1414: NOT
1415: IFFALSE 1439
// sort_list := sort_list ^ list [ i ] ;
1417: LD_ADDR_VAR 0 5
1421: PUSH
1422: LD_VAR 0 5
1426: PUSH
1427: LD_VAR 0 1
1431: PUSH
1432: LD_VAR 0 3
1436: ARRAY
1437: ADD
1438: ST_TO_ADDR
// end ; end ;
1439: GO 1278
1441: POP
1442: POP
// result := sort_list ;
1443: LD_ADDR_VAR 0 2
1447: PUSH
1448: LD_VAR 0 5
1452: ST_TO_ADDR
// end ;
1453: LD_VAR 0 2
1457: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
1458: LD_INT 0
1460: PPUSH
1461: PPUSH
1462: PPUSH
1463: PPUSH
1464: PPUSH
1465: PPUSH
// tmp := [ ] ;
1466: LD_ADDR_VAR 0 8
1470: PUSH
1471: EMPTY
1472: ST_TO_ADDR
// r := [ ] ;
1473: LD_ADDR_VAR 0 7
1477: PUSH
1478: EMPTY
1479: ST_TO_ADDR
// add := false ;
1480: LD_ADDR_VAR 0 9
1484: PUSH
1485: LD_INT 0
1487: ST_TO_ADDR
// if plist then
1488: LD_VAR 0 2
1492: IFFALSE 1568
// begin for i = 1 to plist do
1494: LD_ADDR_VAR 0 5
1498: PUSH
1499: DOUBLE
1500: LD_INT 1
1502: DEC
1503: ST_TO_ADDR
1504: LD_VAR 0 2
1508: PUSH
1509: FOR_TO
1510: IFFALSE 1564
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
1512: LD_ADDR_VAR 0 8
1516: PUSH
1517: LD_VAR 0 8
1521: PUSH
1522: LD_VAR 0 2
1526: PUSH
1527: LD_VAR 0 5
1531: ARRAY
1532: PUSH
1533: LD_VAR 0 2
1537: PUSH
1538: LD_VAR 0 5
1542: ARRAY
1543: PPUSH
1544: LD_VAR 0 3
1548: PPUSH
1549: CALL_OW 259
1553: PUSH
1554: EMPTY
1555: LIST
1556: LIST
1557: PUSH
1558: EMPTY
1559: LIST
1560: ADD
1561: ST_TO_ADDR
// end ;
1562: GO 1509
1564: POP
1565: POP
// end else
1566: GO 1576
// result := false ;
1568: LD_ADDR_VAR 0 4
1572: PUSH
1573: LD_INT 0
1575: ST_TO_ADDR
// if tmp then
1576: LD_VAR 0 8
1580: IFFALSE 1754
// begin r := r ^ [ tmp [ 1 ] ] ;
1582: LD_ADDR_VAR 0 7
1586: PUSH
1587: LD_VAR 0 7
1591: PUSH
1592: LD_VAR 0 8
1596: PUSH
1597: LD_INT 1
1599: ARRAY
1600: PUSH
1601: EMPTY
1602: LIST
1603: ADD
1604: ST_TO_ADDR
// for i = 2 to tmp do
1605: LD_ADDR_VAR 0 5
1609: PUSH
1610: DOUBLE
1611: LD_INT 2
1613: DEC
1614: ST_TO_ADDR
1615: LD_VAR 0 8
1619: PUSH
1620: FOR_TO
1621: IFFALSE 1752
// begin for j = 1 to r do
1623: LD_ADDR_VAR 0 6
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_VAR 0 7
1637: PUSH
1638: FOR_TO
1639: IFFALSE 1716
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
1641: LD_VAR 0 8
1645: PUSH
1646: LD_VAR 0 5
1650: ARRAY
1651: PUSH
1652: LD_INT 2
1654: ARRAY
1655: PUSH
1656: LD_VAR 0 7
1660: PUSH
1661: LD_VAR 0 6
1665: ARRAY
1666: PUSH
1667: LD_INT 2
1669: ARRAY
1670: LESS
1671: IFFALSE 1714
// begin r := Insert ( r , j , tmp [ i ] ) ;
1673: LD_ADDR_VAR 0 7
1677: PUSH
1678: LD_VAR 0 7
1682: PPUSH
1683: LD_VAR 0 6
1687: PPUSH
1688: LD_VAR 0 8
1692: PUSH
1693: LD_VAR 0 5
1697: ARRAY
1698: PPUSH
1699: CALL_OW 2
1703: ST_TO_ADDR
// add := true ;
1704: LD_ADDR_VAR 0 9
1708: PUSH
1709: LD_INT 1
1711: ST_TO_ADDR
// break ;
1712: GO 1716
// end ; end ;
1714: GO 1638
1716: POP
1717: POP
// if not add then
1718: LD_VAR 0 9
1722: NOT
1723: IFFALSE 1750
// r := r ^ [ tmp [ i ] ] ;
1725: LD_ADDR_VAR 0 7
1729: PUSH
1730: LD_VAR 0 7
1734: PUSH
1735: LD_VAR 0 8
1739: PUSH
1740: LD_VAR 0 5
1744: ARRAY
1745: PUSH
1746: EMPTY
1747: LIST
1748: ADD
1749: ST_TO_ADDR
// end ;
1750: GO 1620
1752: POP
1753: POP
// end ; result := r ;
1754: LD_ADDR_VAR 0 4
1758: PUSH
1759: LD_VAR 0 7
1763: ST_TO_ADDR
// end ;
1764: LD_VAR 0 4
1768: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
1769: LD_INT 0
1771: PPUSH
1772: PPUSH
1773: PPUSH
1774: PPUSH
1775: PPUSH
1776: PPUSH
// tmp := [ ] ;
1777: LD_ADDR_VAR 0 8
1781: PUSH
1782: EMPTY
1783: ST_TO_ADDR
// r := [ ] ;
1784: LD_ADDR_VAR 0 7
1788: PUSH
1789: EMPTY
1790: ST_TO_ADDR
// add := false ;
1791: LD_ADDR_VAR 0 9
1795: PUSH
1796: LD_INT 0
1798: ST_TO_ADDR
// if plist then
1799: LD_VAR 0 2
1803: IFFALSE 1879
// begin for i = 1 to plist do
1805: LD_ADDR_VAR 0 5
1809: PUSH
1810: DOUBLE
1811: LD_INT 1
1813: DEC
1814: ST_TO_ADDR
1815: LD_VAR 0 2
1819: PUSH
1820: FOR_TO
1821: IFFALSE 1875
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
1823: LD_ADDR_VAR 0 8
1827: PUSH
1828: LD_VAR 0 8
1832: PUSH
1833: LD_VAR 0 2
1837: PUSH
1838: LD_VAR 0 5
1842: ARRAY
1843: PUSH
1844: LD_VAR 0 2
1848: PUSH
1849: LD_VAR 0 5
1853: ARRAY
1854: PPUSH
1855: LD_VAR 0 3
1859: PPUSH
1860: CALL_OW 259
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: PUSH
1869: EMPTY
1870: LIST
1871: ADD
1872: ST_TO_ADDR
// end ;
1873: GO 1820
1875: POP
1876: POP
// end else
1877: GO 1887
// result := false ;
1879: LD_ADDR_VAR 0 4
1883: PUSH
1884: LD_INT 0
1886: ST_TO_ADDR
// if tmp then
1887: LD_VAR 0 8
1891: IFFALSE 2065
// begin r := r ^ [ tmp [ 1 ] ] ;
1893: LD_ADDR_VAR 0 7
1897: PUSH
1898: LD_VAR 0 7
1902: PUSH
1903: LD_VAR 0 8
1907: PUSH
1908: LD_INT 1
1910: ARRAY
1911: PUSH
1912: EMPTY
1913: LIST
1914: ADD
1915: ST_TO_ADDR
// for i = 2 to tmp do
1916: LD_ADDR_VAR 0 5
1920: PUSH
1921: DOUBLE
1922: LD_INT 2
1924: DEC
1925: ST_TO_ADDR
1926: LD_VAR 0 8
1930: PUSH
1931: FOR_TO
1932: IFFALSE 2063
// begin for j = 1 to r do
1934: LD_ADDR_VAR 0 6
1938: PUSH
1939: DOUBLE
1940: LD_INT 1
1942: DEC
1943: ST_TO_ADDR
1944: LD_VAR 0 7
1948: PUSH
1949: FOR_TO
1950: IFFALSE 2027
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
1952: LD_VAR 0 8
1956: PUSH
1957: LD_VAR 0 5
1961: ARRAY
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_VAR 0 7
1971: PUSH
1972: LD_VAR 0 6
1976: ARRAY
1977: PUSH
1978: LD_INT 2
1980: ARRAY
1981: GREATER
1982: IFFALSE 2025
// begin r := Insert ( r , j , tmp [ i ] ) ;
1984: LD_ADDR_VAR 0 7
1988: PUSH
1989: LD_VAR 0 7
1993: PPUSH
1994: LD_VAR 0 6
1998: PPUSH
1999: LD_VAR 0 8
2003: PUSH
2004: LD_VAR 0 5
2008: ARRAY
2009: PPUSH
2010: CALL_OW 2
2014: ST_TO_ADDR
// add := true ;
2015: LD_ADDR_VAR 0 9
2019: PUSH
2020: LD_INT 1
2022: ST_TO_ADDR
// break ;
2023: GO 2027
// end ; end ;
2025: GO 1949
2027: POP
2028: POP
// if not add then
2029: LD_VAR 0 9
2033: NOT
2034: IFFALSE 2061
// r := r ^ [ tmp [ i ] ] ;
2036: LD_ADDR_VAR 0 7
2040: PUSH
2041: LD_VAR 0 7
2045: PUSH
2046: LD_VAR 0 8
2050: PUSH
2051: LD_VAR 0 5
2055: ARRAY
2056: PUSH
2057: EMPTY
2058: LIST
2059: ADD
2060: ST_TO_ADDR
// end ;
2061: GO 1931
2063: POP
2064: POP
// end ; result := r ;
2065: LD_ADDR_VAR 0 4
2069: PUSH
2070: LD_VAR 0 7
2074: ST_TO_ADDR
// end ;
2075: LD_VAR 0 4
2079: RET
// export function MCF_Clear ( side ) ; var i ; begin
2080: LD_INT 0
2082: PPUSH
2083: PPUSH
// for i = 1 to 100 do
2084: LD_ADDR_VAR 0 3
2088: PUSH
2089: DOUBLE
2090: LD_INT 1
2092: DEC
2093: ST_TO_ADDR
2094: LD_INT 100
2096: PUSH
2097: FOR_TO
2098: IFFALSE 2134
// if MCF_Tag ( side , i , [ ] ) then
2100: LD_VAR 0 1
2104: PPUSH
2105: LD_VAR 0 3
2109: PPUSH
2110: EMPTY
2111: PPUSH
2112: CALL 703 0 3
2116: IFFALSE 2132
// MCF_ClearTag ( side , i ) ;
2118: LD_VAR 0 1
2122: PPUSH
2123: LD_VAR 0 3
2127: PPUSH
2128: CALL 944 0 2
2132: GO 2097
2134: POP
2135: POP
// result := true ;
2136: LD_ADDR_VAR 0 2
2140: PUSH
2141: LD_INT 1
2143: ST_TO_ADDR
// end ;
2144: LD_VAR 0 2
2148: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
2149: LD_INT 0
2151: PPUSH
2152: PPUSH
2153: PPUSH
// for i = 1 to plist do
2154: LD_ADDR_VAR 0 4
2158: PUSH
2159: DOUBLE
2160: LD_INT 1
2162: DEC
2163: ST_TO_ADDR
2164: LD_VAR 0 1
2168: PUSH
2169: FOR_TO
2170: IFFALSE 2219
// if MCF_HasClass ( plist [ i ] ) = n then
2172: LD_VAR 0 1
2176: PUSH
2177: LD_VAR 0 4
2181: ARRAY
2182: PPUSH
2183: CALL 2554 0 1
2187: PUSH
2188: LD_VAR 0 2
2192: EQUAL
2193: IFFALSE 2217
// tmp := tmp ^ plist [ i ] ;
2195: LD_ADDR_VAR 0 5
2199: PUSH
2200: LD_VAR 0 5
2204: PUSH
2205: LD_VAR 0 1
2209: PUSH
2210: LD_VAR 0 4
2214: ARRAY
2215: ADD
2216: ST_TO_ADDR
2217: GO 2169
2219: POP
2220: POP
// result := tmp ;
2221: LD_ADDR_VAR 0 3
2225: PUSH
2226: LD_VAR 0 5
2230: ST_TO_ADDR
// end ;
2231: LD_VAR 0 3
2235: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
2236: LD_INT 0
2238: PPUSH
2239: PPUSH
2240: PPUSH
// if mreg = ToArm then
2241: LD_VAR 0 2
2245: PUSH
2246: LD_STRING ToArm
2248: EQUAL
2249: IFFALSE 2316
// for i = MREG_ToArm [ side ] downto n do
2251: LD_ADDR_VAR 0 5
2255: PUSH
2256: DOUBLE
2257: LD_EXP 25
2261: PUSH
2262: LD_VAR 0 1
2266: ARRAY
2267: INC
2268: ST_TO_ADDR
2269: LD_VAR 0 3
2273: PUSH
2274: FOR_DOWNTO
2275: IFFALSE 2314
// MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
2277: LD_ADDR_EXP 25
2281: PUSH
2282: LD_EXP 25
2286: PPUSH
2287: LD_EXP 25
2291: PUSH
2292: LD_VAR 0 1
2296: ARRAY
2297: PUSH
2298: LD_VAR 0 5
2302: ARRAY
2303: PPUSH
2304: LD_INT 1
2306: PPUSH
2307: CALL 24530 0 3
2311: ST_TO_ADDR
2312: GO 2274
2314: POP
2315: POP
// if mreg = ToDep then
2316: LD_VAR 0 2
2320: PUSH
2321: LD_STRING ToDep
2323: EQUAL
2324: IFFALSE 2391
// for i = MREG_ToDep [ side ] downto n do
2326: LD_ADDR_VAR 0 5
2330: PUSH
2331: DOUBLE
2332: LD_EXP 26
2336: PUSH
2337: LD_VAR 0 1
2341: ARRAY
2342: INC
2343: ST_TO_ADDR
2344: LD_VAR 0 3
2348: PUSH
2349: FOR_DOWNTO
2350: IFFALSE 2389
// MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
2352: LD_ADDR_EXP 26
2356: PUSH
2357: LD_EXP 26
2361: PPUSH
2362: LD_EXP 26
2366: PUSH
2367: LD_VAR 0 1
2371: ARRAY
2372: PUSH
2373: LD_VAR 0 5
2377: ARRAY
2378: PPUSH
2379: LD_INT 1
2381: PPUSH
2382: CALL 24530 0 3
2386: ST_TO_ADDR
2387: GO 2349
2389: POP
2390: POP
// if mreg = ToFac then
2391: LD_VAR 0 2
2395: PUSH
2396: LD_STRING ToFac
2398: EQUAL
2399: IFFALSE 2466
// for i = MREG_ToFac [ side ] downto n do
2401: LD_ADDR_VAR 0 5
2405: PUSH
2406: DOUBLE
2407: LD_EXP 24
2411: PUSH
2412: LD_VAR 0 1
2416: ARRAY
2417: INC
2418: ST_TO_ADDR
2419: LD_VAR 0 3
2423: PUSH
2424: FOR_DOWNTO
2425: IFFALSE 2464
// MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
2427: LD_ADDR_EXP 24
2431: PUSH
2432: LD_EXP 24
2436: PPUSH
2437: LD_EXP 24
2441: PUSH
2442: LD_VAR 0 1
2446: ARRAY
2447: PUSH
2448: LD_VAR 0 5
2452: ARRAY
2453: PPUSH
2454: LD_INT 1
2456: PPUSH
2457: CALL 24530 0 3
2461: ST_TO_ADDR
2462: GO 2424
2464: POP
2465: POP
// if mreg = ToLab then
2466: LD_VAR 0 2
2470: PUSH
2471: LD_STRING ToLab
2473: EQUAL
2474: IFFALSE 2541
// for i = MREG_ToLab [ side ] downto n do
2476: LD_ADDR_VAR 0 5
2480: PUSH
2481: DOUBLE
2482: LD_EXP 23
2486: PUSH
2487: LD_VAR 0 1
2491: ARRAY
2492: INC
2493: ST_TO_ADDR
2494: LD_VAR 0 3
2498: PUSH
2499: FOR_DOWNTO
2500: IFFALSE 2539
// MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
2502: LD_ADDR_EXP 23
2506: PUSH
2507: LD_EXP 23
2511: PPUSH
2512: LD_EXP 23
2516: PUSH
2517: LD_VAR 0 1
2521: ARRAY
2522: PUSH
2523: LD_VAR 0 5
2527: ARRAY
2528: PPUSH
2529: LD_INT 1
2531: PPUSH
2532: CALL 24530 0 3
2536: ST_TO_ADDR
2537: GO 2499
2539: POP
2540: POP
// result := true ;
2541: LD_ADDR_VAR 0 4
2545: PUSH
2546: LD_INT 1
2548: ST_TO_ADDR
// end ;
2549: LD_VAR 0 4
2553: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
// side := GetSide ( unit ) ;
2559: LD_ADDR_VAR 0 4
2563: PUSH
2564: LD_VAR 0 1
2568: PPUSH
2569: CALL_OW 255
2573: ST_TO_ADDR
// tmp := 0 ;
2574: LD_ADDR_VAR 0 3
2578: PUSH
2579: LD_INT 0
2581: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
2582: LD_VAR 0 1
2586: PUSH
2587: LD_EXP 25
2591: PUSH
2592: LD_VAR 0 4
2596: ARRAY
2597: IN
2598: IFFALSE 2608
// tmp := 1 ;
2600: LD_ADDR_VAR 0 3
2604: PUSH
2605: LD_INT 1
2607: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
2608: LD_VAR 0 1
2612: PUSH
2613: LD_EXP 26
2617: PUSH
2618: LD_VAR 0 4
2622: ARRAY
2623: IN
2624: IFFALSE 2634
// tmp := 2 ;
2626: LD_ADDR_VAR 0 3
2630: PUSH
2631: LD_INT 2
2633: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
2634: LD_VAR 0 1
2638: PUSH
2639: LD_EXP 24
2643: PUSH
2644: LD_VAR 0 4
2648: ARRAY
2649: IN
2650: IFFALSE 2660
// tmp := 3 ;
2652: LD_ADDR_VAR 0 3
2656: PUSH
2657: LD_INT 3
2659: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
2660: LD_VAR 0 1
2664: PUSH
2665: LD_EXP 23
2669: PUSH
2670: LD_VAR 0 4
2674: ARRAY
2675: IN
2676: IFFALSE 2686
// tmp := 4 ;
2678: LD_ADDR_VAR 0 3
2682: PUSH
2683: LD_INT 4
2685: ST_TO_ADDR
// result := tmp ;
2686: LD_ADDR_VAR 0 2
2690: PUSH
2691: LD_VAR 0 3
2695: ST_TO_ADDR
// end ;
2696: LD_VAR 0 2
2700: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
2701: LD_INT 0
2703: PPUSH
2704: PPUSH
// if mreg = ToArm then
2705: LD_VAR 0 2
2709: PUSH
2710: LD_STRING ToArm
2712: EQUAL
2713: IFFALSE 2802
// for i = MREG_ToArm [ side ] downto 1 do
2715: LD_ADDR_VAR 0 5
2719: PUSH
2720: DOUBLE
2721: LD_EXP 25
2725: PUSH
2726: LD_VAR 0 1
2730: ARRAY
2731: INC
2732: ST_TO_ADDR
2733: LD_INT 1
2735: PUSH
2736: FOR_DOWNTO
2737: IFFALSE 2800
// if MREG_ToArm [ side ] [ i ] = unit then
2739: LD_EXP 25
2743: PUSH
2744: LD_VAR 0 1
2748: ARRAY
2749: PUSH
2750: LD_VAR 0 5
2754: ARRAY
2755: PUSH
2756: LD_VAR 0 3
2760: EQUAL
2761: IFFALSE 2798
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
2763: LD_ADDR_EXP 25
2767: PUSH
2768: LD_EXP 25
2772: PPUSH
2773: LD_EXP 25
2777: PUSH
2778: LD_VAR 0 1
2782: ARRAY
2783: PUSH
2784: LD_VAR 0 5
2788: ARRAY
2789: PPUSH
2790: LD_INT 1
2792: PPUSH
2793: CALL 24530 0 3
2797: ST_TO_ADDR
// end ;
2798: GO 2736
2800: POP
2801: POP
// if mreg = ToDep then
2802: LD_VAR 0 2
2806: PUSH
2807: LD_STRING ToDep
2809: EQUAL
2810: IFFALSE 2899
// for i = MREG_ToDep [ side ] downto 1 do
2812: LD_ADDR_VAR 0 5
2816: PUSH
2817: DOUBLE
2818: LD_EXP 26
2822: PUSH
2823: LD_VAR 0 1
2827: ARRAY
2828: INC
2829: ST_TO_ADDR
2830: LD_INT 1
2832: PUSH
2833: FOR_DOWNTO
2834: IFFALSE 2897
// if MREG_ToDep [ side ] [ i ] = unit then
2836: LD_EXP 26
2840: PUSH
2841: LD_VAR 0 1
2845: ARRAY
2846: PUSH
2847: LD_VAR 0 5
2851: ARRAY
2852: PUSH
2853: LD_VAR 0 3
2857: EQUAL
2858: IFFALSE 2895
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
2860: LD_ADDR_EXP 26
2864: PUSH
2865: LD_EXP 26
2869: PPUSH
2870: LD_EXP 26
2874: PUSH
2875: LD_VAR 0 1
2879: ARRAY
2880: PUSH
2881: LD_VAR 0 5
2885: ARRAY
2886: PPUSH
2887: LD_INT 1
2889: PPUSH
2890: CALL 24530 0 3
2894: ST_TO_ADDR
// end ;
2895: GO 2833
2897: POP
2898: POP
// if mreg = ToFac then
2899: LD_VAR 0 2
2903: PUSH
2904: LD_STRING ToFac
2906: EQUAL
2907: IFFALSE 2996
// for i = MREG_ToFac [ side ] downto 1 do
2909: LD_ADDR_VAR 0 5
2913: PUSH
2914: DOUBLE
2915: LD_EXP 24
2919: PUSH
2920: LD_VAR 0 1
2924: ARRAY
2925: INC
2926: ST_TO_ADDR
2927: LD_INT 1
2929: PUSH
2930: FOR_DOWNTO
2931: IFFALSE 2994
// if MREG_ToFac [ side ] [ i ] = unit then
2933: LD_EXP 24
2937: PUSH
2938: LD_VAR 0 1
2942: ARRAY
2943: PUSH
2944: LD_VAR 0 5
2948: ARRAY
2949: PUSH
2950: LD_VAR 0 3
2954: EQUAL
2955: IFFALSE 2992
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
2957: LD_ADDR_EXP 24
2961: PUSH
2962: LD_EXP 24
2966: PPUSH
2967: LD_EXP 24
2971: PUSH
2972: LD_VAR 0 1
2976: ARRAY
2977: PUSH
2978: LD_VAR 0 5
2982: ARRAY
2983: PPUSH
2984: LD_INT 1
2986: PPUSH
2987: CALL 24530 0 3
2991: ST_TO_ADDR
// end ;
2992: GO 2930
2994: POP
2995: POP
// if mreg = ToLab then
2996: LD_VAR 0 2
3000: PUSH
3001: LD_STRING ToLab
3003: EQUAL
3004: IFFALSE 3093
// for i = MREG_ToLab [ side ] downto 1 do
3006: LD_ADDR_VAR 0 5
3010: PUSH
3011: DOUBLE
3012: LD_EXP 23
3016: PUSH
3017: LD_VAR 0 1
3021: ARRAY
3022: INC
3023: ST_TO_ADDR
3024: LD_INT 1
3026: PUSH
3027: FOR_DOWNTO
3028: IFFALSE 3091
// if MREG_ToLab [ side ] [ i ] = unit then
3030: LD_EXP 23
3034: PUSH
3035: LD_VAR 0 1
3039: ARRAY
3040: PUSH
3041: LD_VAR 0 5
3045: ARRAY
3046: PUSH
3047: LD_VAR 0 3
3051: EQUAL
3052: IFFALSE 3089
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
3054: LD_ADDR_EXP 23
3058: PUSH
3059: LD_EXP 23
3063: PPUSH
3064: LD_EXP 23
3068: PUSH
3069: LD_VAR 0 1
3073: ARRAY
3074: PUSH
3075: LD_VAR 0 5
3079: ARRAY
3080: PPUSH
3081: LD_INT 1
3083: PPUSH
3084: CALL 24530 0 3
3088: ST_TO_ADDR
// end ;
3089: GO 3027
3091: POP
3092: POP
// end ;
3093: LD_VAR 0 4
3097: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
3098: LD_INT 0
3100: PPUSH
3101: PPUSH
// result := false ;
3102: LD_ADDR_VAR 0 2
3106: PUSH
3107: LD_INT 0
3109: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
3110: LD_ADDR_VAR 0 3
3114: PUSH
3115: DOUBLE
3116: LD_INT 1
3118: DEC
3119: ST_TO_ADDR
3120: LD_EXP 15
3124: PUSH
3125: FOR_TO
3126: IFFALSE 3190
// if MREG_ToBuild [ i ] [ 1 ] = side then
3128: LD_EXP 15
3132: PUSH
3133: LD_VAR 0 3
3137: ARRAY
3138: PUSH
3139: LD_INT 1
3141: ARRAY
3142: PUSH
3143: LD_VAR 0 1
3147: EQUAL
3148: IFFALSE 3188
// begin if MREG_ToBuild [ i ] [ 1 ] then
3150: LD_EXP 15
3154: PUSH
3155: LD_VAR 0 3
3159: ARRAY
3160: PUSH
3161: LD_INT 1
3163: ARRAY
3164: IFFALSE 3188
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
3166: LD_ADDR_VAR 0 2
3170: PUSH
3171: LD_EXP 15
3175: PUSH
3176: LD_VAR 0 3
3180: ARRAY
3181: PUSH
3182: LD_INT 1
3184: ARRAY
3185: ST_TO_ADDR
// break ;
3186: GO 3190
// end ; end ;
3188: GO 3125
3190: POP
3191: POP
// for i = 1 to MREG_ToRepair do
3192: LD_ADDR_VAR 0 3
3196: PUSH
3197: DOUBLE
3198: LD_INT 1
3200: DEC
3201: ST_TO_ADDR
3202: LD_EXP 16
3206: PUSH
3207: FOR_TO
3208: IFFALSE 3272
// if MREG_ToRepair [ i ] [ 1 ] = side then
3210: LD_EXP 16
3214: PUSH
3215: LD_VAR 0 3
3219: ARRAY
3220: PUSH
3221: LD_INT 1
3223: ARRAY
3224: PUSH
3225: LD_VAR 0 1
3229: EQUAL
3230: IFFALSE 3270
// begin if MREG_ToRepair [ i ] [ 1 ] then
3232: LD_EXP 16
3236: PUSH
3237: LD_VAR 0 3
3241: ARRAY
3242: PUSH
3243: LD_INT 1
3245: ARRAY
3246: IFFALSE 3270
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
3248: LD_ADDR_VAR 0 2
3252: PUSH
3253: LD_EXP 16
3257: PUSH
3258: LD_VAR 0 3
3262: ARRAY
3263: PUSH
3264: LD_INT 1
3266: ARRAY
3267: ST_TO_ADDR
// break ;
3268: GO 3272
// end ; end ;
3270: GO 3207
3272: POP
3273: POP
// if MCF_Get ( side , [ f_constructed ] ) then
3274: LD_VAR 0 1
3278: PPUSH
3279: LD_INT 57
3281: PUSH
3282: EMPTY
3283: LIST
3284: PPUSH
3285: CALL 0 0 2
3289: IFFALSE 3316
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
3291: LD_ADDR_VAR 0 2
3295: PUSH
3296: LD_VAR 0 1
3300: PPUSH
3301: LD_INT 57
3303: PUSH
3304: EMPTY
3305: LIST
3306: PPUSH
3307: CALL 0 0 2
3311: PUSH
3312: LD_INT 1
3314: ARRAY
3315: ST_TO_ADDR
// end ;
3316: LD_VAR 0 2
3320: RET
// export function MCF_Info ( ) ; begin
3321: LD_INT 0
3323: PPUSH
// MC_Show ( MCF to zbiór funkcji s³u¿¹cych do operacji na listach i filtrach: ^ - MCF_Class -> Wyœwietla dan¹ klasê [mo¿liwe do³¹czenie dodatkowych filtrów] ^ - MCF_Tag -> Wyœwietla wszystkie jednostki z danymi tagiem [mo¿liwe do³¹czenie dodatkowych filtrów] ^ - MCF_SetTag -> Umo¿liwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortujê listê rosn¹co ^ - MCF_SortListDesc -> Sortujê listê malej¹co ^ - MCF_SortLevelAsc -> Sortujê dan¹ grupê jednnostek wg. danej umiejetnoœci wg. poziomu rosn¹co ^ - MCF_SortLevelDesc -> Sortujê dan¹ grupê jednostek wg. danej umiejetnoœci wg. poziomu malej¹co ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
3324: LD_STRING MCF to zbiór funkcji s³u¿¹cych do operacji na listach i filtrach:
3326: PUSH
3327: LD_STRING - MCF_Class -> Wyœwietla dan¹ klasê [mo¿liwe do³¹czenie dodatkowych filtrów]
3329: ADD
3330: PUSH
3331: LD_STRING - MCF_Tag -> Wyœwietla wszystkie jednostki z danymi tagiem [mo¿liwe do³¹czenie dodatkowych filtrów]
3333: ADD
3334: PUSH
3335: LD_STRING - MCF_SetTag -> Umo¿liwia nadanie tagu danej grupie jednostek
3337: ADD
3338: PUSH
3339: LD_STRING - MCF_ClearTag -> Kasuje dany tag
3341: ADD
3342: PUSH
3343: LD_STRING - MCF_SortListAsc -> Sortujê listê rosn¹co
3345: ADD
3346: PUSH
3347: LD_STRING - MCF_SortListDesc -> Sortujê listê malej¹co
3349: ADD
3350: PUSH
3351: LD_STRING - MCF_SortLevelAsc -> Sortujê dan¹ grupê jednnostek wg. danej umiejetnoœci wg. poziomu rosn¹co
3353: ADD
3354: PUSH
3355: LD_STRING - MCF_SortLevelDesc -> Sortujê dan¹ grupê jednostek wg. danej umiejetnoœci wg. poziomu malej¹co
3357: ADD
3358: PUSH
3359: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
3361: ADD
3362: PPUSH
3363: CALL 3890 0 1
// end ; end_of_file
3367: LD_VAR 0 1
3371: RET
// export function FakePep ( ) ; var i , un ; begin
3372: LD_INT 0
3374: PPUSH
3375: PPUSH
3376: PPUSH
// uc_side := 1 ;
3377: LD_ADDR_OWVAR 20
3381: PUSH
3382: LD_INT 1
3384: ST_TO_ADDR
// uc_nation := 1 ;
3385: LD_ADDR_OWVAR 21
3389: PUSH
3390: LD_INT 1
3392: ST_TO_ADDR
// for i = 1 to 15 do
3393: LD_ADDR_VAR 0 2
3397: PUSH
3398: DOUBLE
3399: LD_INT 1
3401: DEC
3402: ST_TO_ADDR
3403: LD_INT 15
3405: PUSH
3406: FOR_TO
3407: IFFALSE 3456
// begin PrepareHuman ( false , ( i div 4 ) + 1 , 8 ) ;
3409: LD_INT 0
3411: PPUSH
3412: LD_VAR 0 2
3416: PUSH
3417: LD_INT 4
3419: DIV
3420: PUSH
3421: LD_INT 1
3423: PLUS
3424: PPUSH
3425: LD_INT 8
3427: PPUSH
3428: CALL_OW 380
// un := CreateHuman ;
3432: LD_ADDR_VAR 0 3
3436: PUSH
3437: CALL_OW 44
3441: ST_TO_ADDR
// PlaceUnitAnywhere ( un , false ) ;
3442: LD_VAR 0 3
3446: PPUSH
3447: LD_INT 0
3449: PPUSH
3450: CALL_OW 51
// end ;
3454: GO 3406
3456: POP
3457: POP
// end ; end_of_file
3458: LD_VAR 0 1
3462: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
3463: LD_INT 0
3465: PPUSH
3466: PPUSH
3467: PPUSH
3468: PPUSH
3469: PPUSH
3470: PPUSH
3471: PPUSH
3472: PPUSH
// if unit then
3473: LD_VAR 0 1
3477: IFFALSE 3877
// begin if mode = 0 then
3479: LD_VAR 0 3
3483: PUSH
3484: LD_INT 0
3486: EQUAL
3487: IFFALSE 3635
// begin if coords then
3489: LD_VAR 0 2
3493: IFFALSE 3633
// while ( coords > 1 ) do
3495: LD_VAR 0 2
3499: PUSH
3500: LD_INT 1
3502: GREATER
3503: IFFALSE 3633
// if not HasTask ( unit ) then
3505: LD_VAR 0 1
3509: PPUSH
3510: CALL_OW 314
3514: NOT
3515: IFFALSE 3631
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
3517: LD_VAR 0 1
3521: PPUSH
3522: LD_VAR 0 2
3526: PUSH
3527: LD_INT 1
3529: ARRAY
3530: PPUSH
3531: LD_VAR 0 2
3535: PUSH
3536: LD_INT 2
3538: ARRAY
3539: PPUSH
3540: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
3544: LD_INT 35
3546: PPUSH
3547: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
3551: LD_VAR 0 1
3555: PPUSH
3556: CALL_OW 250
3560: PUSH
3561: LD_VAR 0 2
3565: PUSH
3566: LD_INT 1
3568: ARRAY
3569: EQUAL
3570: PUSH
3571: LD_VAR 0 1
3575: PPUSH
3576: CALL_OW 251
3580: PUSH
3581: LD_VAR 0 2
3585: PUSH
3586: LD_INT 2
3588: ARRAY
3589: EQUAL
3590: AND
3591: IFFALSE 3544
// for i = 1 to 2 do
3593: LD_ADDR_VAR 0 5
3597: PUSH
3598: DOUBLE
3599: LD_INT 1
3601: DEC
3602: ST_TO_ADDR
3603: LD_INT 2
3605: PUSH
3606: FOR_TO
3607: IFFALSE 3629
// coords := Delete ( coords , 1 ) ;
3609: LD_ADDR_VAR 0 2
3613: PUSH
3614: LD_VAR 0 2
3618: PPUSH
3619: LD_INT 1
3621: PPUSH
3622: CALL_OW 3
3626: ST_TO_ADDR
3627: GO 3606
3629: POP
3630: POP
// end ;
3631: GO 3495
// end else
3633: GO 3877
// begin if coords then
3635: LD_VAR 0 2
3639: IFFALSE 3877
// begin x := GetX ( unit ) ;
3641: LD_ADDR_VAR 0 6
3645: PUSH
3646: LD_VAR 0 1
3650: PPUSH
3651: CALL_OW 250
3655: ST_TO_ADDR
// y := GetY ( unit ) ;
3656: LD_ADDR_VAR 0 7
3660: PUSH
3661: LD_VAR 0 1
3665: PPUSH
3666: CALL_OW 251
3670: ST_TO_ADDR
// while ( coords > 1 ) do
3671: LD_VAR 0 2
3675: PUSH
3676: LD_INT 1
3678: GREATER
3679: IFFALSE 3877
// begin Wait ( 0 0$0.3 ) ;
3681: LD_INT 10
3683: PPUSH
3684: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
3688: LD_VAR 0 1
3692: PPUSH
3693: CALL_OW 255
3697: PPUSH
3698: LD_VAR 0 1
3702: PPUSH
3703: CALL_OW 250
3707: PPUSH
3708: LD_VAR 0 1
3712: PPUSH
3713: CALL_OW 251
3717: PPUSH
3718: LD_INT 14
3720: PPUSH
3721: CALL 5901 0 4
3725: IFFALSE 3756
// begin ComMoveXY ( unit , x , y ) ;
3727: LD_VAR 0 1
3731: PPUSH
3732: LD_VAR 0 6
3736: PPUSH
3737: LD_VAR 0 7
3741: PPUSH
3742: CALL_OW 111
// result := false ;
3746: LD_ADDR_VAR 0 4
3750: PUSH
3751: LD_INT 0
3753: ST_TO_ADDR
// end else
3754: GO 3795
// if not HasTask ( unit ) then
3756: LD_VAR 0 1
3760: PPUSH
3761: CALL_OW 314
3765: NOT
3766: IFFALSE 3795
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
3768: LD_VAR 0 1
3772: PPUSH
3773: LD_VAR 0 2
3777: PUSH
3778: LD_INT 1
3780: ARRAY
3781: PPUSH
3782: LD_VAR 0 2
3786: PUSH
3787: LD_INT 2
3789: ARRAY
3790: PPUSH
3791: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
3795: LD_VAR 0 1
3799: PPUSH
3800: CALL_OW 250
3804: PUSH
3805: LD_VAR 0 2
3809: PUSH
3810: LD_INT 1
3812: ARRAY
3813: EQUAL
3814: PUSH
3815: LD_VAR 0 1
3819: PPUSH
3820: CALL_OW 251
3824: PUSH
3825: LD_VAR 0 2
3829: PUSH
3830: LD_INT 2
3832: ARRAY
3833: EQUAL
3834: AND
3835: IFFALSE 3875
// for i = 1 to 2 do
3837: LD_ADDR_VAR 0 5
3841: PUSH
3842: DOUBLE
3843: LD_INT 1
3845: DEC
3846: ST_TO_ADDR
3847: LD_INT 2
3849: PUSH
3850: FOR_TO
3851: IFFALSE 3873
// coords := Delete ( coords , 1 ) ;
3853: LD_ADDR_VAR 0 2
3857: PUSH
3858: LD_VAR 0 2
3862: PPUSH
3863: LD_INT 1
3865: PPUSH
3866: CALL_OW 3
3870: ST_TO_ADDR
3871: GO 3850
3873: POP
3874: POP
// end ;
3875: GO 3671
// end ; end ; end ; result := true ;
3877: LD_ADDR_VAR 0 4
3881: PUSH
3882: LD_INT 1
3884: ST_TO_ADDR
// end ;
3885: LD_VAR 0 4
3889: RET
// export function MC_Show ( string ) ; begin
3890: LD_INT 0
3892: PPUSH
// display_strings := string ;
3893: LD_ADDR_OWVAR 47
3897: PUSH
3898: LD_VAR 0 1
3902: ST_TO_ADDR
// end ; end_of_file
3903: LD_VAR 0 2
3907: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Crane , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
3908: LD_INT 0
3910: PPUSH
// MREG_Game := [ ] ;
3911: LD_ADDR_EXP 1
3915: PUSH
3916: EMPTY
3917: ST_TO_ADDR
// MREG_Crates := [ ] ;
3918: LD_ADDR_EXP 2
3922: PUSH
3923: EMPTY
3924: ST_TO_ADDR
// MREG_Heal := [ ] ;
3925: LD_ADDR_EXP 3
3929: PUSH
3930: EMPTY
3931: ST_TO_ADDR
// MREG_Tame := [ ] ;
3932: LD_ADDR_EXP 5
3936: PUSH
3937: EMPTY
3938: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
3939: LD_ADDR_EXP 6
3943: PUSH
3944: EMPTY
3945: ST_TO_ADDR
// MREG_SidesList := [ ] ;
3946: LD_ADDR_EXP 7
3950: PUSH
3951: EMPTY
3952: ST_TO_ADDR
// MREG_LabList := [ ] ;
3953: LD_ADDR_EXP 8
3957: PUSH
3958: EMPTY
3959: ST_TO_ADDR
// MREG_Cargo := [ ] ;
3960: LD_ADDR_EXP 9
3964: PUSH
3965: EMPTY
3966: ST_TO_ADDR
// MREG_Crane := [ ] ;
3967: LD_ADDR_EXP 10
3971: PUSH
3972: EMPTY
3973: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
3974: LD_ADDR_EXP 11
3978: PUSH
3979: EMPTY
3980: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
3981: LD_ADDR_EXP 12
3985: PUSH
3986: EMPTY
3987: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
3988: LD_ADDR_EXP 13
3992: PUSH
3993: EMPTY
3994: ST_TO_ADDR
// MREG_Status := [ ] ;
3995: LD_ADDR_EXP 14
3999: PUSH
4000: EMPTY
4001: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
4002: LD_ADDR_EXP 15
4006: PUSH
4007: EMPTY
4008: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
4009: LD_ADDR_EXP 16
4013: PUSH
4014: EMPTY
4015: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
4016: LD_ADDR_EXP 17
4020: PUSH
4021: EMPTY
4022: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
4023: LD_ADDR_EXP 18
4027: PUSH
4028: EMPTY
4029: ST_TO_ADDR
// MREG_ToRes := [ ] ;
4030: LD_ADDR_EXP 19
4034: PUSH
4035: EMPTY
4036: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
4037: LD_ADDR_EXP 20
4041: PUSH
4042: EMPTY
4043: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
4044: LD_ADDR_EXP 21
4048: PUSH
4049: EMPTY
4050: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
4051: LD_ADDR_EXP 22
4055: PUSH
4056: EMPTY
4057: ST_TO_ADDR
// MREG_ToLab := [ ] ;
4058: LD_ADDR_EXP 23
4062: PUSH
4063: EMPTY
4064: ST_TO_ADDR
// MREG_ToFac := [ ] ;
4065: LD_ADDR_EXP 24
4069: PUSH
4070: EMPTY
4071: ST_TO_ADDR
// MREG_ToArm := [ ] ;
4072: LD_ADDR_EXP 25
4076: PUSH
4077: EMPTY
4078: ST_TO_ADDR
// MREG_ToDep := [ ] ;
4079: LD_ADDR_EXP 26
4083: PUSH
4084: EMPTY
4085: ST_TO_ADDR
// MREG_Parking := [ ] ;
4086: LD_ADDR_EXP 27
4090: PUSH
4091: EMPTY
4092: ST_TO_ADDR
// MREG_VCombat := [ ] ;
4093: LD_ADDR_EXP 28
4097: PUSH
4098: EMPTY
4099: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
4100: LD_ADDR_EXP 31
4104: PUSH
4105: LD_INT 300
4107: PUSH
4108: LD_INT 100
4110: PUSH
4111: LD_INT 25
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: ST_TO_ADDR
// end ;
4119: LD_VAR 0 1
4123: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
4124: LD_INT 0
4126: PPUSH
// if [ side , unit , mreg ] in mreg_list then
4127: LD_VAR 0 2
4131: PUSH
4132: LD_VAR 0 3
4136: PUSH
4137: LD_VAR 0 4
4141: PUSH
4142: EMPTY
4143: LIST
4144: LIST
4145: LIST
4146: PUSH
4147: LD_VAR 0 1
4151: IN
4152: IFFALSE 4166
// result := mreg_list else
4154: LD_ADDR_VAR 0 5
4158: PUSH
4159: LD_VAR 0 1
4163: ST_TO_ADDR
4164: GO 4200
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
4166: LD_ADDR_VAR 0 1
4170: PUSH
4171: LD_VAR 0 1
4175: PUSH
4176: LD_VAR 0 2
4180: PUSH
4181: LD_VAR 0 3
4185: PUSH
4186: LD_VAR 0 4
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: LIST
4195: PUSH
4196: EMPTY
4197: LIST
4198: ADD
4199: ST_TO_ADDR
// result := mreg_list ;
4200: LD_ADDR_VAR 0 5
4204: PUSH
4205: LD_VAR 0 1
4209: ST_TO_ADDR
// end ;
4210: LD_VAR 0 5
4214: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
4215: LD_INT 0
4217: PPUSH
// if [ side , unit , mreg ] in mreg_list then
4218: LD_VAR 0 2
4222: PUSH
4223: LD_VAR 0 3
4227: PUSH
4228: LD_VAR 0 4
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: LIST
4237: PUSH
4238: LD_VAR 0 1
4242: IN
4243: IFFALSE 4281
// result := mreg_list diff [ [ side , unit , mreg ] ] else
4245: LD_ADDR_VAR 0 5
4249: PUSH
4250: LD_VAR 0 1
4254: PUSH
4255: LD_VAR 0 2
4259: PUSH
4260: LD_VAR 0 3
4264: PUSH
4265: LD_VAR 0 4
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: LIST
4274: PUSH
4275: EMPTY
4276: LIST
4277: DIFF
4278: ST_TO_ADDR
4279: GO 4291
// result := mreg_list ;
4281: LD_ADDR_VAR 0 5
4285: PUSH
4286: LD_VAR 0 1
4290: ST_TO_ADDR
// end ;
4291: LD_VAR 0 5
4295: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
4296: LD_INT 0
4298: PPUSH
4299: PPUSH
4300: PPUSH
// for j = 1 to 8 do
4301: LD_ADDR_VAR 0 3
4305: PUSH
4306: DOUBLE
4307: LD_INT 1
4309: DEC
4310: ST_TO_ADDR
4311: LD_INT 8
4313: PUSH
4314: FOR_TO
4315: IFFALSE 5211
// begin if MCF_Get ( j , [ f_alive ] ) then
4317: LD_VAR 0 3
4321: PPUSH
4322: LD_INT 51
4324: PUSH
4325: EMPTY
4326: LIST
4327: PPUSH
4328: CALL 0 0 2
4332: IFFALSE 4350
// MREG_SidesList := MREG_SidesList ^ 1 else
4334: LD_ADDR_EXP 7
4338: PUSH
4339: LD_EXP 7
4343: PUSH
4344: LD_INT 1
4346: ADD
4347: ST_TO_ADDR
4348: GO 4364
// MREG_SidesList := MREG_SidesList ^ 0 ;
4350: LD_ADDR_EXP 7
4354: PUSH
4355: LD_EXP 7
4359: PUSH
4360: LD_INT 0
4362: ADD
4363: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
4364: LD_VAR 0 3
4368: PPUSH
4369: LD_INT 2
4371: PUSH
4372: LD_INT 34
4374: PUSH
4375: LD_INT 12
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 34
4384: PUSH
4385: LD_INT 32
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: LD_INT 34
4394: PUSH
4395: LD_INT 51
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: LIST
4407: PUSH
4408: EMPTY
4409: LIST
4410: PPUSH
4411: CALL 301 0 2
4415: IFFALSE 4516
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
4417: LD_ADDR_VAR 0 2
4421: PUSH
4422: LD_VAR 0 3
4426: PPUSH
4427: LD_INT 2
4429: PUSH
4430: LD_INT 34
4432: PUSH
4433: LD_INT 12
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: LD_INT 34
4442: PUSH
4443: LD_INT 32
4445: PUSH
4446: EMPTY
4447: LIST
4448: LIST
4449: PUSH
4450: LD_INT 34
4452: PUSH
4453: LD_INT 51
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: LIST
4464: PUSH
4465: EMPTY
4466: LIST
4467: LIST
4468: PPUSH
4469: CALL 301 0 2
4473: PUSH
4474: FOR_IN
4475: IFFALSE 4514
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
4477: LD_ADDR_EXP 9
4481: PUSH
4482: LD_EXP 9
4486: PPUSH
4487: LD_VAR 0 3
4491: PPUSH
4492: LD_VAR 0 2
4496: PPUSH
4497: LD_VAR 0 2
4501: PPUSH
4502: CALL_OW 264
4506: PPUSH
4507: CALL 4124 0 4
4511: ST_TO_ADDR
4512: GO 4474
4514: POP
4515: POP
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) then
4516: LD_VAR 0 3
4520: PPUSH
4521: LD_INT 2
4523: PUSH
4524: LD_INT 34
4526: PUSH
4527: LD_INT 13
4529: PUSH
4530: EMPTY
4531: LIST
4532: LIST
4533: PUSH
4534: LD_INT 34
4536: PUSH
4537: LD_INT 52
4539: PUSH
4540: EMPTY
4541: LIST
4542: LIST
4543: PUSH
4544: EMPTY
4545: LIST
4546: LIST
4547: LIST
4548: PUSH
4549: EMPTY
4550: LIST
4551: PPUSH
4552: CALL 301 0 2
4556: IFFALSE 4646
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) do
4558: LD_ADDR_VAR 0 2
4562: PUSH
4563: LD_VAR 0 3
4567: PPUSH
4568: LD_INT 2
4570: PUSH
4571: LD_INT 34
4573: PUSH
4574: LD_INT 13
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 34
4583: PUSH
4584: LD_INT 52
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: PUSH
4595: EMPTY
4596: LIST
4597: LIST
4598: PPUSH
4599: CALL 301 0 2
4603: PUSH
4604: FOR_IN
4605: IFFALSE 4644
// MREG_Crane := MC_RegistryUpdate ( MREG_Crane , j , i , GetWeapon ( i ) ) ;
4607: LD_ADDR_EXP 10
4611: PUSH
4612: LD_EXP 10
4616: PPUSH
4617: LD_VAR 0 3
4621: PPUSH
4622: LD_VAR 0 2
4626: PPUSH
4627: LD_VAR 0 2
4631: PPUSH
4632: CALL_OW 264
4636: PPUSH
4637: CALL 4124 0 4
4641: ST_TO_ADDR
4642: GO 4604
4644: POP
4645: POP
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] ] ] ) then
4646: LD_VAR 0 3
4650: PPUSH
4651: LD_INT 2
4653: PUSH
4654: LD_INT 34
4656: PUSH
4657: LD_INT 14
4659: PUSH
4660: EMPTY
4661: LIST
4662: LIST
4663: PUSH
4664: LD_INT 34
4666: PUSH
4667: LD_INT 53
4669: PUSH
4670: EMPTY
4671: LIST
4672: LIST
4673: PUSH
4674: EMPTY
4675: LIST
4676: LIST
4677: LIST
4678: PUSH
4679: EMPTY
4680: LIST
4681: PPUSH
4682: CALL 301 0 2
4686: IFFALSE 4776
// for i in MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] ] ] ) do
4688: LD_ADDR_VAR 0 2
4692: PUSH
4693: LD_VAR 0 3
4697: PPUSH
4698: LD_INT 2
4700: PUSH
4701: LD_INT 34
4703: PUSH
4704: LD_INT 14
4706: PUSH
4707: EMPTY
4708: LIST
4709: LIST
4710: PUSH
4711: LD_INT 34
4713: PUSH
4714: LD_INT 53
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: PUSH
4721: EMPTY
4722: LIST
4723: LIST
4724: LIST
4725: PUSH
4726: EMPTY
4727: LIST
4728: PPUSH
4729: CALL 301 0 2
4733: PUSH
4734: FOR_IN
4735: IFFALSE 4774
// MREG_Bulldozer := MC_RegistryUpdate ( MREG_Bulldozer , j , i , GetWeapon ( i ) ) ;
4737: LD_ADDR_EXP 11
4741: PUSH
4742: LD_EXP 11
4746: PPUSH
4747: LD_VAR 0 3
4751: PPUSH
4752: LD_VAR 0 2
4756: PPUSH
4757: LD_VAR 0 2
4761: PPUSH
4762: CALL_OW 264
4766: PPUSH
4767: CALL 4124 0 4
4771: ST_TO_ADDR
4772: GO 4734
4774: POP
4775: POP
// if MCF_Class ( j , 4 , [ ] ) then
4776: LD_VAR 0 3
4780: PPUSH
4781: LD_INT 4
4783: PPUSH
4784: EMPTY
4785: PPUSH
4786: CALL 83 0 3
4790: IFFALSE 4823
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
4792: LD_ADDR_EXP 23
4796: PUSH
4797: LD_EXP 23
4801: PUSH
4802: LD_VAR 0 3
4806: PPUSH
4807: LD_INT 4
4809: PPUSH
4810: EMPTY
4811: PPUSH
4812: CALL 83 0 3
4816: PUSH
4817: EMPTY
4818: LIST
4819: ADD
4820: ST_TO_ADDR
4821: GO 4840
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
4823: LD_ADDR_EXP 23
4827: PUSH
4828: LD_EXP 23
4832: PUSH
4833: LD_INT 0
4835: PUSH
4836: EMPTY
4837: LIST
4838: ADD
4839: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
4840: LD_VAR 0 3
4844: PPUSH
4845: LD_INT 3
4847: PPUSH
4848: EMPTY
4849: PPUSH
4850: CALL 83 0 3
4854: IFFALSE 4887
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
4856: LD_ADDR_EXP 24
4860: PUSH
4861: LD_EXP 24
4865: PUSH
4866: LD_VAR 0 3
4870: PPUSH
4871: LD_INT 3
4873: PPUSH
4874: EMPTY
4875: PPUSH
4876: CALL 83 0 3
4880: PUSH
4881: EMPTY
4882: LIST
4883: ADD
4884: ST_TO_ADDR
4885: GO 4904
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
4887: LD_ADDR_EXP 24
4891: PUSH
4892: LD_EXP 24
4896: PUSH
4897: LD_INT 0
4899: PUSH
4900: EMPTY
4901: LIST
4902: ADD
4903: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
4904: LD_VAR 0 3
4908: PPUSH
4909: LD_INT 1
4911: PPUSH
4912: EMPTY
4913: PPUSH
4914: CALL 83 0 3
4918: IFFALSE 4951
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
4920: LD_ADDR_EXP 25
4924: PUSH
4925: LD_EXP 25
4929: PUSH
4930: LD_VAR 0 3
4934: PPUSH
4935: LD_INT 1
4937: PPUSH
4938: EMPTY
4939: PPUSH
4940: CALL 83 0 3
4944: PUSH
4945: EMPTY
4946: LIST
4947: ADD
4948: ST_TO_ADDR
4949: GO 4968
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
4951: LD_ADDR_EXP 25
4955: PUSH
4956: LD_EXP 25
4960: PUSH
4961: LD_INT 0
4963: PUSH
4964: EMPTY
4965: LIST
4966: ADD
4967: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
4968: LD_VAR 0 3
4972: PPUSH
4973: LD_INT 2
4975: PPUSH
4976: EMPTY
4977: PPUSH
4978: CALL 83 0 3
4982: IFFALSE 5015
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
4984: LD_ADDR_EXP 26
4988: PUSH
4989: LD_EXP 26
4993: PUSH
4994: LD_VAR 0 3
4998: PPUSH
4999: LD_INT 2
5001: PPUSH
5002: EMPTY
5003: PPUSH
5004: CALL 83 0 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: ADD
5012: ST_TO_ADDR
5013: GO 5032
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
5015: LD_ADDR_EXP 26
5019: PUSH
5020: LD_EXP 26
5024: PUSH
5025: LD_INT 0
5027: PUSH
5028: EMPTY
5029: LIST
5030: ADD
5031: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
5032: LD_ADDR_EXP 16
5036: PUSH
5037: LD_EXP 16
5041: PUSH
5042: LD_INT 0
5044: PUSH
5045: EMPTY
5046: LIST
5047: ADD
5048: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
5049: LD_ADDR_EXP 3
5053: PUSH
5054: LD_EXP 3
5058: PUSH
5059: LD_INT 0
5061: PUSH
5062: EMPTY
5063: LIST
5064: ADD
5065: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
5066: LD_ADDR_EXP 5
5070: PUSH
5071: LD_EXP 5
5075: PUSH
5076: LD_INT 0
5078: PUSH
5079: EMPTY
5080: LIST
5081: ADD
5082: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
5083: LD_ADDR_EXP 27
5087: PUSH
5088: LD_EXP 27
5092: PUSH
5093: LD_INT 0
5095: PUSH
5096: EMPTY
5097: LIST
5098: ADD
5099: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
5100: LD_ADDR_EXP 28
5104: PUSH
5105: LD_EXP 28
5109: PUSH
5110: LD_INT 0
5112: PUSH
5113: EMPTY
5114: LIST
5115: ADD
5116: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
5117: LD_ADDR_EXP 20
5121: PUSH
5122: LD_EXP 20
5126: PUSH
5127: LD_INT 0
5129: PUSH
5130: EMPTY
5131: LIST
5132: ADD
5133: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
5134: LD_ADDR_EXP 6
5138: PUSH
5139: LD_EXP 6
5143: PUSH
5144: LD_INT 0
5146: PUSH
5147: LD_INT 0
5149: PUSH
5150: LD_INT 0
5152: PUSH
5153: LD_INT 0
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: PUSH
5162: EMPTY
5163: LIST
5164: ADD
5165: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
5166: LD_ADDR_EXP 29
5170: PUSH
5171: LD_EXP 29
5175: PUSH
5176: LD_INT 0
5178: PUSH
5179: EMPTY
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: EMPTY
5186: LIST
5187: ADD
5188: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
5189: LD_ADDR_EXP 30
5193: PUSH
5194: LD_EXP 30
5198: PUSH
5199: LD_INT 0
5201: PUSH
5202: EMPTY
5203: LIST
5204: PUSH
5205: EMPTY
5206: LIST
5207: ADD
5208: ST_TO_ADDR
// end ;
5209: GO 4314
5211: POP
5212: POP
// end ;
5213: LD_VAR 0 1
5217: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
5218: LD_INT 0
5220: PPUSH
5221: PPUSH
5222: PPUSH
// m := false ;
5223: LD_ADDR_VAR 0 5
5227: PUSH
5228: LD_INT 0
5230: ST_TO_ADDR
// for i = 1 to mreg do
5231: LD_ADDR_VAR 0 4
5235: PUSH
5236: DOUBLE
5237: LD_INT 1
5239: DEC
5240: ST_TO_ADDR
5241: LD_VAR 0 2
5245: PUSH
5246: FOR_TO
5247: IFFALSE 5283
// if mreg [ i ] [ 1 ] = side then
5249: LD_VAR 0 2
5253: PUSH
5254: LD_VAR 0 4
5258: ARRAY
5259: PUSH
5260: LD_INT 1
5262: ARRAY
5263: PUSH
5264: LD_VAR 0 1
5268: EQUAL
5269: IFFALSE 5281
// begin m := true ;
5271: LD_ADDR_VAR 0 5
5275: PUSH
5276: LD_INT 1
5278: ST_TO_ADDR
// break ;
5279: GO 5283
// end ;
5281: GO 5246
5283: POP
5284: POP
// result := m ;
5285: LD_ADDR_VAR 0 3
5289: PUSH
5290: LD_VAR 0 5
5294: ST_TO_ADDR
// end ;
5295: LD_VAR 0 3
5299: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
5300: LD_INT 0
5302: PPUSH
5303: PPUSH
5304: PPUSH
// m := 0 ;
5305: LD_ADDR_VAR 0 5
5309: PUSH
5310: LD_INT 0
5312: ST_TO_ADDR
// for i = 1 to mreg do
5313: LD_ADDR_VAR 0 4
5317: PUSH
5318: DOUBLE
5319: LD_INT 1
5321: DEC
5322: ST_TO_ADDR
5323: LD_VAR 0 2
5327: PUSH
5328: FOR_TO
5329: IFFALSE 5369
// if mreg [ i ] [ 1 ] = side then
5331: LD_VAR 0 2
5335: PUSH
5336: LD_VAR 0 4
5340: ARRAY
5341: PUSH
5342: LD_INT 1
5344: ARRAY
5345: PUSH
5346: LD_VAR 0 1
5350: EQUAL
5351: IFFALSE 5367
// begin m := m + 1 ;
5353: LD_ADDR_VAR 0 5
5357: PUSH
5358: LD_VAR 0 5
5362: PUSH
5363: LD_INT 1
5365: PLUS
5366: ST_TO_ADDR
// end ;
5367: GO 5328
5369: POP
5370: POP
// result := m ;
5371: LD_ADDR_VAR 0 3
5375: PUSH
5376: LD_VAR 0 5
5380: ST_TO_ADDR
// end ;
5381: LD_VAR 0 3
5385: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
5386: LD_INT 0
5388: PPUSH
5389: PPUSH
// result := 0 ;
5390: LD_ADDR_VAR 0 3
5394: PUSH
5395: LD_INT 0
5397: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
5398: LD_ADDR_VAR 0 4
5402: PUSH
5403: DOUBLE
5404: LD_INT 1
5406: DEC
5407: ST_TO_ADDR
5408: LD_EXP 22
5412: PUSH
5413: FOR_TO
5414: IFFALSE 5476
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
5416: LD_EXP 22
5420: PUSH
5421: LD_VAR 0 4
5425: ARRAY
5426: PUSH
5427: LD_INT 1
5429: ARRAY
5430: PUSH
5431: LD_VAR 0 1
5435: EQUAL
5436: PUSH
5437: LD_EXP 22
5441: PUSH
5442: LD_VAR 0 4
5446: ARRAY
5447: PUSH
5448: LD_INT 2
5450: ARRAY
5451: PUSH
5452: LD_VAR 0 2
5456: EQUAL
5457: AND
5458: IFFALSE 5474
// begin result := result + 1 ;
5460: LD_ADDR_VAR 0 3
5464: PUSH
5465: LD_VAR 0 3
5469: PUSH
5470: LD_INT 1
5472: PLUS
5473: ST_TO_ADDR
// end ;
5474: GO 5413
5476: POP
5477: POP
// end ; end_of_file
5478: LD_VAR 0 3
5482: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
5483: LD_INT 0
5485: PPUSH
// CreateDepositXY ( x , y , t ) ;
5486: LD_VAR 0 1
5490: PPUSH
5491: LD_VAR 0 2
5495: PPUSH
5496: LD_VAR 0 3
5500: PPUSH
5501: CALL_OW 62
// end ;
5505: LD_VAR 0 4
5509: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
5510: LD_INT 0
5512: PPUSH
5513: PPUSH
// c := 1 ;
5514: LD_ADDR_VAR 0 5
5518: PUSH
5519: LD_INT 1
5521: ST_TO_ADDR
// case color of red :
5522: LD_VAR 0 3
5526: PUSH
5527: LD_STRING red
5529: DOUBLE
5530: EQUAL
5531: IFTRUE 5535
5533: GO 5546
5535: POP
// c = 1 ; dark-green :
5536: LD_ADDR_VAR 0 5
5540: PUSH
5541: LD_INT 1
5543: ST_TO_ADDR
5544: GO 5832
5546: LD_STRING dark-green
5548: DOUBLE
5549: EQUAL
5550: IFTRUE 5554
5552: GO 5565
5554: POP
// c = 2 ; purple :
5555: LD_ADDR_VAR 0 5
5559: PUSH
5560: LD_INT 2
5562: ST_TO_ADDR
5563: GO 5832
5565: LD_STRING purple
5567: DOUBLE
5568: EQUAL
5569: IFTRUE 5573
5571: GO 5584
5573: POP
// c = 3 ; aqua :
5574: LD_ADDR_VAR 0 5
5578: PUSH
5579: LD_INT 3
5581: ST_TO_ADDR
5582: GO 5832
5584: LD_STRING aqua
5586: DOUBLE
5587: EQUAL
5588: IFTRUE 5592
5590: GO 5603
5592: POP
// c = 4 ; grey :
5593: LD_ADDR_VAR 0 5
5597: PUSH
5598: LD_INT 4
5600: ST_TO_ADDR
5601: GO 5832
5603: LD_STRING grey
5605: DOUBLE
5606: EQUAL
5607: IFTRUE 5611
5609: GO 5622
5611: POP
// c = 5 ; lime :
5612: LD_ADDR_VAR 0 5
5616: PUSH
5617: LD_INT 5
5619: ST_TO_ADDR
5620: GO 5832
5622: LD_STRING lime
5624: DOUBLE
5625: EQUAL
5626: IFTRUE 5630
5628: GO 5641
5630: POP
// c = 6 ; tan :
5631: LD_ADDR_VAR 0 5
5635: PUSH
5636: LD_INT 6
5638: ST_TO_ADDR
5639: GO 5832
5641: LD_STRING tan
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5660
5649: POP
// c = 7 ; pink :
5650: LD_ADDR_VAR 0 5
5654: PUSH
5655: LD_INT 7
5657: ST_TO_ADDR
5658: GO 5832
5660: LD_STRING pink
5662: DOUBLE
5663: EQUAL
5664: IFTRUE 5668
5666: GO 5679
5668: POP
// c = 8 ; green :
5669: LD_ADDR_VAR 0 5
5673: PUSH
5674: LD_INT 8
5676: ST_TO_ADDR
5677: GO 5832
5679: LD_STRING green
5681: DOUBLE
5682: EQUAL
5683: IFTRUE 5687
5685: GO 5698
5687: POP
// c = 9 ; blue :
5688: LD_ADDR_VAR 0 5
5692: PUSH
5693: LD_INT 9
5695: ST_TO_ADDR
5696: GO 5832
5698: LD_STRING blue
5700: DOUBLE
5701: EQUAL
5702: IFTRUE 5706
5704: GO 5717
5706: POP
// c = 10 ; yellow :
5707: LD_ADDR_VAR 0 5
5711: PUSH
5712: LD_INT 10
5714: ST_TO_ADDR
5715: GO 5832
5717: LD_STRING yellow
5719: DOUBLE
5720: EQUAL
5721: IFTRUE 5725
5723: GO 5736
5725: POP
// c = 11 ; brown :
5726: LD_ADDR_VAR 0 5
5730: PUSH
5731: LD_INT 11
5733: ST_TO_ADDR
5734: GO 5832
5736: LD_STRING brown
5738: DOUBLE
5739: EQUAL
5740: IFTRUE 5744
5742: GO 5755
5744: POP
// c = 12 ; black :
5745: LD_ADDR_VAR 0 5
5749: PUSH
5750: LD_INT 12
5752: ST_TO_ADDR
5753: GO 5832
5755: LD_STRING black
5757: DOUBLE
5758: EQUAL
5759: IFTRUE 5763
5761: GO 5774
5763: POP
// c = 13 ; aqua2 :
5764: LD_ADDR_VAR 0 5
5768: PUSH
5769: LD_INT 13
5771: ST_TO_ADDR
5772: GO 5832
5774: LD_STRING aqua2
5776: DOUBLE
5777: EQUAL
5778: IFTRUE 5782
5780: GO 5793
5782: POP
// c = 14 ; orange :
5783: LD_ADDR_VAR 0 5
5787: PUSH
5788: LD_INT 14
5790: ST_TO_ADDR
5791: GO 5832
5793: LD_STRING orange
5795: DOUBLE
5796: EQUAL
5797: IFTRUE 5801
5799: GO 5812
5801: POP
// c = 15 ; white :
5802: LD_ADDR_VAR 0 5
5806: PUSH
5807: LD_INT 15
5809: ST_TO_ADDR
5810: GO 5832
5812: LD_STRING white
5814: DOUBLE
5815: EQUAL
5816: IFTRUE 5820
5818: GO 5831
5820: POP
// c = 16 ; end ;
5821: LD_ADDR_VAR 0 5
5825: PUSH
5826: LD_INT 16
5828: ST_TO_ADDR
5829: GO 5832
5831: POP
// if HexInfo ( x , y ) = 0 then
5832: LD_VAR 0 1
5836: PPUSH
5837: LD_VAR 0 2
5841: PPUSH
5842: CALL_OW 428
5846: PUSH
5847: LD_INT 0
5849: EQUAL
5850: IFFALSE 5874
// PlaceEnvironment ( x , y , 58 , c ) ;
5852: LD_VAR 0 1
5856: PPUSH
5857: LD_VAR 0 2
5861: PPUSH
5862: LD_INT 58
5864: PPUSH
5865: LD_VAR 0 5
5869: PPUSH
5870: CALL_OW 349
// end ;
5874: LD_VAR 0 4
5878: RET
// export function MCT_RemovePlace ( x , y ) ; begin
5879: LD_INT 0
5881: PPUSH
// RemoveEnvironment ( x , y ) ;
5882: LD_VAR 0 1
5886: PPUSH
5887: LD_VAR 0 2
5891: PPUSH
5892: CALL_OW 347
// end ;
5896: LD_VAR 0 3
5900: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
5901: LD_INT 0
5903: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
5904: LD_INT 81
5906: PUSH
5907: LD_VAR 0 1
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PPUSH
5916: CALL_OW 69
5920: PUSH
5921: LD_INT 0
5923: EQUAL
5924: IFFALSE 5936
// result := false else
5926: LD_ADDR_VAR 0 5
5930: PUSH
5931: LD_INT 0
5933: ST_TO_ADDR
5934: GO 6000
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
5936: LD_INT 81
5938: PUSH
5939: LD_VAR 0 1
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: PUSH
5948: LD_INT 92
5950: PUSH
5951: LD_VAR 0 2
5955: PUSH
5956: LD_VAR 0 3
5960: PUSH
5961: LD_VAR 0 4
5965: PUSH
5966: EMPTY
5967: LIST
5968: LIST
5969: LIST
5970: LIST
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: PPUSH
5976: CALL_OW 69
5980: IFFALSE 5992
// result := true else
5982: LD_ADDR_VAR 0 5
5986: PUSH
5987: LD_INT 1
5989: ST_TO_ADDR
5990: GO 6000
// result := false ;
5992: LD_ADDR_VAR 0 5
5996: PUSH
5997: LD_INT 0
5999: ST_TO_ADDR
// end ;
6000: LD_VAR 0 5
6004: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
6005: LD_INT 0
6007: PPUSH
6008: PPUSH
6009: PPUSH
6010: PPUSH
6011: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
6012: LD_VAR 0 1
6016: PPUSH
6017: LD_INT 81
6019: PUSH
6020: LD_VAR 0 1
6024: PPUSH
6025: CALL_OW 255
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: PPUSH
6034: CALL_OW 69
6038: PPUSH
6039: LD_VAR 0 1
6043: PPUSH
6044: CALL_OW 74
6048: PPUSH
6049: CALL_OW 119
// dir := GetDir ( un ) ;
6053: LD_ADDR_VAR 0 4
6057: PUSH
6058: LD_VAR 0 1
6062: PPUSH
6063: CALL_OW 254
6067: ST_TO_ADDR
// dir := dir - 3 ;
6068: LD_ADDR_VAR 0 4
6072: PUSH
6073: LD_VAR 0 4
6077: PUSH
6078: LD_INT 3
6080: MINUS
6081: ST_TO_ADDR
// if dir < 0 then
6082: LD_VAR 0 4
6086: PUSH
6087: LD_INT 0
6089: LESS
6090: IFFALSE 6106
// dir := dir + 6 ;
6092: LD_ADDR_VAR 0 4
6096: PUSH
6097: LD_VAR 0 4
6101: PUSH
6102: LD_INT 6
6104: PLUS
6105: ST_TO_ADDR
// while true do
6106: LD_INT 1
6108: IFFALSE 6605
// begin coord_dist := 3 ;
6110: LD_ADDR_VAR 0 3
6114: PUSH
6115: LD_INT 3
6117: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
6118: LD_ADDR_VAR 0 5
6122: PUSH
6123: LD_VAR 0 1
6127: PPUSH
6128: CALL_OW 250
6132: PPUSH
6133: LD_VAR 0 4
6137: PPUSH
6138: LD_VAR 0 3
6142: PPUSH
6143: CALL_OW 272
6147: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
6148: LD_ADDR_VAR 0 6
6152: PUSH
6153: LD_VAR 0 1
6157: PPUSH
6158: CALL_OW 251
6162: PPUSH
6163: LD_VAR 0 4
6167: PPUSH
6168: LD_VAR 0 3
6172: PPUSH
6173: CALL_OW 273
6177: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
6178: LD_VAR 0 1
6182: PPUSH
6183: CALL_OW 255
6187: PPUSH
6188: LD_VAR 0 1
6192: PPUSH
6193: CALL_OW 250
6197: PPUSH
6198: LD_VAR 0 1
6202: PPUSH
6203: CALL_OW 251
6207: PPUSH
6208: LD_INT 14
6210: PPUSH
6211: CALL 5901 0 4
6215: PUSH
6216: LD_VAR 0 5
6220: PPUSH
6221: LD_VAR 0 6
6225: PPUSH
6226: CALL_OW 351
6230: OR
6231: PUSH
6232: LD_VAR 0 5
6236: PPUSH
6237: LD_VAR 0 6
6241: PPUSH
6242: CALL_OW 488
6246: PUSH
6247: LD_INT 0
6249: EQUAL
6250: OR
6251: PUSH
6252: LD_VAR 0 5
6256: PPUSH
6257: LD_VAR 0 6
6261: PPUSH
6262: CALL_OW 546
6266: PUSH
6267: LD_INT 1
6269: EQUAL
6270: OR
6271: PUSH
6272: LD_VAR 0 5
6276: PPUSH
6277: LD_VAR 0 6
6281: PPUSH
6282: CALL_OW 428
6286: PUSH
6287: LD_INT 0
6289: NONEQUAL
6290: OR
6291: IFFALSE 6519
// begin repeat begin Wait ( 0 0$0.3 ) ;
6293: LD_INT 10
6295: PPUSH
6296: CALL_OW 67
// coord_dist := coord_dist + 1 ;
6300: LD_ADDR_VAR 0 3
6304: PUSH
6305: LD_VAR 0 3
6309: PUSH
6310: LD_INT 1
6312: PLUS
6313: ST_TO_ADDR
// dir := dir + 1 ;
6314: LD_ADDR_VAR 0 4
6318: PUSH
6319: LD_VAR 0 4
6323: PUSH
6324: LD_INT 1
6326: PLUS
6327: ST_TO_ADDR
// if dir > 5 then
6328: LD_VAR 0 4
6332: PUSH
6333: LD_INT 5
6335: GREATER
6336: IFFALSE 6346
// dir = 0 ;
6338: LD_ADDR_VAR 0 4
6342: PUSH
6343: LD_INT 0
6345: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
6346: LD_ADDR_VAR 0 5
6350: PUSH
6351: LD_VAR 0 1
6355: PPUSH
6356: CALL_OW 250
6360: PPUSH
6361: LD_VAR 0 4
6365: PPUSH
6366: LD_VAR 0 3
6370: PPUSH
6371: CALL_OW 272
6375: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
6376: LD_ADDR_VAR 0 6
6380: PUSH
6381: LD_VAR 0 1
6385: PPUSH
6386: CALL_OW 251
6390: PPUSH
6391: LD_VAR 0 4
6395: PPUSH
6396: LD_VAR 0 3
6400: PPUSH
6401: CALL_OW 273
6405: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
6406: LD_VAR 0 1
6410: PPUSH
6411: CALL_OW 255
6415: PPUSH
6416: LD_VAR 0 1
6420: PPUSH
6421: CALL_OW 250
6425: PPUSH
6426: LD_VAR 0 1
6430: PPUSH
6431: CALL_OW 251
6435: PPUSH
6436: LD_INT 14
6438: PPUSH
6439: CALL 5901 0 4
6443: NOT
6444: PUSH
6445: LD_VAR 0 5
6449: PPUSH
6450: LD_VAR 0 6
6454: PPUSH
6455: CALL_OW 351
6459: NOT
6460: AND
6461: PUSH
6462: LD_VAR 0 5
6466: PPUSH
6467: LD_VAR 0 6
6471: PPUSH
6472: CALL_OW 488
6476: AND
6477: PUSH
6478: LD_VAR 0 5
6482: PPUSH
6483: LD_VAR 0 6
6487: PPUSH
6488: CALL_OW 546
6492: PUSH
6493: LD_INT 0
6495: EQUAL
6496: AND
6497: PUSH
6498: LD_VAR 0 5
6502: PPUSH
6503: LD_VAR 0 6
6507: PPUSH
6508: CALL_OW 428
6512: PUSH
6513: LD_INT 0
6515: EQUAL
6516: AND
6517: IFFALSE 6293
// end ; ComMoveXY ( un , x , y ) ;
6519: LD_VAR 0 1
6523: PPUSH
6524: LD_VAR 0 5
6528: PPUSH
6529: LD_VAR 0 6
6533: PPUSH
6534: CALL_OW 111
// Wait ( 0 0$1 ) ;
6538: LD_INT 35
6540: PPUSH
6541: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
6545: LD_VAR 0 1
6549: PPUSH
6550: LD_INT 81
6552: PUSH
6553: LD_VAR 0 1
6557: PPUSH
6558: CALL_OW 255
6562: PUSH
6563: EMPTY
6564: LIST
6565: LIST
6566: PPUSH
6567: CALL_OW 69
6571: PPUSH
6572: LD_VAR 0 1
6576: PPUSH
6577: CALL_OW 74
6581: PPUSH
6582: CALL_OW 296
6586: PUSH
6587: LD_INT 14
6589: GREATEREQUAL
6590: IFFALSE 6603
// begin ComStop ( un ) ;
6592: LD_VAR 0 1
6596: PPUSH
6597: CALL_OW 141
// break ;
6601: GO 6605
// end ; end ;
6603: GO 6106
// end ;
6605: LD_VAR 0 2
6609: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
6610: LD_INT 0
6612: PPUSH
6613: PPUSH
6614: PPUSH
6615: PPUSH
6616: PPUSH
6617: PPUSH
6618: PPUSH
6619: PPUSH
// x := GetX ( unit ) ;
6620: LD_ADDR_VAR 0 3
6624: PUSH
6625: LD_VAR 0 1
6629: PPUSH
6630: CALL_OW 250
6634: ST_TO_ADDR
// y := GetY ( unit ) ;
6635: LD_ADDR_VAR 0 4
6639: PUSH
6640: LD_VAR 0 1
6644: PPUSH
6645: CALL_OW 251
6649: ST_TO_ADDR
// i := 0 ;
6650: LD_ADDR_VAR 0 8
6654: PUSH
6655: LD_INT 0
6657: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
6658: LD_VAR 0 1
6662: PPUSH
6663: LD_INT 81
6665: PUSH
6666: LD_VAR 0 1
6670: PPUSH
6671: CALL_OW 255
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: PPUSH
6680: CALL_OW 69
6684: PPUSH
6685: LD_VAR 0 1
6689: PPUSH
6690: CALL_OW 74
6694: PPUSH
6695: CALL_OW 119
// dir := GetDir ( unit ) ;
6699: LD_ADDR_VAR 0 7
6703: PUSH
6704: LD_VAR 0 1
6708: PPUSH
6709: CALL_OW 254
6713: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
6714: LD_ADDR_VAR 0 9
6718: PUSH
6719: LD_INT 0
6721: PPUSH
6722: LD_INT 1
6724: PPUSH
6725: CALL_OW 12
6729: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
6730: LD_INT 10
6732: PPUSH
6733: CALL_OW 67
// if mode then
6737: LD_VAR 0 9
6741: IFFALSE 6759
// dir := dir + 1 else
6743: LD_ADDR_VAR 0 7
6747: PUSH
6748: LD_VAR 0 7
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6773
// dir := dir - 1 ;
6759: LD_ADDR_VAR 0 7
6763: PUSH
6764: LD_VAR 0 7
6768: PUSH
6769: LD_INT 1
6771: MINUS
6772: ST_TO_ADDR
// if ( dir < 0 ) then
6773: LD_VAR 0 7
6777: PUSH
6778: LD_INT 0
6780: LESS
6781: IFFALSE 6791
// dir := 5 ;
6783: LD_ADDR_VAR 0 7
6787: PUSH
6788: LD_INT 5
6790: ST_TO_ADDR
// if ( dir > 5 ) then
6791: LD_VAR 0 7
6795: PUSH
6796: LD_INT 5
6798: GREATER
6799: IFFALSE 6809
// dir := 0 ;
6801: LD_ADDR_VAR 0 7
6805: PUSH
6806: LD_INT 0
6808: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
6809: LD_ADDR_VAR 0 5
6813: PUSH
6814: LD_VAR 0 3
6818: PPUSH
6819: LD_VAR 0 7
6823: PPUSH
6824: LD_INT 4
6826: PPUSH
6827: CALL_OW 272
6831: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
6832: LD_ADDR_VAR 0 6
6836: PUSH
6837: LD_VAR 0 4
6841: PPUSH
6842: LD_VAR 0 7
6846: PPUSH
6847: LD_INT 4
6849: PPUSH
6850: CALL_OW 273
6854: ST_TO_ADDR
// i := i + 1 ;
6855: LD_ADDR_VAR 0 8
6859: PUSH
6860: LD_VAR 0 8
6864: PUSH
6865: LD_INT 1
6867: PLUS
6868: ST_TO_ADDR
// MC_Show ( [ x , y , dir ] ^ [ x2 , y2 ] ) ;
6869: LD_VAR 0 3
6873: PUSH
6874: LD_VAR 0 4
6878: PUSH
6879: LD_VAR 0 7
6883: PUSH
6884: EMPTY
6885: LIST
6886: LIST
6887: LIST
6888: PUSH
6889: LD_VAR 0 5
6893: PUSH
6894: LD_VAR 0 6
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: ADD
6903: PPUSH
6904: CALL 3890 0 1
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
6908: LD_VAR 0 1
6912: PPUSH
6913: CALL_OW 255
6917: PPUSH
6918: LD_VAR 0 5
6922: PPUSH
6923: LD_VAR 0 6
6927: PPUSH
6928: LD_INT 14
6930: PPUSH
6931: CALL 5901 0 4
6935: PUSH
6936: LD_INT 0
6938: EQUAL
6939: PUSH
6940: LD_VAR 0 5
6944: PPUSH
6945: LD_VAR 0 6
6949: PPUSH
6950: CALL_OW 546
6954: PUSH
6955: LD_INT 0
6957: EQUAL
6958: AND
6959: PUSH
6960: LD_VAR 0 5
6964: PPUSH
6965: LD_VAR 0 6
6969: PPUSH
6970: CALL_OW 428
6974: PUSH
6975: LD_INT 0
6977: EQUAL
6978: AND
6979: IFFALSE 6983
// break ;
6981: GO 6993
// end until i > 4 ;
6983: LD_VAR 0 8
6987: PUSH
6988: LD_INT 4
6990: GREATER
6991: IFFALSE 6730
// if x2 and y2 then
6993: LD_VAR 0 5
6997: PUSH
6998: LD_VAR 0 6
7002: AND
7003: IFFALSE 7026
// result := [ x2 , y2 ] else
7005: LD_ADDR_VAR 0 2
7009: PUSH
7010: LD_VAR 0 5
7014: PUSH
7015: LD_VAR 0 6
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: ST_TO_ADDR
7024: GO 7055
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
7026: LD_ADDR_VAR 0 2
7030: PUSH
7031: LD_VAR 0 1
7035: PPUSH
7036: CALL_OW 250
7040: PUSH
7041: LD_VAR 0 1
7045: PPUSH
7046: CALL_OW 251
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: ST_TO_ADDR
// end ;
7055: LD_VAR 0 2
7059: RET
// export function MCT_Hex ( x , y ) ; begin
7060: LD_INT 0
7062: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
7063: LD_ADDR_VAR 0 3
7067: PUSH
7068: LD_VAR 0 1
7072: PPUSH
7073: LD_VAR 0 2
7077: PPUSH
7078: CALL_OW 546
7082: PUSH
7083: LD_VAR 0 1
7087: PPUSH
7088: LD_VAR 0 2
7092: PPUSH
7093: CALL_OW 428
7097: PUSH
7098: EMPTY
7099: LIST
7100: PUSH
7101: EMPTY
7102: LIST
7103: LIST
7104: ST_TO_ADDR
// end ;
7105: LD_VAR 0 3
7109: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
7110: LD_INT 0
7112: PPUSH
7113: PPUSH
7114: PPUSH
7115: PPUSH
7116: PPUSH
7117: PPUSH
7118: PPUSH
7119: PPUSH
7120: PPUSH
7121: PPUSH
7122: PPUSH
7123: PPUSH
7124: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
7125: LD_ADDR_VAR 0 10
7129: PUSH
7130: LD_EXP 29
7134: PUSH
7135: LD_VAR 0 1
7139: ARRAY
7140: PUSH
7141: LD_INT 1
7143: ARRAY
7144: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
7145: LD_ADDR_VAR 0 11
7149: PUSH
7150: LD_EXP 29
7154: PUSH
7155: LD_VAR 0 1
7159: ARRAY
7160: PUSH
7161: LD_INT 2
7163: ARRAY
7164: ST_TO_ADDR
// collectors := [ ] ;
7165: LD_ADDR_VAR 0 12
7169: PUSH
7170: EMPTY
7171: ST_TO_ADDR
// is_cargo := false ;
7172: LD_ADDR_VAR 0 13
7176: PUSH
7177: LD_INT 0
7179: ST_TO_ADDR
// if isEditor then
7180: LD_INT 1
7182: IFFALSE 7188
// TimerStart ( ) ;
7184: CALL_OW 548
// if MCF_Cargo ( side ) then
7188: LD_VAR 0 1
7192: PPUSH
7193: CALL 351 0 1
7197: IFFALSE 7224
// begin collectors := MCF_Cargo ( side ) ;
7199: LD_ADDR_VAR 0 12
7203: PUSH
7204: LD_VAR 0 1
7208: PPUSH
7209: CALL 351 0 1
7213: ST_TO_ADDR
// is_cargo := true ;
7214: LD_ADDR_VAR 0 13
7218: PUSH
7219: LD_INT 1
7221: ST_TO_ADDR
// end else
7222: GO 7373
// begin if MCF_ApeSpec ( side , engineer ) then
7224: LD_VAR 0 1
7228: PPUSH
7229: LD_STRING engineer
7231: PPUSH
7232: CALL 497 0 2
7236: IFFALSE 7256
// collectors := MCF_ApeSpec ( side , engineer ) ;
7238: LD_ADDR_VAR 0 12
7242: PUSH
7243: LD_VAR 0 1
7247: PPUSH
7248: LD_STRING engineer
7250: PPUSH
7251: CALL 497 0 2
7255: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
7256: LD_VAR 0 1
7260: PPUSH
7261: LD_INT 2
7263: PPUSH
7264: EMPTY
7265: PPUSH
7266: CALL 83 0 3
7270: IFFALSE 7373
// begin z := MCF_Class ( side , 2 , [ ] ) ;
7272: LD_ADDR_VAR 0 7
7276: PUSH
7277: LD_VAR 0 1
7281: PPUSH
7282: LD_INT 2
7284: PPUSH
7285: EMPTY
7286: PPUSH
7287: CALL 83 0 3
7291: ST_TO_ADDR
// if z > 5 then
7292: LD_VAR 0 7
7296: PUSH
7297: LD_INT 5
7299: GREATER
7300: IFFALSE 7312
// t1 := 5 else
7302: LD_ADDR_VAR 0 8
7306: PUSH
7307: LD_INT 5
7309: ST_TO_ADDR
7310: GO 7322
// t1 := z ;
7312: LD_ADDR_VAR 0 8
7316: PUSH
7317: LD_VAR 0 7
7321: ST_TO_ADDR
// for t2 = 1 to t1 do
7322: LD_ADDR_VAR 0 9
7326: PUSH
7327: DOUBLE
7328: LD_INT 1
7330: DEC
7331: ST_TO_ADDR
7332: LD_VAR 0 8
7336: PUSH
7337: FOR_TO
7338: IFFALSE 7371
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
7340: LD_ADDR_VAR 0 12
7344: PUSH
7345: LD_VAR 0 12
7349: PPUSH
7350: LD_INT 1
7352: PPUSH
7353: LD_VAR 0 7
7357: PUSH
7358: LD_VAR 0 9
7362: ARRAY
7363: PPUSH
7364: CALL_OW 2
7368: ST_TO_ADDR
7369: GO 7337
7371: POP
7372: POP
// end ; end ; if not mode then
7373: LD_VAR 0 10
7377: NOT
7378: IFFALSE 7384
// exit else
7380: GO 7641
7382: GO 7641
// begin if collectors then
7384: LD_VAR 0 12
7388: IFFALSE 7641
// for i in areas do
7390: LD_ADDR_VAR 0 3
7394: PUSH
7395: LD_VAR 0 11
7399: PUSH
7400: FOR_IN
7401: IFFALSE 7639
// if GetListOfCratesInArea ( i ) then
7403: LD_VAR 0 3
7407: PPUSH
7408: CALL_OW 435
7412: IFFALSE 7637
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
7414: LD_ADDR_VAR 0 5
7418: PUSH
7419: LD_VAR 0 3
7423: PPUSH
7424: CALL_OW 435
7428: PUSH
7429: LD_INT 1
7431: ARRAY
7432: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
7433: LD_ADDR_VAR 0 6
7437: PUSH
7438: LD_VAR 0 3
7442: PPUSH
7443: CALL_OW 435
7447: PUSH
7448: LD_INT 2
7450: ARRAY
7451: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
7452: LD_VAR 0 13
7456: PUSH
7457: LD_VAR 0 12
7461: PUSH
7462: LD_INT 1
7464: ARRAY
7465: PPUSH
7466: CALL_OW 110
7470: PUSH
7471: LD_INT 0
7473: EQUAL
7474: AND
7475: IFFALSE 7537
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
7477: LD_VAR 0 12
7481: PUSH
7482: LD_INT 1
7484: ARRAY
7485: PPUSH
7486: CALL_OW 314
7490: NOT
7491: PUSH
7492: LD_VAR 0 12
7496: PUSH
7497: LD_INT 1
7499: ARRAY
7500: PPUSH
7501: CALL_OW 110
7505: PUSH
7506: LD_INT 0
7508: EQUAL
7509: AND
7510: IFFALSE 7535
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
7512: LD_VAR 0 12
7516: PUSH
7517: LD_INT 1
7519: ARRAY
7520: PPUSH
7521: LD_VAR 0 5
7525: PPUSH
7526: LD_VAR 0 6
7530: PPUSH
7531: CALL_OW 117
// end ; end else
7535: GO 7623
// begin for j = 1 to collectors do
7537: LD_ADDR_VAR 0 4
7541: PUSH
7542: DOUBLE
7543: LD_INT 1
7545: DEC
7546: ST_TO_ADDR
7547: LD_VAR 0 12
7551: PUSH
7552: FOR_TO
7553: IFFALSE 7621
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
7555: LD_VAR 0 12
7559: PUSH
7560: LD_VAR 0 4
7564: ARRAY
7565: PPUSH
7566: CALL_OW 314
7570: NOT
7571: PUSH
7572: LD_VAR 0 12
7576: PUSH
7577: LD_VAR 0 4
7581: ARRAY
7582: PPUSH
7583: CALL_OW 110
7587: PUSH
7588: LD_INT 0
7590: EQUAL
7591: AND
7592: IFFALSE 7619
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
7594: LD_VAR 0 12
7598: PUSH
7599: LD_VAR 0 4
7603: ARRAY
7604: PPUSH
7605: LD_VAR 0 5
7609: PPUSH
7610: LD_VAR 0 6
7614: PPUSH
7615: CALL 8002 0 3
// end ;
7619: GO 7552
7621: POP
7622: POP
// end ; if isEditor then
7623: LD_INT 1
7625: IFFALSE 7637
// begin debug_time := TimerEnd ( ) ;
7627: LD_ADDR_VAR 0 14
7631: PUSH
7632: CALL_OW 549
7636: ST_TO_ADDR
// end ; end ;
7637: GO 7400
7639: POP
7640: POP
// end ; end ;
7641: LD_VAR 0 2
7645: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
7646: LD_INT 0
7648: PPUSH
7649: PPUSH
7650: PPUSH
7651: PPUSH
7652: PPUSH
7653: PPUSH
// if not area then
7654: LD_VAR 0 1
7658: NOT
7659: IFFALSE 7665
// exit else
7661: GO 7917
7663: GO 7917
// if tick mod interval = 0 and Prob ( percent ) then
7665: LD_OWVAR 1
7669: PUSH
7670: LD_VAR 0 4
7674: MOD
7675: PUSH
7676: LD_INT 0
7678: EQUAL
7679: PUSH
7680: LD_VAR 0 3
7684: PPUSH
7685: CALL_OW 13
7689: AND
7690: IFFALSE 7917
// begin if GetListOfCratesInArea ( area ) < limit then
7692: LD_VAR 0 1
7696: PPUSH
7697: CALL_OW 435
7701: PUSH
7702: LD_VAR 0 5
7706: LESS
7707: IFFALSE 7917
// begin Randomize ;
7709: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
7713: LD_ADDR_VAR 0 7
7717: PUSH
7718: LD_INT 1
7720: PPUSH
7721: LD_VAR 0 2
7725: PPUSH
7726: CALL_OW 12
7730: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
7731: LD_ADDR_VAR 0 9
7735: PUSH
7736: LD_VAR 0 1
7740: PPUSH
7741: LD_INT 0
7743: PPUSH
7744: CALL_OW 517
7748: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
7749: LD_ADDR_VAR 0 8
7753: PUSH
7754: LD_INT 1
7756: PPUSH
7757: LD_VAR 0 9
7761: PUSH
7762: LD_INT 1
7764: ARRAY
7765: PPUSH
7766: CALL_OW 12
7770: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
7771: LD_VAR 0 9
7775: PUSH
7776: LD_INT 1
7778: ARRAY
7779: PUSH
7780: LD_VAR 0 8
7784: ARRAY
7785: PPUSH
7786: LD_VAR 0 9
7790: PUSH
7791: LD_INT 2
7793: ARRAY
7794: PUSH
7795: LD_VAR 0 8
7799: ARRAY
7800: PPUSH
7801: CALL_OW 428
7805: PUSH
7806: LD_INT 0
7808: GREATER
7809: PUSH
7810: LD_VAR 0 9
7814: PUSH
7815: LD_INT 1
7817: ARRAY
7818: PUSH
7819: LD_VAR 0 8
7823: ARRAY
7824: PPUSH
7825: LD_VAR 0 9
7829: PUSH
7830: LD_INT 2
7832: ARRAY
7833: PUSH
7834: LD_VAR 0 8
7838: ARRAY
7839: PPUSH
7840: CALL_OW 284
7844: PUSH
7845: LD_INT 0
7847: GREATER
7848: AND
7849: IFFALSE 7875
// c := Rand ( 1 , tmp [ 1 ] ) ;
7851: LD_ADDR_VAR 0 8
7855: PUSH
7856: LD_INT 1
7858: PPUSH
7859: LD_VAR 0 9
7863: PUSH
7864: LD_INT 1
7866: ARRAY
7867: PPUSH
7868: CALL_OW 12
7872: ST_TO_ADDR
7873: GO 7771
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
7875: LD_VAR 0 7
7879: PPUSH
7880: LD_VAR 0 9
7884: PUSH
7885: LD_INT 1
7887: ARRAY
7888: PUSH
7889: LD_VAR 0 8
7893: ARRAY
7894: PPUSH
7895: LD_VAR 0 9
7899: PUSH
7900: LD_INT 2
7902: ARRAY
7903: PUSH
7904: LD_VAR 0 8
7908: ARRAY
7909: PPUSH
7910: LD_INT 1
7912: PPUSH
7913: CALL_OW 54
// end ; end ; end ;
7917: LD_VAR 0 6
7921: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
7922: LD_INT 0
7924: PPUSH
7925: PPUSH
// if not MREG_Crates then
7926: LD_EXP 2
7930: NOT
7931: IFFALSE 7935
// exit ;
7933: GO 7997
// for i = MREG_Crates downto 1 do
7935: LD_ADDR_VAR 0 2
7939: PUSH
7940: DOUBLE
7941: LD_EXP 2
7945: INC
7946: ST_TO_ADDR
7947: LD_INT 1
7949: PUSH
7950: FOR_DOWNTO
7951: IFFALSE 7995
// if MREG_Crates [ i ] [ 3 ] = 0 then
7953: LD_EXP 2
7957: PUSH
7958: LD_VAR 0 2
7962: ARRAY
7963: PUSH
7964: LD_INT 3
7966: ARRAY
7967: PUSH
7968: LD_INT 0
7970: EQUAL
7971: IFFALSE 7993
// MREG_Crates := Delete ( MREG_Crates , i ) ;
7973: LD_ADDR_EXP 2
7977: PUSH
7978: LD_EXP 2
7982: PPUSH
7983: LD_VAR 0 2
7987: PPUSH
7988: CALL_OW 3
7992: ST_TO_ADDR
7993: GO 7950
7995: POP
7996: POP
// end ;
7997: LD_VAR 0 1
8001: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
8002: LD_INT 0
8004: PPUSH
8005: PPUSH
8006: PPUSH
8007: PPUSH
// if not unit then
8008: LD_VAR 0 1
8012: NOT
8013: IFFALSE 8017
// exit ;
8015: GO 8152
// if HasTask ( unit ) or not CanCarry ( unit ) then
8017: LD_VAR 0 1
8021: PPUSH
8022: CALL_OW 314
8026: PUSH
8027: LD_VAR 0 1
8031: PPUSH
8032: CALL_OW 280
8036: NOT
8037: OR
8038: IFFALSE 8042
// exit ;
8040: GO 8152
// side := GetSide ( unit ) ;
8042: LD_ADDR_VAR 0 6
8046: PUSH
8047: LD_VAR 0 1
8051: PPUSH
8052: CALL_OW 255
8056: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
8057: LD_ADDR_VAR 0 7
8061: PUSH
8062: LD_VAR 0 6
8066: PPUSH
8067: LD_INT 30
8069: PUSH
8070: LD_INT 1
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: PPUSH
8077: CALL 0 0 2
8081: ST_TO_ADDR
// if Carry ( unit ) or not dep then
8082: LD_VAR 0 1
8086: PPUSH
8087: CALL_OW 281
8091: PUSH
8092: LD_VAR 0 7
8096: NOT
8097: OR
8098: IFFALSE 8104
// exit else
8100: GO 8152
8102: GO 8152
// if GetResourceAmountXY ( x , y ) then
8104: LD_VAR 0 2
8108: PPUSH
8109: LD_VAR 0 3
8113: PPUSH
8114: CALL_OW 284
8118: IFFALSE 8150
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
8120: LD_VAR 0 1
8124: PPUSH
8125: LD_VAR 0 2
8129: PPUSH
8130: LD_VAR 0 3
8134: PPUSH
8135: LD_VAR 0 7
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: CALL 25535 0 4
// end else
8148: GO 8152
// exit ;
8150: GO 8152
// end ; end_of_file
8152: LD_VAR 0 4
8156: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
8157: LD_INT 0
8159: PPUSH
8160: PPUSH
8161: PPUSH
// pom := GetBase ( bdepot ) ;
8162: LD_ADDR_VAR 0 3
8166: PUSH
8167: LD_VAR 0 1
8171: PPUSH
8172: CALL_OW 274
8176: ST_TO_ADDR
// sor := [ ] ;
8177: LD_ADDR_VAR 0 4
8181: PUSH
8182: EMPTY
8183: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
8184: LD_ADDR_VAR 0 4
8188: PUSH
8189: LD_VAR 0 4
8193: PUSH
8194: LD_VAR 0 3
8198: PPUSH
8199: LD_INT 1
8201: PPUSH
8202: CALL_OW 275
8206: ADD
8207: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
8208: LD_ADDR_VAR 0 4
8212: PUSH
8213: LD_VAR 0 4
8217: PUSH
8218: LD_VAR 0 3
8222: PPUSH
8223: LD_INT 2
8225: PPUSH
8226: CALL_OW 275
8230: ADD
8231: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
8232: LD_ADDR_VAR 0 4
8236: PUSH
8237: LD_VAR 0 4
8241: PUSH
8242: LD_VAR 0 3
8246: PPUSH
8247: LD_INT 3
8249: PPUSH
8250: CALL_OW 275
8254: ADD
8255: ST_TO_ADDR
// result := sor ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 4
8265: ST_TO_ADDR
// end ;
8266: LD_VAR 0 2
8270: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
8271: LD_INT 0
8273: PPUSH
8274: PPUSH
// while ( coord_list ) do
8275: LD_VAR 0 3
8279: IFFALSE 8453
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
8281: LD_ADDR_EXP 15
8285: PUSH
8286: LD_EXP 15
8290: PPUSH
8291: LD_VAR 0 1
8295: PPUSH
8296: LD_VAR 0 2
8300: PPUSH
8301: LD_VAR 0 3
8305: PUSH
8306: LD_INT 1
8308: ARRAY
8309: PUSH
8310: LD_VAR 0 3
8314: PUSH
8315: LD_INT 2
8317: ARRAY
8318: PUSH
8319: LD_VAR 0 3
8323: PUSH
8324: LD_INT 3
8326: ARRAY
8327: PUSH
8328: EMPTY
8329: LIST
8330: LIST
8331: LIST
8332: PPUSH
8333: CALL 4124 0 4
8337: ST_TO_ADDR
// if weapon_list then
8338: LD_VAR 0 4
8342: IFFALSE 8413
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
8344: LD_ADDR_EXP 12
8348: PUSH
8349: LD_EXP 12
8353: PPUSH
8354: LD_VAR 0 1
8358: PPUSH
8359: LD_VAR 0 4
8363: PUSH
8364: LD_INT 1
8366: ARRAY
8367: PPUSH
8368: LD_VAR 0 3
8372: PUSH
8373: LD_INT 1
8375: ARRAY
8376: PUSH
8377: LD_VAR 0 3
8381: PUSH
8382: LD_INT 2
8384: ARRAY
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PPUSH
8390: CALL 4124 0 4
8394: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
8395: LD_ADDR_VAR 0 4
8399: PUSH
8400: LD_VAR 0 4
8404: PPUSH
8405: LD_INT 1
8407: PPUSH
8408: CALL_OW 3
8412: ST_TO_ADDR
// end ; for i = 1 to 3 do
8413: LD_ADDR_VAR 0 6
8417: PUSH
8418: DOUBLE
8419: LD_INT 1
8421: DEC
8422: ST_TO_ADDR
8423: LD_INT 3
8425: PUSH
8426: FOR_TO
8427: IFFALSE 8449
// coord_list := Delete ( coord_list , 1 ) ;
8429: LD_ADDR_VAR 0 3
8433: PUSH
8434: LD_VAR 0 3
8438: PPUSH
8439: LD_INT 1
8441: PPUSH
8442: CALL_OW 3
8446: ST_TO_ADDR
8447: GO 8426
8449: POP
8450: POP
// end ;
8451: GO 8275
// result := true ;
8453: LD_ADDR_VAR 0 5
8457: PUSH
8458: LD_INT 1
8460: ST_TO_ADDR
// end ;
8461: LD_VAR 0 5
8465: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
8466: LD_INT 0
8468: PPUSH
8469: PPUSH
// if not weapon_list then
8470: LD_VAR 0 3
8474: NOT
8475: IFFALSE 8479
// exit ;
8477: GO 8594
// while ( coord_list ) do
8479: LD_VAR 0 2
8483: IFFALSE 8594
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
8485: LD_ADDR_EXP 12
8489: PUSH
8490: LD_EXP 12
8494: PPUSH
8495: LD_VAR 0 1
8499: PPUSH
8500: LD_VAR 0 3
8504: PUSH
8505: LD_INT 1
8507: ARRAY
8508: PPUSH
8509: LD_VAR 0 2
8513: PUSH
8514: LD_INT 1
8516: ARRAY
8517: PUSH
8518: LD_VAR 0 2
8522: PUSH
8523: LD_INT 2
8525: ARRAY
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: PPUSH
8531: CALL 4124 0 4
8535: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
8536: LD_ADDR_VAR 0 3
8540: PUSH
8541: LD_VAR 0 3
8545: PPUSH
8546: LD_INT 1
8548: PPUSH
8549: CALL_OW 3
8553: ST_TO_ADDR
// for i = 1 to 2 do
8554: LD_ADDR_VAR 0 5
8558: PUSH
8559: DOUBLE
8560: LD_INT 1
8562: DEC
8563: ST_TO_ADDR
8564: LD_INT 2
8566: PUSH
8567: FOR_TO
8568: IFFALSE 8590
// coord_list := Delete ( coord_list , 1 ) ;
8570: LD_ADDR_VAR 0 2
8574: PUSH
8575: LD_VAR 0 2
8579: PPUSH
8580: LD_INT 1
8582: PPUSH
8583: CALL_OW 3
8587: ST_TO_ADDR
8588: GO 8567
8590: POP
8591: POP
// end ;
8592: GO 8479
// end ;
8594: LD_VAR 0 4
8598: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
8599: LD_INT 0
8601: PPUSH
8602: PPUSH
// while ( coord_list ) do
8603: LD_VAR 0 2
8607: IFFALSE 8762
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
8609: LD_VAR 0 2
8613: PUSH
8614: LD_INT 1
8616: ARRAY
8617: PPUSH
8618: LD_VAR 0 2
8622: PUSH
8623: LD_INT 2
8625: ARRAY
8626: PPUSH
8627: CALL_OW 428
8631: IFFALSE 8722
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
8633: LD_VAR 0 2
8637: PUSH
8638: LD_INT 1
8640: ARRAY
8641: PPUSH
8642: LD_VAR 0 2
8646: PUSH
8647: LD_INT 2
8649: ARRAY
8650: PPUSH
8651: CALL_OW 428
8655: PPUSH
8656: CALL_OW 266
8660: PUSH
8661: LD_INT 31
8663: PUSH
8664: LD_INT 32
8666: PUSH
8667: LD_INT 33
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: IN
8675: IFFALSE 8722
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
8677: LD_ADDR_EXP 21
8681: PUSH
8682: LD_EXP 21
8686: PPUSH
8687: LD_VAR 0 1
8691: PPUSH
8692: LD_VAR 0 2
8696: PUSH
8697: LD_INT 1
8699: ARRAY
8700: PPUSH
8701: LD_VAR 0 2
8705: PUSH
8706: LD_INT 2
8708: ARRAY
8709: PPUSH
8710: CALL_OW 428
8714: PPUSH
8715: EMPTY
8716: PPUSH
8717: CALL 4124 0 4
8721: ST_TO_ADDR
// for i = 1 to 3 do
8722: LD_ADDR_VAR 0 4
8726: PUSH
8727: DOUBLE
8728: LD_INT 1
8730: DEC
8731: ST_TO_ADDR
8732: LD_INT 3
8734: PUSH
8735: FOR_TO
8736: IFFALSE 8758
// coord_list := Delete ( coord_list , 1 ) ;
8738: LD_ADDR_VAR 0 2
8742: PUSH
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_INT 1
8750: PPUSH
8751: CALL_OW 3
8755: ST_TO_ADDR
8756: GO 8735
8758: POP
8759: POP
// end ;
8760: GO 8603
// result := true ;
8762: LD_ADDR_VAR 0 3
8766: PUSH
8767: LD_INT 1
8769: ST_TO_ADDR
// end ;
8770: LD_VAR 0 3
8774: RET
// export function MCS_Depot ( side , coord_list ) ; begin
8775: LD_INT 0
8777: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
8778: LD_ADDR_EXP 15
8782: PUSH
8783: LD_EXP 15
8787: PPUSH
8788: LD_VAR 0 1
8792: PPUSH
8793: LD_INT 0
8795: PPUSH
8796: LD_VAR 0 2
8800: PPUSH
8801: CALL 4124 0 4
8805: ST_TO_ADDR
// end ;
8806: LD_VAR 0 3
8810: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
8811: LD_INT 0
8813: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
8814: LD_ADDR_EXP 15
8818: PUSH
8819: LD_EXP 15
8823: PPUSH
8824: LD_VAR 0 1
8828: PPUSH
8829: LD_INT 6
8831: PPUSH
8832: LD_VAR 0 2
8836: PPUSH
8837: CALL 4124 0 4
8841: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
8842: LD_ADDR_EXP 18
8846: PUSH
8847: LD_EXP 18
8851: PPUSH
8852: LD_VAR 0 1
8856: PPUSH
8857: LD_VAR 0 3
8861: PUSH
8862: LD_INT 1
8864: ARRAY
8865: PPUSH
8866: LD_VAR 0 3
8870: PUSH
8871: LD_INT 2
8873: ARRAY
8874: PPUSH
8875: CALL 4124 0 4
8879: ST_TO_ADDR
// end ;
8880: LD_VAR 0 4
8884: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
8885: LD_INT 0
8887: PPUSH
8888: PPUSH
// if ext_list > 5 then
8889: LD_VAR 0 3
8893: PUSH
8894: LD_INT 5
8896: GREATER
8897: IFFALSE 8941
// for i = 6 to ext_list do
8899: LD_ADDR_VAR 0 5
8903: PUSH
8904: DOUBLE
8905: LD_INT 6
8907: DEC
8908: ST_TO_ADDR
8909: LD_VAR 0 3
8913: PUSH
8914: FOR_TO
8915: IFFALSE 8939
// ext_list := Delete ( ext_list , ext_list ) ;
8917: LD_ADDR_VAR 0 3
8921: PUSH
8922: LD_VAR 0 3
8926: PPUSH
8927: LD_VAR 0 3
8931: PPUSH
8932: CALL_OW 3
8936: ST_TO_ADDR
8937: GO 8914
8939: POP
8940: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
8941: LD_VAR 0 1
8945: PPUSH
8946: LD_VAR 0 2
8950: PUSH
8951: LD_INT 1
8953: ARRAY
8954: PPUSH
8955: LD_VAR 0 2
8959: PUSH
8960: LD_INT 2
8962: ARRAY
8963: PPUSH
8964: LD_VAR 0 2
8968: PUSH
8969: LD_INT 3
8971: ARRAY
8972: PPUSH
8973: LD_VAR 0 3
8977: PPUSH
8978: CALL 10700 0 5
// end ;
8982: LD_VAR 0 4
8986: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
8987: LD_INT 0
8989: PPUSH
8990: PPUSH
8991: PPUSH
// p := 1 ;
8992: LD_ADDR_VAR 0 6
8996: PUSH
8997: LD_INT 1
8999: ST_TO_ADDR
// if type_list = [ ] then
9000: LD_VAR 0 3
9004: PUSH
9005: EMPTY
9006: EQUAL
9007: IFFALSE 9017
// type_list := b_oil_power ;
9009: LD_ADDR_VAR 0 3
9013: PUSH
9014: LD_INT 26
9016: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
9017: LD_ADDR_VAR 0 5
9021: PUSH
9022: DOUBLE
9023: LD_INT 1
9025: DEC
9026: ST_TO_ADDR
9027: LD_VAR 0 2
9031: PUSH
9032: LD_INT 3
9034: DIVREAL
9035: PUSH
9036: FOR_TO
9037: IFFALSE 9140
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
9039: LD_ADDR_EXP 15
9043: PUSH
9044: LD_EXP 15
9048: PPUSH
9049: LD_VAR 0 1
9053: PPUSH
9054: LD_VAR 0 3
9058: PUSH
9059: LD_INT 1
9061: PPUSH
9062: LD_VAR 0 3
9066: PPUSH
9067: CALL_OW 12
9071: ARRAY
9072: PPUSH
9073: LD_VAR 0 2
9077: PUSH
9078: LD_VAR 0 6
9082: ARRAY
9083: PUSH
9084: LD_VAR 0 2
9088: PUSH
9089: LD_VAR 0 6
9093: PUSH
9094: LD_INT 1
9096: PLUS
9097: ARRAY
9098: PUSH
9099: LD_VAR 0 2
9103: PUSH
9104: LD_VAR 0 6
9108: PUSH
9109: LD_INT 2
9111: PLUS
9112: ARRAY
9113: PUSH
9114: EMPTY
9115: LIST
9116: LIST
9117: LIST
9118: PPUSH
9119: CALL 4124 0 4
9123: ST_TO_ADDR
// p := p + 3 ;
9124: LD_ADDR_VAR 0 6
9128: PUSH
9129: LD_VAR 0 6
9133: PUSH
9134: LD_INT 3
9136: PLUS
9137: ST_TO_ADDR
// end ;
9138: GO 9036
9140: POP
9141: POP
// end ;
9142: LD_VAR 0 4
9146: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
9147: LD_INT 0
9149: PPUSH
9150: PPUSH
9151: PPUSH
9152: PPUSH
// if not MREG_Deposit [ side ] then
9153: LD_EXP 30
9157: PUSH
9158: LD_VAR 0 1
9162: ARRAY
9163: NOT
9164: IFFALSE 9168
// exit ;
9166: GO 9345
// p := 1 ;
9168: LD_ADDR_VAR 0 4
9172: PUSH
9173: LD_INT 1
9175: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
9176: LD_ADDR_VAR 0 3
9180: PUSH
9181: DOUBLE
9182: LD_INT 1
9184: DEC
9185: ST_TO_ADDR
9186: LD_EXP 30
9190: PUSH
9191: LD_VAR 0 1
9195: ARRAY
9196: PUSH
9197: LD_INT 3
9199: DIVREAL
9200: PUSH
9201: FOR_TO
9202: IFFALSE 9343
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
9204: LD_EXP 30
9208: PUSH
9209: LD_VAR 0 1
9213: ARRAY
9214: PUSH
9215: LD_VAR 0 4
9219: PUSH
9220: LD_INT 2
9222: PLUS
9223: ARRAY
9224: PUSH
9225: LD_INT 2
9227: EQUAL
9228: IFFALSE 9240
// b := b_oil_mine else
9230: LD_ADDR_VAR 0 5
9234: PUSH
9235: LD_INT 29
9237: ST_TO_ADDR
9238: GO 9248
// b := b_siberite_mine ;
9240: LD_ADDR_VAR 0 5
9244: PUSH
9245: LD_INT 30
9247: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
9248: LD_ADDR_EXP 15
9252: PUSH
9253: LD_EXP 15
9257: PPUSH
9258: LD_VAR 0 1
9262: PPUSH
9263: LD_VAR 0 5
9267: PPUSH
9268: LD_EXP 30
9272: PUSH
9273: LD_VAR 0 1
9277: ARRAY
9278: PUSH
9279: LD_VAR 0 4
9283: ARRAY
9284: PUSH
9285: LD_EXP 30
9289: PUSH
9290: LD_VAR 0 1
9294: ARRAY
9295: PUSH
9296: LD_VAR 0 4
9300: PUSH
9301: LD_INT 1
9303: PLUS
9304: ARRAY
9305: PUSH
9306: LD_INT 0
9308: PPUSH
9309: LD_INT 5
9311: PPUSH
9312: CALL_OW 12
9316: PUSH
9317: EMPTY
9318: LIST
9319: LIST
9320: LIST
9321: PPUSH
9322: CALL 4124 0 4
9326: ST_TO_ADDR
// p := p + 3 ;
9327: LD_ADDR_VAR 0 4
9331: PUSH
9332: LD_VAR 0 4
9336: PUSH
9337: LD_INT 3
9339: PLUS
9340: ST_TO_ADDR
// end ;
9341: GO 9201
9343: POP
9344: POP
// end ;
9345: LD_VAR 0 2
9349: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
9350: LD_INT 0
9352: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
9353: LD_ADDR_EXP 15
9357: PUSH
9358: LD_EXP 15
9362: PPUSH
9363: LD_VAR 0 1
9367: PPUSH
9368: LD_INT 4
9370: PPUSH
9371: LD_VAR 0 2
9375: PPUSH
9376: CALL 4124 0 4
9380: ST_TO_ADDR
// end ;
9381: LD_VAR 0 3
9385: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
9386: LD_INT 0
9388: PPUSH
// case nation of 1 , us :
9389: LD_VAR 0 2
9393: PUSH
9394: LD_INT 1
9396: DOUBLE
9397: EQUAL
9398: IFTRUE 9408
9400: LD_STRING us
9402: DOUBLE
9403: EQUAL
9404: IFTRUE 9408
9406: GO 9439
9408: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
9409: LD_ADDR_EXP 15
9413: PUSH
9414: LD_EXP 15
9418: PPUSH
9419: LD_VAR 0 1
9423: PPUSH
9424: LD_INT 36
9426: PPUSH
9427: LD_VAR 0 3
9431: PPUSH
9432: CALL 4124 0 4
9436: ST_TO_ADDR
9437: GO 9490
9439: LD_INT 2
9441: DOUBLE
9442: EQUAL
9443: IFTRUE 9453
9445: LD_STRING ar
9447: DOUBLE
9448: EQUAL
9449: IFTRUE 9453
9451: GO 9489
9453: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
9454: LD_ADDR_EXP 15
9458: PUSH
9459: LD_VAR 0 1
9463: PPUSH
9464: LD_INT 14
9466: PUSH
9467: LD_INT 2
9469: PUSH
9470: LD_INT 1
9472: PUSH
9473: LD_INT 31
9475: PUSH
9476: EMPTY
9477: LIST
9478: LIST
9479: LIST
9480: LIST
9481: PPUSH
9482: CALL 9495 0 2
9486: ST_TO_ADDR
9487: GO 9490
9489: POP
// end ;
9490: LD_VAR 0 4
9494: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
9495: LD_INT 0
9497: PPUSH
9498: PPUSH
// for i = 1 to list do
9499: LD_ADDR_VAR 0 4
9503: PUSH
9504: DOUBLE
9505: LD_INT 1
9507: DEC
9508: ST_TO_ADDR
9509: LD_VAR 0 2
9513: PUSH
9514: FOR_TO
9515: IFFALSE 9565
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
9517: LD_ADDR_EXP 20
9521: PUSH
9522: LD_EXP 20
9526: PPUSH
9527: LD_VAR 0 1
9531: PPUSH
9532: LD_EXP 20
9536: PUSH
9537: LD_VAR 0 1
9541: ARRAY
9542: PUSH
9543: LD_INT 1
9545: PLUS
9546: PPUSH
9547: LD_VAR 0 2
9551: PUSH
9552: LD_VAR 0 4
9556: ARRAY
9557: PPUSH
9558: CALL 24454 0 4
9562: ST_TO_ADDR
9563: GO 9514
9565: POP
9566: POP
// end ;
9567: LD_VAR 0 3
9571: RET
// export function MCS_GetVehicleList ( side ) ; begin
9572: LD_INT 0
9574: PPUSH
// result := MREG_ToConstruct [ side ] ;
9575: LD_ADDR_VAR 0 2
9579: PUSH
9580: LD_EXP 20
9584: PUSH
9585: LD_VAR 0 1
9589: ARRAY
9590: ST_TO_ADDR
// end ;
9591: LD_VAR 0 2
9595: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
9596: LD_INT 0
9598: PPUSH
9599: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
9600: LD_ADDR_EXP 27
9604: PUSH
9605: LD_EXP 27
9609: PPUSH
9610: LD_VAR 0 1
9614: PPUSH
9615: LD_VAR 0 2
9619: PPUSH
9620: CALL_OW 1
9624: ST_TO_ADDR
// end ;
9625: LD_VAR 0 3
9629: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
9630: LD_INT 0
9632: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
9633: LD_ADDR_EXP 5
9637: PUSH
9638: LD_EXP 5
9642: PPUSH
9643: LD_VAR 0 1
9647: PPUSH
9648: LD_VAR 0 2
9652: PPUSH
9653: CALL_OW 1
9657: ST_TO_ADDR
// end ;
9658: LD_VAR 0 3
9662: RET
// export function MCS_ApeOptions ( side , options ) ; begin
9663: LD_INT 0
9665: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
9666: LD_ADDR_EXP 6
9670: PUSH
9671: LD_EXP 6
9675: PPUSH
9676: LD_VAR 0 1
9680: PPUSH
9681: LD_VAR 0 2
9685: PPUSH
9686: CALL_OW 1
9690: ST_TO_ADDR
// end ;
9691: LD_VAR 0 3
9695: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
9696: LD_INT 0
9698: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
9699: LD_ADDR_EXP 29
9703: PUSH
9704: LD_EXP 29
9708: PPUSH
9709: LD_VAR 0 1
9713: PPUSH
9714: LD_INT 1
9716: PPUSH
9717: LD_VAR 0 2
9721: PPUSH
9722: CALL 24454 0 4
9726: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
9727: LD_ADDR_EXP 29
9731: PUSH
9732: LD_EXP 29
9736: PPUSH
9737: LD_VAR 0 1
9741: PPUSH
9742: LD_INT 2
9744: PPUSH
9745: LD_VAR 0 3
9749: PPUSH
9750: CALL 24454 0 4
9754: ST_TO_ADDR
// end ;
9755: LD_VAR 0 4
9759: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
9760: LD_INT 0
9762: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
9763: LD_ADDR_EXP 31
9767: PUSH
9768: LD_EXP 31
9772: PPUSH
9773: LD_INT 1
9775: PPUSH
9776: LD_VAR 0 1
9780: PPUSH
9781: CALL_OW 1
9785: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
9786: LD_ADDR_EXP 31
9790: PUSH
9791: LD_EXP 31
9795: PPUSH
9796: LD_INT 2
9798: PPUSH
9799: LD_VAR 0 2
9803: PPUSH
9804: CALL_OW 1
9808: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
9809: LD_ADDR_EXP 31
9813: PUSH
9814: LD_EXP 31
9818: PPUSH
9819: LD_INT 3
9821: PPUSH
9822: LD_VAR 0 3
9826: PPUSH
9827: CALL_OW 1
9831: ST_TO_ADDR
// end ;
9832: LD_VAR 0 4
9836: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
9837: LD_INT 0
9839: PPUSH
9840: PPUSH
9841: PPUSH
// if not side or not list then
9842: LD_VAR 0 1
9846: NOT
9847: PUSH
9848: LD_VAR 0 2
9852: NOT
9853: OR
9854: IFFALSE 9858
// exit ;
9856: GO 10024
// SetTech ( 20 , side , state_researched ) ;
9858: LD_INT 20
9860: PPUSH
9861: LD_VAR 0 1
9865: PPUSH
9866: LD_INT 2
9868: PPUSH
9869: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
9873: LD_ADDR_EXP 30
9877: PUSH
9878: LD_EXP 30
9882: PPUSH
9883: LD_VAR 0 1
9887: PPUSH
9888: LD_VAR 0 2
9892: PPUSH
9893: CALL_OW 2
9897: ST_TO_ADDR
// p := 1 ;
9898: LD_ADDR_VAR 0 5
9902: PUSH
9903: LD_INT 1
9905: ST_TO_ADDR
// for i = 1 to list / 3 do
9906: LD_ADDR_VAR 0 4
9910: PUSH
9911: DOUBLE
9912: LD_INT 1
9914: DEC
9915: ST_TO_ADDR
9916: LD_VAR 0 2
9920: PUSH
9921: LD_INT 3
9923: DIVREAL
9924: PUSH
9925: FOR_TO
9926: IFFALSE 10022
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
9928: LD_VAR 0 2
9932: PUSH
9933: LD_VAR 0 5
9937: ARRAY
9938: PPUSH
9939: LD_VAR 0 2
9943: PUSH
9944: LD_VAR 0 5
9948: PUSH
9949: LD_INT 1
9951: PLUS
9952: ARRAY
9953: PPUSH
9954: LD_VAR 0 2
9958: PUSH
9959: LD_VAR 0 5
9963: PUSH
9964: LD_INT 2
9966: PLUS
9967: ARRAY
9968: PPUSH
9969: CALL 5483 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , true ) ;
9973: LD_VAR 0 2
9977: PUSH
9978: LD_VAR 0 5
9982: ARRAY
9983: PPUSH
9984: LD_VAR 0 2
9988: PUSH
9989: LD_VAR 0 5
9993: PUSH
9994: LD_INT 1
9996: PLUS
9997: ARRAY
9998: PPUSH
9999: LD_INT 1
10001: PPUSH
10002: CALL_OW 441
// p := p + 3 ;
10006: LD_ADDR_VAR 0 5
10010: PUSH
10011: LD_VAR 0 5
10015: PUSH
10016: LD_INT 3
10018: PLUS
10019: ST_TO_ADDR
// end ;
10020: GO 9925
10022: POP
10023: POP
// end ;
10024: LD_VAR 0 3
10028: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
10029: LD_INT 0
10031: PPUSH
10032: PPUSH
// if nat = nation_arabian then
10033: LD_VAR 0 2
10037: PUSH
10038: LD_INT 2
10040: EQUAL
10041: IFFALSE 10047
// exit else
10043: GO 10119
10045: GO 10105
// if nat = nation_american then
10047: LD_VAR 0 2
10051: PUSH
10052: LD_INT 1
10054: EQUAL
10055: IFFALSE 10082
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
10057: LD_ADDR_VAR 0 4
10061: PUSH
10062: LD_INT 4
10064: PUSH
10065: LD_INT 3
10067: PUSH
10068: LD_INT 1
10070: PUSH
10071: LD_INT 8
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: ST_TO_ADDR
10080: GO 10105
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
10082: LD_ADDR_VAR 0 4
10086: PUSH
10087: LD_INT 24
10089: PUSH
10090: LD_INT 3
10092: PUSH
10093: LD_INT 1
10095: PUSH
10096: LD_INT 48
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
10105: LD_VAR 0 1
10109: PPUSH
10110: LD_VAR 0 4
10114: PPUSH
10115: CALL 9495 0 2
// end ; end_of_file
10119: LD_VAR 0 3
10123: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
10124: LD_INT 0
10126: PPUSH
10127: PPUSH
10128: PPUSH
10129: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10130: LD_ADDR_VAR 0 8
10134: PUSH
10135: LD_VAR 0 1
10139: PPUSH
10140: LD_INT 2
10142: PPUSH
10143: EMPTY
10144: PPUSH
10145: CALL 83 0 3
10149: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
10150: LD_VAR 0 8
10154: PUSH
10155: LD_VAR 0 2
10159: PPUSH
10160: LD_VAR 0 3
10164: PPUSH
10165: CALL_OW 428
10169: PUSH
10170: LD_INT 0
10172: EQUAL
10173: AND
10174: IFFALSE 10248
// for i = 1 to plist do
10176: LD_ADDR_VAR 0 6
10180: PUSH
10181: DOUBLE
10182: LD_INT 1
10184: DEC
10185: ST_TO_ADDR
10186: LD_VAR 0 8
10190: PUSH
10191: FOR_TO
10192: IFFALSE 10246
// if NotTask ( plist [ i ] ) then
10194: LD_VAR 0 8
10198: PUSH
10199: LD_VAR 0 6
10203: ARRAY
10204: PPUSH
10205: CALL 25710 0 1
10209: IFFALSE 10244
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
10211: LD_VAR 0 8
10215: PUSH
10216: LD_VAR 0 6
10220: ARRAY
10221: PPUSH
10222: LD_INT 0
10224: PPUSH
10225: LD_VAR 0 2
10229: PPUSH
10230: LD_VAR 0 3
10234: PPUSH
10235: LD_VAR 0 4
10239: PPUSH
10240: CALL_OW 145
// end ;
10244: GO 10191
10246: POP
10247: POP
// end ;
10248: LD_VAR 0 5
10252: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
10253: LD_INT 0
10255: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
10256: LD_VAR 0 1
10260: PPUSH
10261: LD_INT 6
10263: PPUSH
10264: LD_VAR 0 2
10268: PPUSH
10269: LD_VAR 0 3
10273: PPUSH
10274: LD_VAR 0 4
10278: PPUSH
10279: CALL 11757 0 5
// end ;
10283: LD_VAR 0 5
10287: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
10288: LD_INT 0
10290: PPUSH
10291: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
10292: LD_ADDR_VAR 0 4
10296: PUSH
10297: LD_INT 22
10299: PUSH
10300: LD_VAR 0 1
10304: PUSH
10305: EMPTY
10306: LIST
10307: LIST
10308: PUSH
10309: LD_INT 2
10311: PUSH
10312: LD_INT 30
10314: PUSH
10315: LD_INT 0
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: PUSH
10322: LD_INT 30
10324: PUSH
10325: LD_INT 1
10327: PUSH
10328: EMPTY
10329: LIST
10330: LIST
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: PUSH
10341: EMPTY
10342: LIST
10343: PPUSH
10344: CALL_OW 69
10348: PPUSH
10349: LD_VAR 0 2
10353: PPUSH
10354: CALL_OW 250
10358: PPUSH
10359: LD_VAR 0 2
10363: PPUSH
10364: CALL_OW 251
10368: PPUSH
10369: CALL_OW 73
10373: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
10374: LD_VAR 0 4
10378: PPUSH
10379: LD_VAR 0 2
10383: PPUSH
10384: CALL 12046 0 2
10388: IFFALSE 10447
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
10390: LD_VAR 0 1
10394: PPUSH
10395: LD_INT 30
10397: PUSH
10398: LD_VAR 0 2
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: PPUSH
10407: CALL 0 0 2
10411: PUSH
10412: LD_INT 1
10414: ARRAY
10415: PPUSH
10416: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
10420: LD_ADDR_EXP 17
10424: PUSH
10425: LD_EXP 17
10429: PPUSH
10430: LD_VAR 0 1
10434: PPUSH
10435: LD_VAR 0 2
10439: PPUSH
10440: EMPTY
10441: PPUSH
10442: CALL 4215 0 4
10446: ST_TO_ADDR
// end ; end ;
10447: LD_VAR 0 3
10451: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
10452: LD_INT 0
10454: PPUSH
10455: PPUSH
10456: PPUSH
10457: PPUSH
10458: PPUSH
10459: PPUSH
// result := false ;
10460: LD_ADDR_VAR 0 4
10464: PUSH
10465: LD_INT 0
10467: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
10468: LD_VAR 0 1
10472: PPUSH
10473: LD_EXP 8
10477: PPUSH
10478: CALL 5218 0 2
10482: IFFALSE 10695
// for i = 1 to MREG_LabList do
10484: LD_ADDR_VAR 0 5
10488: PUSH
10489: DOUBLE
10490: LD_INT 1
10492: DEC
10493: ST_TO_ADDR
10494: LD_EXP 8
10498: PUSH
10499: FOR_TO
10500: IFFALSE 10693
// begin if MREG_LabList [ i ] [ 1 ] = side then
10502: LD_EXP 8
10506: PUSH
10507: LD_VAR 0 5
10511: ARRAY
10512: PUSH
10513: LD_INT 1
10515: ARRAY
10516: PUSH
10517: LD_VAR 0 1
10521: EQUAL
10522: IFFALSE 10691
// begin lab := MREG_LabList [ i ] [ 2 ] ;
10524: LD_ADDR_VAR 0 7
10528: PUSH
10529: LD_EXP 8
10533: PUSH
10534: LD_VAR 0 5
10538: ARRAY
10539: PUSH
10540: LD_INT 2
10542: ARRAY
10543: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
10544: LD_ADDR_VAR 0 9
10548: PUSH
10549: LD_INT 22
10551: PUSH
10552: LD_VAR 0 1
10556: PUSH
10557: EMPTY
10558: LIST
10559: LIST
10560: PUSH
10561: LD_INT 2
10563: PUSH
10564: LD_INT 30
10566: PUSH
10567: LD_INT 0
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: PUSH
10574: LD_INT 30
10576: PUSH
10577: LD_INT 1
10579: PUSH
10580: EMPTY
10581: LIST
10582: LIST
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: LIST
10588: PUSH
10589: EMPTY
10590: LIST
10591: LIST
10592: PUSH
10593: EMPTY
10594: LIST
10595: PPUSH
10596: CALL_OW 69
10600: PPUSH
10601: LD_VAR 0 7
10605: PPUSH
10606: CALL_OW 250
10610: PPUSH
10611: LD_VAR 0 7
10615: PPUSH
10616: CALL_OW 251
10620: PPUSH
10621: CALL_OW 73
10625: ST_TO_ADDR
// if dep then
10626: LD_VAR 0 9
10630: IFFALSE 10689
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
10632: LD_VAR 0 9
10636: PPUSH
10637: LD_VAR 0 2
10641: PPUSH
10642: LD_VAR 0 3
10646: PPUSH
10647: CALL 12162 0 3
10651: IFFALSE 10689
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
10653: LD_VAR 0 7
10657: PPUSH
10658: LD_VAR 0 2
10662: PPUSH
10663: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
10667: LD_VAR 0 7
10671: PPUSH
10672: LD_VAR 0 3
10676: PPUSH
10677: CALL_OW 207
// result := true ;
10681: LD_ADDR_VAR 0 4
10685: PUSH
10686: LD_INT 1
10688: ST_TO_ADDR
// end ; end ; break ;
10689: GO 10693
// end ; end ;
10691: GO 10499
10693: POP
10694: POP
// end ;
10695: LD_VAR 0 4
10699: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
10700: LD_INT 0
10702: PPUSH
10703: PPUSH
10704: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
10705: LD_ADDR_VAR 0 7
10709: PUSH
10710: LD_VAR 0 2
10714: PPUSH
10715: LD_VAR 0 3
10719: PPUSH
10720: LD_VAR 0 4
10724: PPUSH
10725: CALL 10887 0 3
10729: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
10730: LD_ADDR_EXP 15
10734: PUSH
10735: LD_EXP 15
10739: PPUSH
10740: LD_VAR 0 1
10744: PPUSH
10745: LD_INT 2
10747: PPUSH
10748: LD_VAR 0 2
10752: PUSH
10753: LD_VAR 0 3
10757: PUSH
10758: LD_VAR 0 4
10762: PUSH
10763: EMPTY
10764: LIST
10765: LIST
10766: LIST
10767: PPUSH
10768: CALL 4124 0 4
10772: ST_TO_ADDR
// if ext_list then
10773: LD_VAR 0 5
10777: IFFALSE 10882
// for i = 1 to ext_list do
10779: LD_ADDR_VAR 0 8
10783: PUSH
10784: DOUBLE
10785: LD_INT 1
10787: DEC
10788: ST_TO_ADDR
10789: LD_VAR 0 5
10793: PUSH
10794: FOR_TO
10795: IFFALSE 10880
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
10797: LD_ADDR_EXP 15
10801: PUSH
10802: LD_EXP 15
10806: PPUSH
10807: LD_VAR 0 1
10811: PPUSH
10812: LD_VAR 0 5
10816: PUSH
10817: LD_VAR 0 8
10821: ARRAY
10822: PPUSH
10823: LD_VAR 0 7
10827: PUSH
10828: LD_VAR 0 8
10832: ARRAY
10833: PUSH
10834: LD_INT 1
10836: ARRAY
10837: PUSH
10838: LD_VAR 0 7
10842: PUSH
10843: LD_VAR 0 8
10847: ARRAY
10848: PUSH
10849: LD_INT 2
10851: ARRAY
10852: PUSH
10853: LD_VAR 0 7
10857: PUSH
10858: LD_VAR 0 8
10862: ARRAY
10863: PUSH
10864: LD_INT 3
10866: ARRAY
10867: PUSH
10868: EMPTY
10869: LIST
10870: LIST
10871: LIST
10872: PPUSH
10873: CALL 4124 0 4
10877: ST_TO_ADDR
10878: GO 10794
10880: POP
10881: POP
// end ;
10882: LD_VAR 0 6
10886: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
10887: LD_INT 0
10889: PPUSH
10890: PPUSH
// list := [ ] ;
10891: LD_ADDR_VAR 0 5
10895: PUSH
10896: EMPTY
10897: ST_TO_ADDR
// case d of 0 :
10898: LD_VAR 0 3
10902: PUSH
10903: LD_INT 0
10905: DOUBLE
10906: EQUAL
10907: IFTRUE 10911
10909: GO 11044
10911: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
10912: LD_ADDR_VAR 0 5
10916: PUSH
10917: LD_VAR 0 1
10921: PUSH
10922: LD_INT 4
10924: MINUS
10925: PUSH
10926: LD_VAR 0 2
10930: PUSH
10931: LD_INT 4
10933: MINUS
10934: PUSH
10935: LD_INT 2
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: LIST
10942: PUSH
10943: LD_VAR 0 1
10947: PUSH
10948: LD_INT 3
10950: MINUS
10951: PUSH
10952: LD_VAR 0 2
10956: PUSH
10957: LD_INT 1
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: LIST
10964: PUSH
10965: LD_VAR 0 1
10969: PUSH
10970: LD_INT 4
10972: PLUS
10973: PUSH
10974: LD_VAR 0 2
10978: PUSH
10979: LD_INT 4
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: LIST
10986: PUSH
10987: LD_VAR 0 1
10991: PUSH
10992: LD_INT 3
10994: PLUS
10995: PUSH
10996: LD_VAR 0 2
11000: PUSH
11001: LD_INT 3
11003: PLUS
11004: PUSH
11005: LD_INT 5
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: LIST
11012: PUSH
11013: LD_VAR 0 1
11017: PUSH
11018: LD_VAR 0 2
11022: PUSH
11023: LD_INT 4
11025: PLUS
11026: PUSH
11027: LD_INT 0
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: PUSH
11035: EMPTY
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: ST_TO_ADDR
// end ; 1 :
11042: GO 11742
11044: LD_INT 1
11046: DOUBLE
11047: EQUAL
11048: IFTRUE 11052
11050: GO 11185
11052: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 3 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
11053: LD_ADDR_VAR 0 5
11057: PUSH
11058: LD_VAR 0 1
11062: PUSH
11063: LD_VAR 0 2
11067: PUSH
11068: LD_INT 4
11070: MINUS
11071: PUSH
11072: LD_INT 3
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: LIST
11079: PUSH
11080: LD_VAR 0 1
11084: PUSH
11085: LD_INT 3
11087: MINUS
11088: PUSH
11089: LD_VAR 0 2
11093: PUSH
11094: LD_INT 3
11096: MINUS
11097: PUSH
11098: LD_INT 2
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: LIST
11105: PUSH
11106: LD_VAR 0 1
11110: PUSH
11111: LD_INT 3
11113: MINUS
11114: PUSH
11115: LD_VAR 0 2
11119: PUSH
11120: LD_INT 1
11122: PUSH
11123: EMPTY
11124: LIST
11125: LIST
11126: LIST
11127: PUSH
11128: LD_VAR 0 1
11132: PUSH
11133: LD_VAR 0 2
11137: PUSH
11138: LD_INT 3
11140: PLUS
11141: PUSH
11142: LD_INT 0
11144: PUSH
11145: EMPTY
11146: LIST
11147: LIST
11148: LIST
11149: PUSH
11150: LD_VAR 0 1
11154: PUSH
11155: LD_INT 4
11157: PLUS
11158: PUSH
11159: LD_VAR 0 2
11163: PUSH
11164: LD_INT 4
11166: PLUS
11167: PUSH
11168: LD_INT 5
11170: PUSH
11171: EMPTY
11172: LIST
11173: LIST
11174: LIST
11175: PUSH
11176: EMPTY
11177: LIST
11178: LIST
11179: LIST
11180: LIST
11181: LIST
11182: ST_TO_ADDR
// end ; 2 :
11183: GO 11742
11185: LD_INT 2
11187: DOUBLE
11188: EQUAL
11189: IFTRUE 11193
11191: GO 11322
11193: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 3 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
11194: LD_ADDR_VAR 0 5
11198: PUSH
11199: LD_VAR 0 1
11203: PUSH
11204: LD_VAR 0 2
11208: PUSH
11209: LD_INT 3
11211: MINUS
11212: PUSH
11213: LD_INT 3
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: LIST
11220: PUSH
11221: LD_VAR 0 1
11225: PUSH
11226: LD_INT 3
11228: PLUS
11229: PUSH
11230: LD_VAR 0 2
11234: PUSH
11235: LD_INT 4
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: LIST
11242: PUSH
11243: LD_VAR 0 1
11247: PUSH
11248: LD_VAR 0 2
11252: PUSH
11253: LD_INT 4
11255: PLUS
11256: PUSH
11257: LD_INT 0
11259: PUSH
11260: EMPTY
11261: LIST
11262: LIST
11263: LIST
11264: PUSH
11265: LD_VAR 0 1
11269: PUSH
11270: LD_INT 3
11272: MINUS
11273: PUSH
11274: LD_VAR 0 2
11278: PUSH
11279: LD_INT 1
11281: PUSH
11282: EMPTY
11283: LIST
11284: LIST
11285: LIST
11286: PUSH
11287: LD_VAR 0 1
11291: PUSH
11292: LD_INT 4
11294: MINUS
11295: PUSH
11296: LD_VAR 0 2
11300: PUSH
11301: LD_INT 4
11303: MINUS
11304: PUSH
11305: LD_INT 2
11307: PUSH
11308: EMPTY
11309: LIST
11310: LIST
11311: LIST
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: ST_TO_ADDR
// end ; 3 :
11320: GO 11742
11322: LD_INT 3
11324: DOUBLE
11325: EQUAL
11326: IFTRUE 11330
11328: GO 11463
11330: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
11331: LD_ADDR_VAR 0 5
11335: PUSH
11336: LD_VAR 0 1
11340: PUSH
11341: LD_INT 3
11343: PLUS
11344: PUSH
11345: LD_VAR 0 2
11349: PUSH
11350: LD_INT 4
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: LIST
11357: PUSH
11358: LD_VAR 0 1
11362: PUSH
11363: LD_INT 4
11365: PLUS
11366: PUSH
11367: LD_VAR 0 2
11371: PUSH
11372: LD_INT 4
11374: PLUS
11375: PUSH
11376: LD_INT 5
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: LIST
11383: PUSH
11384: LD_VAR 0 1
11388: PUSH
11389: LD_INT 4
11391: MINUS
11392: PUSH
11393: LD_VAR 0 2
11397: PUSH
11398: LD_INT 1
11400: PUSH
11401: EMPTY
11402: LIST
11403: LIST
11404: LIST
11405: PUSH
11406: LD_VAR 0 1
11410: PUSH
11411: LD_VAR 0 2
11415: PUSH
11416: LD_INT 4
11418: MINUS
11419: PUSH
11420: LD_INT 3
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: LIST
11427: PUSH
11428: LD_VAR 0 1
11432: PUSH
11433: LD_INT 3
11435: MINUS
11436: PUSH
11437: LD_VAR 0 2
11441: PUSH
11442: LD_INT 3
11444: MINUS
11445: PUSH
11446: LD_INT 2
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: LIST
11453: PUSH
11454: EMPTY
11455: LIST
11456: LIST
11457: LIST
11458: LIST
11459: LIST
11460: ST_TO_ADDR
// end ; 4 :
11461: GO 11742
11463: LD_INT 4
11465: DOUBLE
11466: EQUAL
11467: IFTRUE 11471
11469: GO 11604
11471: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
11472: LD_ADDR_VAR 0 5
11476: PUSH
11477: LD_VAR 0 1
11481: PUSH
11482: LD_VAR 0 2
11486: PUSH
11487: LD_INT 4
11489: PLUS
11490: PUSH
11491: LD_INT 0
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: PUSH
11499: LD_VAR 0 1
11503: PUSH
11504: LD_INT 3
11506: PLUS
11507: PUSH
11508: LD_VAR 0 2
11512: PUSH
11513: LD_INT 3
11515: PLUS
11516: PUSH
11517: LD_INT 5
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: LIST
11524: PUSH
11525: LD_VAR 0 1
11529: PUSH
11530: LD_INT 3
11532: PLUS
11533: PUSH
11534: LD_VAR 0 2
11538: PUSH
11539: LD_INT 4
11541: PUSH
11542: EMPTY
11543: LIST
11544: LIST
11545: LIST
11546: PUSH
11547: LD_VAR 0 1
11551: PUSH
11552: LD_VAR 0 2
11556: PUSH
11557: LD_INT 3
11559: MINUS
11560: PUSH
11561: LD_INT 3
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: LIST
11568: PUSH
11569: LD_VAR 0 1
11573: PUSH
11574: LD_INT 4
11576: MINUS
11577: PUSH
11578: LD_VAR 0 2
11582: PUSH
11583: LD_INT 4
11585: MINUS
11586: PUSH
11587: LD_INT 2
11589: PUSH
11590: EMPTY
11591: LIST
11592: LIST
11593: LIST
11594: PUSH
11595: EMPTY
11596: LIST
11597: LIST
11598: LIST
11599: LIST
11600: LIST
11601: ST_TO_ADDR
// end ; 5 :
11602: GO 11742
11604: LD_INT 5
11606: DOUBLE
11607: EQUAL
11608: IFTRUE 11612
11610: GO 11741
11612: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
11613: LD_ADDR_VAR 0 5
11617: PUSH
11618: LD_VAR 0 1
11622: PUSH
11623: LD_INT 4
11625: MINUS
11626: PUSH
11627: LD_VAR 0 2
11631: PUSH
11632: LD_INT 1
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: LIST
11639: PUSH
11640: LD_VAR 0 1
11644: PUSH
11645: LD_VAR 0 2
11649: PUSH
11650: LD_INT 4
11652: MINUS
11653: PUSH
11654: LD_INT 3
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: LIST
11661: PUSH
11662: LD_VAR 0 1
11666: PUSH
11667: LD_INT 4
11669: PLUS
11670: PUSH
11671: LD_VAR 0 2
11675: PUSH
11676: LD_INT 4
11678: PLUS
11679: PUSH
11680: LD_INT 5
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: LIST
11687: PUSH
11688: LD_VAR 0 1
11692: PUSH
11693: LD_INT 3
11695: PLUS
11696: PUSH
11697: LD_VAR 0 2
11701: PUSH
11702: LD_INT 4
11704: PUSH
11705: EMPTY
11706: LIST
11707: LIST
11708: LIST
11709: PUSH
11710: LD_VAR 0 1
11714: PUSH
11715: LD_VAR 0 2
11719: PUSH
11720: LD_INT 3
11722: PLUS
11723: PUSH
11724: LD_INT 0
11726: PUSH
11727: EMPTY
11728: LIST
11729: LIST
11730: LIST
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: ST_TO_ADDR
// end ; end ;
11739: GO 11742
11741: POP
// result := list ;
11742: LD_ADDR_VAR 0 4
11746: PUSH
11747: LD_VAR 0 5
11751: ST_TO_ADDR
// end ;
11752: LD_VAR 0 4
11756: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
11757: LD_INT 0
11759: PPUSH
11760: PPUSH
11761: PPUSH
11762: PPUSH
11763: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11764: LD_ADDR_VAR 0 10
11768: PUSH
11769: LD_VAR 0 1
11773: PPUSH
11774: LD_INT 2
11776: PPUSH
11777: EMPTY
11778: PPUSH
11779: CALL 83 0 3
11783: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
11784: LD_ADDR_VAR 0 9
11788: PUSH
11789: LD_INT 22
11791: PUSH
11792: LD_VAR 0 1
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: PUSH
11801: LD_INT 2
11803: PUSH
11804: LD_INT 30
11806: PUSH
11807: LD_INT 0
11809: PUSH
11810: EMPTY
11811: LIST
11812: LIST
11813: PUSH
11814: LD_INT 30
11816: PUSH
11817: LD_INT 1
11819: PUSH
11820: EMPTY
11821: LIST
11822: LIST
11823: PUSH
11824: EMPTY
11825: LIST
11826: LIST
11827: LIST
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: PUSH
11833: EMPTY
11834: LIST
11835: PPUSH
11836: CALL_OW 69
11840: PPUSH
11841: LD_VAR 0 3
11845: PPUSH
11846: LD_VAR 0 4
11850: PPUSH
11851: CALL_OW 73
11855: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
11856: LD_ADDR_VAR 0 8
11860: PUSH
11861: LD_VAR 0 9
11865: PPUSH
11866: LD_VAR 0 2
11870: PPUSH
11871: CALL 12046 0 2
11875: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
11876: LD_VAR 0 10
11880: PUSH
11881: LD_VAR 0 8
11885: AND
11886: PUSH
11887: LD_VAR 0 9
11891: PPUSH
11892: LD_VAR 0 3
11896: PPUSH
11897: LD_VAR 0 4
11901: PPUSH
11902: CALL_OW 297
11906: PUSH
11907: LD_INT 26
11909: LESSEQUAL
11910: AND
11911: PUSH
11912: LD_VAR 0 3
11916: PPUSH
11917: LD_VAR 0 4
11921: PPUSH
11922: CALL_OW 428
11926: PUSH
11927: LD_INT 0
11929: EQUAL
11930: AND
11931: IFFALSE 12041
// for i = 1 to plist do
11933: LD_ADDR_VAR 0 7
11937: PUSH
11938: DOUBLE
11939: LD_INT 1
11941: DEC
11942: ST_TO_ADDR
11943: LD_VAR 0 10
11947: PUSH
11948: FOR_TO
11949: IFFALSE 12039
// if IsInUnit ( plist [ i ] ) then
11951: LD_VAR 0 10
11955: PUSH
11956: LD_VAR 0 7
11960: ARRAY
11961: PPUSH
11962: CALL_OW 310
11966: IFFALSE 11985
// ComExitBuilding ( plist [ i ] ) else
11968: LD_VAR 0 10
11972: PUSH
11973: LD_VAR 0 7
11977: ARRAY
11978: PPUSH
11979: CALL_OW 122
11983: GO 12037
// if NotTask ( plist [ i ] ) then
11985: LD_VAR 0 10
11989: PUSH
11990: LD_VAR 0 7
11994: ARRAY
11995: PPUSH
11996: CALL 25710 0 1
12000: IFFALSE 12037
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
12002: LD_VAR 0 10
12006: PUSH
12007: LD_VAR 0 7
12011: ARRAY
12012: PPUSH
12013: LD_VAR 0 2
12017: PPUSH
12018: LD_VAR 0 3
12022: PPUSH
12023: LD_VAR 0 4
12027: PPUSH
12028: LD_VAR 0 5
12032: PPUSH
12033: CALL_OW 145
// end ;
12037: GO 11948
12039: POP
12040: POP
// end ;
12041: LD_VAR 0 6
12045: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
12046: LD_INT 0
12048: PPUSH
12049: PPUSH
12050: PPUSH
// pom := GetBase ( bdepot ) ;
12051: LD_ADDR_VAR 0 4
12055: PUSH
12056: LD_VAR 0 1
12060: PPUSH
12061: CALL_OW 274
12065: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
12066: LD_ADDR_VAR 0 5
12070: PUSH
12071: LD_VAR 0 2
12075: PPUSH
12076: LD_VAR 0 1
12080: PPUSH
12081: CALL_OW 248
12085: PPUSH
12086: CALL_OW 450
12090: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
12091: LD_VAR 0 4
12095: PPUSH
12096: LD_INT 1
12098: PPUSH
12099: CALL_OW 275
12103: PUSH
12104: LD_VAR 0 5
12108: PUSH
12109: LD_INT 1
12111: ARRAY
12112: GREATEREQUAL
12113: PUSH
12114: LD_VAR 0 4
12118: PPUSH
12119: LD_INT 3
12121: PPUSH
12122: CALL_OW 275
12126: PUSH
12127: LD_VAR 0 5
12131: PUSH
12132: LD_INT 3
12134: ARRAY
12135: GREATEREQUAL
12136: AND
12137: IFFALSE 12149
// result := true else
12139: LD_ADDR_VAR 0 3
12143: PUSH
12144: LD_INT 1
12146: ST_TO_ADDR
12147: GO 12157
// result := false ;
12149: LD_ADDR_VAR 0 3
12153: PUSH
12154: LD_INT 0
12156: ST_TO_ADDR
// end ;
12157: LD_VAR 0 3
12161: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
12162: LD_INT 0
12164: PPUSH
12165: PPUSH
12166: PPUSH
12167: PPUSH
12168: PPUSH
// pom := GetBase ( bdepot ) ;
12169: LD_ADDR_VAR 0 5
12173: PUSH
12174: LD_VAR 0 1
12178: PPUSH
12179: CALL_OW 274
12183: ST_TO_ADDR
// cost := [ ] ;
12184: LD_ADDR_VAR 0 8
12188: PUSH
12189: EMPTY
12190: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
12191: LD_ADDR_VAR 0 6
12195: PUSH
12196: LD_VAR 0 2
12200: PPUSH
12201: LD_VAR 0 1
12205: PPUSH
12206: CALL_OW 248
12210: PPUSH
12211: CALL_OW 450
12215: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
12216: LD_ADDR_VAR 0 7
12220: PUSH
12221: LD_VAR 0 3
12225: PPUSH
12226: LD_VAR 0 1
12230: PPUSH
12231: CALL_OW 248
12235: PPUSH
12236: CALL_OW 450
12240: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
12241: LD_ADDR_VAR 0 8
12245: PUSH
12246: LD_VAR 0 8
12250: PPUSH
12251: LD_INT 1
12253: PPUSH
12254: LD_VAR 0 6
12258: PUSH
12259: LD_INT 1
12261: ARRAY
12262: PUSH
12263: LD_VAR 0 7
12267: PUSH
12268: LD_INT 1
12270: ARRAY
12271: PLUS
12272: PPUSH
12273: CALL_OW 1
12277: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
12278: LD_ADDR_VAR 0 8
12282: PUSH
12283: LD_VAR 0 8
12287: PPUSH
12288: LD_INT 2
12290: PPUSH
12291: LD_VAR 0 6
12295: PUSH
12296: LD_INT 2
12298: ARRAY
12299: PUSH
12300: LD_VAR 0 7
12304: PUSH
12305: LD_INT 2
12307: ARRAY
12308: PLUS
12309: PPUSH
12310: CALL_OW 1
12314: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
12315: LD_ADDR_VAR 0 8
12319: PUSH
12320: LD_VAR 0 8
12324: PPUSH
12325: LD_INT 3
12327: PPUSH
12328: LD_VAR 0 6
12332: PUSH
12333: LD_INT 3
12335: ARRAY
12336: PUSH
12337: LD_VAR 0 7
12341: PUSH
12342: LD_INT 3
12344: ARRAY
12345: PLUS
12346: PPUSH
12347: CALL_OW 1
12351: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
12352: LD_VAR 0 5
12356: PPUSH
12357: LD_INT 1
12359: PPUSH
12360: CALL_OW 275
12364: PUSH
12365: LD_VAR 0 8
12369: PUSH
12370: LD_INT 1
12372: ARRAY
12373: GREATEREQUAL
12374: PUSH
12375: LD_VAR 0 5
12379: PPUSH
12380: LD_INT 3
12382: PPUSH
12383: CALL_OW 275
12387: PUSH
12388: LD_VAR 0 8
12392: PUSH
12393: LD_INT 3
12395: ARRAY
12396: GREATEREQUAL
12397: AND
12398: IFFALSE 12410
// result := true else
12400: LD_ADDR_VAR 0 4
12404: PUSH
12405: LD_INT 1
12407: ST_TO_ADDR
12408: GO 12418
// result := false ;
12410: LD_ADDR_VAR 0 4
12414: PUSH
12415: LD_INT 0
12417: ST_TO_ADDR
// end ;
12418: LD_VAR 0 4
12422: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
12423: LD_INT 0
12425: PPUSH
12426: PPUSH
12427: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
12428: LD_ADDR_VAR 0 5
12432: PUSH
12433: LD_VAR 0 1
12437: PPUSH
12438: LD_INT 2
12440: PPUSH
12441: EMPTY
12442: PPUSH
12443: CALL 83 0 3
12447: ST_TO_ADDR
// if unit and plist then
12448: LD_VAR 0 2
12452: PUSH
12453: LD_VAR 0 5
12457: AND
12458: IFFALSE 12519
// for i = 1 to plist do
12460: LD_ADDR_VAR 0 4
12464: PUSH
12465: DOUBLE
12466: LD_INT 1
12468: DEC
12469: ST_TO_ADDR
12470: LD_VAR 0 5
12474: PUSH
12475: FOR_TO
12476: IFFALSE 12517
// if NotTask ( plist [ i ] ) then
12478: LD_VAR 0 5
12482: PUSH
12483: LD_VAR 0 4
12487: ARRAY
12488: PPUSH
12489: CALL 25710 0 1
12493: IFFALSE 12515
// ComDismantle ( plist [ i ] , unit ) ;
12495: LD_VAR 0 5
12499: PUSH
12500: LD_VAR 0 4
12504: ARRAY
12505: PPUSH
12506: LD_VAR 0 2
12510: PPUSH
12511: CALL_OW 167
12515: GO 12475
12517: POP
12518: POP
// result := true ;
12519: LD_ADDR_VAR 0 3
12523: PUSH
12524: LD_INT 1
12526: ST_TO_ADDR
// end ;
12527: LD_VAR 0 3
12531: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
12532: LD_INT 0
12534: PPUSH
12535: PPUSH
12536: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
12537: LD_ADDR_VAR 0 5
12541: PUSH
12542: LD_VAR 0 1
12546: PPUSH
12547: LD_INT 2
12549: PPUSH
12550: EMPTY
12551: PPUSH
12552: CALL 83 0 3
12556: ST_TO_ADDR
// if unit and plist then
12557: LD_VAR 0 2
12561: PUSH
12562: LD_VAR 0 5
12566: AND
12567: IFFALSE 12628
// for i = 1 to plist do
12569: LD_ADDR_VAR 0 4
12573: PUSH
12574: DOUBLE
12575: LD_INT 1
12577: DEC
12578: ST_TO_ADDR
12579: LD_VAR 0 5
12583: PUSH
12584: FOR_TO
12585: IFFALSE 12626
// if NotTask ( plist [ i ] ) then
12587: LD_VAR 0 5
12591: PUSH
12592: LD_VAR 0 4
12596: ARRAY
12597: PPUSH
12598: CALL 25710 0 1
12602: IFFALSE 12624
// ComComplete ( plist [ i ] , unit ) ;
12604: LD_VAR 0 5
12608: PUSH
12609: LD_VAR 0 4
12613: ARRAY
12614: PPUSH
12615: LD_VAR 0 2
12619: PPUSH
12620: CALL 25246 0 2
12624: GO 12584
12626: POP
12627: POP
// result := true ;
12628: LD_ADDR_VAR 0 3
12632: PUSH
12633: LD_INT 1
12635: ST_TO_ADDR
// end ;
12636: LD_VAR 0 3
12640: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
12641: LD_INT 0
12643: PPUSH
12644: PPUSH
12645: PPUSH
12646: PPUSH
12647: PPUSH
12648: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12649: LD_ADDR_VAR 0 5
12653: PUSH
12654: LD_INT 22
12656: PUSH
12657: LD_VAR 0 1
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: PUSH
12666: LD_INT 21
12668: PUSH
12669: LD_INT 3
12671: PUSH
12672: EMPTY
12673: LIST
12674: LIST
12675: PUSH
12676: LD_INT 3
12678: PUSH
12679: LD_INT 57
12681: PUSH
12682: EMPTY
12683: LIST
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PUSH
12689: LD_INT 3
12691: PUSH
12692: LD_INT 24
12694: PUSH
12695: LD_INT 1000
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: PUSH
12702: EMPTY
12703: LIST
12704: LIST
12705: PUSH
12706: EMPTY
12707: LIST
12708: LIST
12709: LIST
12710: LIST
12711: PPUSH
12712: CALL_OW 69
12716: ST_TO_ADDR
// r := [ ] ;
12717: LD_ADDR_VAR 0 6
12721: PUSH
12722: EMPTY
12723: ST_TO_ADDR
// if not tmp then
12724: LD_VAR 0 5
12728: NOT
12729: IFFALSE 12735
// exit else
12731: GO 12923
12733: GO 12903
// begin r := [ tmp [ 1 ] ] ;
12735: LD_ADDR_VAR 0 6
12739: PUSH
12740: LD_VAR 0 5
12744: PUSH
12745: LD_INT 1
12747: ARRAY
12748: PUSH
12749: EMPTY
12750: LIST
12751: ST_TO_ADDR
// for i = 2 to tmp do
12752: LD_ADDR_VAR 0 3
12756: PUSH
12757: DOUBLE
12758: LD_INT 2
12760: DEC
12761: ST_TO_ADDR
12762: LD_VAR 0 5
12766: PUSH
12767: FOR_TO
12768: IFFALSE 12901
// begin m := false ;
12770: LD_ADDR_VAR 0 7
12774: PUSH
12775: LD_INT 0
12777: ST_TO_ADDR
// for j = 1 to r do
12778: LD_ADDR_VAR 0 4
12782: PUSH
12783: DOUBLE
12784: LD_INT 1
12786: DEC
12787: ST_TO_ADDR
12788: LD_VAR 0 6
12792: PUSH
12793: FOR_TO
12794: IFFALSE 12868
// if GetLives ( tmp [ i ] ) < r [ j ] then
12796: LD_VAR 0 5
12800: PUSH
12801: LD_VAR 0 3
12805: ARRAY
12806: PPUSH
12807: CALL_OW 256
12811: PUSH
12812: LD_VAR 0 6
12816: PUSH
12817: LD_VAR 0 4
12821: ARRAY
12822: LESS
12823: IFFALSE 12866
// begin r := Insert ( r , j , tmp [ i ] ) ;
12825: LD_ADDR_VAR 0 6
12829: PUSH
12830: LD_VAR 0 6
12834: PPUSH
12835: LD_VAR 0 4
12839: PPUSH
12840: LD_VAR 0 5
12844: PUSH
12845: LD_VAR 0 3
12849: ARRAY
12850: PPUSH
12851: CALL_OW 2
12855: ST_TO_ADDR
// m := true ;
12856: LD_ADDR_VAR 0 7
12860: PUSH
12861: LD_INT 1
12863: ST_TO_ADDR
// break ;
12864: GO 12868
// end ;
12866: GO 12793
12868: POP
12869: POP
// if not m then
12870: LD_VAR 0 7
12874: NOT
12875: IFFALSE 12899
// r := r ^ tmp [ i ] ;
12877: LD_ADDR_VAR 0 6
12881: PUSH
12882: LD_VAR 0 6
12886: PUSH
12887: LD_VAR 0 5
12891: PUSH
12892: LD_VAR 0 3
12896: ARRAY
12897: ADD
12898: ST_TO_ADDR
// end ;
12899: GO 12767
12901: POP
12902: POP
// end ; if r then
12903: LD_VAR 0 6
12907: IFFALSE 12921
// result := r else
12909: LD_ADDR_VAR 0 2
12913: PUSH
12914: LD_VAR 0 6
12918: ST_TO_ADDR
12919: GO 12923
// exit ;
12921: GO 12923
// end ;
12923: LD_VAR 0 2
12927: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
12928: LD_INT 0
12930: PPUSH
12931: PPUSH
12932: PPUSH
12933: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
12934: LD_ADDR_VAR 0 5
12938: PUSH
12939: LD_INT 22
12941: PUSH
12942: LD_VAR 0 1
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 2
12953: PUSH
12954: LD_INT 25
12956: PUSH
12957: LD_INT 2
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 25
12966: PUSH
12967: LD_INT 16
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 34
12976: PUSH
12977: LD_INT 13
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: PUSH
12984: LD_INT 34
12986: PUSH
12987: LD_INT 52
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: PUSH
13001: LD_INT 24
13003: PUSH
13004: LD_INT 650
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: PPUSH
13016: CALL_OW 69
13020: ST_TO_ADDR
// p := 1 ;
13021: LD_ADDR_VAR 0 4
13025: PUSH
13026: LD_INT 1
13028: ST_TO_ADDR
// for i = 1 to repairs do
13029: LD_ADDR_VAR 0 3
13033: PUSH
13034: DOUBLE
13035: LD_INT 1
13037: DEC
13038: ST_TO_ADDR
13039: LD_VAR 0 5
13043: PUSH
13044: FOR_TO
13045: IFFALSE 13181
// begin if IsInUnit ( repairs [ i ] ) then
13047: LD_VAR 0 5
13051: PUSH
13052: LD_VAR 0 3
13056: ARRAY
13057: PPUSH
13058: CALL_OW 310
13062: IFFALSE 13081
// ComExitBuilding ( repairs [ i ] ) else
13064: LD_VAR 0 5
13068: PUSH
13069: LD_VAR 0 3
13073: ARRAY
13074: PPUSH
13075: CALL_OW 122
13079: GO 13179
// if not HasTask ( repairs [ i ] ) then
13081: LD_VAR 0 5
13085: PUSH
13086: LD_VAR 0 3
13090: ARRAY
13091: PPUSH
13092: CALL_OW 314
13096: NOT
13097: IFFALSE 13179
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
13099: LD_VAR 0 5
13103: PUSH
13104: LD_VAR 0 3
13108: ARRAY
13109: PPUSH
13110: LD_EXP 16
13114: PUSH
13115: LD_VAR 0 1
13119: ARRAY
13120: PUSH
13121: LD_VAR 0 4
13125: ARRAY
13126: PPUSH
13127: CALL_OW 130
// if i mod 3 = 0 then
13131: LD_VAR 0 3
13135: PUSH
13136: LD_INT 3
13138: MOD
13139: PUSH
13140: LD_INT 0
13142: EQUAL
13143: IFFALSE 13159
// p := p + 1 ;
13145: LD_ADDR_VAR 0 4
13149: PUSH
13150: LD_VAR 0 4
13154: PUSH
13155: LD_INT 1
13157: PLUS
13158: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
13159: LD_EXP 16
13163: PUSH
13164: LD_VAR 0 1
13168: ARRAY
13169: PUSH
13170: LD_VAR 0 4
13174: LESS
13175: IFFALSE 13179
// break ;
13177: GO 13181
// end ; end ;
13179: GO 13044
13181: POP
13182: POP
// end ; end_of_file
13183: LD_VAR 0 2
13187: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
13188: LD_INT 0
13190: PPUSH
13191: PPUSH
13192: PPUSH
13193: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
13194: LD_ADDR_VAR 0 5
13198: PUSH
13199: LD_INT 35
13201: PUSH
13202: LD_INT 45
13204: PUSH
13205: LD_INT 46
13207: PUSH
13208: LD_INT 47
13210: PUSH
13211: LD_INT 1
13213: PUSH
13214: LD_INT 2
13216: PUSH
13217: LD_INT 48
13219: PUSH
13220: LD_INT 49
13222: PUSH
13223: LD_INT 50
13225: PUSH
13226: LD_INT 20
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: ST_TO_ADDR
// if MCF_Lab ( side ) then
13241: LD_VAR 0 1
13245: PPUSH
13246: CALL 39 0 1
13250: IFFALSE 13489
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
13252: LD_VAR 0 1
13256: PPUSH
13257: CALL 39 0 1
13261: PUSH
13262: LD_INT 1
13264: ARRAY
13265: PPUSH
13266: CALL_OW 461
13270: PUSH
13271: LD_INT 2
13273: EQUAL
13274: IFFALSE 13413
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
13276: LD_VAR 0 1
13280: PPUSH
13281: CALL 39 0 1
13285: PUSH
13286: LD_INT 1
13288: ARRAY
13289: PPUSH
13290: LD_VAR 0 2
13294: PPUSH
13295: CALL 13585 0 2
13299: IFFALSE 13326
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
13301: LD_VAR 0 1
13305: PPUSH
13306: CALL 39 0 1
13310: PUSH
13311: LD_INT 1
13313: ARRAY
13314: PPUSH
13315: LD_VAR 0 2
13319: PPUSH
13320: CALL_OW 124
13324: GO 13413
// if MCF_Lab ( side ) > 1 then
13326: LD_VAR 0 1
13330: PPUSH
13331: CALL 39 0 1
13335: PUSH
13336: LD_INT 1
13338: GREATER
13339: IFFALSE 13413
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
13341: LD_VAR 0 1
13345: PPUSH
13346: CALL 39 0 1
13350: PUSH
13351: LD_INT 2
13353: ARRAY
13354: PPUSH
13355: CALL_OW 461
13359: PUSH
13360: LD_INT 2
13362: EQUAL
13363: IFFALSE 13413
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
13365: LD_VAR 0 1
13369: PPUSH
13370: CALL 39 0 1
13374: PUSH
13375: LD_INT 2
13377: ARRAY
13378: PPUSH
13379: LD_VAR 0 2
13383: PPUSH
13384: CALL 13585 0 2
13388: IFFALSE 13413
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
13390: LD_VAR 0 1
13394: PPUSH
13395: CALL 39 0 1
13399: PUSH
13400: LD_INT 2
13402: ARRAY
13403: PPUSH
13404: LD_VAR 0 2
13408: PPUSH
13409: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
13413: LD_VAR 0 2
13417: PUSH
13418: LD_INT 2
13420: PUSH
13421: LD_INT 11
13423: PUSH
13424: LD_INT 4
13426: PUSH
13427: LD_INT 3
13429: PUSH
13430: EMPTY
13431: LIST
13432: LIST
13433: LIST
13434: LIST
13435: IN
13436: IFFALSE 13489
// begin for lab in MCF_Lab ( side ) do
13438: LD_ADDR_VAR 0 6
13442: PUSH
13443: LD_VAR 0 1
13447: PPUSH
13448: CALL 39 0 1
13452: PUSH
13453: FOR_IN
13454: IFFALSE 13487
// if BuildingStatus ( lab ) = bs_need_ape then
13456: LD_VAR 0 6
13460: PPUSH
13461: CALL_OW 461
13465: PUSH
13466: LD_INT 10
13468: EQUAL
13469: IFFALSE 13485
// MCL_ResTame ( side , lab ) ;
13471: LD_VAR 0 1
13475: PPUSH
13476: LD_VAR 0 6
13480: PPUSH
13481: CALL 13710 0 2
13485: GO 13453
13487: POP
13488: POP
// end ; end ; end ;
13489: LD_VAR 0 3
13493: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
13494: LD_INT 0
13496: PPUSH
13497: PPUSH
// tmp := [ ] ;
13498: LD_ADDR_VAR 0 3
13502: PUSH
13503: EMPTY
13504: ST_TO_ADDR
// if not lab then
13505: LD_VAR 0 1
13509: NOT
13510: IFFALSE 13522
// result := false else
13512: LD_ADDR_VAR 0 2
13516: PUSH
13517: LD_INT 0
13519: ST_TO_ADDR
13520: GO 13580
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_VAR 0 3
13531: PUSH
13532: LD_VAR 0 1
13536: PPUSH
13537: LD_INT 1
13539: PPUSH
13540: CALL_OW 268
13544: ADD
13545: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
13546: LD_ADDR_VAR 0 3
13550: PUSH
13551: LD_VAR 0 3
13555: PUSH
13556: LD_VAR 0 1
13560: PPUSH
13561: LD_INT 2
13563: PPUSH
13564: CALL_OW 268
13568: ADD
13569: ST_TO_ADDR
// result := tmp ;
13570: LD_ADDR_VAR 0 2
13574: PUSH
13575: LD_VAR 0 3
13579: ST_TO_ADDR
// end ; end ;
13580: LD_VAR 0 2
13584: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
13585: LD_INT 0
13587: PPUSH
13588: PPUSH
13589: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
13590: LD_ADDR_VAR 0 5
13594: PUSH
13595: LD_INT 35
13597: PUSH
13598: LD_INT 45
13600: PUSH
13601: LD_INT 46
13603: PUSH
13604: LD_INT 47
13606: PUSH
13607: LD_INT 1
13609: PUSH
13610: LD_INT 2
13612: PUSH
13613: LD_INT 48
13615: PUSH
13616: LD_INT 49
13618: PUSH
13619: LD_INT 50
13621: PUSH
13622: LD_INT 20
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: LIST
13635: LIST
13636: ST_TO_ADDR
// if lab then
13637: LD_VAR 0 1
13641: IFFALSE 13697
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
13643: LD_VAR 0 2
13647: PUSH
13648: LD_VAR 0 5
13652: IN
13653: PUSH
13654: LD_VAR 0 2
13658: PPUSH
13659: CALL_OW 481
13663: PUSH
13664: LD_VAR 0 1
13668: PPUSH
13669: CALL 13494 0 1
13673: IN
13674: OR
13675: IFFALSE 13687
// result := true else
13677: LD_ADDR_VAR 0 3
13681: PUSH
13682: LD_INT 1
13684: ST_TO_ADDR
13685: GO 13695
// result := false ;
13687: LD_ADDR_VAR 0 3
13691: PUSH
13692: LD_INT 0
13694: ST_TO_ADDR
// end else
13695: GO 13705
// result := false ;
13697: LD_ADDR_VAR 0 3
13701: PUSH
13702: LD_INT 0
13704: ST_TO_ADDR
// end ;
13705: LD_VAR 0 3
13709: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
13710: LD_INT 0
13712: PPUSH
13713: PPUSH
13714: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
13715: LD_ADDR_VAR 0 4
13719: PUSH
13720: LD_VAR 0 1
13724: PPUSH
13725: LD_INT 171
13727: PPUSH
13728: EMPTY
13729: PPUSH
13730: CALL 703 0 3
13734: ST_TO_ADDR
// if not ape then
13735: LD_VAR 0 4
13739: NOT
13740: IFFALSE 13772
// if MCF_Ape ( side ) then
13742: LD_VAR 0 1
13746: PPUSH
13747: CALL 413 0 1
13751: IFFALSE 13772
// ape := MCF_Ape ( side ) [ 1 ] ;
13753: LD_ADDR_VAR 0 4
13757: PUSH
13758: LD_VAR 0 1
13762: PPUSH
13763: CALL 413 0 1
13767: PUSH
13768: LD_INT 1
13770: ARRAY
13771: ST_TO_ADDR
// if ape then
13772: LD_VAR 0 4
13776: IFFALSE 13827
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
13778: LD_VAR 0 4
13782: PUSH
13783: LD_INT 1
13785: ARRAY
13786: PPUSH
13787: CALL_OW 310
13791: PUSH
13792: LD_VAR 0 4
13796: PUSH
13797: LD_INT 1
13799: ARRAY
13800: PPUSH
13801: CALL_OW 310
13805: PUSH
13806: LD_VAR 0 2
13810: NONEQUAL
13811: AND
13812: IFFALSE 13827
// ComExitBuilding ( ape [ 1 ] ) ;
13814: LD_VAR 0 4
13818: PUSH
13819: LD_INT 1
13821: ARRAY
13822: PPUSH
13823: CALL_OW 122
// if not lab then
13827: LD_VAR 0 2
13831: NOT
13832: IFFALSE 13838
// exit else
13834: GO 13986
13836: GO 13946
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
13838: LD_VAR 0 1
13842: PPUSH
13843: LD_INT 16
13845: PPUSH
13846: LD_INT 25
13848: PUSH
13849: LD_INT 4
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PPUSH
13856: CALL 703 0 3
13860: PUSH
13861: LD_INT 0
13863: EQUAL
13864: PUSH
13865: LD_VAR 0 2
13869: PPUSH
13870: CALL_OW 313
13874: PUSH
13875: LD_INT 6
13877: EQUAL
13878: AND
13879: IFFALSE 13946
// begin tmp := UnitsInside ( lab ) ;
13881: LD_ADDR_VAR 0 5
13885: PUSH
13886: LD_VAR 0 2
13890: PPUSH
13891: CALL_OW 313
13895: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
13896: LD_VAR 0 5
13900: PUSH
13901: LD_VAR 0 5
13905: ARRAY
13906: PPUSH
13907: LD_INT 16
13909: PPUSH
13910: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
13914: LD_VAR 0 5
13918: PUSH
13919: LD_VAR 0 5
13923: ARRAY
13924: PPUSH
13925: CALL_OW 310
13929: IFFALSE 13946
// ComExitBuilding ( tmp [ tmp ] ) ;
13931: LD_VAR 0 5
13935: PUSH
13936: LD_VAR 0 5
13940: ARRAY
13941: PPUSH
13942: CALL_OW 122
// end ; if ape then
13946: LD_VAR 0 4
13950: IFFALSE 13986
// if not IsInUnit ( ape [ 1 ] ) then
13952: LD_VAR 0 4
13956: PUSH
13957: LD_INT 1
13959: ARRAY
13960: PPUSH
13961: CALL_OW 310
13965: NOT
13966: IFFALSE 13986
// ComEnterUnit ( ape [ 1 ] , lab ) ;
13968: LD_VAR 0 4
13972: PUSH
13973: LD_INT 1
13975: ARRAY
13976: PPUSH
13977: LD_VAR 0 2
13981: PPUSH
13982: CALL_OW 120
// end ;
13986: LD_VAR 0 3
13990: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
13991: LD_INT 0
13993: PPUSH
13994: PPUSH
13995: PPUSH
// result := false ;
13996: LD_ADDR_VAR 0 2
14000: PUSH
14001: LD_INT 0
14003: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
14004: LD_ADDR_VAR 0 3
14008: PUSH
14009: LD_VAR 0 1
14013: PPUSH
14014: CALL 14153 0 1
14018: ST_TO_ADDR
// if techs then
14019: LD_VAR 0 3
14023: IFFALSE 14053
// if techs [ 2 ] then
14025: LD_VAR 0 3
14029: PUSH
14030: LD_INT 2
14032: ARRAY
14033: IFFALSE 14045
// result := true else
14035: LD_ADDR_VAR 0 2
14039: PUSH
14040: LD_INT 1
14042: ST_TO_ADDR
14043: GO 14053
// result := false ;
14045: LD_ADDR_VAR 0 2
14049: PUSH
14050: LD_INT 0
14052: ST_TO_ADDR
// end ;
14053: LD_VAR 0 2
14057: RET
// export function MCL_Start ( side ) ; var i ; begin
14058: LD_INT 0
14060: PPUSH
14061: PPUSH
// if MREG_ForSide ( side , MREG_ToRes ) then
14062: LD_VAR 0 1
14066: PPUSH
14067: LD_EXP 19
14071: PPUSH
14072: CALL 5218 0 2
14076: IFFALSE 14148
// for i = 1 to MREG_ToRes do
14078: LD_ADDR_VAR 0 3
14082: PUSH
14083: DOUBLE
14084: LD_INT 1
14086: DEC
14087: ST_TO_ADDR
14088: LD_EXP 19
14092: PUSH
14093: FOR_TO
14094: IFFALSE 14146
// if MREG_ToRes [ i ] [ 1 ] = side then
14096: LD_EXP 19
14100: PUSH
14101: LD_VAR 0 3
14105: ARRAY
14106: PUSH
14107: LD_INT 1
14109: ARRAY
14110: PUSH
14111: LD_VAR 0 1
14115: EQUAL
14116: IFFALSE 14144
// begin MCL_Research ( side , MREG_ToRes [ i ] [ 2 ] ) ;
14118: LD_VAR 0 1
14122: PPUSH
14123: LD_EXP 19
14127: PUSH
14128: LD_VAR 0 3
14132: ARRAY
14133: PUSH
14134: LD_INT 2
14136: ARRAY
14137: PPUSH
14138: CALL 13188 0 2
// break ;
14142: GO 14146
// end ;
14144: GO 14093
14146: POP
14147: POP
// end ;
14148: LD_VAR 0 2
14152: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
14153: LD_INT 0
14155: PPUSH
14156: PPUSH
14157: PPUSH
// if MREG_ToRes then
14158: LD_EXP 19
14162: IFFALSE 14236
// for i = 1 to MREG_ToRes do
14164: LD_ADDR_VAR 0 3
14168: PUSH
14169: DOUBLE
14170: LD_INT 1
14172: DEC
14173: ST_TO_ADDR
14174: LD_EXP 19
14178: PUSH
14179: FOR_TO
14180: IFFALSE 14234
// if MREG_ToRes [ i ] [ 1 ] = side then
14182: LD_EXP 19
14186: PUSH
14187: LD_VAR 0 3
14191: ARRAY
14192: PUSH
14193: LD_INT 1
14195: ARRAY
14196: PUSH
14197: LD_VAR 0 1
14201: EQUAL
14202: IFFALSE 14232
// begin techs := techs ^ MREG_ToRes [ i ] [ 2 ] ;
14204: LD_ADDR_VAR 0 4
14208: PUSH
14209: LD_VAR 0 4
14213: PUSH
14214: LD_EXP 19
14218: PUSH
14219: LD_VAR 0 3
14223: ARRAY
14224: PUSH
14225: LD_INT 2
14227: ARRAY
14228: ADD
14229: ST_TO_ADDR
// break ;
14230: GO 14234
// end ;
14232: GO 14179
14234: POP
14235: POP
// result := techs ;
14236: LD_ADDR_VAR 0 2
14240: PUSH
14241: LD_VAR 0 4
14245: ST_TO_ADDR
// end ;
14246: LD_VAR 0 2
14250: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
14251: LD_INT 0
14253: PPUSH
14254: PPUSH
// for i = 1 to tech_list do
14255: LD_ADDR_VAR 0 4
14259: PUSH
14260: DOUBLE
14261: LD_INT 1
14263: DEC
14264: ST_TO_ADDR
14265: LD_VAR 0 2
14269: PUSH
14270: FOR_TO
14271: IFFALSE 14325
// if not tech_list [ i ] = 20 then
14273: LD_VAR 0 2
14277: PUSH
14278: LD_VAR 0 4
14282: ARRAY
14283: PUSH
14284: LD_INT 20
14286: EQUAL
14287: NOT
14288: IFFALSE 14323
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
14290: LD_ADDR_EXP 19
14294: PUSH
14295: LD_EXP 19
14299: PPUSH
14300: LD_VAR 0 1
14304: PPUSH
14305: LD_VAR 0 2
14309: PUSH
14310: LD_VAR 0 4
14314: ARRAY
14315: PPUSH
14316: EMPTY
14317: PPUSH
14318: CALL 4124 0 4
14322: ST_TO_ADDR
14323: GO 14270
14325: POP
14326: POP
// result := true ;
14327: LD_ADDR_VAR 0 3
14331: PUSH
14332: LD_INT 1
14334: ST_TO_ADDR
// end ;
14335: LD_VAR 0 3
14339: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
14340: LD_INT 0
14342: PPUSH
14343: PPUSH
// for i = MREG_ToRes downto 1 do
14344: LD_ADDR_VAR 0 3
14348: PUSH
14349: DOUBLE
14350: LD_EXP 19
14354: INC
14355: ST_TO_ADDR
14356: LD_INT 1
14358: PUSH
14359: FOR_DOWNTO
14360: IFFALSE 14406
// if MREG_ToRes [ i ] [ 1 ] = side then
14362: LD_EXP 19
14366: PUSH
14367: LD_VAR 0 3
14371: ARRAY
14372: PUSH
14373: LD_INT 1
14375: ARRAY
14376: PUSH
14377: LD_VAR 0 1
14381: EQUAL
14382: IFFALSE 14404
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
14384: LD_ADDR_EXP 19
14388: PUSH
14389: LD_EXP 19
14393: PPUSH
14394: LD_VAR 0 3
14398: PPUSH
14399: CALL_OW 3
14403: ST_TO_ADDR
14404: GO 14359
14406: POP
14407: POP
// result := true ;
14408: LD_ADDR_VAR 0 2
14412: PUSH
14413: LD_INT 1
14415: ST_TO_ADDR
// end ;
14416: LD_VAR 0 2
14420: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
14421: LD_INT 0
14423: PPUSH
// result := GetTechProgress ( side , tech ) ;
14424: LD_ADDR_VAR 0 3
14428: PUSH
14429: LD_VAR 0 1
14433: PPUSH
14434: LD_VAR 0 2
14438: PPUSH
14439: CALL_OW 326
14443: ST_TO_ADDR
// end ;
14444: LD_VAR 0 3
14448: RET
// export function MCL_Require ( tech ) ; begin
14449: LD_INT 0
14451: PPUSH
// result := GetTechTechsReq ( tech ) ;
14452: LD_ADDR_VAR 0 2
14456: PUSH
14457: LD_VAR 0 1
14461: PPUSH
14462: CALL_OW 480
14466: ST_TO_ADDR
// end ; end_of_file
14467: LD_VAR 0 2
14471: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
14472: LD_INT 0
14474: PPUSH
14475: PPUSH
14476: PPUSH
// pom := GetBase ( fac ) ;
14477: LD_ADDR_VAR 0 5
14481: PUSH
14482: LD_VAR 0 1
14486: PPUSH
14487: CALL_OW 274
14491: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
14492: LD_ADDR_VAR 0 4
14496: PUSH
14497: LD_VAR 0 2
14501: PUSH
14502: LD_INT 1
14504: ARRAY
14505: PPUSH
14506: LD_VAR 0 2
14510: PUSH
14511: LD_INT 2
14513: ARRAY
14514: PPUSH
14515: LD_VAR 0 2
14519: PUSH
14520: LD_INT 3
14522: ARRAY
14523: PPUSH
14524: LD_VAR 0 2
14528: PUSH
14529: LD_INT 4
14531: ARRAY
14532: PPUSH
14533: CALL_OW 449
14537: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
14538: LD_VAR 0 5
14542: PPUSH
14543: LD_INT 1
14545: PPUSH
14546: CALL_OW 275
14550: PUSH
14551: LD_VAR 0 4
14555: PUSH
14556: LD_INT 1
14558: ARRAY
14559: GREATEREQUAL
14560: PUSH
14561: LD_VAR 0 5
14565: PPUSH
14566: LD_INT 2
14568: PPUSH
14569: CALL_OW 275
14573: PUSH
14574: LD_VAR 0 4
14578: PUSH
14579: LD_INT 2
14581: ARRAY
14582: GREATEREQUAL
14583: AND
14584: PUSH
14585: LD_VAR 0 5
14589: PPUSH
14590: LD_INT 3
14592: PPUSH
14593: CALL_OW 275
14597: PUSH
14598: LD_VAR 0 4
14602: PUSH
14603: LD_INT 3
14605: ARRAY
14606: GREATEREQUAL
14607: AND
14608: IFFALSE 14620
// result := true else
14610: LD_ADDR_VAR 0 3
14614: PUSH
14615: LD_INT 1
14617: ST_TO_ADDR
14618: GO 14628
// result := false ;
14620: LD_ADDR_VAR 0 3
14624: PUSH
14625: LD_INT 0
14627: ST_TO_ADDR
// end ;
14628: LD_VAR 0 3
14632: RET
// export function MCV_Produce ( side , fac , list ) ; var i ; begin
14633: LD_INT 0
14635: PPUSH
14636: PPUSH
// if fac then
14637: LD_VAR 0 2
14641: IFFALSE 14835
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
14643: LD_VAR 0 2
14647: PPUSH
14648: LD_VAR 0 3
14652: PPUSH
14653: CALL 14472 0 2
14657: PUSH
14658: LD_VAR 0 2
14662: PPUSH
14663: CALL_OW 461
14667: PUSH
14668: LD_INT 2
14670: EQUAL
14671: AND
14672: PUSH
14673: LD_VAR 0 2
14677: PPUSH
14678: LD_VAR 0 3
14682: PUSH
14683: LD_INT 1
14685: ARRAY
14686: PPUSH
14687: LD_VAR 0 3
14691: PUSH
14692: LD_INT 2
14694: ARRAY
14695: PPUSH
14696: LD_VAR 0 3
14700: PUSH
14701: LD_INT 3
14703: ARRAY
14704: PPUSH
14705: LD_VAR 0 3
14709: PUSH
14710: LD_INT 4
14712: ARRAY
14713: PPUSH
14714: CALL_OW 448
14718: AND
14719: IFFALSE 14825
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
14721: LD_VAR 0 2
14725: PPUSH
14726: LD_VAR 0 3
14730: PUSH
14731: LD_INT 1
14733: ARRAY
14734: PPUSH
14735: LD_VAR 0 3
14739: PUSH
14740: LD_INT 2
14742: ARRAY
14743: PPUSH
14744: LD_VAR 0 3
14748: PUSH
14749: LD_INT 3
14751: ARRAY
14752: PPUSH
14753: LD_VAR 0 3
14757: PUSH
14758: LD_INT 4
14760: ARRAY
14761: PPUSH
14762: CALL_OW 125
// for i = 1 to 4 do
14766: LD_ADDR_VAR 0 5
14770: PUSH
14771: DOUBLE
14772: LD_INT 1
14774: DEC
14775: ST_TO_ADDR
14776: LD_INT 4
14778: PUSH
14779: FOR_TO
14780: IFFALSE 14813
// MREG_ToConstruct := Remove ( MREG_ToConstruct , list [ i ] , true ) ;
14782: LD_ADDR_EXP 20
14786: PUSH
14787: LD_EXP 20
14791: PPUSH
14792: LD_VAR 0 3
14796: PUSH
14797: LD_VAR 0 5
14801: ARRAY
14802: PPUSH
14803: LD_INT 1
14805: PPUSH
14806: CALL 24530 0 3
14810: ST_TO_ADDR
14811: GO 14779
14813: POP
14814: POP
// result := true ;
14815: LD_ADDR_VAR 0 4
14819: PUSH
14820: LD_INT 1
14822: ST_TO_ADDR
// end else
14823: GO 14833
// result := false ;
14825: LD_ADDR_VAR 0 4
14829: PUSH
14830: LD_INT 0
14832: ST_TO_ADDR
// end else
14833: GO 14843
// result := false ;
14835: LD_ADDR_VAR 0 4
14839: PUSH
14840: LD_INT 0
14842: ST_TO_ADDR
// end ;
14843: LD_VAR 0 4
14847: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
14848: LD_INT 0
14850: PPUSH
14851: PPUSH
// if MREG_Parking [ side ] then
14852: LD_EXP 27
14856: PUSH
14857: LD_VAR 0 1
14861: ARRAY
14862: IFFALSE 15015
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
14864: LD_VAR 0 2
14868: PPUSH
14869: LD_EXP 27
14873: PUSH
14874: LD_VAR 0 1
14878: ARRAY
14879: PPUSH
14880: CALL_OW 308
14884: NOT
14885: IFFALSE 15015
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
14887: LD_VAR 0 2
14891: PPUSH
14892: LD_EXP 27
14896: PUSH
14897: LD_VAR 0 1
14901: ARRAY
14902: PPUSH
14903: CALL_OW 113
// if GetControl ( veh ) = control_manual then
14907: LD_VAR 0 2
14911: PPUSH
14912: CALL_OW 263
14916: PUSH
14917: LD_INT 1
14919: EQUAL
14920: IFFALSE 15015
// begin i := GetDriver ( veh ) ;
14922: LD_ADDR_VAR 0 4
14926: PUSH
14927: LD_VAR 0 2
14931: PPUSH
14932: CALL 25065 0 1
14936: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
14937: LD_INT 35
14939: PPUSH
14940: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) ;
14944: LD_VAR 0 2
14948: PPUSH
14949: LD_EXP 27
14953: PUSH
14954: LD_VAR 0 1
14958: ARRAY
14959: PPUSH
14960: CALL_OW 308
14964: IFFALSE 14937
// ComExitVehicle ( i ) ;
14966: LD_VAR 0 4
14970: PPUSH
14971: CALL_OW 121
// Wait ( 1 ) ;
14975: LD_INT 1
14977: PPUSH
14978: CALL_OW 67
// ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
14982: LD_VAR 0 4
14986: PPUSH
14987: LD_VAR 0 1
14991: PPUSH
14992: LD_INT 30
14994: PUSH
14995: LD_INT 3
14997: PUSH
14998: EMPTY
14999: LIST
15000: LIST
15001: PPUSH
15002: CALL 0 0 2
15006: PUSH
15007: LD_INT 1
15009: ARRAY
15010: PPUSH
15011: CALL_OW 120
// end ; end ; end ;
15015: LD_VAR 0 3
15019: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
15020: LD_INT 0
15022: PPUSH
15023: PPUSH
15024: PPUSH
15025: PPUSH
15026: PPUSH
15027: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
15028: LD_VAR 0 1
15032: PPUSH
15033: LD_INT 30
15035: PUSH
15036: LD_INT 3
15038: PUSH
15039: EMPTY
15040: LIST
15041: LIST
15042: PPUSH
15043: CALL 0 0 2
15047: IFFALSE 15286
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
15049: LD_VAR 0 1
15053: PPUSH
15054: LD_INT 30
15056: PUSH
15057: LD_INT 3
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PPUSH
15064: CALL 0 0 2
15068: PUSH
15069: LD_INT 1
15071: ARRAY
15072: PPUSH
15073: CALL_OW 461
15077: PUSH
15078: LD_INT 2
15080: EQUAL
15081: IFFALSE 15286
// begin if MREG_ForSide ( side , MREG_TurretWeapon ) then
15083: LD_VAR 0 1
15087: PPUSH
15088: LD_EXP 12
15092: PPUSH
15093: CALL 5218 0 2
15097: IFFALSE 15286
// for i = 1 to MREG_TurretWeapon do
15099: LD_ADDR_VAR 0 3
15103: PUSH
15104: DOUBLE
15105: LD_INT 1
15107: DEC
15108: ST_TO_ADDR
15109: LD_EXP 12
15113: PUSH
15114: FOR_TO
15115: IFFALSE 15284
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
15117: LD_EXP 12
15121: PUSH
15122: LD_VAR 0 3
15126: ARRAY
15127: PUSH
15128: LD_INT 1
15130: ARRAY
15131: PUSH
15132: LD_VAR 0 1
15136: EQUAL
15137: IFFALSE 15282
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
15139: LD_ADDR_VAR 0 5
15143: PUSH
15144: LD_EXP 12
15148: PUSH
15149: LD_VAR 0 3
15153: ARRAY
15154: PUSH
15155: LD_INT 2
15157: ARRAY
15158: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
15159: LD_ADDR_VAR 0 6
15163: PUSH
15164: LD_EXP 12
15168: PUSH
15169: LD_VAR 0 3
15173: ARRAY
15174: PUSH
15175: LD_INT 3
15177: ARRAY
15178: PUSH
15179: LD_INT 1
15181: ARRAY
15182: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
15183: LD_ADDR_VAR 0 7
15187: PUSH
15188: LD_EXP 12
15192: PUSH
15193: LD_VAR 0 3
15197: ARRAY
15198: PUSH
15199: LD_INT 3
15201: ARRAY
15202: PUSH
15203: LD_INT 2
15205: ARRAY
15206: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
15207: LD_ADDR_VAR 0 4
15211: PUSH
15212: LD_VAR 0 6
15216: PPUSH
15217: LD_VAR 0 7
15221: PPUSH
15222: CALL_OW 428
15226: ST_TO_ADDR
// AddComPlaceWeapon ( turret , weapon ) ;
15227: LD_VAR 0 4
15231: PPUSH
15232: LD_VAR 0 5
15236: PPUSH
15237: CALL_OW 208
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , side , weapon , [ x , y ] ) ;
15241: LD_ADDR_EXP 12
15245: PUSH
15246: LD_EXP 12
15250: PPUSH
15251: LD_VAR 0 1
15255: PPUSH
15256: LD_VAR 0 5
15260: PPUSH
15261: LD_VAR 0 6
15265: PUSH
15266: LD_VAR 0 7
15270: PUSH
15271: EMPTY
15272: LIST
15273: LIST
15274: PPUSH
15275: CALL 4215 0 4
15279: ST_TO_ADDR
// break ;
15280: GO 15284
// end ;
15282: GO 15114
15284: POP
15285: POP
// end ; end ;
15286: LD_VAR 0 2
15290: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
15291: LD_INT 0
15293: PPUSH
15294: PPUSH
15295: PPUSH
15296: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
15297: LD_ADDR_VAR 0 4
15301: PUSH
15302: LD_VAR 0 1
15306: PPUSH
15307: LD_INT 32
15309: PUSH
15310: LD_INT 1
15312: PUSH
15313: EMPTY
15314: LIST
15315: LIST
15316: PPUSH
15317: CALL 0 0 2
15321: ST_TO_ADDR
// if not tmp then
15322: LD_VAR 0 4
15326: NOT
15327: IFFALSE 15333
// exit else
15329: GO 15415
15331: GO 15415
// begin for i = 1 to tmp do
15333: LD_ADDR_VAR 0 3
15337: PUSH
15338: DOUBLE
15339: LD_INT 1
15341: DEC
15342: ST_TO_ADDR
15343: LD_VAR 0 4
15347: PUSH
15348: FOR_TO
15349: IFFALSE 15413
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
15351: LD_VAR 0 4
15355: PUSH
15356: LD_VAR 0 3
15360: ARRAY
15361: PPUSH
15362: CALL_OW 261
15366: PUSH
15367: LD_INT 20
15369: LESS
15370: PUSH
15371: LD_VAR 0 4
15375: PUSH
15376: LD_VAR 0 3
15380: ARRAY
15381: PPUSH
15382: CALL_OW 110
15386: PUSH
15387: LD_INT 0
15389: EQUAL
15390: AND
15391: IFFALSE 15411
// begin SetTag ( tmp [ i ] , 21 ) ;
15393: LD_VAR 0 4
15397: PUSH
15398: LD_VAR 0 3
15402: ARRAY
15403: PPUSH
15404: LD_INT 21
15406: PPUSH
15407: CALL_OW 109
// end ;
15411: GO 15348
15413: POP
15414: POP
// end ; end ;
15415: LD_VAR 0 2
15419: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
15420: LD_INT 0
15422: PPUSH
15423: PPUSH
15424: PPUSH
15425: PPUSH
15426: PPUSH
// if not unit then
15427: LD_VAR 0 1
15431: NOT
15432: IFFALSE 15436
// exit ;
15434: GO 15641
// side := GetSide ( unit ) ;
15436: LD_ADDR_VAR 0 3
15440: PUSH
15441: LD_VAR 0 1
15445: PPUSH
15446: CALL_OW 255
15450: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
15451: LD_ADDR_VAR 0 5
15455: PUSH
15456: LD_VAR 0 3
15460: PPUSH
15461: LD_INT 2
15463: PUSH
15464: LD_INT 30
15466: PUSH
15467: LD_INT 1
15469: PUSH
15470: EMPTY
15471: LIST
15472: LIST
15473: PUSH
15474: LD_INT 30
15476: PUSH
15477: LD_INT 3
15479: PUSH
15480: EMPTY
15481: LIST
15482: LIST
15483: PUSH
15484: LD_INT 30
15486: PUSH
15487: LD_INT 29
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: LIST
15498: LIST
15499: PPUSH
15500: CALL 0 0 2
15504: ST_TO_ADDR
// if not b then
15505: LD_VAR 0 5
15509: NOT
15510: IFFALSE 15516
// exit else
15512: GO 15641
15514: GO 15641
// if GetTag ( unit ) = 21 then
15516: LD_VAR 0 1
15520: PPUSH
15521: CALL_OW 110
15525: PUSH
15526: LD_INT 21
15528: EQUAL
15529: IFFALSE 15641
// begin c := NearestUnitToUnit ( b , unit ) ;
15531: LD_ADDR_VAR 0 6
15535: PUSH
15536: LD_VAR 0 5
15540: PPUSH
15541: LD_VAR 0 1
15545: PPUSH
15546: CALL_OW 74
15550: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
15551: LD_VAR 0 1
15555: PPUSH
15556: LD_VAR 0 6
15560: PPUSH
15561: CALL_OW 250
15565: PPUSH
15566: LD_VAR 0 6
15570: PPUSH
15571: CALL_OW 251
15575: PPUSH
15576: CALL_OW 297
15580: PUSH
15581: LD_INT 6
15583: GREATER
15584: IFFALSE 15617
// ComMoveXY ( unit , GetX ( c ) , GetY ( c ) ) else
15586: LD_VAR 0 1
15590: PPUSH
15591: LD_VAR 0 6
15595: PPUSH
15596: CALL_OW 250
15600: PPUSH
15601: LD_VAR 0 6
15605: PPUSH
15606: CALL_OW 251
15610: PPUSH
15611: CALL_OW 111
15615: GO 15641
// begin SetFuel ( unit , 100 ) ;
15617: LD_VAR 0 1
15621: PPUSH
15622: LD_INT 100
15624: PPUSH
15625: CALL_OW 240
// SetTag ( unit , 0 ) ;
15629: LD_VAR 0 1
15633: PPUSH
15634: LD_INT 0
15636: PPUSH
15637: CALL_OW 109
// end ; end ; end ;
15641: LD_VAR 0 2
15645: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
15646: LD_INT 0
15648: PPUSH
15649: PPUSH
15650: PPUSH
15651: PPUSH
15652: PPUSH
15653: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
15654: LD_ADDR_VAR 0 7
15658: PUSH
15659: LD_VAR 0 1
15663: PPUSH
15664: LD_INT 33
15666: PUSH
15667: LD_INT 2
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: PUSH
15674: LD_INT 3
15676: PUSH
15677: LD_INT 61
15679: PUSH
15680: EMPTY
15681: LIST
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: PPUSH
15691: CALL 0 0 2
15695: ST_TO_ADDR
// if not vehs then
15696: LD_VAR 0 7
15700: NOT
15701: IFFALSE 15705
// exit ;
15703: GO 15990
// if nation = 1 then
15705: LD_VAR 0 2
15709: PUSH
15710: LD_INT 1
15712: EQUAL
15713: IFFALSE 15883
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
15715: LD_VAR 0 1
15719: PPUSH
15720: LD_INT 30
15722: PUSH
15723: LD_INT 36
15725: PUSH
15726: EMPTY
15727: LIST
15728: LIST
15729: PPUSH
15730: CALL 0 0 2
15734: NOT
15735: IFFALSE 15741
// exit else
15737: GO 15990
15739: GO 15881
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
15741: LD_ADDR_VAR 0 5
15745: PUSH
15746: LD_VAR 0 1
15750: PPUSH
15751: LD_INT 30
15753: PUSH
15754: LD_INT 36
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: PPUSH
15761: CALL 0 0 2
15765: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
15766: LD_ADDR_VAR 0 6
15770: PUSH
15771: LD_VAR 0 5
15775: PUSH
15776: LD_INT 1
15778: ARRAY
15779: PPUSH
15780: CALL_OW 313
15784: ST_TO_ADDR
// for i = vehs downto 1 do
15785: LD_ADDR_VAR 0 4
15789: PUSH
15790: DOUBLE
15791: LD_VAR 0 7
15795: INC
15796: ST_TO_ADDR
15797: LD_INT 1
15799: PUSH
15800: FOR_DOWNTO
15801: IFFALSE 15879
// begin if not IsControledBy ( vehs [ i ] ) then
15803: LD_VAR 0 7
15807: PUSH
15808: LD_VAR 0 4
15812: ARRAY
15813: PPUSH
15814: CALL_OW 312
15818: NOT
15819: IFFALSE 15877
// begin tmp := MCV_RemoteDriver ( oper ) ;
15821: LD_ADDR_VAR 0 8
15825: PUSH
15826: LD_VAR 0 6
15830: PPUSH
15831: CALL 15995 0 1
15835: ST_TO_ADDR
// if not tmp then
15836: LD_VAR 0 8
15840: NOT
15841: IFFALSE 15849
// exit else
15843: POP
15844: POP
15845: GO 15990
15847: GO 15877
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
15849: LD_VAR 0 7
15853: PUSH
15854: LD_VAR 0 4
15858: ARRAY
15859: PPUSH
15860: LD_VAR 0 8
15864: PUSH
15865: LD_INT 1
15867: ARRAY
15868: PUSH
15869: LD_INT 1
15871: ARRAY
15872: PPUSH
15873: CALL_OW 135
// end ; end ;
15877: GO 15800
15879: POP
15880: POP
// end ; end else
15881: GO 15990
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
15883: LD_VAR 0 1
15887: PPUSH
15888: LD_INT 34
15890: PUSH
15891: LD_INT 31
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: PPUSH
15898: CALL 0 0 2
15902: NOT
15903: IFFALSE 15909
// exit else
15905: GO 15990
15907: GO 15990
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
15909: LD_ADDR_VAR 0 5
15913: PUSH
15914: LD_VAR 0 1
15918: PPUSH
15919: LD_INT 34
15921: PUSH
15922: LD_INT 31
15924: PUSH
15925: EMPTY
15926: LIST
15927: LIST
15928: PPUSH
15929: CALL 0 0 2
15933: ST_TO_ADDR
// oper := [ ] ;
15934: LD_ADDR_VAR 0 6
15938: PUSH
15939: EMPTY
15940: ST_TO_ADDR
// for i = 1 to ct do
15941: LD_ADDR_VAR 0 4
15945: PUSH
15946: DOUBLE
15947: LD_INT 1
15949: DEC
15950: ST_TO_ADDR
15951: LD_VAR 0 5
15955: PUSH
15956: FOR_TO
15957: IFFALSE 15988
// oper := oper ^ GetDriver ( ct [ i ] ) ;
15959: LD_ADDR_VAR 0 6
15963: PUSH
15964: LD_VAR 0 6
15968: PUSH
15969: LD_VAR 0 5
15973: PUSH
15974: LD_VAR 0 4
15978: ARRAY
15979: PPUSH
15980: CALL 25065 0 1
15984: ADD
15985: ST_TO_ADDR
15986: GO 15956
15988: POP
15989: POP
// end ; end ; end ;
15990: LD_VAR 0 3
15994: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
15995: LD_INT 0
15997: PPUSH
15998: PPUSH
15999: PPUSH
16000: PPUSH
16001: PPUSH
16002: PPUSH
// if not drivers then
16003: LD_VAR 0 1
16007: NOT
16008: IFFALSE 16014
// exit else
16010: GO 16294
16012: GO 16294
// begin linked := [ ] ;
16014: LD_ADDR_VAR 0 5
16018: PUSH
16019: EMPTY
16020: ST_TO_ADDR
// for i = 1 to drivers do
16021: LD_ADDR_VAR 0 3
16025: PUSH
16026: DOUBLE
16027: LD_INT 1
16029: DEC
16030: ST_TO_ADDR
16031: LD_VAR 0 1
16035: PUSH
16036: FOR_TO
16037: IFFALSE 16282
// begin if CanControl ( drivers [ i ] ) then
16039: LD_VAR 0 1
16043: PUSH
16044: LD_VAR 0 3
16048: ARRAY
16049: PPUSH
16050: CALL 25637 0 1
16054: IFFALSE 16280
// if i > 1 then
16056: LD_VAR 0 3
16060: PUSH
16061: LD_INT 1
16063: GREATER
16064: IFFALSE 16241
// begin m := false ;
16066: LD_ADDR_VAR 0 6
16070: PUSH
16071: LD_INT 0
16073: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
16074: LD_ADDR_VAR 0 7
16078: PUSH
16079: LD_VAR 0 1
16083: PUSH
16084: LD_VAR 0 3
16088: ARRAY
16089: PPUSH
16090: CALL_OW 432
16094: ST_TO_ADDR
// for j = 1 to linked do
16095: LD_ADDR_VAR 0 4
16099: PUSH
16100: DOUBLE
16101: LD_INT 1
16103: DEC
16104: ST_TO_ADDR
16105: LD_VAR 0 5
16109: PUSH
16110: FOR_TO
16111: IFFALSE 16185
// begin if l < linked [ j ] [ 2 ] then
16113: LD_VAR 0 7
16117: PUSH
16118: LD_VAR 0 5
16122: PUSH
16123: LD_VAR 0 4
16127: ARRAY
16128: PUSH
16129: LD_INT 2
16131: ARRAY
16132: LESS
16133: IFFALSE 16183
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
16135: LD_ADDR_VAR 0 5
16139: PUSH
16140: LD_VAR 0 5
16144: PPUSH
16145: LD_INT 1
16147: PPUSH
16148: LD_VAR 0 1
16152: PUSH
16153: LD_VAR 0 3
16157: ARRAY
16158: PUSH
16159: LD_VAR 0 7
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: PPUSH
16168: CALL_OW 2
16172: ST_TO_ADDR
// m := true ;
16173: LD_ADDR_VAR 0 6
16177: PUSH
16178: LD_INT 1
16180: ST_TO_ADDR
// break ;
16181: GO 16185
// end ; end ;
16183: GO 16110
16185: POP
16186: POP
// if not m then
16187: LD_VAR 0 6
16191: NOT
16192: IFFALSE 16239
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
16194: LD_ADDR_VAR 0 5
16198: PUSH
16199: LD_VAR 0 5
16203: PUSH
16204: LD_VAR 0 1
16208: PUSH
16209: LD_VAR 0 3
16213: ARRAY
16214: PUSH
16215: LD_VAR 0 1
16219: PUSH
16220: LD_VAR 0 3
16224: ARRAY
16225: PPUSH
16226: CALL_OW 432
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: PUSH
16235: EMPTY
16236: LIST
16237: ADD
16238: ST_TO_ADDR
// end else
16239: GO 16280
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
16241: LD_ADDR_VAR 0 5
16245: PUSH
16246: LD_VAR 0 1
16250: PUSH
16251: LD_VAR 0 3
16255: ARRAY
16256: PUSH
16257: LD_VAR 0 1
16261: PUSH
16262: LD_VAR 0 3
16266: ARRAY
16267: PPUSH
16268: CALL_OW 432
16272: PUSH
16273: EMPTY
16274: LIST
16275: LIST
16276: PUSH
16277: EMPTY
16278: LIST
16279: ST_TO_ADDR
// end ;
16280: GO 16036
16282: POP
16283: POP
// result := linked ;
16284: LD_ADDR_VAR 0 2
16288: PUSH
16289: LD_VAR 0 5
16293: ST_TO_ADDR
// end ; end ;
16294: LD_VAR 0 2
16298: RET
// export function MCV_ToRepair ( unit ) ; begin
16299: LD_INT 0
16301: PPUSH
// if not unit then
16302: LD_VAR 0 1
16306: NOT
16307: IFFALSE 16313
// exit else
16309: GO 16344
16311: GO 16344
// begin SetTag ( unit , 6 ) ;
16313: LD_VAR 0 1
16317: PPUSH
16318: LD_INT 6
16320: PPUSH
16321: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
16325: LD_VAR 0 1
16329: PPUSH
16330: CALL_OW 255
16334: PPUSH
16335: LD_VAR 0 1
16339: PPUSH
16340: CALL 14848 0 2
// end ; end ;
16344: LD_VAR 0 2
16348: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
16349: LD_INT 0
16351: PPUSH
16352: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
16353: LD_VAR 0 1
16357: PPUSH
16358: LD_INT 6
16360: PPUSH
16361: EMPTY
16362: PPUSH
16363: CALL 703 0 3
16367: IFFALSE 16460
// begin for i = MCF_Tag ( side , 6 , [ ] ) to 1 do
16369: LD_ADDR_VAR 0 3
16373: PUSH
16374: DOUBLE
16375: LD_VAR 0 1
16379: PPUSH
16380: LD_INT 6
16382: PPUSH
16383: EMPTY
16384: PPUSH
16385: CALL 703 0 3
16389: DEC
16390: ST_TO_ADDR
16391: LD_INT 1
16393: PUSH
16394: FOR_TO
16395: IFFALSE 16458
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
16397: LD_VAR 0 1
16401: PPUSH
16402: LD_INT 6
16404: PPUSH
16405: EMPTY
16406: PPUSH
16407: CALL 703 0 3
16411: PUSH
16412: LD_VAR 0 3
16416: ARRAY
16417: PPUSH
16418: CALL_OW 256
16422: PUSH
16423: LD_INT 1000
16425: EQUAL
16426: IFFALSE 16456
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
16428: LD_VAR 0 1
16432: PPUSH
16433: LD_INT 6
16435: PPUSH
16436: EMPTY
16437: PPUSH
16438: CALL 703 0 3
16442: PUSH
16443: LD_VAR 0 3
16447: ARRAY
16448: PPUSH
16449: LD_INT 0
16451: PPUSH
16452: CALL_OW 109
16456: GO 16394
16458: POP
16459: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
16460: LD_ADDR_VAR 0 3
16464: PUSH
16465: LD_VAR 0 1
16469: PPUSH
16470: EMPTY
16471: PPUSH
16472: CALL 301 0 2
16476: PUSH
16477: LD_VAR 0 1
16481: PPUSH
16482: LD_INT 7
16484: PPUSH
16485: EMPTY
16486: PPUSH
16487: CALL 703 0 3
16491: DIFF
16492: PUSH
16493: FOR_IN
16494: IFFALSE 16538
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
16496: LD_VAR 0 3
16500: PPUSH
16501: CALL_OW 256
16505: PUSH
16506: LD_INT 650
16508: LESS
16509: PUSH
16510: LD_VAR 0 3
16514: PPUSH
16515: CALL_OW 110
16519: PUSH
16520: LD_INT 6
16522: EQUAL
16523: NOT
16524: AND
16525: IFFALSE 16536
// MCV_ToRepair ( i ) ;
16527: LD_VAR 0 3
16531: PPUSH
16532: CALL 16299 0 1
16536: GO 16493
16538: POP
16539: POP
// end ; end_of_file
16540: LD_VAR 0 2
16544: RET
// export mc_game_live ; starting begin ResetFog ( ) ;
16545: CALL_OW 335
// RandomizeAll ;
16549: CALL_OW 11
// FakePep ( ) ;
16553: CALL 3372 0 0
// mc_game_live := 1 ;
16557: LD_ADDR_EXP 32
16561: PUSH
16562: LD_INT 1
16564: ST_TO_ADDR
// MC_Registry ( ) ;
16565: CALL 3908 0 0
// MC_RegistryInit ( ) ;
16569: CALL 4296 0 0
// MCT_MarkPlace ( 10 , 7 , aqua ) ;
16573: LD_INT 10
16575: PPUSH
16576: LD_INT 7
16578: PPUSH
16579: LD_STRING aqua
16581: PPUSH
16582: CALL 5510 0 3
// MCN_AddApes ( Area43 , 5 , 10 ) ;
16586: LD_INT 5
16588: PPUSH
16589: LD_INT 5
16591: PPUSH
16592: LD_INT 10
16594: PPUSH
16595: CALL 25855 0 3
// MCS_SetResourcesBonus ( 20 , 16000 , 30 ) ;
16599: LD_INT 20
16601: PPUSH
16602: LD_INT 16000
16604: PPUSH
16605: LD_INT 30
16607: PPUSH
16608: CALL 9760 0 3
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , 20 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_weap3 , tech_rocket , tech_advMet , tech_sib1 , tech_comp1 , tech_ai , tech_advai , tech_comp2 , tech_opto1 , tech_opto2 , tech_radar , tech_remcont ] ) ;
16612: LD_INT 1
16614: PPUSH
16615: LD_INT 48
16617: PUSH
16618: LD_INT 49
16620: PUSH
16621: LD_INT 20
16623: PUSH
16624: LD_INT 46
16626: PUSH
16627: LD_INT 47
16629: PUSH
16630: LD_INT 35
16632: PUSH
16633: LD_INT 45
16635: PUSH
16636: LD_INT 1
16638: PUSH
16639: LD_INT 50
16641: PUSH
16642: LD_INT 2
16644: PUSH
16645: LD_INT 51
16647: PUSH
16648: LD_INT 52
16650: PUSH
16651: LD_INT 69
16653: PUSH
16654: LD_INT 39
16656: PUSH
16657: LD_INT 53
16659: PUSH
16660: LD_INT 40
16662: PUSH
16663: LD_INT 34
16665: PUSH
16666: LD_INT 54
16668: PUSH
16669: LD_INT 57
16671: PUSH
16672: LD_INT 32
16674: PUSH
16675: LD_INT 27
16677: PUSH
16678: LD_INT 58
16680: PUSH
16681: LD_INT 60
16683: PUSH
16684: LD_INT 61
16686: PUSH
16687: LD_INT 6
16689: PUSH
16690: LD_INT 15
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: LIST
16697: LIST
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: LIST
16720: PPUSH
16721: CALL 14251 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
16725: LD_INT 1
16727: PPUSH
16728: LD_INT 3
16730: PPUSH
16731: CALL 9630 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
16735: LD_INT 1
16737: PPUSH
16738: LD_INT 0
16740: PUSH
16741: LD_INT 1
16743: PUSH
16744: LD_INT 0
16746: PUSH
16747: LD_INT 0
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: LIST
16754: LIST
16755: PPUSH
16756: CALL 9663 0 2
// MCS_CreateDeposits ( 1 , [ 9 , 13 , 2 , 29 , 10 , 3 ] ) ;
16760: LD_INT 1
16762: PPUSH
16763: LD_INT 9
16765: PUSH
16766: LD_INT 13
16768: PUSH
16769: LD_INT 2
16771: PUSH
16772: LD_INT 29
16774: PUSH
16775: LD_INT 10
16777: PUSH
16778: LD_INT 3
16780: PUSH
16781: EMPTY
16782: LIST
16783: LIST
16784: LIST
16785: LIST
16786: LIST
16787: LIST
16788: PPUSH
16789: CALL 9837 0 2
// MCS_Collector ( 1 , 1 , [ Area44 ] ) ;
16793: LD_INT 1
16795: PPUSH
16796: LD_INT 1
16798: PPUSH
16799: LD_INT 6
16801: PUSH
16802: EMPTY
16803: LIST
16804: PPUSH
16805: CALL 9696 0 3
// MCS_SetParking ( 1 , area42 ) ;
16809: LD_INT 1
16811: PPUSH
16812: LD_INT 4
16814: PPUSH
16815: CALL 9596 0 2
// MCS_Depot ( 1 , [ 33 , 27 , 1 ] ) ;
16819: LD_INT 1
16821: PPUSH
16822: LD_INT 33
16824: PUSH
16825: LD_INT 27
16827: PUSH
16828: LD_INT 1
16830: PUSH
16831: EMPTY
16832: LIST
16833: LIST
16834: LIST
16835: PPUSH
16836: CALL 8775 0 2
// MCS_Mine ( 1 ) ;
16840: LD_INT 1
16842: PPUSH
16843: CALL 9147 0 1
// MCS_Lab ( 1 , [ 20 , 20 , 3 ] , [ b_lab_weapon , b_lab_opto ] ) ;
16847: LD_INT 1
16849: PPUSH
16850: LD_INT 20
16852: PUSH
16853: LD_INT 20
16855: PUSH
16856: LD_INT 3
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: LIST
16863: PPUSH
16864: LD_INT 10
16866: PUSH
16867: LD_INT 15
16869: PUSH
16870: EMPTY
16871: LIST
16872: LIST
16873: PPUSH
16874: CALL 8811 0 3
// MCS_Lab ( 1 , [ 40 , 17 , 1 ] , [ b_lab_computer , b_lab_siberium ] ) ;
16878: LD_INT 1
16880: PPUSH
16881: LD_INT 40
16883: PUSH
16884: LD_INT 17
16886: PUSH
16887: LD_INT 1
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: LIST
16894: PPUSH
16895: LD_INT 12
16897: PUSH
16898: LD_INT 11
16900: PUSH
16901: EMPTY
16902: LIST
16903: LIST
16904: PPUSH
16905: CALL 8811 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 10 , 7 , 2 , 37 , 41 , 3 ] , [ us_machine_gun , us_machine_gun ] ) ;
16909: LD_INT 1
16911: PPUSH
16912: LD_INT 32
16914: PPUSH
16915: LD_INT 10
16917: PUSH
16918: LD_INT 7
16920: PUSH
16921: LD_INT 2
16923: PUSH
16924: LD_INT 37
16926: PUSH
16927: LD_INT 41
16929: PUSH
16930: LD_INT 3
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: PPUSH
16941: LD_INT 2
16943: PUSH
16944: LD_INT 2
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PPUSH
16951: CALL 8271 0 4
// MCS_ChangeFortification ( 1 , [ 10 , 7 ] , [ us_gatling_gun ] ) ;
16955: LD_INT 1
16957: PPUSH
16958: LD_INT 10
16960: PUSH
16961: LD_INT 7
16963: PUSH
16964: EMPTY
16965: LIST
16966: LIST
16967: PPUSH
16968: LD_INT 4
16970: PUSH
16971: EMPTY
16972: LIST
16973: PPUSH
16974: CALL 8466 0 3
// MCS_PowerPlants ( 1 , [ 29 , 13 , 0 , 17 , 10 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
16978: LD_INT 1
16980: PPUSH
16981: LD_INT 29
16983: PUSH
16984: LD_INT 13
16986: PUSH
16987: LD_INT 0
16989: PUSH
16990: LD_INT 17
16992: PUSH
16993: LD_INT 10
16995: PUSH
16996: LD_INT 2
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: PPUSH
17007: LD_INT 27
17009: PUSH
17010: LD_INT 26
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: PPUSH
17017: CALL 8987 0 3
// MCS_Barracks ( 1 , [ 46 , 27 , 5 ] ) ;
17021: LD_INT 1
17023: PPUSH
17024: LD_INT 46
17026: PUSH
17027: LD_INT 27
17029: PUSH
17030: LD_INT 5
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: LIST
17037: PPUSH
17038: CALL 9350 0 2
// MCS_Factory ( 1 , [ 48 , 40 , 0 ] , [ b_ext_gun , b_ext_noncombat , b_ext_computer , b_ext_radar , b_ext_track , b_ext_gun ] ) ;
17042: LD_INT 1
17044: PPUSH
17045: LD_INT 48
17047: PUSH
17048: LD_INT 40
17050: PUSH
17051: LD_INT 0
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: LIST
17058: PPUSH
17059: LD_INT 17
17061: PUSH
17062: LD_INT 19
17064: PUSH
17065: LD_INT 24
17067: PUSH
17068: LD_INT 20
17070: PUSH
17071: LD_INT 16
17073: PUSH
17074: LD_INT 17
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: PPUSH
17085: CALL 8885 0 3
// MCS_ControlTower ( 1 , 1 , [ 33 , 49 , 2 ] ) ;
17089: LD_INT 1
17091: PPUSH
17092: LD_INT 1
17094: PPUSH
17095: LD_INT 33
17097: PUSH
17098: LD_INT 49
17100: PUSH
17101: LD_INT 2
17103: PUSH
17104: EMPTY
17105: LIST
17106: LIST
17107: LIST
17108: PPUSH
17109: CALL 9386 0 3
// MCS_AddVehicle ( 1 , [ us_medium_wheeled , engine_combustion , control_computer , us_cargo_bay ] ) ;
17113: LD_INT 1
17115: PPUSH
17116: LD_INT 2
17118: PUSH
17119: LD_INT 1
17121: PUSH
17122: LD_INT 3
17124: PUSH
17125: LD_INT 12
17127: PUSH
17128: EMPTY
17129: LIST
17130: LIST
17131: LIST
17132: LIST
17133: PPUSH
17134: CALL 9495 0 2
// MCS_AddVehicle ( 1 , [ us_medium_wheeled , engine_combustion , control_remote , us_gatling_gun ] ) ;
17138: LD_INT 1
17140: PPUSH
17141: LD_INT 2
17143: PUSH
17144: LD_INT 1
17146: PUSH
17147: LD_INT 2
17149: PUSH
17150: LD_INT 4
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: LIST
17157: LIST
17158: PPUSH
17159: CALL 9495 0 2
// MC_Game ( 0 0$01 ) ;
17163: LD_INT 35
17165: PPUSH
17166: CALL 17171 0 1
// end ;
17170: END
// function MC_Game ( int ) ; var i , side , un ; begin
17171: LD_INT 0
17173: PPUSH
17174: PPUSH
17175: PPUSH
17176: PPUSH
// while ( mc_game_live ) do
17177: LD_EXP 32
17181: IFFALSE 18762
// begin Wait ( int ) ;
17183: LD_VAR 0 1
17187: PPUSH
17188: CALL_OW 67
// if isEditor then
17192: LD_INT 1
17194: IFFALSE 17229
// MC_Show ( MCF_Tag ( 1 , 6 , [ f_distxy , 23 , 27 , 10 ] ) ) ;
17196: LD_INT 1
17198: PPUSH
17199: LD_INT 6
17201: PPUSH
17202: LD_INT 92
17204: PUSH
17205: LD_INT 23
17207: PUSH
17208: LD_INT 27
17210: PUSH
17211: LD_INT 10
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: PPUSH
17220: CALL 703 0 3
17224: PPUSH
17225: CALL 3890 0 1
// MCT_Crates ( area44 , 4 , 66 , 0 0$20 , 20 ) ;
17229: LD_INT 6
17231: PPUSH
17232: LD_INT 4
17234: PPUSH
17235: LD_INT 66
17237: PPUSH
17238: LD_INT 700
17240: PPUSH
17241: LD_INT 20
17243: PPUSH
17244: CALL 7646 0 5
// for side = 1 to 8 do
17248: LD_ADDR_VAR 0 4
17252: PUSH
17253: DOUBLE
17254: LD_INT 1
17256: DEC
17257: ST_TO_ADDR
17258: LD_INT 8
17260: PUSH
17261: FOR_TO
17262: IFFALSE 18758
// begin if MREG_SidesList [ side ] = 0 then
17264: LD_EXP 7
17268: PUSH
17269: LD_VAR 0 4
17273: ARRAY
17274: PUSH
17275: LD_INT 0
17277: EQUAL
17278: IFFALSE 17282
// continue ;
17280: GO 17261
// if MCL_GetTechList ( side ) then
17282: LD_VAR 0 4
17286: PPUSH
17287: CALL 14153 0 1
17291: IFFALSE 17302
// MCL_Start ( side ) ;
17293: LD_VAR 0 4
17297: PPUSH
17298: CALL 14058 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
17302: LD_ADDR_EXP 3
17306: PUSH
17307: LD_EXP 3
17311: PPUSH
17312: LD_VAR 0 4
17316: PPUSH
17317: LD_VAR 0 4
17321: PPUSH
17322: CALL 26782 0 1
17326: PPUSH
17327: CALL_OW 1
17331: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
17332: LD_ADDR_EXP 16
17336: PUSH
17337: LD_EXP 16
17341: PPUSH
17342: LD_VAR 0 4
17346: PPUSH
17347: LD_VAR 0 4
17351: PPUSH
17352: CALL 12641 0 1
17356: PPUSH
17357: CALL_OW 1
17361: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
17362: LD_VAR 0 4
17366: PPUSH
17367: LD_INT 21
17369: PUSH
17370: LD_INT 2
17372: PUSH
17373: EMPTY
17374: LIST
17375: LIST
17376: PPUSH
17377: CALL 0 0 2
17381: IFFALSE 17392
// MCV_CheckStatus ( side ) ;
17383: LD_VAR 0 4
17387: PPUSH
17388: CALL 16349 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
17392: LD_VAR 0 4
17396: PPUSH
17397: LD_EXP 22
17401: PPUSH
17402: CALL 5218 0 2
17406: IFFALSE 17491
// begin for i = MREG_ToChangeClass downto 1 do
17408: LD_ADDR_VAR 0 3
17412: PUSH
17413: DOUBLE
17414: LD_EXP 22
17418: INC
17419: ST_TO_ADDR
17420: LD_INT 1
17422: PUSH
17423: FOR_DOWNTO
17424: IFFALSE 17489
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
17426: LD_EXP 22
17430: PUSH
17431: LD_VAR 0 3
17435: ARRAY
17436: PUSH
17437: LD_INT 1
17439: ARRAY
17440: PUSH
17441: LD_VAR 0 4
17445: EQUAL
17446: IFFALSE 17487
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
17448: LD_VAR 0 4
17452: PPUSH
17453: LD_EXP 22
17457: PUSH
17458: LD_VAR 0 3
17462: ARRAY
17463: PUSH
17464: LD_INT 2
17466: ARRAY
17467: PPUSH
17468: LD_EXP 22
17472: PUSH
17473: LD_VAR 0 3
17477: ARRAY
17478: PUSH
17479: LD_INT 3
17481: ARRAY
17482: PPUSH
17483: CALL 23890 0 3
// end ; end ;
17487: GO 17423
17489: POP
17490: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
17491: LD_INT 1
17493: PUSH
17494: LD_EXP 6
17498: PUSH
17499: LD_VAR 0 4
17503: ARRAY
17504: IN
17505: IFFALSE 17516
// begin MCN_TrainApe ( side ) ;
17507: LD_VAR 0 4
17511: PPUSH
17512: CALL 26435 0 1
// end ; if MREG_ToConstruct [ side ] then
17516: LD_EXP 20
17520: PUSH
17521: LD_VAR 0 4
17525: ARRAY
17526: IFFALSE 17648
// begin if MCF_Get ( side , [ f_btype , b_factory ] ) then
17528: LD_VAR 0 4
17532: PPUSH
17533: LD_INT 30
17535: PUSH
17536: LD_INT 3
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: PPUSH
17543: CALL 0 0 2
17547: IFFALSE 17648
// MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
17549: LD_VAR 0 4
17553: PPUSH
17554: LD_VAR 0 4
17558: PPUSH
17559: LD_INT 30
17561: PUSH
17562: LD_INT 3
17564: PUSH
17565: EMPTY
17566: LIST
17567: LIST
17568: PPUSH
17569: CALL 0 0 2
17573: PUSH
17574: LD_INT 1
17576: ARRAY
17577: PPUSH
17578: LD_EXP 20
17582: PUSH
17583: LD_VAR 0 4
17587: ARRAY
17588: PUSH
17589: LD_INT 1
17591: ARRAY
17592: PUSH
17593: LD_EXP 20
17597: PUSH
17598: LD_VAR 0 4
17602: ARRAY
17603: PUSH
17604: LD_INT 2
17606: ARRAY
17607: PUSH
17608: LD_EXP 20
17612: PUSH
17613: LD_VAR 0 4
17617: ARRAY
17618: PUSH
17619: LD_INT 3
17621: ARRAY
17622: PUSH
17623: LD_EXP 20
17627: PUSH
17628: LD_VAR 0 4
17632: ARRAY
17633: PUSH
17634: LD_INT 4
17636: ARRAY
17637: PUSH
17638: EMPTY
17639: LIST
17640: LIST
17641: LIST
17642: LIST
17643: PPUSH
17644: CALL 14633 0 3
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) then
17648: LD_VAR 0 4
17652: PPUSH
17653: LD_INT 30
17655: PUSH
17656: LD_INT 3
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: PPUSH
17663: CALL 0 0 2
17667: PUSH
17668: LD_VAR 0 4
17672: PPUSH
17673: LD_EXP 12
17677: PPUSH
17678: CALL 5218 0 2
17682: AND
17683: IFFALSE 17694
// MCV_Turret ( side ) ;
17685: LD_VAR 0 4
17689: PPUSH
17690: CALL 15020 0 1
// if MCF_Get ( side , [ f_engine , engine_combustion ] ) then
17694: LD_VAR 0 4
17698: PPUSH
17699: LD_INT 32
17701: PUSH
17702: LD_INT 1
17704: PUSH
17705: EMPTY
17706: LIST
17707: LIST
17708: PPUSH
17709: CALL 0 0 2
17713: IFFALSE 17763
// begin MCV_CheckFuel ( side ) ;
17715: LD_VAR 0 4
17719: PPUSH
17720: CALL 15291 0 1
// if MCF_Tag ( side , 21 , [ ] ) then
17724: LD_VAR 0 4
17728: PPUSH
17729: LD_INT 21
17731: PPUSH
17732: EMPTY
17733: PPUSH
17734: CALL 703 0 3
17738: IFFALSE 17763
// MCV_Refuel ( MCF_Tag ( side , 21 , [ ] ) [ 1 ] ) ;
17740: LD_VAR 0 4
17744: PPUSH
17745: LD_INT 21
17747: PPUSH
17748: EMPTY
17749: PPUSH
17750: CALL 703 0 3
17754: PUSH
17755: LD_INT 1
17757: ARRAY
17758: PPUSH
17759: CALL 15420 0 1
// end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
17763: LD_VAR 0 4
17767: PPUSH
17768: LD_INT 33
17770: PUSH
17771: LD_INT 2
17773: PUSH
17774: EMPTY
17775: LIST
17776: LIST
17777: PPUSH
17778: CALL 0 0 2
17782: IFFALSE 17822
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
17784: LD_VAR 0 4
17788: PPUSH
17789: LD_VAR 0 4
17793: PPUSH
17794: LD_INT 33
17796: PUSH
17797: LD_INT 2
17799: PUSH
17800: EMPTY
17801: LIST
17802: LIST
17803: PPUSH
17804: CALL 0 0 2
17808: PUSH
17809: LD_INT 1
17811: ARRAY
17812: PPUSH
17813: CALL_OW 248
17817: PPUSH
17818: CALL 15646 0 2
// if MREG_ToRepair [ side ] then
17822: LD_EXP 16
17826: PUSH
17827: LD_VAR 0 4
17831: ARRAY
17832: IFFALSE 17845
// begin MCB_Repair ( side ) ;
17834: LD_VAR 0 4
17838: PPUSH
17839: CALL 12928 0 1
// end else
17843: GO 18726
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
17845: LD_VAR 0 4
17849: PPUSH
17850: LD_EXP 18
17854: PPUSH
17855: CALL 5218 0 2
17859: PUSH
17860: LD_VAR 0 4
17864: PPUSH
17865: LD_EXP 8
17869: PPUSH
17870: CALL 5218 0 2
17874: AND
17875: IFFALSE 18083
// begin for i = 1 to MREG_ToUpLab do
17877: LD_ADDR_VAR 0 3
17881: PUSH
17882: DOUBLE
17883: LD_INT 1
17885: DEC
17886: ST_TO_ADDR
17887: LD_EXP 18
17891: PUSH
17892: FOR_TO
17893: IFFALSE 18079
// if MREG_ToUpLab [ i ] [ 1 ] = side then
17895: LD_EXP 18
17899: PUSH
17900: LD_VAR 0 3
17904: ARRAY
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PUSH
17910: LD_VAR 0 4
17914: EQUAL
17915: IFFALSE 18077
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
17917: LD_EXP 18
17921: PUSH
17922: LD_VAR 0 3
17926: ARRAY
17927: PUSH
17928: LD_INT 2
17930: ARRAY
17931: PUSH
17932: LD_EXP 18
17936: PUSH
17937: LD_VAR 0 3
17941: ARRAY
17942: PUSH
17943: LD_INT 3
17945: ARRAY
17946: AND
17947: IFFALSE 18075
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
17949: LD_VAR 0 4
17953: PPUSH
17954: LD_EXP 18
17958: PUSH
17959: LD_VAR 0 3
17963: ARRAY
17964: PUSH
17965: LD_INT 2
17967: ARRAY
17968: PPUSH
17969: LD_EXP 18
17973: PUSH
17974: LD_VAR 0 3
17978: ARRAY
17979: PUSH
17980: LD_INT 3
17982: ARRAY
17983: PPUSH
17984: CALL 10452 0 3
17988: IFFALSE 18075
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
17990: LD_ADDR_EXP 18
17994: PUSH
17995: LD_EXP 18
17999: PPUSH
18000: LD_VAR 0 4
18004: PPUSH
18005: LD_EXP 18
18009: PUSH
18010: LD_VAR 0 3
18014: ARRAY
18015: PUSH
18016: LD_INT 2
18018: ARRAY
18019: PPUSH
18020: LD_EXP 18
18024: PUSH
18025: LD_VAR 0 3
18029: ARRAY
18030: PUSH
18031: LD_INT 3
18033: ARRAY
18034: PPUSH
18035: CALL 4215 0 4
18039: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
18040: LD_ADDR_EXP 8
18044: PUSH
18045: LD_EXP 8
18049: PPUSH
18050: LD_VAR 0 4
18054: PPUSH
18055: LD_EXP 8
18059: PUSH
18060: LD_INT 1
18062: ARRAY
18063: PUSH
18064: LD_INT 2
18066: ARRAY
18067: PPUSH
18068: EMPTY
18069: PPUSH
18070: CALL 4215 0 4
18074: ST_TO_ADDR
// end ; break ;
18075: GO 18079
// end ;
18077: GO 17892
18079: POP
18080: POP
// end else
18081: GO 18726
// if MREG_ForSide ( side , MREG_ToUpdate ) then
18083: LD_VAR 0 4
18087: PPUSH
18088: LD_EXP 17
18092: PPUSH
18093: CALL 5218 0 2
18097: IFFALSE 18171
// begin for i = 1 to MREG_ToUpdate do
18099: LD_ADDR_VAR 0 3
18103: PUSH
18104: DOUBLE
18105: LD_INT 1
18107: DEC
18108: ST_TO_ADDR
18109: LD_EXP 17
18113: PUSH
18114: FOR_TO
18115: IFFALSE 18167
// if MREG_ToUpdate [ i ] [ 1 ] = side then
18117: LD_EXP 17
18121: PUSH
18122: LD_VAR 0 3
18126: ARRAY
18127: PUSH
18128: LD_INT 1
18130: ARRAY
18131: PUSH
18132: LD_VAR 0 4
18136: EQUAL
18137: IFFALSE 18165
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
18139: LD_VAR 0 4
18143: PPUSH
18144: LD_EXP 17
18148: PUSH
18149: LD_VAR 0 3
18153: ARRAY
18154: PUSH
18155: LD_INT 2
18157: ARRAY
18158: PPUSH
18159: CALL 10288 0 2
// break ;
18163: GO 18167
// end ;
18165: GO 18114
18167: POP
18168: POP
// end else
18169: GO 18726
// if MCF_Get ( side , [ f_constructed ] ) then
18171: LD_VAR 0 4
18175: PPUSH
18176: LD_INT 57
18178: PUSH
18179: EMPTY
18180: LIST
18181: PPUSH
18182: CALL 0 0 2
18186: IFFALSE 18219
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
18188: LD_VAR 0 4
18192: PPUSH
18193: LD_VAR 0 4
18197: PPUSH
18198: LD_INT 57
18200: PUSH
18201: EMPTY
18202: LIST
18203: PPUSH
18204: CALL 0 0 2
18208: PUSH
18209: LD_INT 1
18211: ARRAY
18212: PPUSH
18213: CALL 12532 0 2
18217: GO 18726
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) then
18219: LD_VAR 0 4
18223: PPUSH
18224: LD_EXP 15
18228: PPUSH
18229: CALL 5218 0 2
18233: PUSH
18234: LD_VAR 0 4
18238: PPUSH
18239: CALL_OW 345
18243: NOT
18244: AND
18245: IFFALSE 18642
// begin for i = 1 to MREG_ToBuild do
18247: LD_ADDR_VAR 0 3
18251: PUSH
18252: DOUBLE
18253: LD_INT 1
18255: DEC
18256: ST_TO_ADDR
18257: LD_EXP 15
18261: PUSH
18262: FOR_TO
18263: IFFALSE 18638
// if MREG_ToBuild [ i ] [ 1 ] = side then
18265: LD_EXP 15
18269: PUSH
18270: LD_VAR 0 3
18274: ARRAY
18275: PUSH
18276: LD_INT 1
18278: ARRAY
18279: PUSH
18280: LD_VAR 0 4
18284: EQUAL
18285: IFFALSE 18636
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
18287: LD_INT 1
18289: PUSH
18290: LD_EXP 15
18294: PUSH
18295: LD_VAR 0 3
18299: ARRAY
18300: PUSH
18301: LD_INT 3
18303: ARRAY
18304: PUSH
18305: LD_INT 1
18307: ARRAY
18308: PPUSH
18309: LD_EXP 15
18313: PUSH
18314: LD_VAR 0 3
18318: ARRAY
18319: PUSH
18320: LD_INT 3
18322: ARRAY
18323: PUSH
18324: LD_INT 2
18326: ARRAY
18327: PPUSH
18328: CALL_OW 351
18332: AND
18333: IFFALSE 18377
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
18335: LD_EXP 15
18339: PUSH
18340: LD_VAR 0 3
18344: ARRAY
18345: PUSH
18346: LD_INT 3
18348: ARRAY
18349: PUSH
18350: LD_INT 1
18352: ARRAY
18353: PPUSH
18354: LD_EXP 15
18358: PUSH
18359: LD_VAR 0 3
18363: ARRAY
18364: PUSH
18365: LD_INT 3
18367: ARRAY
18368: PUSH
18369: LD_INT 2
18371: ARRAY
18372: PPUSH
18373: CALL 5879 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
18377: LD_EXP 15
18381: PUSH
18382: LD_VAR 0 3
18386: ARRAY
18387: PUSH
18388: LD_INT 2
18390: ARRAY
18391: PUSH
18392: LD_INT 0
18394: EQUAL
18395: IFFALSE 18465
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
18397: LD_VAR 0 4
18401: PPUSH
18402: LD_EXP 15
18406: PUSH
18407: LD_VAR 0 3
18411: ARRAY
18412: PUSH
18413: LD_INT 3
18415: ARRAY
18416: PUSH
18417: LD_INT 1
18419: ARRAY
18420: PPUSH
18421: LD_EXP 15
18425: PUSH
18426: LD_VAR 0 3
18430: ARRAY
18431: PUSH
18432: LD_INT 3
18434: ARRAY
18435: PUSH
18436: LD_INT 2
18438: ARRAY
18439: PPUSH
18440: LD_EXP 15
18444: PUSH
18445: LD_VAR 0 3
18449: ARRAY
18450: PUSH
18451: LD_INT 3
18453: ARRAY
18454: PUSH
18455: LD_INT 3
18457: ARRAY
18458: PPUSH
18459: CALL 10124 0 4
18463: GO 18634
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
18465: LD_EXP 15
18469: PUSH
18470: LD_VAR 0 3
18474: ARRAY
18475: PUSH
18476: LD_INT 2
18478: ARRAY
18479: PUSH
18480: LD_INT 6
18482: EQUAL
18483: IFFALSE 18553
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
18485: LD_VAR 0 4
18489: PPUSH
18490: LD_EXP 15
18494: PUSH
18495: LD_VAR 0 3
18499: ARRAY
18500: PUSH
18501: LD_INT 3
18503: ARRAY
18504: PUSH
18505: LD_INT 1
18507: ARRAY
18508: PPUSH
18509: LD_EXP 15
18513: PUSH
18514: LD_VAR 0 3
18518: ARRAY
18519: PUSH
18520: LD_INT 3
18522: ARRAY
18523: PUSH
18524: LD_INT 2
18526: ARRAY
18527: PPUSH
18528: LD_EXP 15
18532: PUSH
18533: LD_VAR 0 3
18537: ARRAY
18538: PUSH
18539: LD_INT 3
18541: ARRAY
18542: PUSH
18543: LD_INT 3
18545: ARRAY
18546: PPUSH
18547: CALL 10253 0 4
18551: GO 18634
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
18553: LD_VAR 0 4
18557: PPUSH
18558: LD_EXP 15
18562: PUSH
18563: LD_VAR 0 3
18567: ARRAY
18568: PUSH
18569: LD_INT 2
18571: ARRAY
18572: PPUSH
18573: LD_EXP 15
18577: PUSH
18578: LD_VAR 0 3
18582: ARRAY
18583: PUSH
18584: LD_INT 3
18586: ARRAY
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: PPUSH
18592: LD_EXP 15
18596: PUSH
18597: LD_VAR 0 3
18601: ARRAY
18602: PUSH
18603: LD_INT 3
18605: ARRAY
18606: PUSH
18607: LD_INT 2
18609: ARRAY
18610: PPUSH
18611: LD_EXP 15
18615: PUSH
18616: LD_VAR 0 3
18620: ARRAY
18621: PUSH
18622: LD_INT 3
18624: ARRAY
18625: PUSH
18626: LD_INT 3
18628: ARRAY
18629: PPUSH
18630: CALL 11757 0 5
// break ;
18634: GO 18638
// end ;
18636: GO 18262
18638: POP
18639: POP
// end else
18640: GO 18726
// if MREG_ForSide ( side , MREG_ToDismantle ) then
18642: LD_VAR 0 4
18646: PPUSH
18647: LD_EXP 21
18651: PPUSH
18652: CALL 5218 0 2
18656: IFFALSE 18726
// begin for i = 1 to MREG_ToDismantle do
18658: LD_ADDR_VAR 0 3
18662: PUSH
18663: DOUBLE
18664: LD_INT 1
18666: DEC
18667: ST_TO_ADDR
18668: LD_EXP 21
18672: PUSH
18673: FOR_TO
18674: IFFALSE 18724
// if MREG_ToDismantle [ i ] [ 1 ] = side then
18676: LD_EXP 21
18680: PUSH
18681: LD_VAR 0 3
18685: ARRAY
18686: PUSH
18687: LD_INT 1
18689: ARRAY
18690: PUSH
18691: LD_VAR 0 4
18695: EQUAL
18696: IFFALSE 18722
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
18698: LD_VAR 0 4
18702: PPUSH
18703: LD_EXP 21
18707: PUSH
18708: LD_VAR 0 3
18712: ARRAY
18713: PUSH
18714: LD_INT 2
18716: ARRAY
18717: PPUSH
18718: CALL 12423 0 2
// end ;
18722: GO 18673
18724: POP
18725: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18726: LD_VAR 0 4
18730: PPUSH
18731: LD_INT 30
18733: PUSH
18734: LD_INT 1
18736: PUSH
18737: EMPTY
18738: LIST
18739: LIST
18740: PPUSH
18741: CALL 0 0 2
18745: IFFALSE 18756
// MCT_CollectCrates ( side ) ;
18747: LD_VAR 0 4
18751: PPUSH
18752: CALL 7110 0 1
// end ;
18756: GO 17261
18758: POP
18759: POP
// end ;
18760: GO 17177
// end ;
18762: LD_VAR 0 2
18766: RET
// every 0 0$03 trigger mc_game_live do var i , j , un , side , b , v , c , e , f , k , x , y , all , eng , mech , sci , ct , tmp , at_war ;
18767: LD_EXP 32
18771: IFFALSE 21143
18773: GO 18775
18775: DISABLE
18776: LD_INT 0
18778: PPUSH
18779: PPUSH
18780: PPUSH
18781: PPUSH
18782: PPUSH
18783: PPUSH
18784: PPUSH
18785: PPUSH
18786: PPUSH
18787: PPUSH
18788: PPUSH
18789: PPUSH
18790: PPUSH
18791: PPUSH
18792: PPUSH
18793: PPUSH
18794: PPUSH
18795: PPUSH
18796: PPUSH
// begin enable ;
18797: ENABLE
// for i = 1 to 8 do
18798: LD_ADDR_VAR 0 1
18802: PUSH
18803: DOUBLE
18804: LD_INT 1
18806: DEC
18807: ST_TO_ADDR
18808: LD_INT 8
18810: PUSH
18811: FOR_TO
18812: IFFALSE 21141
// begin if MREG_SidesList [ i ] = 0 then
18814: LD_EXP 7
18818: PUSH
18819: LD_VAR 0 1
18823: ARRAY
18824: PUSH
18825: LD_INT 0
18827: EQUAL
18828: IFFALSE 18832
// continue ;
18830: GO 18811
// at_war := false ;
18832: LD_ADDR_VAR 0 19
18836: PUSH
18837: LD_INT 0
18839: ST_TO_ADDR
// if MREG_Heal [ i ] then
18840: LD_EXP 3
18844: PUSH
18845: LD_VAR 0 1
18849: ARRAY
18850: IFFALSE 18998
// begin if MCF_Class ( i , 4 , [ ] ) then
18852: LD_VAR 0 1
18856: PPUSH
18857: LD_INT 4
18859: PPUSH
18860: EMPTY
18861: PPUSH
18862: CALL 83 0 3
18866: IFFALSE 18996
// for j in MCF_Class ( i , 4 , [ ] ) do
18868: LD_ADDR_VAR 0 2
18872: PUSH
18873: LD_VAR 0 1
18877: PPUSH
18878: LD_INT 4
18880: PPUSH
18881: EMPTY
18882: PPUSH
18883: CALL 83 0 3
18887: PUSH
18888: FOR_IN
18889: IFFALSE 18994
// if not GetTag ( j ) = 4 then
18891: LD_VAR 0 2
18895: PPUSH
18896: CALL_OW 110
18900: PUSH
18901: LD_INT 4
18903: EQUAL
18904: NOT
18905: IFFALSE 18941
// begin SetTag ( j , 4 ) ;
18907: LD_VAR 0 2
18911: PPUSH
18912: LD_INT 4
18914: PPUSH
18915: CALL_OW 109
// if IsInUnit ( j ) then
18919: LD_VAR 0 2
18923: PPUSH
18924: CALL_OW 310
18928: IFFALSE 18939
// ComExitBuilding ( j ) ;
18930: LD_VAR 0 2
18934: PPUSH
18935: CALL_OW 122
// end else
18939: GO 18992
// if not WantHeal ( j , MREG_Heal [ i ] [ 1 ] ) then
18941: LD_VAR 0 2
18945: PPUSH
18946: LD_EXP 3
18950: PUSH
18951: LD_VAR 0 1
18955: ARRAY
18956: PUSH
18957: LD_INT 1
18959: ARRAY
18960: PPUSH
18961: CALL 25756 0 2
18965: NOT
18966: IFFALSE 18992
// MCP_Heal ( j , MREG_Heal [ i ] [ 1 ] ) ;
18968: LD_VAR 0 2
18972: PPUSH
18973: LD_EXP 3
18977: PUSH
18978: LD_VAR 0 1
18982: ARRAY
18983: PUSH
18984: LD_INT 1
18986: ARRAY
18987: PPUSH
18988: CALL 26712 0 2
18992: GO 18888
18994: POP
18995: POP
// end else
18996: GO 19230
// if MCF_Class ( i , 4 , [ ] ) and MCF_Tag ( i , 4 , [ ] ) then
18998: LD_VAR 0 1
19002: PPUSH
19003: LD_INT 4
19005: PPUSH
19006: EMPTY
19007: PPUSH
19008: CALL 83 0 3
19012: PUSH
19013: LD_VAR 0 1
19017: PPUSH
19018: LD_INT 4
19020: PPUSH
19021: EMPTY
19022: PPUSH
19023: CALL 703 0 3
19027: AND
19028: IFFALSE 19230
// for j in MCF_Class ( i , 4 , [ ] ) do
19030: LD_ADDR_VAR 0 2
19034: PUSH
19035: LD_VAR 0 1
19039: PPUSH
19040: LD_INT 4
19042: PPUSH
19043: EMPTY
19044: PPUSH
19045: CALL 83 0 3
19049: PUSH
19050: FOR_IN
19051: IFFALSE 19228
// begin if GetTag ( j ) = 4 then
19053: LD_VAR 0 2
19057: PPUSH
19058: CALL_OW 110
19062: PUSH
19063: LD_INT 4
19065: EQUAL
19066: IFFALSE 19226
// begin SetTag ( j , 0 ) ;
19068: LD_VAR 0 2
19072: PPUSH
19073: LD_INT 0
19075: PPUSH
19076: CALL_OW 109
// if MCF_Lab ( i ) and not MCL_GetTechList ( i ) then
19080: LD_VAR 0 1
19084: PPUSH
19085: CALL 39 0 1
19089: PUSH
19090: LD_VAR 0 1
19094: PPUSH
19095: CALL 14153 0 1
19099: NOT
19100: AND
19101: IFFALSE 19126
// ComEnterUnit ( j , MCF_Lab ( i ) [ 1 ] ) ;
19103: LD_VAR 0 2
19107: PPUSH
19108: LD_VAR 0 1
19112: PPUSH
19113: CALL 39 0 1
19117: PUSH
19118: LD_INT 1
19120: ARRAY
19121: PPUSH
19122: CALL_OW 120
// if not MCF_Lab ( i ) and MCF_Get ( i , [ f_btype , b_warehouse ] ) then
19126: LD_VAR 0 1
19130: PPUSH
19131: CALL 39 0 1
19135: NOT
19136: PUSH
19137: LD_VAR 0 1
19141: PPUSH
19142: LD_INT 30
19144: PUSH
19145: LD_INT 1
19147: PUSH
19148: EMPTY
19149: LIST
19150: LIST
19151: PPUSH
19152: CALL 0 0 2
19156: AND
19157: IFFALSE 19226
// ComMoveXY ( j , GetX ( MCF_Get ( i , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( i , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
19159: LD_VAR 0 2
19163: PPUSH
19164: LD_VAR 0 1
19168: PPUSH
19169: LD_INT 30
19171: PUSH
19172: LD_INT 1
19174: PUSH
19175: EMPTY
19176: LIST
19177: LIST
19178: PPUSH
19179: CALL 0 0 2
19183: PUSH
19184: LD_INT 1
19186: ARRAY
19187: PPUSH
19188: CALL_OW 250
19192: PPUSH
19193: LD_VAR 0 1
19197: PPUSH
19198: LD_INT 30
19200: PUSH
19201: LD_INT 1
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: PPUSH
19208: CALL 0 0 2
19212: PUSH
19213: LD_INT 1
19215: ARRAY
19216: PPUSH
19217: CALL_OW 251
19221: PPUSH
19222: CALL_OW 111
// end ; end ;
19226: GO 19050
19228: POP
19229: POP
// if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and not at_war and not MREG_Heal [ i ] and not MCL_GetTechList ( i ) and MCF_Class ( i , 4 , [ ] ) then
19230: LD_INT 1
19232: PPUSH
19233: LD_VAR 0 2
19237: PPUSH
19238: CALL_OW 255
19242: PPUSH
19243: CALL_OW 321
19247: PUSH
19248: LD_INT 2
19250: EQUAL
19251: PUSH
19252: LD_VAR 0 19
19256: NOT
19257: AND
19258: PUSH
19259: LD_EXP 3
19263: PUSH
19264: LD_VAR 0 1
19268: ARRAY
19269: NOT
19270: AND
19271: PUSH
19272: LD_VAR 0 1
19276: PPUSH
19277: CALL 14153 0 1
19281: NOT
19282: AND
19283: PUSH
19284: LD_VAR 0 1
19288: PPUSH
19289: LD_INT 4
19291: PPUSH
19292: EMPTY
19293: PPUSH
19294: CALL 83 0 3
19298: AND
19299: IFFALSE 19347
// for j in MCF_Class ( i , 4 , [ ] ) do
19301: LD_ADDR_VAR 0 2
19305: PUSH
19306: LD_VAR 0 1
19310: PPUSH
19311: LD_INT 4
19313: PPUSH
19314: EMPTY
19315: PPUSH
19316: CALL 83 0 3
19320: PUSH
19321: FOR_IN
19322: IFFALSE 19345
// MCN_Tame ( GetSide ( j ) , j ) ;
19324: LD_VAR 0 2
19328: PPUSH
19329: CALL_OW 255
19333: PPUSH
19334: LD_VAR 0 2
19338: PPUSH
19339: CALL 26044 0 2
19343: GO 19321
19345: POP
19346: POP
// if at_war then
19347: LD_VAR 0 19
19351: IFFALSE 19355
// begin end else
19353: GO 21139
// begin all := MCF_All ( i , [ ] ) ;
19355: LD_ADDR_VAR 0 13
19359: PUSH
19360: LD_VAR 0 1
19364: PPUSH
19365: EMPTY
19366: PPUSH
19367: CALL 135 0 2
19371: ST_TO_ADDR
// eng := MREG_ToDep [ i ] ;
19372: LD_ADDR_VAR 0 14
19376: PUSH
19377: LD_EXP 26
19381: PUSH
19382: LD_VAR 0 1
19386: ARRAY
19387: ST_TO_ADDR
// mech := MREG_ToFac [ i ] ;
19388: LD_ADDR_VAR 0 15
19392: PUSH
19393: LD_EXP 24
19397: PUSH
19398: LD_VAR 0 1
19402: ARRAY
19403: ST_TO_ADDR
// sci := MREG_ToLab [ i ] ;
19404: LD_ADDR_VAR 0 16
19408: PUSH
19409: LD_EXP 23
19413: PUSH
19414: LD_VAR 0 1
19418: ARRAY
19419: ST_TO_ADDR
// if not at_war and MREG_ToArm [ i ] then
19420: LD_VAR 0 19
19424: NOT
19425: PUSH
19426: LD_EXP 25
19430: PUSH
19431: LD_VAR 0 1
19435: ARRAY
19436: AND
19437: IFFALSE 19454
// MCF_RemoveClass ( i , ToArm , 1 ) ;
19439: LD_VAR 0 1
19443: PPUSH
19444: LD_STRING ToArm
19446: PPUSH
19447: LD_INT 1
19449: PPUSH
19450: CALL 2236 0 3
// if MCL_GetTechList ( i ) and MCF_Lab ( i ) and not MREG_Heal [ i ] then
19454: LD_VAR 0 1
19458: PPUSH
19459: CALL 14153 0 1
19463: PUSH
19464: LD_VAR 0 1
19468: PPUSH
19469: CALL 39 0 1
19473: AND
19474: PUSH
19475: LD_EXP 3
19479: PUSH
19480: LD_VAR 0 1
19484: ARRAY
19485: NOT
19486: AND
19487: IFFALSE 19919
// begin for j = 1 to MCF_Lab ( i ) do
19489: LD_ADDR_VAR 0 2
19493: PUSH
19494: DOUBLE
19495: LD_INT 1
19497: DEC
19498: ST_TO_ADDR
19499: LD_VAR 0 1
19503: PPUSH
19504: CALL 39 0 1
19508: PUSH
19509: FOR_TO
19510: IFFALSE 19570
// if BuildingStatus ( MCF_Lab ( i ) [ j ] ) in [ bs_working , bs_need_people ] then
19512: LD_VAR 0 1
19516: PPUSH
19517: CALL 39 0 1
19521: PUSH
19522: LD_VAR 0 2
19526: ARRAY
19527: PPUSH
19528: CALL_OW 461
19532: PUSH
19533: LD_INT 3
19535: PUSH
19536: LD_INT 6
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: IN
19543: IFFALSE 19568
// begin b := MCF_Lab ( i ) [ j ] ;
19545: LD_ADDR_VAR 0 5
19549: PUSH
19550: LD_VAR 0 1
19554: PPUSH
19555: CALL 39 0 1
19559: PUSH
19560: LD_VAR 0 2
19564: ARRAY
19565: ST_TO_ADDR
// break ;
19566: GO 19570
// end ;
19568: GO 19509
19570: POP
19571: POP
// if MCF_Class ( i , 4 , [ ] ) then
19572: LD_VAR 0 1
19576: PPUSH
19577: LD_INT 4
19579: PPUSH
19580: EMPTY
19581: PPUSH
19582: CALL 83 0 3
19586: IFFALSE 19761
// for j in MCF_Class ( i , 4 , [ ] ) do
19588: LD_ADDR_VAR 0 2
19592: PUSH
19593: LD_VAR 0 1
19597: PPUSH
19598: LD_INT 4
19600: PPUSH
19601: EMPTY
19602: PPUSH
19603: CALL 83 0 3
19607: PUSH
19608: FOR_IN
19609: IFFALSE 19759
// begin if GetTag ( j ) = 0 then
19611: LD_VAR 0 2
19615: PPUSH
19616: CALL_OW 110
19620: PUSH
19621: LD_INT 0
19623: EQUAL
19624: IFFALSE 19715
// begin if IsInUnit ( j ) and b then
19626: LD_VAR 0 2
19630: PPUSH
19631: CALL_OW 310
19635: PUSH
19636: LD_VAR 0 5
19640: AND
19641: IFFALSE 19689
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
19643: LD_VAR 0 2
19647: PPUSH
19648: CALL_OW 310
19652: PPUSH
19653: CALL_OW 461
19657: PUSH
19658: LD_INT 2
19660: EQUAL
19661: PUSH
19662: LD_VAR 0 2
19666: PPUSH
19667: CALL_OW 310
19671: PUSH
19672: LD_VAR 0 5
19676: NONEQUAL
19677: AND
19678: IFFALSE 19689
// ComExitBuilding ( j ) ;
19680: LD_VAR 0 2
19684: PPUSH
19685: CALL_OW 122
// if not IsInUnit ( j ) then
19689: LD_VAR 0 2
19693: PPUSH
19694: CALL_OW 310
19698: NOT
19699: IFFALSE 19715
// ComEnterUnit ( j , b ) ;
19701: LD_VAR 0 2
19705: PPUSH
19706: LD_VAR 0 5
19710: PPUSH
19711: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched then
19715: LD_INT 1
19717: PPUSH
19718: LD_VAR 0 2
19722: PPUSH
19723: CALL_OW 255
19727: PPUSH
19728: CALL_OW 321
19732: PUSH
19733: LD_INT 2
19735: EQUAL
19736: IFFALSE 19757
// MCN_Tame ( GetSide ( j ) , j ) ;
19738: LD_VAR 0 2
19742: PPUSH
19743: CALL_OW 255
19747: PPUSH
19748: LD_VAR 0 2
19752: PPUSH
19753: CALL 26044 0 2
// end ;
19757: GO 19608
19759: POP
19760: POP
// if all > 6 then
19761: LD_VAR 0 13
19765: PUSH
19766: LD_INT 6
19768: GREATER
19769: IFFALSE 19877
// begin if sci < 6 then
19771: LD_VAR 0 16
19775: PUSH
19776: LD_INT 6
19778: LESS
19779: IFFALSE 19875
// begin if MCF_Get ( i , [ f_btype , b_warehouse ] ) then
19781: LD_VAR 0 1
19785: PPUSH
19786: LD_INT 30
19788: PUSH
19789: LD_INT 1
19791: PUSH
19792: EMPTY
19793: LIST
19794: LIST
19795: PPUSH
19796: CALL 0 0 2
19800: IFFALSE 19817
// MCF_RemoveClass ( i , ToDep , 1 ) ;
19802: LD_VAR 0 1
19806: PPUSH
19807: LD_STRING ToDep
19809: PPUSH
19810: LD_INT 1
19812: PPUSH
19813: CALL 2236 0 3
// if MCF_Get ( i , [ f_btype , b_factory ] ) = 0 then
19817: LD_VAR 0 1
19821: PPUSH
19822: LD_INT 30
19824: PUSH
19825: LD_INT 3
19827: PUSH
19828: EMPTY
19829: LIST
19830: LIST
19831: PPUSH
19832: CALL 0 0 2
19836: PUSH
19837: LD_INT 0
19839: EQUAL
19840: IFFALSE 19857
// MCF_RemoveClass ( i , ToFac , 1 ) ;
19842: LD_VAR 0 1
19846: PPUSH
19847: LD_STRING ToFac
19849: PPUSH
19850: LD_INT 1
19852: PPUSH
19853: CALL 2236 0 3
// MCH_TrainScientist ( i , 6 - sci ) ;
19857: LD_VAR 0 1
19861: PPUSH
19862: LD_INT 6
19864: PUSH
19865: LD_VAR 0 16
19869: MINUS
19870: PPUSH
19871: CALL 23451 0 2
// end ; end else
19875: GO 19917
// if sci < all - 1 then
19877: LD_VAR 0 16
19881: PUSH
19882: LD_VAR 0 13
19886: PUSH
19887: LD_INT 1
19889: MINUS
19890: LESS
19891: IFFALSE 19917
// MCH_TrainScientist ( i , ( all - 1 ) - sci ) ;
19893: LD_VAR 0 1
19897: PPUSH
19898: LD_VAR 0 13
19902: PUSH
19903: LD_INT 1
19905: MINUS
19906: PUSH
19907: LD_VAR 0 16
19911: MINUS
19912: PPUSH
19913: CALL 23451 0 2
// end else
19917: GO 20013
// if MCL_GetTechList ( i ) = 0 then
19919: LD_VAR 0 1
19923: PPUSH
19924: CALL 14153 0 1
19928: PUSH
19929: LD_INT 0
19931: EQUAL
19932: IFFALSE 20013
// begin if all <= 6 then
19934: LD_VAR 0 13
19938: PUSH
19939: LD_INT 6
19941: LESSEQUAL
19942: IFFALSE 19961
// MCF_RemoveClass ( i , ToLab , 1 ) else
19944: LD_VAR 0 1
19948: PPUSH
19949: LD_STRING ToLab
19951: PPUSH
19952: LD_INT 1
19954: PPUSH
19955: CALL 2236 0 3
19959: GO 20013
// if all > 6 and all < 12 then
19961: LD_VAR 0 13
19965: PUSH
19966: LD_INT 6
19968: GREATER
19969: PUSH
19970: LD_VAR 0 13
19974: PUSH
19975: LD_INT 12
19977: LESS
19978: AND
19979: IFFALSE 19998
// MCF_RemoveClass ( i , ToLab , 2 ) else
19981: LD_VAR 0 1
19985: PPUSH
19986: LD_STRING ToLab
19988: PPUSH
19989: LD_INT 2
19991: PPUSH
19992: CALL 2236 0 3
19996: GO 20013
// MCF_RemoveClass ( i , ToLab , 3 ) ;
19998: LD_VAR 0 1
20002: PPUSH
20003: LD_STRING ToLab
20005: PPUSH
20006: LD_INT 3
20008: PPUSH
20009: CALL 2236 0 3
// end ; if MCF_Get ( i , [ f_btype , b_factory ] ) then
20013: LD_VAR 0 1
20017: PPUSH
20018: LD_INT 30
20020: PUSH
20021: LD_INT 3
20023: PUSH
20024: EMPTY
20025: LIST
20026: LIST
20027: PPUSH
20028: CALL 0 0 2
20032: IFFALSE 20584
// begin b := MCF_Get ( i , [ f_btype , b_factory ] ) [ 1 ] ;
20034: LD_ADDR_VAR 0 5
20038: PUSH
20039: LD_VAR 0 1
20043: PPUSH
20044: LD_INT 30
20046: PUSH
20047: LD_INT 3
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: PPUSH
20054: CALL 0 0 2
20058: PUSH
20059: LD_INT 1
20061: ARRAY
20062: ST_TO_ADDR
// if MCF_Class ( i , 3 , [ f_not , [ f_inside ] ] ) then
20063: LD_VAR 0 1
20067: PPUSH
20068: LD_INT 3
20070: PPUSH
20071: LD_INT 3
20073: PUSH
20074: LD_INT 54
20076: PUSH
20077: EMPTY
20078: LIST
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: PPUSH
20084: CALL 83 0 3
20088: IFFALSE 20157
// for j in MCF_Class ( i , 3 , [ f_not , [ f_inside ] ] ) do
20090: LD_ADDR_VAR 0 2
20094: PUSH
20095: LD_VAR 0 1
20099: PPUSH
20100: LD_INT 3
20102: PPUSH
20103: LD_INT 3
20105: PUSH
20106: LD_INT 54
20108: PUSH
20109: EMPTY
20110: LIST
20111: PUSH
20112: EMPTY
20113: LIST
20114: LIST
20115: PPUSH
20116: CALL 83 0 3
20120: PUSH
20121: FOR_IN
20122: IFFALSE 20155
// if GetTag ( j ) = 0 then
20124: LD_VAR 0 2
20128: PPUSH
20129: CALL_OW 110
20133: PUSH
20134: LD_INT 0
20136: EQUAL
20137: IFFALSE 20153
// ComEnterUnit ( j , b ) ;
20139: LD_VAR 0 2
20143: PPUSH
20144: LD_VAR 0 5
20148: PPUSH
20149: CALL_OW 120
20153: GO 20121
20155: POP
20156: POP
// if all - sci > 1 and BuildingStatus ( b ) = bs_need_people then
20157: LD_VAR 0 13
20161: PUSH
20162: LD_VAR 0 16
20166: MINUS
20167: PUSH
20168: LD_INT 1
20170: GREATER
20171: PUSH
20172: LD_VAR 0 5
20176: PPUSH
20177: CALL_OW 461
20181: PUSH
20182: LD_INT 6
20184: EQUAL
20185: AND
20186: IFFALSE 20298
// begin if mech < 6 then
20188: LD_VAR 0 15
20192: PUSH
20193: LD_INT 6
20195: LESS
20196: IFFALSE 20298
// begin if MCF_Get ( i , [ f_btype , b_warehouse ] ) then
20198: LD_VAR 0 1
20202: PPUSH
20203: LD_INT 30
20205: PUSH
20206: LD_INT 1
20208: PUSH
20209: EMPTY
20210: LIST
20211: LIST
20212: PPUSH
20213: CALL 0 0 2
20217: IFFALSE 20234
// MCF_RemoveClass ( i , ToDep , 2 ) ;
20219: LD_VAR 0 1
20223: PPUSH
20224: LD_STRING ToDep
20226: PPUSH
20227: LD_INT 2
20229: PPUSH
20230: CALL 2236 0 3
// if all - ( sci + 1 ) > 6 then
20234: LD_VAR 0 13
20238: PUSH
20239: LD_VAR 0 16
20243: PUSH
20244: LD_INT 1
20246: PLUS
20247: MINUS
20248: PUSH
20249: LD_INT 6
20251: GREATER
20252: IFFALSE 20264
// v := 6 else
20254: LD_ADDR_VAR 0 6
20258: PUSH
20259: LD_INT 6
20261: ST_TO_ADDR
20262: GO 20284
// v := all - ( sci + 1 ) ;
20264: LD_ADDR_VAR 0 6
20268: PUSH
20269: LD_VAR 0 13
20273: PUSH
20274: LD_VAR 0 16
20278: PUSH
20279: LD_INT 1
20281: PLUS
20282: MINUS
20283: ST_TO_ADDR
// MCH_TrainMechanic ( i , v ) ;
20284: LD_VAR 0 1
20288: PPUSH
20289: LD_VAR 0 6
20293: PPUSH
20294: CALL 23213 0 2
// end ; end ; ct := MCF_Get ( i , [ f_btype , b_control_tower ] ) ;
20298: LD_ADDR_VAR 0 17
20302: PUSH
20303: LD_VAR 0 1
20307: PPUSH
20308: LD_INT 30
20310: PUSH
20311: LD_INT 36
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: PPUSH
20318: CALL 0 0 2
20322: ST_TO_ADDR
// if ct and mech and MCF_Class ( i , 3 , [ ] ) then
20323: LD_VAR 0 17
20327: PUSH
20328: LD_VAR 0 15
20332: AND
20333: PUSH
20334: LD_VAR 0 1
20338: PPUSH
20339: LD_INT 3
20341: PPUSH
20342: EMPTY
20343: PPUSH
20344: CALL 83 0 3
20348: AND
20349: IFFALSE 20491
// if MCF_Tag ( i , 9 , [ ] ) < 3 then
20351: LD_VAR 0 1
20355: PPUSH
20356: LD_INT 9
20358: PPUSH
20359: EMPTY
20360: PPUSH
20361: CALL 703 0 3
20365: PUSH
20366: LD_INT 3
20368: LESS
20369: IFFALSE 20491
// begin if mech < 3 then
20371: LD_VAR 0 15
20375: PUSH
20376: LD_INT 3
20378: LESS
20379: IFFALSE 20393
// f := mech else
20381: LD_ADDR_VAR 0 9
20385: PUSH
20386: LD_VAR 0 15
20390: ST_TO_ADDR
20391: GO 20401
// f := 3 ;
20393: LD_ADDR_VAR 0 9
20397: PUSH
20398: LD_INT 3
20400: ST_TO_ADDR
// for c = 1 to f do
20401: LD_ADDR_VAR 0 7
20405: PUSH
20406: DOUBLE
20407: LD_INT 1
20409: DEC
20410: ST_TO_ADDR
20411: LD_VAR 0 9
20415: PUSH
20416: FOR_TO
20417: IFFALSE 20475
// if GetClass ( mech [ c ] ) = 3 then
20419: LD_VAR 0 15
20423: PUSH
20424: LD_VAR 0 7
20428: ARRAY
20429: PPUSH
20430: CALL_OW 257
20434: PUSH
20435: LD_INT 3
20437: EQUAL
20438: IFFALSE 20473
// begin SetTag ( mech [ c ] , 9 ) ;
20440: LD_VAR 0 15
20444: PUSH
20445: LD_VAR 0 7
20449: ARRAY
20450: PPUSH
20451: LD_INT 9
20453: PPUSH
20454: CALL_OW 109
// ComExitBuilding ( mech [ c ] ) ;
20458: LD_VAR 0 15
20462: PUSH
20463: LD_VAR 0 7
20467: ARRAY
20468: PPUSH
20469: CALL_OW 122
// end ;
20473: GO 20416
20475: POP
20476: POP
// MCH_TrainMechanic ( i , f ) ;
20477: LD_VAR 0 1
20481: PPUSH
20482: LD_VAR 0 9
20486: PPUSH
20487: CALL 23213 0 2
// end ; if MCF_Tag ( i , 9 , [ ] ) then
20491: LD_VAR 0 1
20495: PPUSH
20496: LD_INT 9
20498: PPUSH
20499: EMPTY
20500: PPUSH
20501: CALL 703 0 3
20505: IFFALSE 20584
// for c in MCF_Tag ( i , 9 , [ ] ) do
20507: LD_ADDR_VAR 0 7
20511: PUSH
20512: LD_VAR 0 1
20516: PPUSH
20517: LD_INT 9
20519: PPUSH
20520: EMPTY
20521: PPUSH
20522: CALL 703 0 3
20526: PUSH
20527: FOR_IN
20528: IFFALSE 20582
// if not IsInUnit ( c ) then
20530: LD_VAR 0 7
20534: PPUSH
20535: CALL_OW 310
20539: NOT
20540: IFFALSE 20580
// if ct then
20542: LD_VAR 0 17
20546: IFFALSE 20568
// ComEnterUnit ( c , ct [ 1 ] ) else
20548: LD_VAR 0 7
20552: PPUSH
20553: LD_VAR 0 17
20557: PUSH
20558: LD_INT 1
20560: ARRAY
20561: PPUSH
20562: CALL_OW 120
20566: GO 20580
// SetTag ( c , 0 ) ;
20568: LD_VAR 0 7
20572: PPUSH
20573: LD_INT 0
20575: PPUSH
20576: CALL_OW 109
20580: GO 20527
20582: POP
20583: POP
// end ; if MCF_Class ( i , 3 , [ ] ) and MREG_Parking [ i ] then
20584: LD_VAR 0 1
20588: PPUSH
20589: LD_INT 3
20591: PPUSH
20592: EMPTY
20593: PPUSH
20594: CALL 83 0 3
20598: PUSH
20599: LD_EXP 27
20603: PUSH
20604: LD_VAR 0 1
20608: ARRAY
20609: AND
20610: IFFALSE 20895
// begin x := AreaToList ( MREG_Parking [ i ] , 0 ) [ 1 ] [ 1 ] ;
20612: LD_ADDR_VAR 0 11
20616: PUSH
20617: LD_EXP 27
20621: PUSH
20622: LD_VAR 0 1
20626: ARRAY
20627: PPUSH
20628: LD_INT 0
20630: PPUSH
20631: CALL_OW 517
20635: PUSH
20636: LD_INT 1
20638: ARRAY
20639: PUSH
20640: LD_INT 1
20642: ARRAY
20643: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ i ] , 0 ) [ 2 ] [ 1 ] ;
20644: LD_ADDR_VAR 0 12
20648: PUSH
20649: LD_EXP 27
20653: PUSH
20654: LD_VAR 0 1
20658: ARRAY
20659: PPUSH
20660: LD_INT 0
20662: PPUSH
20663: CALL_OW 517
20667: PUSH
20668: LD_INT 2
20670: ARRAY
20671: PUSH
20672: LD_INT 1
20674: ARRAY
20675: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
20676: LD_VAR 0 4
20680: PPUSH
20681: LD_INT 6
20683: PPUSH
20684: LD_INT 92
20686: PUSH
20687: LD_VAR 0 11
20691: PUSH
20692: LD_VAR 0 12
20696: PUSH
20697: LD_INT 10
20699: PUSH
20700: EMPTY
20701: LIST
20702: LIST
20703: LIST
20704: LIST
20705: PPUSH
20706: CALL 703 0 3
20710: IFFALSE 20895
// begin if MCF_Class ( i , 3 , [ ] ) then
20712: LD_VAR 0 1
20716: PPUSH
20717: LD_INT 3
20719: PPUSH
20720: EMPTY
20721: PPUSH
20722: CALL 83 0 3
20726: IFFALSE 20782
// for k in MCF_Class ( i , 3 , [ ] ) do
20728: LD_ADDR_VAR 0 10
20732: PUSH
20733: LD_VAR 0 1
20737: PPUSH
20738: LD_INT 3
20740: PPUSH
20741: EMPTY
20742: PPUSH
20743: CALL 83 0 3
20747: PUSH
20748: FOR_IN
20749: IFFALSE 20780
// if GetTag ( k ) = 0 then
20751: LD_VAR 0 10
20755: PPUSH
20756: CALL_OW 110
20760: PUSH
20761: LD_INT 0
20763: EQUAL
20764: IFFALSE 20778
// SetTag ( k , 8 ) ;
20766: LD_VAR 0 10
20770: PPUSH
20771: LD_INT 8
20773: PPUSH
20774: CALL_OW 109
20778: GO 20748
20780: POP
20781: POP
// if MCF_Tag ( i , 8 , [ ] ) then
20782: LD_VAR 0 1
20786: PPUSH
20787: LD_INT 8
20789: PPUSH
20790: EMPTY
20791: PPUSH
20792: CALL 703 0 3
20796: IFFALSE 20895
// for j in MCF_Tag ( i , 8 , [ ] ) do
20798: LD_ADDR_VAR 0 2
20802: PUSH
20803: LD_VAR 0 1
20807: PPUSH
20808: LD_INT 8
20810: PPUSH
20811: EMPTY
20812: PPUSH
20813: CALL 703 0 3
20817: PUSH
20818: FOR_IN
20819: IFFALSE 20893
// if IsInUnit ( j ) then
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 310
20830: IFFALSE 20843
// ComExitBuilding ( j ) else
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 122
20841: GO 20891
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
20843: LD_VAR 0 2
20847: PPUSH
20848: LD_VAR 0 4
20852: PPUSH
20853: LD_INT 6
20855: PPUSH
20856: LD_INT 92
20858: PUSH
20859: LD_VAR 0 11
20863: PUSH
20864: LD_VAR 0 12
20868: PUSH
20869: LD_INT 10
20871: PUSH
20872: EMPTY
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: PPUSH
20878: CALL 703 0 3
20882: PUSH
20883: LD_INT 1
20885: ARRAY
20886: PPUSH
20887: CALL_OW 129
20891: GO 20818
20893: POP
20894: POP
// end ; end ; if MCF_Tag ( i , 8 , [ ] ) and not MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
20895: LD_VAR 0 1
20899: PPUSH
20900: LD_INT 8
20902: PPUSH
20903: EMPTY
20904: PPUSH
20905: CALL 703 0 3
20909: PUSH
20910: LD_VAR 0 4
20914: PPUSH
20915: LD_INT 6
20917: PPUSH
20918: LD_INT 92
20920: PUSH
20921: LD_VAR 0 11
20925: PUSH
20926: LD_VAR 0 12
20930: PUSH
20931: LD_INT 10
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: LIST
20938: LIST
20939: PPUSH
20940: CALL 703 0 3
20944: NOT
20945: AND
20946: IFFALSE 20975
// MCF_SetTag ( i , MCF_Tag ( i , 8 , [ ] ) , 0 ) ;
20948: LD_VAR 0 1
20952: PPUSH
20953: LD_VAR 0 1
20957: PPUSH
20958: LD_INT 8
20960: PPUSH
20961: EMPTY
20962: PPUSH
20963: CALL 703 0 3
20967: PPUSH
20968: LD_INT 0
20970: PPUSH
20971: CALL 835 0 3
// if MCF_Get ( i , [ f_btype , b_warehouse ] ) then
20975: LD_VAR 0 1
20979: PPUSH
20980: LD_INT 30
20982: PUSH
20983: LD_INT 1
20985: PUSH
20986: EMPTY
20987: LIST
20988: LIST
20989: PPUSH
20990: CALL 0 0 2
20994: IFFALSE 21139
// begin b := MCF_Get ( i , [ f_btype , b_warehouse ] ) ;
20996: LD_ADDR_VAR 0 5
21000: PUSH
21001: LD_VAR 0 1
21005: PPUSH
21006: LD_INT 30
21008: PUSH
21009: LD_INT 1
21011: PUSH
21012: EMPTY
21013: LIST
21014: LIST
21015: PPUSH
21016: CALL 0 0 2
21020: ST_TO_ADDR
// if BuildingStatus ( b ) <> bs_build then
21021: LD_VAR 0 5
21025: PPUSH
21026: CALL_OW 461
21030: PUSH
21031: LD_INT 1
21033: NONEQUAL
21034: IFFALSE 21139
// begin if eng < all - sci - mech then
21036: LD_VAR 0 14
21040: PUSH
21041: LD_VAR 0 13
21045: PUSH
21046: LD_VAR 0 16
21050: MINUS
21051: PUSH
21052: LD_VAR 0 15
21056: MINUS
21057: LESS
21058: IFFALSE 21086
// MCH_TrainEngineer ( i , all - sci - mech ) ;
21060: LD_VAR 0 1
21064: PPUSH
21065: LD_VAR 0 13
21069: PUSH
21070: LD_VAR 0 16
21074: MINUS
21075: PUSH
21076: LD_VAR 0 15
21080: MINUS
21081: PPUSH
21082: CALL 22975 0 2
// if UnitsInside ( b ) and MCF_UnfinishedBuilding ( i ) then
21086: LD_VAR 0 5
21090: PPUSH
21091: CALL_OW 313
21095: PUSH
21096: LD_VAR 0 1
21100: PPUSH
21101: CALL 3098 0 1
21105: AND
21106: IFFALSE 21139
// for e in UnitsInside ( b ) do
21108: LD_ADDR_VAR 0 8
21112: PUSH
21113: LD_VAR 0 5
21117: PPUSH
21118: CALL_OW 313
21122: PUSH
21123: FOR_IN
21124: IFFALSE 21137
// ComExitBuilding ( e ) ;
21126: LD_VAR 0 8
21130: PPUSH
21131: CALL_OW 122
21135: GO 21123
21137: POP
21138: POP
// end ; end ; end ; end ;
21139: GO 18811
21141: POP
21142: POP
// end ; end_of_file
21143: PPOPN 19
21145: END
// on SailEvent ( event ) do begin if isEditor then
21146: LD_INT 1
21148: IFFALSE 21159
// MC_Show ( event ) ;
21150: LD_VAR 0 1
21154: PPUSH
21155: CALL 3890 0 1
// end ;
21159: PPOPN 1
21161: END
// on BuildingStarted ( b , unit ) do var side , i ;
21162: LD_INT 0
21164: PPUSH
21165: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
21166: LD_EXP 7
21170: PUSH
21171: LD_VAR 0 1
21175: PPUSH
21176: CALL_OW 255
21180: ARRAY
21181: IFFALSE 21312
// begin side := GetSide ( b ) ;
21183: LD_ADDR_VAR 0 3
21187: PUSH
21188: LD_VAR 0 1
21192: PPUSH
21193: CALL_OW 255
21197: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
21198: LD_VAR 0 3
21202: PPUSH
21203: LD_INT 21
21205: PUSH
21206: LD_INT 3
21208: PUSH
21209: EMPTY
21210: LIST
21211: LIST
21212: PPUSH
21213: CALL 0 0 2
21217: PUSH
21218: LD_INT 1
21220: EQUAL
21221: IFFALSE 21312
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
21223: LD_ADDR_VAR 0 4
21227: PUSH
21228: LD_VAR 0 3
21232: PPUSH
21233: LD_INT 21
21235: PUSH
21236: LD_INT 1
21238: PUSH
21239: EMPTY
21240: LIST
21241: LIST
21242: PPUSH
21243: CALL 0 0 2
21247: PUSH
21248: LD_VAR 0 3
21252: PPUSH
21253: LD_INT 2
21255: PPUSH
21256: EMPTY
21257: PPUSH
21258: CALL 83 0 3
21262: DIFF
21263: PUSH
21264: FOR_IN
21265: IFFALSE 21310
// if not HasTask ( i ) then
21267: LD_VAR 0 4
21271: PPUSH
21272: CALL_OW 314
21276: NOT
21277: IFFALSE 21308
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
21279: LD_VAR 0 4
21283: PPUSH
21284: LD_VAR 0 1
21288: PPUSH
21289: CALL_OW 250
21293: PPUSH
21294: LD_VAR 0 1
21298: PPUSH
21299: CALL_OW 251
21303: PPUSH
21304: CALL_OW 111
21308: GO 21264
21310: POP
21311: POP
// end ;
21312: PPOPN 4
21314: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
21315: LD_EXP 7
21319: PUSH
21320: LD_VAR 0 1
21324: PPUSH
21325: CALL_OW 255
21329: ARRAY
21330: IFFALSE 21662
// begin MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
21332: LD_ADDR_EXP 15
21336: PUSH
21337: LD_EXP 15
21341: PPUSH
21342: LD_VAR 0 1
21346: PPUSH
21347: CALL_OW 255
21351: PPUSH
21352: LD_VAR 0 1
21356: PPUSH
21357: CALL_OW 266
21361: PPUSH
21362: LD_VAR 0 1
21366: PPUSH
21367: CALL_OW 250
21371: PUSH
21372: LD_VAR 0 1
21376: PPUSH
21377: CALL_OW 251
21381: PUSH
21382: LD_VAR 0 1
21386: PPUSH
21387: CALL_OW 254
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: LIST
21396: PPUSH
21397: CALL 4215 0 4
21401: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
21402: LD_VAR 0 1
21406: PPUSH
21407: CALL_OW 266
21411: PUSH
21412: LD_INT 6
21414: EQUAL
21415: IFFALSE 21449
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
21417: LD_ADDR_EXP 8
21421: PUSH
21422: LD_EXP 8
21426: PPUSH
21427: LD_VAR 0 1
21431: PPUSH
21432: CALL_OW 255
21436: PPUSH
21437: LD_VAR 0 1
21441: PPUSH
21442: EMPTY
21443: PPUSH
21444: CALL 4124 0 4
21448: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
21449: LD_VAR 0 1
21453: PPUSH
21454: CALL_OW 266
21458: PUSH
21459: LD_INT 0
21461: EQUAL
21462: IFFALSE 21572
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
21464: LD_ADDR_EXP 17
21468: PUSH
21469: LD_EXP 17
21473: PPUSH
21474: LD_VAR 0 1
21478: PPUSH
21479: CALL_OW 255
21483: PPUSH
21484: LD_INT 0
21486: PPUSH
21487: EMPTY
21488: PPUSH
21489: CALL 4124 0 4
21493: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
21494: LD_VAR 0 1
21498: PPUSH
21499: CALL_OW 274
21503: PPUSH
21504: LD_INT 1
21506: PPUSH
21507: LD_EXP 31
21511: PUSH
21512: LD_INT 1
21514: ARRAY
21515: PPUSH
21516: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
21520: LD_VAR 0 1
21524: PPUSH
21525: CALL_OW 274
21529: PPUSH
21530: LD_INT 2
21532: PPUSH
21533: LD_EXP 31
21537: PUSH
21538: LD_INT 2
21540: ARRAY
21541: PPUSH
21542: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
21546: LD_VAR 0 1
21550: PPUSH
21551: CALL_OW 274
21555: PPUSH
21556: LD_INT 3
21558: PPUSH
21559: LD_EXP 31
21563: PUSH
21564: LD_INT 3
21566: ARRAY
21567: PPUSH
21568: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
21572: LD_VAR 0 1
21576: PPUSH
21577: CALL_OW 266
21581: PUSH
21582: LD_INT 2
21584: EQUAL
21585: IFFALSE 21617
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
21587: LD_ADDR_EXP 17
21591: PUSH
21592: LD_EXP 17
21596: PPUSH
21597: LD_VAR 0 1
21601: PPUSH
21602: CALL_OW 255
21606: PPUSH
21607: LD_INT 2
21609: PPUSH
21610: EMPTY
21611: PPUSH
21612: CALL 4124 0 4
21616: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
21617: LD_VAR 0 1
21621: PPUSH
21622: CALL_OW 266
21626: PUSH
21627: LD_INT 4
21629: EQUAL
21630: IFFALSE 21662
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
21632: LD_ADDR_EXP 17
21636: PUSH
21637: LD_EXP 17
21641: PPUSH
21642: LD_VAR 0 1
21646: PPUSH
21647: CALL_OW 255
21651: PPUSH
21652: LD_INT 4
21654: PPUSH
21655: EMPTY
21656: PPUSH
21657: CALL 4124 0 4
21661: ST_TO_ADDR
// end ;
21662: PPOPN 1
21664: END
// on ResearchComplete ( tech , lab ) do var i ;
21665: LD_INT 0
21667: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
21668: LD_EXP 7
21672: PUSH
21673: LD_VAR 0 2
21677: PPUSH
21678: CALL_OW 255
21682: ARRAY
21683: IFFALSE 21930
// begin for i = 1 to MREG_ToRes do
21685: LD_ADDR_VAR 0 3
21689: PUSH
21690: DOUBLE
21691: LD_INT 1
21693: DEC
21694: ST_TO_ADDR
21695: LD_EXP 19
21699: PUSH
21700: FOR_TO
21701: IFFALSE 21788
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
21703: LD_EXP 19
21707: PUSH
21708: LD_VAR 0 3
21712: ARRAY
21713: PUSH
21714: LD_INT 1
21716: ARRAY
21717: PUSH
21718: LD_VAR 0 2
21722: PPUSH
21723: CALL_OW 255
21727: EQUAL
21728: PUSH
21729: LD_EXP 19
21733: PUSH
21734: LD_VAR 0 3
21738: ARRAY
21739: PUSH
21740: LD_INT 2
21742: ARRAY
21743: PUSH
21744: LD_VAR 0 1
21748: EQUAL
21749: AND
21750: IFFALSE 21786
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
21752: LD_ADDR_EXP 19
21756: PUSH
21757: LD_EXP 19
21761: PPUSH
21762: LD_VAR 0 2
21766: PPUSH
21767: CALL_OW 255
21771: PPUSH
21772: LD_VAR 0 1
21776: PPUSH
21777: EMPTY
21778: PPUSH
21779: CALL 4215 0 4
21783: ST_TO_ADDR
// break ;
21784: GO 21788
// end ;
21786: GO 21700
21788: POP
21789: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
21790: LD_VAR 0 1
21794: PUSH
21795: LD_INT 2
21797: PUSH
21798: LD_INT 11
21800: PUSH
21801: LD_INT 4
21803: PUSH
21804: LD_INT 3
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: LIST
21812: IN
21813: IFFALSE 21930
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
21815: LD_ADDR_VAR 0 3
21819: PUSH
21820: LD_VAR 0 2
21824: PPUSH
21825: CALL_OW 255
21829: PPUSH
21830: LD_INT 16
21832: PPUSH
21833: LD_INT 25
21835: PUSH
21836: LD_INT 4
21838: PUSH
21839: EMPTY
21840: LIST
21841: LIST
21842: PPUSH
21843: CALL 703 0 3
21847: ST_TO_ADDR
// if i then
21848: LD_VAR 0 3
21852: IFFALSE 21870
// SetTag ( i [ 1 ] , 0 ) ;
21854: LD_VAR 0 3
21858: PUSH
21859: LD_INT 1
21861: ARRAY
21862: PPUSH
21863: LD_INT 0
21865: PPUSH
21866: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_VAR 0 2
21879: PPUSH
21880: CALL_OW 255
21884: PPUSH
21885: LD_INT 171
21887: PPUSH
21888: EMPTY
21889: PPUSH
21890: CALL 703 0 3
21894: ST_TO_ADDR
// if i then
21895: LD_VAR 0 3
21899: IFFALSE 21930
// begin SetTag ( i [ 1 ] , 0 ) ;
21901: LD_VAR 0 3
21905: PUSH
21906: LD_INT 1
21908: ARRAY
21909: PPUSH
21910: LD_INT 0
21912: PPUSH
21913: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
21917: LD_VAR 0 3
21921: PUSH
21922: LD_INT 1
21924: ARRAY
21925: PPUSH
21926: CALL_OW 122
// end ; end ; end ;
21930: PPOPN 3
21932: END
// on VehicleConstructed ( veh , b ) do var i , side ;
21933: LD_INT 0
21935: PPUSH
21936: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
21937: LD_EXP 7
21941: PUSH
21942: LD_VAR 0 2
21946: PPUSH
21947: CALL_OW 255
21951: ARRAY
21952: IFFALSE 22103
// begin side := GetSide ( veh ) ;
21954: LD_ADDR_VAR 0 4
21958: PUSH
21959: LD_VAR 0 1
21963: PPUSH
21964: CALL_OW 255
21968: ST_TO_ADDR
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
21969: LD_VAR 0 1
21973: PPUSH
21974: CALL_OW 264
21978: PUSH
21979: LD_INT 13
21981: PUSH
21982: LD_INT 12
21984: PUSH
21985: LD_INT 14
21987: PUSH
21988: LD_INT 51
21990: PUSH
21991: LD_INT 53
21993: PUSH
21994: LD_INT 52
21996: PUSH
21997: LD_INT 32
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: LIST
22004: LIST
22005: LIST
22006: LIST
22007: LIST
22008: IN
22009: NOT
22010: IFFALSE 22052
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
22012: LD_ADDR_EXP 28
22016: PUSH
22017: LD_EXP 28
22021: PPUSH
22022: LD_VAR 0 4
22026: PPUSH
22027: LD_EXP 28
22031: PUSH
22032: LD_VAR 0 4
22036: ARRAY
22037: PUSH
22038: LD_INT 1
22040: PLUS
22041: PPUSH
22042: LD_VAR 0 1
22046: PPUSH
22047: CALL 24454 0 4
22051: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
22052: LD_VAR 0 1
22056: PPUSH
22057: CALL_OW 264
22061: PUSH
22062: LD_INT 31
22064: EQUAL
22065: IFFALSE 22084
// SetTag ( GetDriver ( veh ) , 9 ) ;
22067: LD_VAR 0 1
22071: PPUSH
22072: CALL 25065 0 1
22076: PPUSH
22077: LD_INT 9
22079: PPUSH
22080: CALL_OW 109
// MCV_Parking ( GetSide ( veh ) , veh ) ;
22084: LD_VAR 0 1
22088: PPUSH
22089: CALL_OW 255
22093: PPUSH
22094: LD_VAR 0 1
22098: PPUSH
22099: CALL 14848 0 2
// end ;
22103: PPOPN 4
22105: END
// on ApemanTamed ( ape , unit ) do begin if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
22106: LD_INT 11
22108: PPUSH
22109: LD_VAR 0 2
22113: PPUSH
22114: CALL_OW 255
22118: PPUSH
22119: CALL_OW 321
22123: PUSH
22124: LD_INT 2
22126: EQUAL
22127: NOT
22128: PUSH
22129: LD_INT 2
22131: PPUSH
22132: LD_VAR 0 2
22136: PPUSH
22137: CALL_OW 255
22141: PPUSH
22142: CALL_OW 321
22146: PUSH
22147: LD_INT 2
22149: EQUAL
22150: NOT
22151: OR
22152: PUSH
22153: LD_VAR 0 2
22157: PPUSH
22158: CALL_OW 255
22162: PPUSH
22163: LD_INT 171
22165: PPUSH
22166: EMPTY
22167: PPUSH
22168: CALL 703 0 3
22172: PUSH
22173: LD_INT 0
22175: EQUAL
22176: AND
22177: IFFALSE 22191
// begin SetTag ( ape , 171 ) ;
22179: LD_VAR 0 1
22183: PPUSH
22184: LD_INT 171
22186: PPUSH
22187: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
22191: LD_VAR 0 2
22195: PPUSH
22196: CALL_OW 255
22200: PPUSH
22201: LD_INT 30
22203: PUSH
22204: LD_INT 1
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: PPUSH
22211: CALL 0 0 2
22215: IFFALSE 22294
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
22217: LD_VAR 0 1
22221: PPUSH
22222: LD_VAR 0 2
22226: PPUSH
22227: CALL_OW 255
22231: PPUSH
22232: LD_INT 30
22234: PUSH
22235: LD_INT 1
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PPUSH
22242: CALL 0 0 2
22246: PUSH
22247: LD_INT 1
22249: ARRAY
22250: PPUSH
22251: CALL_OW 250
22255: PPUSH
22256: LD_VAR 0 2
22260: PPUSH
22261: CALL_OW 255
22265: PPUSH
22266: LD_INT 30
22268: PUSH
22269: LD_INT 1
22271: PUSH
22272: EMPTY
22273: LIST
22274: LIST
22275: PPUSH
22276: CALL 0 0 2
22280: PUSH
22281: LD_INT 1
22283: ARRAY
22284: PPUSH
22285: CALL_OW 251
22289: PPUSH
22290: CALL_OW 111
// end ;
22294: PPOPN 2
22296: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
22297: LD_EXP 7
22301: PUSH
22302: LD_VAR 0 1
22306: PPUSH
22307: CALL_OW 255
22311: ARRAY
22312: IFFALSE 22484
// begin if un in MCF_Ape ( GetSide ( un ) ) then
22314: LD_VAR 0 2
22318: PUSH
22319: LD_VAR 0 2
22323: PPUSH
22324: CALL_OW 255
22328: PPUSH
22329: CALL 413 0 1
22333: IN
22334: IFFALSE 22484
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
22336: LD_VAR 0 1
22340: PPUSH
22341: CALL_OW 266
22345: PUSH
22346: LD_INT 0
22348: PUSH
22349: LD_INT 1
22351: PUSH
22352: EMPTY
22353: LIST
22354: LIST
22355: IN
22356: IFFALSE 22386
// begin Wait ( 0 0$0.3 ) ;
22358: LD_INT 10
22360: PPUSH
22361: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
22365: LD_VAR 0 2
22369: PPUSH
22370: LD_INT 16
22372: PPUSH
22373: CALL_OW 336
// ComExitBuilding ( un ) ;
22377: LD_VAR 0 2
22381: PPUSH
22382: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
22386: LD_VAR 0 1
22390: PPUSH
22391: CALL_OW 266
22395: PUSH
22396: LD_INT 4
22398: PUSH
22399: LD_INT 5
22401: PUSH
22402: EMPTY
22403: LIST
22404: LIST
22405: IN
22406: IFFALSE 22484
// begin Wait ( 0 0$0.3 ) ;
22408: LD_INT 10
22410: PPUSH
22411: CALL_OW 67
// if GetTag ( un ) = 0 then
22415: LD_VAR 0 2
22419: PPUSH
22420: CALL_OW 110
22424: PUSH
22425: LD_INT 0
22427: EQUAL
22428: IFFALSE 22444
// SetClass ( un , class_apeman_soldier ) else
22430: LD_VAR 0 2
22434: PPUSH
22435: LD_INT 15
22437: PPUSH
22438: CALL_OW 336
22442: GO 22475
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
22444: LD_INT 3
22446: PPUSH
22447: LD_VAR 0 2
22451: PPUSH
22452: CALL_OW 255
22456: PPUSH
22457: CALL_OW 321
22461: IFFALSE 22475
// SetClass ( un , class_apeman_kamikaze ) ;
22463: LD_VAR 0 2
22467: PPUSH
22468: LD_INT 17
22470: PPUSH
22471: CALL_OW 336
// ComExitBuilding ( un ) ;
22475: LD_VAR 0 2
22479: PPUSH
22480: CALL_OW 122
// end ; end ; end ;
22484: PPOPN 2
22486: END
// on UnitDestroyed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
22487: LD_EXP 7
22491: PUSH
22492: LD_VAR 0 1
22496: PPUSH
22497: CALL_OW 255
22501: ARRAY
22502: IFFALSE 22690
// begin if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
22504: LD_VAR 0 1
22508: PUSH
22509: LD_VAR 0 1
22513: PPUSH
22514: CALL_OW 255
22518: PPUSH
22519: LD_INT 21
22521: PUSH
22522: LD_INT 1
22524: PUSH
22525: EMPTY
22526: LIST
22527: LIST
22528: PPUSH
22529: CALL 0 0 2
22533: IN
22534: IFFALSE 22690
// begin if MCF_HasClass ( un ) then
22536: LD_VAR 0 1
22540: PPUSH
22541: CALL 2554 0 1
22545: IFFALSE 22690
// case MCF_HasClass ( un ) of 1 :
22547: LD_VAR 0 1
22551: PPUSH
22552: CALL 2554 0 1
22556: PUSH
22557: LD_INT 1
22559: DOUBLE
22560: EQUAL
22561: IFTRUE 22565
22563: GO 22590
22565: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
22566: LD_VAR 0 1
22570: PPUSH
22571: CALL_OW 255
22575: PPUSH
22576: LD_STRING ToArm
22578: PPUSH
22579: LD_VAR 0 1
22583: PPUSH
22584: CALL 2701 0 3
22588: GO 22690
22590: LD_INT 2
22592: DOUBLE
22593: EQUAL
22594: IFTRUE 22598
22596: GO 22623
22598: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
22599: LD_VAR 0 1
22603: PPUSH
22604: CALL_OW 255
22608: PPUSH
22609: LD_STRING ToDep
22611: PPUSH
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL 2701 0 3
22621: GO 22690
22623: LD_INT 3
22625: DOUBLE
22626: EQUAL
22627: IFTRUE 22631
22629: GO 22656
22631: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
22632: LD_VAR 0 1
22636: PPUSH
22637: CALL_OW 255
22641: PPUSH
22642: LD_STRING ToFac
22644: PPUSH
22645: LD_VAR 0 1
22649: PPUSH
22650: CALL 2701 0 3
22654: GO 22690
22656: LD_INT 4
22658: DOUBLE
22659: EQUAL
22660: IFTRUE 22664
22662: GO 22689
22664: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
22665: LD_VAR 0 1
22669: PPUSH
22670: CALL_OW 255
22674: PPUSH
22675: LD_STRING ToLab
22677: PPUSH
22678: LD_VAR 0 1
22682: PPUSH
22683: CALL 2701 0 3
22687: GO 22690
22689: POP
// end ; end ;
22690: PPOPN 1
22692: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
22693: LD_EXP 7
22697: PUSH
22698: LD_VAR 0 1
22702: PPUSH
22703: CALL_OW 255
22707: ARRAY
22708: IFFALSE 22734
// begin if GetControl ( un ) = control_remote then
22710: LD_VAR 0 1
22714: PPUSH
22715: CALL_OW 263
22719: PUSH
22720: LD_INT 2
22722: EQUAL
22723: IFFALSE 22734
// ComUnlink ( un ) ;
22725: LD_VAR 0 1
22729: PPUSH
22730: CALL_OW 136
// end ; end_of_file
22734: PPOPN 1
22736: END
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
22737: LD_INT 0
22739: PPUSH
22740: PPUSH
22741: PPUSH
22742: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
22743: LD_ADDR_VAR 0 5
22747: PUSH
22748: LD_VAR 0 1
22752: PPUSH
22753: LD_INT 2
22755: PUSH
22756: LD_INT 25
22758: PUSH
22759: LD_INT 2
22761: PUSH
22762: EMPTY
22763: LIST
22764: LIST
22765: PUSH
22766: LD_INT 25
22768: PUSH
22769: LD_INT 3
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: PUSH
22776: LD_INT 25
22778: PUSH
22779: LD_INT 4
22781: PUSH
22782: EMPTY
22783: LIST
22784: LIST
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: PPUSH
22792: CALL 0 0 2
22796: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
22797: LD_ADDR_VAR 0 5
22801: PUSH
22802: LD_VAR 0 5
22806: PPUSH
22807: LD_INT 0
22809: PPUSH
22810: CALL 2149 0 2
22814: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
22815: LD_ADDR_VAR 0 6
22819: PUSH
22820: LD_VAR 0 1
22824: PPUSH
22825: LD_VAR 0 5
22829: PPUSH
22830: LD_INT 1
22832: PPUSH
22833: CALL 1769 0 3
22837: ST_TO_ADDR
// if n > sk then
22838: LD_VAR 0 2
22842: PUSH
22843: LD_VAR 0 6
22847: GREATER
22848: IFFALSE 22860
// n := sk ;
22850: LD_ADDR_VAR 0 2
22854: PUSH
22855: LD_VAR 0 6
22859: ST_TO_ADDR
// for i = 1 to n do
22860: LD_ADDR_VAR 0 4
22864: PUSH
22865: DOUBLE
22866: LD_INT 1
22868: DEC
22869: ST_TO_ADDR
22870: LD_VAR 0 2
22874: PUSH
22875: FOR_TO
22876: IFFALSE 22968
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
22878: LD_ADDR_EXP 22
22882: PUSH
22883: LD_EXP 22
22887: PPUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: LD_VAR 0 6
22897: PUSH
22898: LD_VAR 0 4
22902: ARRAY
22903: PUSH
22904: LD_INT 1
22906: ARRAY
22907: PPUSH
22908: LD_INT 1
22910: PPUSH
22911: CALL 4124 0 4
22915: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
22916: LD_ADDR_EXP 25
22920: PUSH
22921: LD_EXP 25
22925: PPUSH
22926: LD_VAR 0 1
22930: PPUSH
22931: LD_EXP 25
22935: PUSH
22936: LD_VAR 0 1
22940: ARRAY
22941: PUSH
22942: LD_INT 1
22944: PLUS
22945: PPUSH
22946: LD_VAR 0 6
22950: PUSH
22951: LD_VAR 0 4
22955: ARRAY
22956: PUSH
22957: LD_INT 1
22959: ARRAY
22960: PPUSH
22961: CALL 24454 0 4
22965: ST_TO_ADDR
// end ;
22966: GO 22875
22968: POP
22969: POP
// end ;
22970: LD_VAR 0 3
22974: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
22975: LD_INT 0
22977: PPUSH
22978: PPUSH
22979: PPUSH
22980: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
22981: LD_ADDR_VAR 0 5
22985: PUSH
22986: LD_VAR 0 1
22990: PPUSH
22991: LD_INT 2
22993: PUSH
22994: LD_INT 25
22996: PUSH
22997: LD_INT 1
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: PUSH
23004: LD_INT 25
23006: PUSH
23007: LD_INT 3
23009: PUSH
23010: EMPTY
23011: LIST
23012: LIST
23013: PUSH
23014: LD_INT 25
23016: PUSH
23017: LD_INT 4
23019: PUSH
23020: EMPTY
23021: LIST
23022: LIST
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: LIST
23028: LIST
23029: PPUSH
23030: CALL 0 0 2
23034: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
23035: LD_ADDR_VAR 0 5
23039: PUSH
23040: LD_VAR 0 5
23044: PPUSH
23045: LD_INT 0
23047: PPUSH
23048: CALL 2149 0 2
23052: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
23053: LD_ADDR_VAR 0 6
23057: PUSH
23058: LD_VAR 0 1
23062: PPUSH
23063: LD_VAR 0 5
23067: PPUSH
23068: LD_INT 2
23070: PPUSH
23071: CALL 1769 0 3
23075: ST_TO_ADDR
// if n > sk then
23076: LD_VAR 0 2
23080: PUSH
23081: LD_VAR 0 6
23085: GREATER
23086: IFFALSE 23098
// n := sk ;
23088: LD_ADDR_VAR 0 2
23092: PUSH
23093: LD_VAR 0 6
23097: ST_TO_ADDR
// for i = 1 to n do
23098: LD_ADDR_VAR 0 4
23102: PUSH
23103: DOUBLE
23104: LD_INT 1
23106: DEC
23107: ST_TO_ADDR
23108: LD_VAR 0 2
23112: PUSH
23113: FOR_TO
23114: IFFALSE 23206
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
23116: LD_ADDR_EXP 22
23120: PUSH
23121: LD_EXP 22
23125: PPUSH
23126: LD_VAR 0 1
23130: PPUSH
23131: LD_VAR 0 6
23135: PUSH
23136: LD_VAR 0 4
23140: ARRAY
23141: PUSH
23142: LD_INT 1
23144: ARRAY
23145: PPUSH
23146: LD_INT 2
23148: PPUSH
23149: CALL 4124 0 4
23153: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
23154: LD_ADDR_EXP 26
23158: PUSH
23159: LD_EXP 26
23163: PPUSH
23164: LD_VAR 0 1
23168: PPUSH
23169: LD_EXP 26
23173: PUSH
23174: LD_VAR 0 1
23178: ARRAY
23179: PUSH
23180: LD_INT 1
23182: PLUS
23183: PPUSH
23184: LD_VAR 0 6
23188: PUSH
23189: LD_VAR 0 4
23193: ARRAY
23194: PUSH
23195: LD_INT 1
23197: ARRAY
23198: PPUSH
23199: CALL 24454 0 4
23203: ST_TO_ADDR
// end ;
23204: GO 23113
23206: POP
23207: POP
// end ;
23208: LD_VAR 0 3
23212: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
23213: LD_INT 0
23215: PPUSH
23216: PPUSH
23217: PPUSH
23218: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
23219: LD_ADDR_VAR 0 5
23223: PUSH
23224: LD_VAR 0 1
23228: PPUSH
23229: LD_INT 2
23231: PUSH
23232: LD_INT 25
23234: PUSH
23235: LD_INT 1
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: PUSH
23242: LD_INT 25
23244: PUSH
23245: LD_INT 2
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: PUSH
23252: LD_INT 25
23254: PUSH
23255: LD_INT 4
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: PUSH
23262: EMPTY
23263: LIST
23264: LIST
23265: LIST
23266: LIST
23267: PPUSH
23268: CALL 0 0 2
23272: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
23273: LD_ADDR_VAR 0 5
23277: PUSH
23278: LD_VAR 0 5
23282: PPUSH
23283: LD_INT 0
23285: PPUSH
23286: CALL 2149 0 2
23290: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
23291: LD_ADDR_VAR 0 6
23295: PUSH
23296: LD_VAR 0 1
23300: PPUSH
23301: LD_VAR 0 5
23305: PPUSH
23306: LD_INT 3
23308: PPUSH
23309: CALL 1769 0 3
23313: ST_TO_ADDR
// if n > sk then
23314: LD_VAR 0 2
23318: PUSH
23319: LD_VAR 0 6
23323: GREATER
23324: IFFALSE 23336
// n := sk ;
23326: LD_ADDR_VAR 0 2
23330: PUSH
23331: LD_VAR 0 6
23335: ST_TO_ADDR
// for i = 1 to n do
23336: LD_ADDR_VAR 0 4
23340: PUSH
23341: DOUBLE
23342: LD_INT 1
23344: DEC
23345: ST_TO_ADDR
23346: LD_VAR 0 2
23350: PUSH
23351: FOR_TO
23352: IFFALSE 23444
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
23354: LD_ADDR_EXP 22
23358: PUSH
23359: LD_EXP 22
23363: PPUSH
23364: LD_VAR 0 1
23368: PPUSH
23369: LD_VAR 0 6
23373: PUSH
23374: LD_VAR 0 4
23378: ARRAY
23379: PUSH
23380: LD_INT 1
23382: ARRAY
23383: PPUSH
23384: LD_INT 3
23386: PPUSH
23387: CALL 4124 0 4
23391: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
23392: LD_ADDR_EXP 24
23396: PUSH
23397: LD_EXP 24
23401: PPUSH
23402: LD_VAR 0 1
23406: PPUSH
23407: LD_EXP 24
23411: PUSH
23412: LD_VAR 0 1
23416: ARRAY
23417: PUSH
23418: LD_INT 1
23420: PLUS
23421: PPUSH
23422: LD_VAR 0 6
23426: PUSH
23427: LD_VAR 0 4
23431: ARRAY
23432: PUSH
23433: LD_INT 1
23435: ARRAY
23436: PPUSH
23437: CALL 24454 0 4
23441: ST_TO_ADDR
// end ;
23442: GO 23351
23444: POP
23445: POP
// end ;
23446: LD_VAR 0 3
23450: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
23451: LD_INT 0
23453: PPUSH
23454: PPUSH
23455: PPUSH
23456: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] ) ;
23457: LD_ADDR_VAR 0 5
23461: PUSH
23462: LD_VAR 0 1
23466: PPUSH
23467: LD_INT 2
23469: PUSH
23470: LD_INT 25
23472: PUSH
23473: LD_INT 1
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: PUSH
23480: LD_INT 25
23482: PUSH
23483: LD_INT 2
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 3
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: LIST
23504: LIST
23505: PPUSH
23506: CALL 0 0 2
23510: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
23511: LD_ADDR_VAR 0 5
23515: PUSH
23516: LD_VAR 0 5
23520: PPUSH
23521: LD_INT 0
23523: PPUSH
23524: CALL 2149 0 2
23528: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
23529: LD_ADDR_VAR 0 6
23533: PUSH
23534: LD_VAR 0 1
23538: PPUSH
23539: LD_VAR 0 5
23543: PPUSH
23544: LD_INT 4
23546: PPUSH
23547: CALL 1769 0 3
23551: ST_TO_ADDR
// if n > sk then
23552: LD_VAR 0 2
23556: PUSH
23557: LD_VAR 0 6
23561: GREATER
23562: IFFALSE 23574
// n := sk ;
23564: LD_ADDR_VAR 0 2
23568: PUSH
23569: LD_VAR 0 6
23573: ST_TO_ADDR
// for i = 1 to n do
23574: LD_ADDR_VAR 0 4
23578: PUSH
23579: DOUBLE
23580: LD_INT 1
23582: DEC
23583: ST_TO_ADDR
23584: LD_VAR 0 2
23588: PUSH
23589: FOR_TO
23590: IFFALSE 23682
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
23592: LD_ADDR_EXP 22
23596: PUSH
23597: LD_EXP 22
23601: PPUSH
23602: LD_VAR 0 1
23606: PPUSH
23607: LD_VAR 0 6
23611: PUSH
23612: LD_VAR 0 4
23616: ARRAY
23617: PUSH
23618: LD_INT 1
23620: ARRAY
23621: PPUSH
23622: LD_INT 4
23624: PPUSH
23625: CALL 4124 0 4
23629: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
23630: LD_ADDR_EXP 23
23634: PUSH
23635: LD_EXP 23
23639: PPUSH
23640: LD_VAR 0 1
23644: PPUSH
23645: LD_EXP 23
23649: PUSH
23650: LD_VAR 0 1
23654: ARRAY
23655: PUSH
23656: LD_INT 1
23658: PLUS
23659: PPUSH
23660: LD_VAR 0 6
23664: PUSH
23665: LD_VAR 0 4
23669: ARRAY
23670: PUSH
23671: LD_INT 1
23673: ARRAY
23674: PPUSH
23675: CALL 24454 0 4
23679: ST_TO_ADDR
// end ;
23680: GO 23589
23682: POP
23683: POP
// end ;
23684: LD_VAR 0 3
23688: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
23689: LD_INT 0
23691: PPUSH
23692: PPUSH
23693: PPUSH
23694: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
23695: LD_ADDR_VAR 0 6
23699: PUSH
23700: LD_VAR 0 1
23704: PPUSH
23705: LD_INT 2
23707: PUSH
23708: LD_INT 25
23710: PUSH
23711: LD_INT 1
23713: PUSH
23714: EMPTY
23715: LIST
23716: LIST
23717: PUSH
23718: LD_INT 25
23720: PUSH
23721: LD_INT 2
23723: PUSH
23724: EMPTY
23725: LIST
23726: LIST
23727: PUSH
23728: LD_INT 25
23730: PUSH
23731: LD_INT 3
23733: PUSH
23734: EMPTY
23735: LIST
23736: LIST
23737: PUSH
23738: LD_INT 25
23740: PUSH
23741: LD_INT 4
23743: PUSH
23744: EMPTY
23745: LIST
23746: LIST
23747: PUSH
23748: EMPTY
23749: LIST
23750: LIST
23751: LIST
23752: LIST
23753: LIST
23754: PPUSH
23755: CALL 0 0 2
23759: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
23760: LD_ADDR_VAR 0 6
23764: PUSH
23765: LD_VAR 0 6
23769: PPUSH
23770: LD_INT 0
23772: PPUSH
23773: CALL 2149 0 2
23777: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
23778: LD_ADDR_VAR 0 7
23782: PUSH
23783: LD_VAR 0 1
23787: PPUSH
23788: LD_VAR 0 6
23792: PPUSH
23793: LD_INT 1
23795: PPUSH
23796: CALL 1769 0 3
23800: ST_TO_ADDR
// if n > sk then
23801: LD_VAR 0 2
23805: PUSH
23806: LD_VAR 0 7
23810: GREATER
23811: IFFALSE 23823
// n := sk ;
23813: LD_ADDR_VAR 0 2
23817: PUSH
23818: LD_VAR 0 7
23822: ST_TO_ADDR
// for i = 1 to n do
23823: LD_ADDR_VAR 0 5
23827: PUSH
23828: DOUBLE
23829: LD_INT 1
23831: DEC
23832: ST_TO_ADDR
23833: LD_VAR 0 2
23837: PUSH
23838: FOR_TO
23839: IFFALSE 23883
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
23841: LD_ADDR_EXP 22
23845: PUSH
23846: LD_EXP 22
23850: PPUSH
23851: LD_VAR 0 1
23855: PPUSH
23856: LD_VAR 0 7
23860: PUSH
23861: LD_VAR 0 5
23865: ARRAY
23866: PUSH
23867: LD_INT 1
23869: ARRAY
23870: PPUSH
23871: LD_VAR 0 3
23875: PPUSH
23876: CALL 4124 0 4
23880: ST_TO_ADDR
// end ;
23881: GO 23838
23883: POP
23884: POP
// end ;
23885: LD_VAR 0 4
23889: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
23890: LD_INT 0
23892: PPUSH
23893: PPUSH
23894: PPUSH
// b := false ;
23895: LD_ADDR_VAR 0 6
23899: PUSH
23900: LD_INT 0
23902: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
23903: LD_VAR 0 3
23907: PUSH
23908: LD_INT 1
23910: PUSH
23911: LD_INT 9
23913: PUSH
23914: LD_INT 5
23916: PUSH
23917: LD_INT 8
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: LIST
23924: LIST
23925: IN
23926: IFFALSE 24014
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
23928: LD_VAR 0 1
23932: PPUSH
23933: LD_INT 2
23935: PUSH
23936: LD_INT 30
23938: PUSH
23939: LD_INT 4
23941: PUSH
23942: EMPTY
23943: LIST
23944: LIST
23945: PUSH
23946: LD_INT 30
23948: PUSH
23949: LD_INT 5
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: PUSH
23956: EMPTY
23957: LIST
23958: LIST
23959: LIST
23960: PPUSH
23961: CALL 0 0 2
23965: IFFALSE 24014
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
23967: LD_ADDR_VAR 0 6
23971: PUSH
23972: LD_VAR 0 1
23976: PPUSH
23977: LD_INT 2
23979: PUSH
23980: LD_INT 30
23982: PUSH
23983: LD_INT 4
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: PUSH
23990: LD_INT 30
23992: PUSH
23993: LD_INT 5
23995: PUSH
23996: EMPTY
23997: LIST
23998: LIST
23999: PUSH
24000: EMPTY
24001: LIST
24002: LIST
24003: LIST
24004: PPUSH
24005: CALL 0 0 2
24009: PUSH
24010: LD_INT 1
24012: ARRAY
24013: ST_TO_ADDR
// if class = class_engineer then
24014: LD_VAR 0 3
24018: PUSH
24019: LD_INT 2
24021: EQUAL
24022: IFFALSE 24110
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24024: LD_VAR 0 1
24028: PPUSH
24029: LD_INT 2
24031: PUSH
24032: LD_INT 30
24034: PUSH
24035: LD_INT 0
24037: PUSH
24038: EMPTY
24039: LIST
24040: LIST
24041: PUSH
24042: LD_INT 30
24044: PUSH
24045: LD_INT 1
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: LIST
24056: PPUSH
24057: CALL 0 0 2
24061: IFFALSE 24110
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
24063: LD_ADDR_VAR 0 6
24067: PUSH
24068: LD_VAR 0 1
24072: PPUSH
24073: LD_INT 2
24075: PUSH
24076: LD_INT 30
24078: PUSH
24079: LD_INT 0
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: PUSH
24086: LD_INT 30
24088: PUSH
24089: LD_INT 1
24091: PUSH
24092: EMPTY
24093: LIST
24094: LIST
24095: PUSH
24096: EMPTY
24097: LIST
24098: LIST
24099: LIST
24100: PPUSH
24101: CALL 0 0 2
24105: PUSH
24106: LD_INT 1
24108: ARRAY
24109: ST_TO_ADDR
// if class = class_mechanic then
24110: LD_VAR 0 3
24114: PUSH
24115: LD_INT 3
24117: EQUAL
24118: IFFALSE 24188
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
24120: LD_VAR 0 1
24124: PPUSH
24125: LD_INT 30
24127: PUSH
24128: LD_INT 3
24130: PUSH
24131: EMPTY
24132: LIST
24133: LIST
24134: PPUSH
24135: CALL 0 0 2
24139: IFFALSE 24188
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24141: LD_ADDR_VAR 0 6
24145: PUSH
24146: LD_VAR 0 1
24150: PPUSH
24151: LD_INT 2
24153: PUSH
24154: LD_INT 30
24156: PUSH
24157: LD_INT 2
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PUSH
24164: LD_INT 30
24166: PUSH
24167: LD_INT 3
24169: PUSH
24170: EMPTY
24171: LIST
24172: LIST
24173: PUSH
24174: EMPTY
24175: LIST
24176: LIST
24177: LIST
24178: PPUSH
24179: CALL 0 0 2
24183: PUSH
24184: LD_INT 1
24186: ARRAY
24187: ST_TO_ADDR
// if class = class_scientistic then
24188: LD_VAR 0 3
24192: PUSH
24193: LD_INT 4
24195: EQUAL
24196: IFFALSE 24306
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
24198: LD_VAR 0 1
24202: PPUSH
24203: LD_INT 2
24205: PUSH
24206: LD_INT 30
24208: PUSH
24209: LD_INT 6
24211: PUSH
24212: EMPTY
24213: LIST
24214: LIST
24215: PUSH
24216: LD_INT 30
24218: PUSH
24219: LD_INT 7
24221: PUSH
24222: EMPTY
24223: LIST
24224: LIST
24225: PUSH
24226: LD_INT 30
24228: PUSH
24229: LD_INT 8
24231: PUSH
24232: EMPTY
24233: LIST
24234: LIST
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: LIST
24240: LIST
24241: PPUSH
24242: CALL 0 0 2
24246: IFFALSE 24306
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
24248: LD_ADDR_VAR 0 6
24252: PUSH
24253: LD_VAR 0 1
24257: PPUSH
24258: LD_INT 2
24260: PUSH
24261: LD_INT 30
24263: PUSH
24264: LD_INT 6
24266: PUSH
24267: EMPTY
24268: LIST
24269: LIST
24270: PUSH
24271: LD_INT 30
24273: PUSH
24274: LD_INT 7
24276: PUSH
24277: EMPTY
24278: LIST
24279: LIST
24280: PUSH
24281: LD_INT 30
24283: PUSH
24284: LD_INT 8
24286: PUSH
24287: EMPTY
24288: LIST
24289: LIST
24290: PUSH
24291: EMPTY
24292: LIST
24293: LIST
24294: LIST
24295: LIST
24296: PPUSH
24297: CALL 0 0 2
24301: PUSH
24302: LD_INT 1
24304: ARRAY
24305: ST_TO_ADDR
// if GetClass ( unit ) = class then
24306: LD_VAR 0 2
24310: PPUSH
24311: CALL_OW 257
24315: PUSH
24316: LD_VAR 0 3
24320: EQUAL
24321: IFFALSE 24355
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
24323: LD_ADDR_EXP 22
24327: PUSH
24328: LD_EXP 22
24332: PPUSH
24333: LD_VAR 0 1
24337: PPUSH
24338: LD_VAR 0 2
24342: PPUSH
24343: LD_VAR 0 3
24347: PPUSH
24348: CALL 4215 0 4
24352: ST_TO_ADDR
// end else
24353: GO 24449
// if b then
24355: LD_VAR 0 6
24359: IFFALSE 24441
// begin if IsInUnit ( unit ) and not unit in UnitsInside ( b ) then
24361: LD_VAR 0 2
24365: PPUSH
24366: CALL_OW 310
24370: PUSH
24371: LD_VAR 0 2
24375: PUSH
24376: LD_VAR 0 6
24380: PPUSH
24381: CALL_OW 313
24385: IN
24386: NOT
24387: AND
24388: IFFALSE 24399
// ComExitBuilding ( unit ) ;
24390: LD_VAR 0 2
24394: PPUSH
24395: CALL_OW 122
// if not IsInUnit ( unit ) then
24399: LD_VAR 0 2
24403: PPUSH
24404: CALL_OW 310
24408: NOT
24409: IFFALSE 24425
// AddComEnterUnit ( unit , b ) ;
24411: LD_VAR 0 2
24415: PPUSH
24416: LD_VAR 0 6
24420: PPUSH
24421: CALL_OW 180
// AddComChangeProfession ( unit , class ) ;
24425: LD_VAR 0 2
24429: PPUSH
24430: LD_VAR 0 3
24434: PPUSH
24435: CALL_OW 183
// end else
24439: GO 24449
// result := false ;
24441: LD_ADDR_VAR 0 4
24445: PUSH
24446: LD_INT 0
24448: ST_TO_ADDR
// end ; end_of_file end_of_file
24449: LD_VAR 0 4
24453: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
24454: LD_INT 0
24456: PPUSH
24457: PPUSH
24458: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
24459: LD_ADDR_VAR 0 7
24463: PUSH
24464: LD_VAR 0 1
24468: PUSH
24469: LD_VAR 0 2
24473: ARRAY
24474: PPUSH
24475: LD_VAR 0 3
24479: PPUSH
24480: LD_VAR 0 4
24484: PPUSH
24485: CALL_OW 1
24489: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
24490: LD_ADDR_VAR 0 1
24494: PUSH
24495: LD_VAR 0 1
24499: PPUSH
24500: LD_VAR 0 2
24504: PPUSH
24505: LD_VAR 0 7
24509: PPUSH
24510: CALL_OW 1
24514: ST_TO_ADDR
// result := tab ;
24515: LD_ADDR_VAR 0 5
24519: PUSH
24520: LD_VAR 0 1
24524: ST_TO_ADDR
// end ;
24525: LD_VAR 0 5
24529: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
24530: LD_INT 0
24532: PPUSH
24533: PPUSH
24534: PPUSH
24535: PPUSH
// i := 1 ;
24536: LD_ADDR_VAR 0 5
24540: PUSH
24541: LD_INT 1
24543: ST_TO_ADDR
// while ( i <= tab ) do
24544: LD_VAR 0 5
24548: PUSH
24549: LD_VAR 0 1
24553: LESSEQUAL
24554: IFFALSE 24929
// begin if not tab [ i ] then
24556: LD_VAR 0 1
24560: PUSH
24561: LD_VAR 0 5
24565: ARRAY
24566: NOT
24567: IFFALSE 24571
// break ;
24569: GO 24929
// if value in tab then
24571: LD_VAR 0 2
24575: PUSH
24576: LD_VAR 0 1
24580: IN
24581: IFFALSE 24694
// begin if not mode then
24583: LD_VAR 0 3
24587: NOT
24588: IFFALSE 24608
// tab := tab diff value else
24590: LD_ADDR_VAR 0 1
24594: PUSH
24595: LD_VAR 0 1
24599: PUSH
24600: LD_VAR 0 2
24604: DIFF
24605: ST_TO_ADDR
24606: GO 24670
// for j = 1 to tab do
24608: LD_ADDR_VAR 0 6
24612: PUSH
24613: DOUBLE
24614: LD_INT 1
24616: DEC
24617: ST_TO_ADDR
24618: LD_VAR 0 1
24622: PUSH
24623: FOR_TO
24624: IFFALSE 24668
// if tab [ j ] = value then
24626: LD_VAR 0 1
24630: PUSH
24631: LD_VAR 0 6
24635: ARRAY
24636: PUSH
24637: LD_VAR 0 2
24641: EQUAL
24642: IFFALSE 24666
// begin tab := Delete ( tab , j ) ;
24644: LD_ADDR_VAR 0 1
24648: PUSH
24649: LD_VAR 0 1
24653: PPUSH
24654: LD_VAR 0 6
24658: PPUSH
24659: CALL_OW 3
24663: ST_TO_ADDR
// break ;
24664: GO 24668
// end ;
24666: GO 24623
24668: POP
24669: POP
// i := i - 1 ;
24670: LD_ADDR_VAR 0 5
24674: PUSH
24675: LD_VAR 0 5
24679: PUSH
24680: LD_INT 1
24682: MINUS
24683: ST_TO_ADDR
// if mode then
24684: LD_VAR 0 3
24688: IFFALSE 24692
// break ;
24690: GO 24929
// end else
24692: GO 24913
// if tab [ i ] and value in tab [ i ] then
24694: LD_VAR 0 1
24698: PUSH
24699: LD_VAR 0 5
24703: ARRAY
24704: PUSH
24705: LD_VAR 0 2
24709: PUSH
24710: LD_VAR 0 1
24714: PUSH
24715: LD_VAR 0 5
24719: ARRAY
24720: IN
24721: AND
24722: IFFALSE 24913
// begin if not mode then
24724: LD_VAR 0 3
24728: NOT
24729: IFFALSE 24755
// tmp := tab [ i ] diff value else
24731: LD_ADDR_VAR 0 7
24735: PUSH
24736: LD_VAR 0 1
24740: PUSH
24741: LD_VAR 0 5
24745: ARRAY
24746: PUSH
24747: LD_VAR 0 2
24751: DIFF
24752: ST_TO_ADDR
24753: GO 24835
// for j = 1 to tab [ i ] do
24755: LD_ADDR_VAR 0 6
24759: PUSH
24760: DOUBLE
24761: LD_INT 1
24763: DEC
24764: ST_TO_ADDR
24765: LD_VAR 0 1
24769: PUSH
24770: LD_VAR 0 5
24774: ARRAY
24775: PUSH
24776: FOR_TO
24777: IFFALSE 24833
// if value = tab [ i ] [ j ] then
24779: LD_VAR 0 2
24783: PUSH
24784: LD_VAR 0 1
24788: PUSH
24789: LD_VAR 0 5
24793: ARRAY
24794: PUSH
24795: LD_VAR 0 6
24799: ARRAY
24800: EQUAL
24801: IFFALSE 24831
// begin tmp := Delete ( tab [ i ] , j ) ;
24803: LD_ADDR_VAR 0 7
24807: PUSH
24808: LD_VAR 0 1
24812: PUSH
24813: LD_VAR 0 5
24817: ARRAY
24818: PPUSH
24819: LD_VAR 0 6
24823: PPUSH
24824: CALL_OW 3
24828: ST_TO_ADDR
// break ;
24829: GO 24833
// end ;
24831: GO 24776
24833: POP
24834: POP
// if tmp = [ ] then
24835: LD_VAR 0 7
24839: PUSH
24840: EMPTY
24841: EQUAL
24842: IFFALSE 24866
// begin tab := Delete ( tab , i ) ;
24844: LD_ADDR_VAR 0 1
24848: PUSH
24849: LD_VAR 0 1
24853: PPUSH
24854: LD_VAR 0 5
24858: PPUSH
24859: CALL_OW 3
24863: ST_TO_ADDR
// end else
24864: GO 24891
// tab := Replace ( tab , i , tmp ) ;
24866: LD_ADDR_VAR 0 1
24870: PUSH
24871: LD_VAR 0 1
24875: PPUSH
24876: LD_VAR 0 5
24880: PPUSH
24881: LD_VAR 0 7
24885: PPUSH
24886: CALL_OW 1
24890: ST_TO_ADDR
// i := i - 1 ;
24891: LD_ADDR_VAR 0 5
24895: PUSH
24896: LD_VAR 0 5
24900: PUSH
24901: LD_INT 1
24903: MINUS
24904: ST_TO_ADDR
// if mode then
24905: LD_VAR 0 3
24909: IFFALSE 24913
// break ;
24911: GO 24929
// end ; i := i + 1 ;
24913: LD_ADDR_VAR 0 5
24917: PUSH
24918: LD_VAR 0 5
24922: PUSH
24923: LD_INT 1
24925: PLUS
24926: ST_TO_ADDR
// end ;
24927: GO 24544
// result := tab ;
24929: LD_ADDR_VAR 0 4
24933: PUSH
24934: LD_VAR 0 1
24938: ST_TO_ADDR
// end ;
24939: LD_VAR 0 4
24943: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
24944: LD_INT 0
24946: PPUSH
24947: PPUSH
// for i = 1 to values do
24948: LD_ADDR_VAR 0 4
24952: PUSH
24953: DOUBLE
24954: LD_INT 1
24956: DEC
24957: ST_TO_ADDR
24958: LD_VAR 0 2
24962: PUSH
24963: FOR_TO
24964: IFFALSE 24997
// tab := Remove ( tab , values [ i ] , false ) ;
24966: LD_ADDR_VAR 0 1
24970: PUSH
24971: LD_VAR 0 1
24975: PPUSH
24976: LD_VAR 0 2
24980: PUSH
24981: LD_VAR 0 4
24985: ARRAY
24986: PPUSH
24987: LD_INT 0
24989: PPUSH
24990: CALL 24530 0 3
24994: ST_TO_ADDR
24995: GO 24963
24997: POP
24998: POP
// result := tab ;
24999: LD_ADDR_VAR 0 3
25003: PUSH
25004: LD_VAR 0 1
25008: ST_TO_ADDR
// end ;
25009: LD_VAR 0 3
25013: RET
// export function IsDriver ( unit ) ; begin
25014: LD_INT 0
25016: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
25017: LD_VAR 0 1
25021: PUSH
25022: LD_INT 55
25024: PUSH
25025: EMPTY
25026: LIST
25027: PPUSH
25028: CALL_OW 69
25032: IN
25033: IFFALSE 25052
// result := IsInUnit ( unit ) else
25035: LD_ADDR_VAR 0 2
25039: PUSH
25040: LD_VAR 0 1
25044: PPUSH
25045: CALL_OW 310
25049: ST_TO_ADDR
25050: GO 25060
// result := false ;
25052: LD_ADDR_VAR 0 2
25056: PUSH
25057: LD_INT 0
25059: ST_TO_ADDR
// end ;
25060: LD_VAR 0 2
25064: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
25065: LD_INT 0
25067: PPUSH
25068: PPUSH
25069: PPUSH
// if not GetControl ( veh ) = control_manual then
25070: LD_VAR 0 1
25074: PPUSH
25075: CALL_OW 263
25079: PUSH
25080: LD_INT 1
25082: EQUAL
25083: NOT
25084: IFFALSE 25096
// result := false else
25086: LD_ADDR_VAR 0 2
25090: PUSH
25091: LD_INT 0
25093: ST_TO_ADDR
25094: GO 25241
// if veh in FilterAllUnits ( [ f_empty ] ) then
25096: LD_VAR 0 1
25100: PUSH
25101: LD_INT 58
25103: PUSH
25104: EMPTY
25105: LIST
25106: PPUSH
25107: CALL_OW 69
25111: IN
25112: IFFALSE 25124
// result := false else
25114: LD_ADDR_VAR 0 2
25118: PUSH
25119: LD_INT 0
25121: ST_TO_ADDR
25122: GO 25241
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
25124: LD_ADDR_VAR 0 4
25128: PUSH
25129: LD_INT 22
25131: PUSH
25132: LD_VAR 0 1
25136: PPUSH
25137: CALL_OW 255
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PUSH
25146: LD_INT 55
25148: PUSH
25149: EMPTY
25150: LIST
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: PPUSH
25156: CALL_OW 69
25160: ST_TO_ADDR
// if not filter then
25161: LD_VAR 0 4
25165: NOT
25166: IFFALSE 25178
// result := false else
25168: LD_ADDR_VAR 0 2
25172: PUSH
25173: LD_INT 0
25175: ST_TO_ADDR
25176: GO 25241
// for i = 1 to filter do
25178: LD_ADDR_VAR 0 3
25182: PUSH
25183: DOUBLE
25184: LD_INT 1
25186: DEC
25187: ST_TO_ADDR
25188: LD_VAR 0 4
25192: PUSH
25193: FOR_TO
25194: IFFALSE 25239
// if IsDriver ( filter [ i ] ) = veh then
25196: LD_VAR 0 4
25200: PUSH
25201: LD_VAR 0 3
25205: ARRAY
25206: PPUSH
25207: CALL 25014 0 1
25211: PUSH
25212: LD_VAR 0 1
25216: EQUAL
25217: IFFALSE 25237
// begin result := filter [ i ] ;
25219: LD_ADDR_VAR 0 2
25223: PUSH
25224: LD_VAR 0 4
25228: PUSH
25229: LD_VAR 0 3
25233: ARRAY
25234: ST_TO_ADDR
// break ;
25235: GO 25239
// end ;
25237: GO 25193
25239: POP
25240: POP
// end ; end ;
25241: LD_VAR 0 2
25245: RET
// export function ComComplete ( unit , b ) ; var i ; begin
25246: LD_INT 0
25248: PPUSH
25249: PPUSH
// if BuildingStatus ( b ) = bs_build then
25250: LD_VAR 0 2
25254: PPUSH
25255: CALL_OW 461
25259: PUSH
25260: LD_INT 1
25262: EQUAL
25263: IFFALSE 25323
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25265: LD_VAR 0 1
25269: PPUSH
25270: LD_STRING h
25272: PUSH
25273: LD_VAR 0 2
25277: PPUSH
25278: CALL_OW 250
25282: PUSH
25283: LD_VAR 0 2
25287: PPUSH
25288: CALL_OW 251
25292: PUSH
25293: LD_VAR 0 2
25297: PUSH
25298: LD_INT 0
25300: PUSH
25301: LD_INT 0
25303: PUSH
25304: LD_INT 0
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: LIST
25311: LIST
25312: LIST
25313: LIST
25314: LIST
25315: PUSH
25316: EMPTY
25317: LIST
25318: PPUSH
25319: CALL_OW 446
// end ;
25323: LD_VAR 0 3
25327: RET
// export function Compare ( val1 , val2 ) ; begin
25328: LD_INT 0
25330: PPUSH
// if val1 = val2 then
25331: LD_VAR 0 1
25335: PUSH
25336: LD_VAR 0 2
25340: EQUAL
25341: IFFALSE 25353
// result := true else
25343: LD_ADDR_VAR 0 3
25347: PUSH
25348: LD_INT 1
25350: ST_TO_ADDR
25351: GO 25361
// result := false ;
25353: LD_ADDR_VAR 0 3
25357: PUSH
25358: LD_INT 0
25360: ST_TO_ADDR
// end ;
25361: LD_VAR 0 3
25365: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25366: LD_INT 0
25368: PPUSH
25369: PPUSH
// result := true ;
25370: LD_ADDR_VAR 0 3
25374: PUSH
25375: LD_INT 1
25377: ST_TO_ADDR
// if array1 = array2 then
25378: LD_VAR 0 1
25382: PUSH
25383: LD_VAR 0 2
25387: EQUAL
25388: IFFALSE 25453
// begin for i = 1 to array1 do
25390: LD_ADDR_VAR 0 4
25394: PUSH
25395: DOUBLE
25396: LD_INT 1
25398: DEC
25399: ST_TO_ADDR
25400: LD_VAR 0 1
25404: PUSH
25405: FOR_TO
25406: IFFALSE 25449
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
25408: LD_VAR 0 1
25412: PUSH
25413: LD_VAR 0 4
25417: ARRAY
25418: PPUSH
25419: LD_VAR 0 2
25423: PUSH
25424: LD_VAR 0 4
25428: ARRAY
25429: PPUSH
25430: CALL 25328 0 2
25434: NOT
25435: IFFALSE 25447
// begin result := false ;
25437: LD_ADDR_VAR 0 3
25441: PUSH
25442: LD_INT 0
25444: ST_TO_ADDR
// break ;
25445: GO 25449
// end ;
25447: GO 25405
25449: POP
25450: POP
// end else
25451: GO 25461
// result := false ;
25453: LD_ADDR_VAR 0 3
25457: PUSH
25458: LD_INT 0
25460: ST_TO_ADDR
// end ;
25461: LD_VAR 0 3
25465: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
25466: LD_INT 0
25468: PPUSH
25469: PPUSH
// result := false ;
25470: LD_ADDR_VAR 0 3
25474: PUSH
25475: LD_INT 0
25477: ST_TO_ADDR
// for j = 1 to e2 do
25478: LD_ADDR_VAR 0 4
25482: PUSH
25483: DOUBLE
25484: LD_INT 1
25486: DEC
25487: ST_TO_ADDR
25488: LD_VAR 0 2
25492: PUSH
25493: FOR_TO
25494: IFFALSE 25528
// if Compare ( e1 , e2 [ j ] ) then
25496: LD_VAR 0 1
25500: PPUSH
25501: LD_VAR 0 2
25505: PUSH
25506: LD_VAR 0 4
25510: ARRAY
25511: PPUSH
25512: CALL 25328 0 2
25516: IFFALSE 25526
// result := true ;
25518: LD_ADDR_VAR 0 3
25522: PUSH
25523: LD_INT 1
25525: ST_TO_ADDR
25526: GO 25493
25528: POP
25529: POP
// end ;
25530: LD_VAR 0 3
25534: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
25535: LD_INT 0
25537: PPUSH
25538: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
25539: LD_VAR 0 1
25543: PPUSH
25544: LD_STRING C
25546: PUSH
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 3
25556: PUSH
25557: LD_INT 0
25559: PUSH
25560: LD_INT 0
25562: PUSH
25563: LD_INT 0
25565: PUSH
25566: LD_INT 0
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: LIST
25573: LIST
25574: LIST
25575: LIST
25576: LIST
25577: PUSH
25578: LD_STRING v
25580: PUSH
25581: LD_VAR 0 4
25585: PPUSH
25586: CALL_OW 250
25590: PUSH
25591: LD_VAR 0 4
25595: PPUSH
25596: CALL_OW 251
25600: PUSH
25601: LD_VAR 0 4
25605: PUSH
25606: LD_INT 0
25608: PUSH
25609: LD_INT 0
25611: PUSH
25612: LD_INT 0
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: LIST
25619: LIST
25620: LIST
25621: LIST
25622: LIST
25623: PUSH
25624: EMPTY
25625: LIST
25626: LIST
25627: PPUSH
25628: CALL_OW 446
// end ;
25632: LD_VAR 0 5
25636: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
25637: LD_INT 0
25639: PPUSH
25640: PPUSH
25641: PPUSH
// linked := UnitsLinked ( unit ) ;
25642: LD_ADDR_VAR 0 4
25646: PUSH
25647: LD_VAR 0 1
25651: PPUSH
25652: CALL_OW 432
25656: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
25657: LD_ADDR_VAR 0 3
25661: PUSH
25662: LD_VAR 0 1
25666: PPUSH
25667: LD_INT 3
25669: PPUSH
25670: CALL_OW 259
25674: ST_TO_ADDR
// if sk > linked then
25675: LD_VAR 0 3
25679: PUSH
25680: LD_VAR 0 4
25684: GREATER
25685: IFFALSE 25697
// result := true else
25687: LD_ADDR_VAR 0 2
25691: PUSH
25692: LD_INT 1
25694: ST_TO_ADDR
25695: GO 25705
// result := false ;
25697: LD_ADDR_VAR 0 2
25701: PUSH
25702: LD_INT 0
25704: ST_TO_ADDR
// end ;
25705: LD_VAR 0 2
25709: RET
// export function NotTask ( unit ) ; begin
25710: LD_INT 0
25712: PPUSH
// result := true ;
25713: LD_ADDR_VAR 0 2
25717: PUSH
25718: LD_INT 1
25720: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
25721: LD_VAR 0 1
25725: PPUSH
25726: CALL_OW 437
25730: PUSH
25731: LD_VAR 0 1
25735: PPUSH
25736: CALL_OW 314
25740: OR
25741: IFFALSE 25751
// result := false ;
25743: LD_ADDR_VAR 0 2
25747: PUSH
25748: LD_INT 0
25750: ST_TO_ADDR
// end ;
25751: LD_VAR 0 2
25755: RET
// export function WantHeal ( sci , unit ) ; begin
25756: LD_INT 0
25758: PPUSH
// if GetTaskList ( sci ) > 0 then
25759: LD_VAR 0 1
25763: PPUSH
25764: CALL_OW 437
25768: PUSH
25769: LD_INT 0
25771: GREATER
25772: IFFALSE 25842
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
25774: LD_VAR 0 1
25778: PPUSH
25779: CALL_OW 437
25783: PUSH
25784: LD_INT 1
25786: ARRAY
25787: PUSH
25788: LD_INT 1
25790: ARRAY
25791: PUSH
25792: LD_STRING l
25794: EQUAL
25795: PUSH
25796: LD_VAR 0 1
25800: PPUSH
25801: CALL_OW 437
25805: PUSH
25806: LD_INT 1
25808: ARRAY
25809: PUSH
25810: LD_INT 4
25812: ARRAY
25813: PUSH
25814: LD_VAR 0 2
25818: EQUAL
25819: AND
25820: IFFALSE 25832
// result := true else
25822: LD_ADDR_VAR 0 3
25826: PUSH
25827: LD_INT 1
25829: ST_TO_ADDR
25830: GO 25840
// result := false ;
25832: LD_ADDR_VAR 0 3
25836: PUSH
25837: LD_INT 0
25839: ST_TO_ADDR
// end else
25840: GO 25850
// result := false ;
25842: LD_ADDR_VAR 0 3
25846: PUSH
25847: LD_INT 0
25849: ST_TO_ADDR
// end ; end_of_file
25850: LD_VAR 0 3
25854: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
25855: LD_INT 0
25857: PPUSH
25858: PPUSH
25859: PPUSH
// uc_side := 0 ;
25860: LD_ADDR_OWVAR 20
25864: PUSH
25865: LD_INT 0
25867: ST_TO_ADDR
// uc_nation := 0 ;
25868: LD_ADDR_OWVAR 21
25872: PUSH
25873: LD_INT 0
25875: ST_TO_ADDR
// for i = 1 to n do
25876: LD_ADDR_VAR 0 5
25880: PUSH
25881: DOUBLE
25882: LD_INT 1
25884: DEC
25885: ST_TO_ADDR
25886: LD_VAR 0 2
25890: PUSH
25891: FOR_TO
25892: IFFALSE 26037
// begin hc_importance := 0 ;
25894: LD_ADDR_OWVAR 32
25898: PUSH
25899: LD_INT 0
25901: ST_TO_ADDR
// hc_gallery :=  ;
25902: LD_ADDR_OWVAR 33
25906: PUSH
25907: LD_STRING 
25909: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
25910: LD_ADDR_OWVAR 35
25914: PUSH
25915: LD_VAR 0 3
25919: PUSH
25920: LD_INT 20
25922: MINUS
25923: PPUSH
25924: LD_VAR 0 3
25928: PUSH
25929: LD_INT 20
25931: PLUS
25932: PPUSH
25933: CALL_OW 12
25937: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
25938: LD_ADDR_OWVAR 31
25942: PUSH
25943: LD_INT 0
25945: PPUSH
25946: LD_INT 2
25948: PPUSH
25949: CALL_OW 12
25953: PUSH
25954: LD_INT 0
25956: PUSH
25957: LD_INT 0
25959: PUSH
25960: LD_INT 0
25962: PUSH
25963: EMPTY
25964: LIST
25965: LIST
25966: LIST
25967: LIST
25968: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
25969: LD_ADDR_OWVAR 30
25973: PUSH
25974: LD_INT 0
25976: PUSH
25977: LD_INT 0
25979: PUSH
25980: LD_INT 0
25982: PUSH
25983: LD_INT 0
25985: PUSH
25986: EMPTY
25987: LIST
25988: LIST
25989: LIST
25990: LIST
25991: ST_TO_ADDR
// hc_name :=  ;
25992: LD_ADDR_OWVAR 26
25996: PUSH
25997: LD_STRING 
25999: ST_TO_ADDR
// hc_class := class_apeman ;
26000: LD_ADDR_OWVAR 28
26004: PUSH
26005: LD_INT 12
26007: ST_TO_ADDR
// ape := CreateHuman ;
26008: LD_ADDR_VAR 0 6
26012: PUSH
26013: CALL_OW 44
26017: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
26018: LD_VAR 0 6
26022: PPUSH
26023: LD_VAR 0 1
26027: PPUSH
26028: LD_INT 0
26030: PPUSH
26031: CALL_OW 49
// end ;
26035: GO 25891
26037: POP
26038: POP
// end ;
26039: LD_VAR 0 4
26043: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
26044: LD_INT 0
26046: PPUSH
26047: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
26048: LD_VAR 0 1
26052: PPUSH
26053: CALL 413 0 1
26057: PUSH
26058: LD_EXP 5
26062: PUSH
26063: LD_VAR 0 1
26067: ARRAY
26068: GREATEREQUAL
26069: IFFALSE 26246
// begin if GetTag ( unit ) = 17 then
26071: LD_VAR 0 2
26075: PPUSH
26076: CALL_OW 110
26080: PUSH
26081: LD_INT 17
26083: EQUAL
26084: IFFALSE 26244
// begin SetTag ( unit , 0 ) ;
26086: LD_VAR 0 2
26090: PPUSH
26091: LD_INT 0
26093: PPUSH
26094: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
26098: LD_VAR 0 1
26102: PPUSH
26103: CALL 39 0 1
26107: PUSH
26108: LD_VAR 0 1
26112: PPUSH
26113: CALL 14153 0 1
26117: NOT
26118: AND
26119: IFFALSE 26144
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
26121: LD_VAR 0 2
26125: PPUSH
26126: LD_VAR 0 1
26130: PPUSH
26131: CALL 39 0 1
26135: PUSH
26136: LD_INT 1
26138: ARRAY
26139: PPUSH
26140: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
26144: LD_VAR 0 1
26148: PPUSH
26149: CALL 39 0 1
26153: NOT
26154: PUSH
26155: LD_VAR 0 1
26159: PPUSH
26160: LD_INT 30
26162: PUSH
26163: LD_INT 1
26165: PUSH
26166: EMPTY
26167: LIST
26168: LIST
26169: PPUSH
26170: CALL 0 0 2
26174: AND
26175: IFFALSE 26244
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
26177: LD_VAR 0 2
26181: PPUSH
26182: LD_VAR 0 1
26186: PPUSH
26187: LD_INT 30
26189: PUSH
26190: LD_INT 1
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: PPUSH
26197: CALL 0 0 2
26201: PUSH
26202: LD_INT 1
26204: ARRAY
26205: PPUSH
26206: CALL_OW 250
26210: PPUSH
26211: LD_VAR 0 1
26215: PPUSH
26216: LD_INT 30
26218: PUSH
26219: LD_INT 1
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: PPUSH
26226: CALL 0 0 2
26230: PUSH
26231: LD_INT 1
26233: ARRAY
26234: PPUSH
26235: CALL_OW 251
26239: PPUSH
26240: CALL_OW 111
// end ; end else
26244: GO 26430
// if GetClass ( unit ) <> 4 then
26246: LD_VAR 0 2
26250: PPUSH
26251: CALL_OW 257
26255: PUSH
26256: LD_INT 4
26258: NONEQUAL
26259: IFFALSE 26265
// exit else
26261: GO 26430
26263: GO 26430
// if GetTag ( unit ) = 0 then
26265: LD_VAR 0 2
26269: PPUSH
26270: CALL_OW 110
26274: PUSH
26275: LD_INT 0
26277: EQUAL
26278: IFFALSE 26294
// SetTag ( unit , 17 ) else
26280: LD_VAR 0 2
26284: PPUSH
26285: LD_INT 17
26287: PPUSH
26288: CALL_OW 109
26292: GO 26430
// begin if IsInUnit ( unit ) then
26294: LD_VAR 0 2
26298: PPUSH
26299: CALL_OW 310
26303: IFFALSE 26314
// ComExitBuilding ( unit ) ;
26305: LD_VAR 0 2
26309: PPUSH
26310: CALL_OW 122
// Wait ( 1 ) ;
26314: LD_INT 1
26316: PPUSH
26317: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
26321: LD_ADDR_VAR 0 4
26325: PUSH
26326: LD_INT 22
26328: PUSH
26329: LD_INT 0
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 25
26338: PUSH
26339: LD_INT 12
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: PPUSH
26350: CALL_OW 69
26354: PPUSH
26355: LD_VAR 0 2
26359: PPUSH
26360: CALL_OW 74
26364: ST_TO_ADDR
// if not ape then
26365: LD_VAR 0 4
26369: NOT
26370: IFFALSE 26376
// exit else
26372: GO 26430
26374: GO 26385
// ComHold ( ape ) ;
26376: LD_VAR 0 4
26380: PPUSH
26381: CALL_OW 140
// if not HasTask ( unit ) then
26385: LD_VAR 0 2
26389: PPUSH
26390: CALL_OW 314
26394: NOT
26395: IFFALSE 26428
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
26397: LD_VAR 0 2
26401: PPUSH
26402: LD_VAR 0 4
26406: PPUSH
26407: CALL_OW 250
26411: PPUSH
26412: LD_VAR 0 4
26416: PPUSH
26417: CALL_OW 251
26421: PPUSH
26422: CALL_OW 131
26426: GO 26430
// exit ;
26428: GO 26430
// end ; end ;
26430: LD_VAR 0 3
26434: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
26435: LD_INT 0
26437: PPUSH
26438: PPUSH
26439: PPUSH
26440: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
26441: LD_ADDR_VAR 0 4
26445: PUSH
26446: LD_EXP 6
26450: PUSH
26451: LD_VAR 0 1
26455: ARRAY
26456: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
26457: LD_ADDR_VAR 0 5
26461: PUSH
26462: LD_VAR 0 1
26466: PPUSH
26467: LD_STRING normal
26469: PPUSH
26470: CALL 497 0 2
26474: ST_TO_ADDR
// if apes then
26475: LD_VAR 0 5
26479: IFFALSE 26707
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
26481: LD_INT 2
26483: PPUSH
26484: LD_VAR 0 1
26488: PPUSH
26489: CALL_OW 321
26493: PUSH
26494: LD_INT 2
26496: EQUAL
26497: PUSH
26498: LD_VAR 0 4
26502: PUSH
26503: LD_INT 2
26505: ARRAY
26506: PUSH
26507: LD_INT 1
26509: EQUAL
26510: AND
26511: PUSH
26512: LD_VAR 0 1
26516: PPUSH
26517: LD_STRING engineer
26519: PPUSH
26520: CALL 497 0 2
26524: PUSH
26525: LD_INT 3
26527: LESS
26528: AND
26529: PUSH
26530: LD_VAR 0 1
26534: PPUSH
26535: LD_INT 30
26537: PUSH
26538: LD_INT 1
26540: PUSH
26541: EMPTY
26542: LIST
26543: LIST
26544: PPUSH
26545: CALL 0 0 2
26549: AND
26550: IFFALSE 26604
// begin for i in apes do
26552: LD_ADDR_VAR 0 3
26556: PUSH
26557: LD_VAR 0 5
26561: PUSH
26562: FOR_IN
26563: IFFALSE 26600
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
26565: LD_VAR 0 3
26569: PPUSH
26570: LD_VAR 0 1
26574: PPUSH
26575: LD_INT 30
26577: PUSH
26578: LD_INT 1
26580: PUSH
26581: EMPTY
26582: LIST
26583: LIST
26584: PPUSH
26585: CALL 0 0 2
26589: PUSH
26590: LD_INT 1
26592: ARRAY
26593: PPUSH
26594: CALL_OW 120
// end ;
26598: GO 26562
26600: POP
26601: POP
// end else
26602: GO 26707
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
26604: LD_INT 11
26606: PPUSH
26607: LD_VAR 0 1
26611: PPUSH
26612: CALL_OW 321
26616: PUSH
26617: LD_INT 2
26619: EQUAL
26620: PUSH
26621: LD_VAR 0 4
26625: PUSH
26626: LD_INT 1
26628: ARRAY
26629: PUSH
26630: LD_INT 1
26632: EQUAL
26633: AND
26634: PUSH
26635: LD_VAR 0 1
26639: PPUSH
26640: LD_INT 30
26642: PUSH
26643: LD_INT 5
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PPUSH
26650: CALL 0 0 2
26654: AND
26655: IFFALSE 26707
// begin for i in apes do
26657: LD_ADDR_VAR 0 3
26661: PUSH
26662: LD_VAR 0 5
26666: PUSH
26667: FOR_IN
26668: IFFALSE 26705
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: LD_VAR 0 1
26679: PPUSH
26680: LD_INT 30
26682: PUSH
26683: LD_INT 5
26685: PUSH
26686: EMPTY
26687: LIST
26688: LIST
26689: PPUSH
26690: CALL 0 0 2
26694: PUSH
26695: LD_INT 1
26697: ARRAY
26698: PPUSH
26699: CALL_OW 120
// end ;
26703: GO 26667
26705: POP
26706: POP
// end ; end ; end ; end_of_file
26707: LD_VAR 0 2
26711: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
26712: LD_INT 0
26714: PPUSH
26715: PPUSH
// if not GetClass ( unit ) = 4 or not target then
26716: LD_VAR 0 1
26720: PPUSH
26721: CALL_OW 257
26725: PUSH
26726: LD_INT 4
26728: EQUAL
26729: NOT
26730: PUSH
26731: LD_VAR 0 2
26735: NOT
26736: OR
26737: IFFALSE 26743
// exit else
26739: GO 26777
26741: GO 26777
// if not GetTag ( unit ) = 4 then
26743: LD_VAR 0 1
26747: PPUSH
26748: CALL_OW 110
26752: PUSH
26753: LD_INT 4
26755: EQUAL
26756: NOT
26757: IFFALSE 26763
// exit else
26759: GO 26777
26761: GO 26777
// ComHeal ( unit , target ) ;
26763: LD_VAR 0 1
26767: PPUSH
26768: LD_VAR 0 2
26772: PPUSH
26773: CALL_OW 128
// end ;
26777: LD_VAR 0 3
26781: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
26782: LD_INT 0
26784: PPUSH
26785: PPUSH
26786: PPUSH
26787: PPUSH
26788: PPUSH
26789: PPUSH
26790: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26791: LD_ADDR_VAR 0 5
26795: PUSH
26796: LD_INT 22
26798: PUSH
26799: LD_VAR 0 1
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: PUSH
26808: LD_INT 21
26810: PUSH
26811: LD_INT 1
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: PUSH
26818: LD_INT 3
26820: PUSH
26821: LD_INT 24
26823: PUSH
26824: LD_INT 1000
26826: PUSH
26827: EMPTY
26828: LIST
26829: LIST
26830: PUSH
26831: EMPTY
26832: LIST
26833: LIST
26834: PUSH
26835: EMPTY
26836: LIST
26837: LIST
26838: LIST
26839: PPUSH
26840: CALL_OW 69
26844: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
26845: LD_ADDR_VAR 0 8
26849: PUSH
26850: LD_VAR 0 1
26854: PPUSH
26855: LD_INT 30
26857: PUSH
26858: LD_INT 1
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PPUSH
26865: CALL 0 0 2
26869: ST_TO_ADDR
// r := [ ] ;
26870: LD_ADDR_VAR 0 6
26874: PUSH
26875: EMPTY
26876: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
26877: LD_VAR 0 1
26881: PPUSH
26882: LD_INT 5
26884: PPUSH
26885: EMPTY
26886: PPUSH
26887: CALL 703 0 3
26891: IFFALSE 26947
// for j in MCF_Tag ( side , 5 , [ ] ) do
26893: LD_ADDR_VAR 0 4
26897: PUSH
26898: LD_VAR 0 1
26902: PPUSH
26903: LD_INT 5
26905: PPUSH
26906: EMPTY
26907: PPUSH
26908: CALL 703 0 3
26912: PUSH
26913: FOR_IN
26914: IFFALSE 26945
// if GetLives ( j ) = 1000 then
26916: LD_VAR 0 4
26920: PPUSH
26921: CALL_OW 256
26925: PUSH
26926: LD_INT 1000
26928: EQUAL
26929: IFFALSE 26943
// SetTag ( j , 0 ) ;
26931: LD_VAR 0 4
26935: PPUSH
26936: LD_INT 0
26938: PPUSH
26939: CALL_OW 109
26943: GO 26913
26945: POP
26946: POP
// if tmp then
26947: LD_VAR 0 5
26951: IFFALSE 27280
// begin r := [ tmp [ 1 ] ] ;
26953: LD_ADDR_VAR 0 6
26957: PUSH
26958: LD_VAR 0 5
26962: PUSH
26963: LD_INT 1
26965: ARRAY
26966: PUSH
26967: EMPTY
26968: LIST
26969: ST_TO_ADDR
// for i = 2 to tmp do
26970: LD_ADDR_VAR 0 3
26974: PUSH
26975: DOUBLE
26976: LD_INT 2
26978: DEC
26979: ST_TO_ADDR
26980: LD_VAR 0 5
26984: PUSH
26985: FOR_TO
26986: IFFALSE 27278
// begin m := false ;
26988: LD_ADDR_VAR 0 7
26992: PUSH
26993: LD_INT 0
26995: ST_TO_ADDR
// if d then
26996: LD_VAR 0 8
27000: IFFALSE 27155
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
27002: LD_VAR 0 5
27006: PUSH
27007: LD_VAR 0 3
27011: ARRAY
27012: PPUSH
27013: CALL_OW 256
27017: PUSH
27018: LD_INT 650
27020: LESS
27021: PUSH
27022: LD_VAR 0 5
27026: PUSH
27027: LD_VAR 0 3
27031: ARRAY
27032: PPUSH
27033: LD_VAR 0 8
27037: PUSH
27038: LD_INT 1
27040: ARRAY
27041: PPUSH
27042: CALL_OW 250
27046: PPUSH
27047: LD_VAR 0 8
27051: PUSH
27052: LD_INT 1
27054: ARRAY
27055: PPUSH
27056: CALL_OW 251
27060: PPUSH
27061: CALL_OW 297
27065: PUSH
27066: LD_INT 10
27068: GREATER
27069: AND
27070: IFFALSE 27155
// begin if not GetTag ( tmp [ i ] ) = 5 then
27072: LD_VAR 0 5
27076: PUSH
27077: LD_VAR 0 3
27081: ARRAY
27082: PPUSH
27083: CALL_OW 110
27087: PUSH
27088: LD_INT 5
27090: EQUAL
27091: NOT
27092: IFFALSE 27112
// SetTag ( tmp [ i ] , 5 ) ;
27094: LD_VAR 0 5
27098: PUSH
27099: LD_VAR 0 3
27103: ARRAY
27104: PPUSH
27105: LD_INT 5
27107: PPUSH
27108: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
27112: LD_VAR 0 5
27116: PUSH
27117: LD_VAR 0 3
27121: ARRAY
27122: PPUSH
27123: LD_VAR 0 8
27127: PUSH
27128: LD_INT 1
27130: ARRAY
27131: PPUSH
27132: CALL_OW 250
27136: PPUSH
27137: LD_VAR 0 8
27141: PUSH
27142: LD_INT 1
27144: ARRAY
27145: PPUSH
27146: CALL_OW 251
27150: PPUSH
27151: CALL_OW 111
// end ; for j = 1 to r do
27155: LD_ADDR_VAR 0 4
27159: PUSH
27160: DOUBLE
27161: LD_INT 1
27163: DEC
27164: ST_TO_ADDR
27165: LD_VAR 0 6
27169: PUSH
27170: FOR_TO
27171: IFFALSE 27245
// if GetLives ( tmp [ i ] ) < r [ j ] then
27173: LD_VAR 0 5
27177: PUSH
27178: LD_VAR 0 3
27182: ARRAY
27183: PPUSH
27184: CALL_OW 256
27188: PUSH
27189: LD_VAR 0 6
27193: PUSH
27194: LD_VAR 0 4
27198: ARRAY
27199: LESS
27200: IFFALSE 27243
// begin r := Insert ( r , j , tmp [ i ] ) ;
27202: LD_ADDR_VAR 0 6
27206: PUSH
27207: LD_VAR 0 6
27211: PPUSH
27212: LD_VAR 0 4
27216: PPUSH
27217: LD_VAR 0 5
27221: PUSH
27222: LD_VAR 0 3
27226: ARRAY
27227: PPUSH
27228: CALL_OW 2
27232: ST_TO_ADDR
// m := true ;
27233: LD_ADDR_VAR 0 7
27237: PUSH
27238: LD_INT 1
27240: ST_TO_ADDR
// break ;
27241: GO 27245
// end ;
27243: GO 27170
27245: POP
27246: POP
// if not m then
27247: LD_VAR 0 7
27251: NOT
27252: IFFALSE 27276
// r := r ^ tmp [ i ] ;
27254: LD_ADDR_VAR 0 6
27258: PUSH
27259: LD_VAR 0 6
27263: PUSH
27264: LD_VAR 0 5
27268: PUSH
27269: LD_VAR 0 3
27273: ARRAY
27274: ADD
27275: ST_TO_ADDR
// end ;
27276: GO 26985
27278: POP
27279: POP
// end ; result := r end ;
27280: LD_ADDR_VAR 0 2
27284: PUSH
27285: LD_VAR 0 6
27289: ST_TO_ADDR
27290: LD_VAR 0 2
27294: RET
