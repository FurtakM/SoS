// export function MCF_Get ( side , filter ) ; begin
   0: LD_INT 0
   2: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
   3: LD_ADDR_VAR 0 3
   7: PUSH
   8: LD_INT 22
  10: PUSH
  11: LD_VAR 0 1
  15: PUSH
  16: EMPTY
  17: LIST
  18: LIST
  19: PUSH
  20: LD_VAR 0 2
  24: PUSH
  25: EMPTY
  26: LIST
  27: LIST
  28: PPUSH
  29: CALL_OW 69
  33: ST_TO_ADDR
// end ;
  34: LD_VAR 0 3
  38: RET
// export function MCF_Lab ( side ) ; begin
  39: LD_INT 0
  41: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
  42: LD_ADDR_VAR 0 2
  46: PUSH
  47: LD_INT 22
  49: PUSH
  50: LD_VAR 0 1
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 8
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: PUSH
  69: EMPTY
  70: LIST
  71: LIST
  72: PPUSH
  73: CALL_OW 69
  77: ST_TO_ADDR
// end ;
  78: LD_VAR 0 2
  82: RET
// export function MCF_Class ( side , class , filter ) ; begin
  83: LD_INT 0
  85: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
  86: LD_ADDR_VAR 0 4
  90: PUSH
  91: LD_INT 22
  93: PUSH
  94: LD_VAR 0 1
  98: PUSH
  99: EMPTY
 100: LIST
 101: LIST
 102: PUSH
 103: LD_INT 25
 105: PUSH
 106: LD_VAR 0 2
 110: PUSH
 111: EMPTY
 112: LIST
 113: LIST
 114: PUSH
 115: LD_VAR 0 3
 119: PUSH
 120: EMPTY
 121: LIST
 122: LIST
 123: LIST
 124: PPUSH
 125: CALL_OW 69
 129: ST_TO_ADDR
// end ;
 130: LD_VAR 0 4
 134: RET
// export function MCF_All ( side , filter ) ; begin
 135: LD_INT 0
 137: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
 138: LD_ADDR_VAR 0 3
 142: PUSH
 143: LD_INT 22
 145: PUSH
 146: LD_VAR 0 1
 150: PUSH
 151: EMPTY
 152: LIST
 153: LIST
 154: PUSH
 155: LD_INT 2
 157: PUSH
 158: LD_INT 25
 160: PUSH
 161: LD_INT 1
 163: PUSH
 164: EMPTY
 165: LIST
 166: LIST
 167: PUSH
 168: LD_INT 25
 170: PUSH
 171: LD_INT 2
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: PUSH
 178: LD_INT 25
 180: PUSH
 181: LD_INT 3
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PUSH
 188: LD_INT 25
 190: PUSH
 191: LD_INT 4
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: PUSH
 198: EMPTY
 199: LIST
 200: LIST
 201: LIST
 202: LIST
 203: LIST
 204: PUSH
 205: LD_VAR 0 2
 209: PUSH
 210: EMPTY
 211: LIST
 212: LIST
 213: LIST
 214: PPUSH
 215: CALL_OW 69
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 3
 224: RET
// export function MCF_Dist ( side , point , filter ) ; begin
 225: LD_INT 0
 227: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
 228: LD_ADDR_VAR 0 4
 232: PUSH
 233: LD_INT 22
 235: PUSH
 236: LD_VAR 0 1
 240: PUSH
 241: EMPTY
 242: LIST
 243: LIST
 244: PUSH
 245: LD_INT 92
 247: PUSH
 248: LD_VAR 0 2
 252: PUSH
 253: LD_INT 1
 255: ARRAY
 256: PUSH
 257: LD_VAR 0 2
 261: PUSH
 262: LD_INT 2
 264: ARRAY
 265: PUSH
 266: LD_VAR 0 2
 270: PUSH
 271: LD_INT 3
 273: ARRAY
 274: PUSH
 275: EMPTY
 276: LIST
 277: LIST
 278: LIST
 279: LIST
 280: PUSH
 281: LD_VAR 0 3
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: LIST
 290: PPUSH
 291: CALL_OW 69
 295: ST_TO_ADDR
// end ;
 296: LD_VAR 0 4
 300: RET
// export function MCF_Vehicle ( side , filter ) ; begin
 301: LD_INT 0
 303: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
 304: LD_ADDR_VAR 0 3
 308: PUSH
 309: LD_INT 22
 311: PUSH
 312: LD_VAR 0 1
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 21
 323: PUSH
 324: LD_INT 2
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: LD_VAR 0 2
 335: PUSH
 336: EMPTY
 337: LIST
 338: LIST
 339: LIST
 340: PPUSH
 341: CALL_OW 69
 345: ST_TO_ADDR
// end ;
 346: LD_VAR 0 3
 350: RET
// export function MCF_Cargo ( side ) ; begin
 351: LD_INT 0
 353: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
 354: LD_ADDR_VAR 0 2
 358: PUSH
 359: LD_VAR 0 1
 363: PPUSH
 364: LD_INT 2
 366: PUSH
 367: LD_INT 34
 369: PUSH
 370: LD_INT 12
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: PUSH
 377: LD_INT 34
 379: PUSH
 380: LD_INT 32
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: PUSH
 387: LD_INT 34
 389: PUSH
 390: LD_INT 51
 392: PUSH
 393: EMPTY
 394: LIST
 395: LIST
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: PPUSH
 403: CALL 301 0 2
 407: ST_TO_ADDR
// end ;
 408: LD_VAR 0 2
 412: RET
// export function MCF_Ape ( side ) ; begin
 413: LD_INT 0
 415: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
 416: LD_ADDR_VAR 0 2
 420: PUSH
 421: LD_INT 22
 423: PUSH
 424: LD_VAR 0 1
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 2
 435: PUSH
 436: LD_INT 25
 438: PUSH
 439: LD_INT 12
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: PUSH
 446: LD_INT 25
 448: PUSH
 449: LD_INT 15
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 25
 458: PUSH
 459: LD_INT 16
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: PUSH
 466: LD_INT 25
 468: PUSH
 469: LD_INT 17
 471: PUSH
 472: EMPTY
 473: LIST
 474: LIST
 475: PUSH
 476: EMPTY
 477: LIST
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: ST_TO_ADDR
// end ;
 492: LD_VAR 0 2
 496: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
 497: LD_INT 0
 499: PPUSH
 500: PPUSH
 501: PPUSH
 502: PPUSH
// result := [ ] ;
 503: LD_ADDR_VAR 0 3
 507: PUSH
 508: EMPTY
 509: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_VAR 0 1
 519: PPUSH
 520: CALL 413 0 1
 524: ST_TO_ADDR
// case type of 0 , normal :
 525: LD_VAR 0 2
 529: PUSH
 530: LD_INT 0
 532: DOUBLE
 533: EQUAL
 534: IFTRUE 544
 536: LD_STRING normal
 538: DOUBLE
 539: EQUAL
 540: IFTRUE 544
 542: GO 555
 544: POP
// cl := class_apeman ; 1 , soldier :
 545: LD_ADDR_VAR 0 5
 549: PUSH
 550: LD_INT 12
 552: ST_TO_ADDR
 553: GO 631
 555: LD_INT 1
 557: DOUBLE
 558: EQUAL
 559: IFTRUE 569
 561: LD_STRING soldier
 563: DOUBLE
 564: EQUAL
 565: IFTRUE 569
 567: GO 580
 569: POP
// cl := class_apeman_soldier ; 2 , engineer :
 570: LD_ADDR_VAR 0 5
 574: PUSH
 575: LD_INT 15
 577: ST_TO_ADDR
 578: GO 631
 580: LD_INT 2
 582: DOUBLE
 583: EQUAL
 584: IFTRUE 594
 586: LD_STRING engineer
 588: DOUBLE
 589: EQUAL
 590: IFTRUE 594
 592: GO 605
 594: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
 595: LD_ADDR_VAR 0 5
 599: PUSH
 600: LD_INT 16
 602: ST_TO_ADDR
 603: GO 631
 605: LD_INT 3
 607: DOUBLE
 608: EQUAL
 609: IFTRUE 619
 611: LD_STRING kamikaze
 613: DOUBLE
 614: EQUAL
 615: IFTRUE 619
 617: GO 630
 619: POP
// cl := class_apeman_kamikaze ; end ;
 620: LD_ADDR_VAR 0 5
 624: PUSH
 625: LD_INT 17
 627: ST_TO_ADDR
 628: GO 631
 630: POP
// for i = 1 to tmp do
 631: LD_ADDR_VAR 0 6
 635: PUSH
 636: DOUBLE
 637: LD_INT 1
 639: DEC
 640: ST_TO_ADDR
 641: LD_VAR 0 4
 645: PUSH
 646: FOR_TO
 647: IFFALSE 696
// if GetClass ( tmp [ i ] ) = cl then
 649: LD_VAR 0 4
 653: PUSH
 654: LD_VAR 0 6
 658: ARRAY
 659: PPUSH
 660: CALL_OW 257
 664: PUSH
 665: LD_VAR 0 5
 669: EQUAL
 670: IFFALSE 694
// result := result ^ tmp [ i ] ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_VAR 0 3
 681: PUSH
 682: LD_VAR 0 4
 686: PUSH
 687: LD_VAR 0 6
 691: ARRAY
 692: ADD
 693: ST_TO_ADDR
 694: GO 646
 696: POP
 697: POP
// end ;
 698: LD_VAR 0 3
 702: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
 709: LD_ADDR_VAR 0 5
 713: PUSH
 714: LD_INT 22
 716: PUSH
 717: LD_VAR 0 1
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: PUSH
 726: LD_VAR 0 3
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: PPUSH
 735: CALL_OW 69
 739: ST_TO_ADDR
// r := [ ] ;
 740: LD_ADDR_VAR 0 6
 744: PUSH
 745: EMPTY
 746: ST_TO_ADDR
// if tmp then
 747: LD_VAR 0 5
 751: IFFALSE 820
// for i = 1 to tmp do
 753: LD_ADDR_VAR 0 7
 757: PUSH
 758: DOUBLE
 759: LD_INT 1
 761: DEC
 762: ST_TO_ADDR
 763: LD_VAR 0 5
 767: PUSH
 768: FOR_TO
 769: IFFALSE 818
// if GetTag ( tmp [ i ] ) = tag then
 771: LD_VAR 0 5
 775: PUSH
 776: LD_VAR 0 7
 780: ARRAY
 781: PPUSH
 782: CALL_OW 110
 786: PUSH
 787: LD_VAR 0 2
 791: EQUAL
 792: IFFALSE 816
// r := r ^ tmp [ i ] ;
 794: LD_ADDR_VAR 0 6
 798: PUSH
 799: LD_VAR 0 6
 803: PUSH
 804: LD_VAR 0 5
 808: PUSH
 809: LD_VAR 0 7
 813: ARRAY
 814: ADD
 815: ST_TO_ADDR
 816: GO 768
 818: POP
 819: POP
// result := r ;
 820: LD_ADDR_VAR 0 4
 824: PUSH
 825: LD_VAR 0 6
 829: ST_TO_ADDR
// end ;
 830: LD_VAR 0 4
 834: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
 835: LD_INT 0
 837: PPUSH
 838: PPUSH
 839: PPUSH
// tmp := plist ;
 840: LD_ADDR_VAR 0 5
 844: PUSH
 845: LD_VAR 0 2
 849: ST_TO_ADDR
// if tmp then
 850: LD_VAR 0 5
 854: IFFALSE 931
// begin for i = 1 to tmp do
 856: LD_ADDR_VAR 0 6
 860: PUSH
 861: DOUBLE
 862: LD_INT 1
 864: DEC
 865: ST_TO_ADDR
 866: LD_VAR 0 5
 870: PUSH
 871: FOR_TO
 872: IFFALSE 919
// if GetTag ( tmp [ i ] ) <> tag then
 874: LD_VAR 0 5
 878: PUSH
 879: LD_VAR 0 6
 883: ARRAY
 884: PPUSH
 885: CALL_OW 110
 889: PUSH
 890: LD_VAR 0 3
 894: NONEQUAL
 895: IFFALSE 917
// SetTag ( tmp [ i ] , tag ) ;
 897: LD_VAR 0 5
 901: PUSH
 902: LD_VAR 0 6
 906: ARRAY
 907: PPUSH
 908: LD_VAR 0 3
 912: PPUSH
 913: CALL_OW 109
 917: GO 871
 919: POP
 920: POP
// result := true ;
 921: LD_ADDR_VAR 0 4
 925: PUSH
 926: LD_INT 1
 928: ST_TO_ADDR
// end else
 929: GO 939
// result := false ;
 931: LD_ADDR_VAR 0 4
 935: PUSH
 936: LD_INT 0
 938: ST_TO_ADDR
// end ;
 939: LD_VAR 0 4
 943: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
 944: LD_INT 0
 946: PPUSH
 947: PPUSH
 948: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
 949: LD_ADDR_VAR 0 4
 953: PUSH
 954: LD_VAR 0 1
 958: PPUSH
 959: LD_VAR 0 2
 963: PPUSH
 964: EMPTY
 965: PPUSH
 966: CALL 703 0 3
 970: ST_TO_ADDR
// if tmp then
 971: LD_VAR 0 4
 975: IFFALSE 1027
// begin for i = 1 to tmp do
 977: LD_ADDR_VAR 0 5
 981: PUSH
 982: DOUBLE
 983: LD_INT 1
 985: DEC
 986: ST_TO_ADDR
 987: LD_VAR 0 4
 991: PUSH
 992: FOR_TO
 993: IFFALSE 1015
// SetTag ( tmp [ i ] , 0 ) ;
 995: LD_VAR 0 4
 999: PUSH
1000: LD_VAR 0 5
1004: ARRAY
1005: PPUSH
1006: LD_INT 0
1008: PPUSH
1009: CALL_OW 109
1013: GO 992
1015: POP
1016: POP
// result := true ;
1017: LD_ADDR_VAR 0 3
1021: PUSH
1022: LD_INT 1
1024: ST_TO_ADDR
// end else
1025: GO 1035
// result := false ;
1027: LD_ADDR_VAR 0 3
1031: PUSH
1032: LD_INT 0
1034: ST_TO_ADDR
// end ;
1035: LD_VAR 0 3
1039: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
1040: LD_INT 0
1042: PPUSH
1043: PPUSH
1044: PPUSH
1045: PPUSH
1046: PPUSH
// sort_list := [ ] ;
1047: LD_ADDR_VAR 0 5
1051: PUSH
1052: EMPTY
1053: ST_TO_ADDR
// for i = 1 to list do
1054: LD_ADDR_VAR 0 3
1058: PUSH
1059: DOUBLE
1060: LD_INT 1
1062: DEC
1063: ST_TO_ADDR
1064: LD_VAR 0 1
1068: PUSH
1069: FOR_TO
1070: IFFALSE 1232
// begin if i = 1 then
1072: LD_VAR 0 3
1076: PUSH
1077: LD_INT 1
1079: EQUAL
1080: IFFALSE 1106
// sort_list := sort_list ^ list [ i ] else
1082: LD_ADDR_VAR 0 5
1086: PUSH
1087: LD_VAR 0 5
1091: PUSH
1092: LD_VAR 0 1
1096: PUSH
1097: LD_VAR 0 3
1101: ARRAY
1102: ADD
1103: ST_TO_ADDR
1104: GO 1230
// begin for j = 1 to sort_list do
1106: LD_ADDR_VAR 0 4
1110: PUSH
1111: DOUBLE
1112: LD_INT 1
1114: DEC
1115: ST_TO_ADDR
1116: LD_VAR 0 5
1120: PUSH
1121: FOR_TO
1122: IFFALSE 1199
// begin add := false ;
1124: LD_ADDR_VAR 0 6
1128: PUSH
1129: LD_INT 0
1131: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
1132: LD_VAR 0 1
1136: PUSH
1137: LD_VAR 0 3
1141: ARRAY
1142: PUSH
1143: LD_VAR 0 5
1147: PUSH
1148: LD_VAR 0 4
1152: ARRAY
1153: LESS
1154: IFFALSE 1197
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
1156: LD_ADDR_VAR 0 5
1160: PUSH
1161: LD_VAR 0 5
1165: PPUSH
1166: LD_VAR 0 4
1170: PPUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_VAR 0 3
1180: ARRAY
1181: PPUSH
1182: CALL_OW 2
1186: ST_TO_ADDR
// add := true ;
1187: LD_ADDR_VAR 0 6
1191: PUSH
1192: LD_INT 1
1194: ST_TO_ADDR
// break ;
1195: GO 1199
// end ; end ;
1197: GO 1121
1199: POP
1200: POP
// if not add then
1201: LD_VAR 0 6
1205: NOT
1206: IFFALSE 1230
// sort_list := sort_list ^ list [ i ] ;
1208: LD_ADDR_VAR 0 5
1212: PUSH
1213: LD_VAR 0 5
1217: PUSH
1218: LD_VAR 0 1
1222: PUSH
1223: LD_VAR 0 3
1227: ARRAY
1228: ADD
1229: ST_TO_ADDR
// end ; end ;
1230: GO 1069
1232: POP
1233: POP
// result := sort_list ;
1234: LD_ADDR_VAR 0 2
1238: PUSH
1239: LD_VAR 0 5
1243: ST_TO_ADDR
// end ;
1244: LD_VAR 0 2
1248: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
1253: PPUSH
1254: PPUSH
1255: PPUSH
// sort_list := [ ] ;
1256: LD_ADDR_VAR 0 5
1260: PUSH
1261: EMPTY
1262: ST_TO_ADDR
// for i = 1 to list do
1263: LD_ADDR_VAR 0 3
1267: PUSH
1268: DOUBLE
1269: LD_INT 1
1271: DEC
1272: ST_TO_ADDR
1273: LD_VAR 0 1
1277: PUSH
1278: FOR_TO
1279: IFFALSE 1441
// begin if i = 1 then
1281: LD_VAR 0 3
1285: PUSH
1286: LD_INT 1
1288: EQUAL
1289: IFFALSE 1315
// sort_list := sort_list ^ list [ i ] else
1291: LD_ADDR_VAR 0 5
1295: PUSH
1296: LD_VAR 0 5
1300: PUSH
1301: LD_VAR 0 1
1305: PUSH
1306: LD_VAR 0 3
1310: ARRAY
1311: ADD
1312: ST_TO_ADDR
1313: GO 1439
// begin for j = 1 to sort_list do
1315: LD_ADDR_VAR 0 4
1319: PUSH
1320: DOUBLE
1321: LD_INT 1
1323: DEC
1324: ST_TO_ADDR
1325: LD_VAR 0 5
1329: PUSH
1330: FOR_TO
1331: IFFALSE 1408
// begin add := false ;
1333: LD_ADDR_VAR 0 6
1337: PUSH
1338: LD_INT 0
1340: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
1341: LD_VAR 0 1
1345: PUSH
1346: LD_VAR 0 3
1350: ARRAY
1351: PUSH
1352: LD_VAR 0 5
1356: PUSH
1357: LD_VAR 0 4
1361: ARRAY
1362: GREATER
1363: IFFALSE 1406
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
1365: LD_ADDR_VAR 0 5
1369: PUSH
1370: LD_VAR 0 5
1374: PPUSH
1375: LD_VAR 0 4
1379: PPUSH
1380: LD_VAR 0 1
1384: PUSH
1385: LD_VAR 0 3
1389: ARRAY
1390: PPUSH
1391: CALL_OW 2
1395: ST_TO_ADDR
// add := true ;
1396: LD_ADDR_VAR 0 6
1400: PUSH
1401: LD_INT 1
1403: ST_TO_ADDR
// break ;
1404: GO 1408
// end ; end ;
1406: GO 1330
1408: POP
1409: POP
// if not add then
1410: LD_VAR 0 6
1414: NOT
1415: IFFALSE 1439
// sort_list := sort_list ^ list [ i ] ;
1417: LD_ADDR_VAR 0 5
1421: PUSH
1422: LD_VAR 0 5
1426: PUSH
1427: LD_VAR 0 1
1431: PUSH
1432: LD_VAR 0 3
1436: ARRAY
1437: ADD
1438: ST_TO_ADDR
// end ; end ;
1439: GO 1278
1441: POP
1442: POP
// result := sort_list ;
1443: LD_ADDR_VAR 0 2
1447: PUSH
1448: LD_VAR 0 5
1452: ST_TO_ADDR
// end ;
1453: LD_VAR 0 2
1457: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
1458: LD_INT 0
1460: PPUSH
1461: PPUSH
1462: PPUSH
1463: PPUSH
1464: PPUSH
1465: PPUSH
// tmp := [ ] ;
1466: LD_ADDR_VAR 0 8
1470: PUSH
1471: EMPTY
1472: ST_TO_ADDR
// r := [ ] ;
1473: LD_ADDR_VAR 0 7
1477: PUSH
1478: EMPTY
1479: ST_TO_ADDR
// add := false ;
1480: LD_ADDR_VAR 0 9
1484: PUSH
1485: LD_INT 0
1487: ST_TO_ADDR
// if plist then
1488: LD_VAR 0 2
1492: IFFALSE 1568
// begin for i = 1 to plist do
1494: LD_ADDR_VAR 0 5
1498: PUSH
1499: DOUBLE
1500: LD_INT 1
1502: DEC
1503: ST_TO_ADDR
1504: LD_VAR 0 2
1508: PUSH
1509: FOR_TO
1510: IFFALSE 1564
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
1512: LD_ADDR_VAR 0 8
1516: PUSH
1517: LD_VAR 0 8
1521: PUSH
1522: LD_VAR 0 2
1526: PUSH
1527: LD_VAR 0 5
1531: ARRAY
1532: PUSH
1533: LD_VAR 0 2
1537: PUSH
1538: LD_VAR 0 5
1542: ARRAY
1543: PPUSH
1544: LD_VAR 0 3
1548: PPUSH
1549: CALL_OW 259
1553: PUSH
1554: EMPTY
1555: LIST
1556: LIST
1557: PUSH
1558: EMPTY
1559: LIST
1560: ADD
1561: ST_TO_ADDR
// end ;
1562: GO 1509
1564: POP
1565: POP
// end else
1566: GO 1576
// result := false ;
1568: LD_ADDR_VAR 0 4
1572: PUSH
1573: LD_INT 0
1575: ST_TO_ADDR
// if tmp then
1576: LD_VAR 0 8
1580: IFFALSE 1754
// begin r := r ^ [ tmp [ 1 ] ] ;
1582: LD_ADDR_VAR 0 7
1586: PUSH
1587: LD_VAR 0 7
1591: PUSH
1592: LD_VAR 0 8
1596: PUSH
1597: LD_INT 1
1599: ARRAY
1600: PUSH
1601: EMPTY
1602: LIST
1603: ADD
1604: ST_TO_ADDR
// for i = 2 to tmp do
1605: LD_ADDR_VAR 0 5
1609: PUSH
1610: DOUBLE
1611: LD_INT 2
1613: DEC
1614: ST_TO_ADDR
1615: LD_VAR 0 8
1619: PUSH
1620: FOR_TO
1621: IFFALSE 1752
// begin for j = 1 to r do
1623: LD_ADDR_VAR 0 6
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_VAR 0 7
1637: PUSH
1638: FOR_TO
1639: IFFALSE 1716
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
1641: LD_VAR 0 8
1645: PUSH
1646: LD_VAR 0 5
1650: ARRAY
1651: PUSH
1652: LD_INT 2
1654: ARRAY
1655: PUSH
1656: LD_VAR 0 7
1660: PUSH
1661: LD_VAR 0 6
1665: ARRAY
1666: PUSH
1667: LD_INT 2
1669: ARRAY
1670: LESS
1671: IFFALSE 1714
// begin r := Insert ( r , j , tmp [ i ] ) ;
1673: LD_ADDR_VAR 0 7
1677: PUSH
1678: LD_VAR 0 7
1682: PPUSH
1683: LD_VAR 0 6
1687: PPUSH
1688: LD_VAR 0 8
1692: PUSH
1693: LD_VAR 0 5
1697: ARRAY
1698: PPUSH
1699: CALL_OW 2
1703: ST_TO_ADDR
// add := true ;
1704: LD_ADDR_VAR 0 9
1708: PUSH
1709: LD_INT 1
1711: ST_TO_ADDR
// break ;
1712: GO 1716
// end ; end ;
1714: GO 1638
1716: POP
1717: POP
// if not add then
1718: LD_VAR 0 9
1722: NOT
1723: IFFALSE 1750
// r := r ^ [ tmp [ i ] ] ;
1725: LD_ADDR_VAR 0 7
1729: PUSH
1730: LD_VAR 0 7
1734: PUSH
1735: LD_VAR 0 8
1739: PUSH
1740: LD_VAR 0 5
1744: ARRAY
1745: PUSH
1746: EMPTY
1747: LIST
1748: ADD
1749: ST_TO_ADDR
// end ;
1750: GO 1620
1752: POP
1753: POP
// end ; result := r ;
1754: LD_ADDR_VAR 0 4
1758: PUSH
1759: LD_VAR 0 7
1763: ST_TO_ADDR
// end ;
1764: LD_VAR 0 4
1768: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
1769: LD_INT 0
1771: PPUSH
1772: PPUSH
1773: PPUSH
1774: PPUSH
1775: PPUSH
1776: PPUSH
// tmp := [ ] ;
1777: LD_ADDR_VAR 0 8
1781: PUSH
1782: EMPTY
1783: ST_TO_ADDR
// r := [ ] ;
1784: LD_ADDR_VAR 0 7
1788: PUSH
1789: EMPTY
1790: ST_TO_ADDR
// add := false ;
1791: LD_ADDR_VAR 0 9
1795: PUSH
1796: LD_INT 0
1798: ST_TO_ADDR
// if plist then
1799: LD_VAR 0 2
1803: IFFALSE 1879
// begin for i = 1 to plist do
1805: LD_ADDR_VAR 0 5
1809: PUSH
1810: DOUBLE
1811: LD_INT 1
1813: DEC
1814: ST_TO_ADDR
1815: LD_VAR 0 2
1819: PUSH
1820: FOR_TO
1821: IFFALSE 1875
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
1823: LD_ADDR_VAR 0 8
1827: PUSH
1828: LD_VAR 0 8
1832: PUSH
1833: LD_VAR 0 2
1837: PUSH
1838: LD_VAR 0 5
1842: ARRAY
1843: PUSH
1844: LD_VAR 0 2
1848: PUSH
1849: LD_VAR 0 5
1853: ARRAY
1854: PPUSH
1855: LD_VAR 0 3
1859: PPUSH
1860: CALL_OW 259
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: PUSH
1869: EMPTY
1870: LIST
1871: ADD
1872: ST_TO_ADDR
// end ;
1873: GO 1820
1875: POP
1876: POP
// end else
1877: GO 1887
// result := false ;
1879: LD_ADDR_VAR 0 4
1883: PUSH
1884: LD_INT 0
1886: ST_TO_ADDR
// if tmp then
1887: LD_VAR 0 8
1891: IFFALSE 2065
// begin r := r ^ [ tmp [ 1 ] ] ;
1893: LD_ADDR_VAR 0 7
1897: PUSH
1898: LD_VAR 0 7
1902: PUSH
1903: LD_VAR 0 8
1907: PUSH
1908: LD_INT 1
1910: ARRAY
1911: PUSH
1912: EMPTY
1913: LIST
1914: ADD
1915: ST_TO_ADDR
// for i = 2 to tmp do
1916: LD_ADDR_VAR 0 5
1920: PUSH
1921: DOUBLE
1922: LD_INT 2
1924: DEC
1925: ST_TO_ADDR
1926: LD_VAR 0 8
1930: PUSH
1931: FOR_TO
1932: IFFALSE 2063
// begin for j = 1 to r do
1934: LD_ADDR_VAR 0 6
1938: PUSH
1939: DOUBLE
1940: LD_INT 1
1942: DEC
1943: ST_TO_ADDR
1944: LD_VAR 0 7
1948: PUSH
1949: FOR_TO
1950: IFFALSE 2027
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
1952: LD_VAR 0 8
1956: PUSH
1957: LD_VAR 0 5
1961: ARRAY
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_VAR 0 7
1971: PUSH
1972: LD_VAR 0 6
1976: ARRAY
1977: PUSH
1978: LD_INT 2
1980: ARRAY
1981: GREATER
1982: IFFALSE 2025
// begin r := Insert ( r , j , tmp [ i ] ) ;
1984: LD_ADDR_VAR 0 7
1988: PUSH
1989: LD_VAR 0 7
1993: PPUSH
1994: LD_VAR 0 6
1998: PPUSH
1999: LD_VAR 0 8
2003: PUSH
2004: LD_VAR 0 5
2008: ARRAY
2009: PPUSH
2010: CALL_OW 2
2014: ST_TO_ADDR
// add := true ;
2015: LD_ADDR_VAR 0 9
2019: PUSH
2020: LD_INT 1
2022: ST_TO_ADDR
// break ;
2023: GO 2027
// end ; end ;
2025: GO 1949
2027: POP
2028: POP
// if not add then
2029: LD_VAR 0 9
2033: NOT
2034: IFFALSE 2061
// r := r ^ [ tmp [ i ] ] ;
2036: LD_ADDR_VAR 0 7
2040: PUSH
2041: LD_VAR 0 7
2045: PUSH
2046: LD_VAR 0 8
2050: PUSH
2051: LD_VAR 0 5
2055: ARRAY
2056: PUSH
2057: EMPTY
2058: LIST
2059: ADD
2060: ST_TO_ADDR
// end ;
2061: GO 1931
2063: POP
2064: POP
// end ; result := r ;
2065: LD_ADDR_VAR 0 4
2069: PUSH
2070: LD_VAR 0 7
2074: ST_TO_ADDR
// end ;
2075: LD_VAR 0 4
2079: RET
// export function MCF_Clear ( side ) ; var i ; begin
2080: LD_INT 0
2082: PPUSH
2083: PPUSH
// for i = 1 to 100 do
2084: LD_ADDR_VAR 0 3
2088: PUSH
2089: DOUBLE
2090: LD_INT 1
2092: DEC
2093: ST_TO_ADDR
2094: LD_INT 100
2096: PUSH
2097: FOR_TO
2098: IFFALSE 2134
// if MCF_Tag ( side , i , [ ] ) then
2100: LD_VAR 0 1
2104: PPUSH
2105: LD_VAR 0 3
2109: PPUSH
2110: EMPTY
2111: PPUSH
2112: CALL 703 0 3
2116: IFFALSE 2132
// MCF_ClearTag ( side , i ) ;
2118: LD_VAR 0 1
2122: PPUSH
2123: LD_VAR 0 3
2127: PPUSH
2128: CALL 944 0 2
2132: GO 2097
2134: POP
2135: POP
// result := true ;
2136: LD_ADDR_VAR 0 2
2140: PUSH
2141: LD_INT 1
2143: ST_TO_ADDR
// end ;
2144: LD_VAR 0 2
2148: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
2149: LD_INT 0
2151: PPUSH
2152: PPUSH
2153: PPUSH
// for i = 1 to plist do
2154: LD_ADDR_VAR 0 4
2158: PUSH
2159: DOUBLE
2160: LD_INT 1
2162: DEC
2163: ST_TO_ADDR
2164: LD_VAR 0 1
2168: PUSH
2169: FOR_TO
2170: IFFALSE 2219
// if MCF_HasClass ( plist [ i ] ) = n then
2172: LD_VAR 0 1
2176: PUSH
2177: LD_VAR 0 4
2181: ARRAY
2182: PPUSH
2183: CALL 2554 0 1
2187: PUSH
2188: LD_VAR 0 2
2192: EQUAL
2193: IFFALSE 2217
// tmp := tmp ^ plist [ i ] ;
2195: LD_ADDR_VAR 0 5
2199: PUSH
2200: LD_VAR 0 5
2204: PUSH
2205: LD_VAR 0 1
2209: PUSH
2210: LD_VAR 0 4
2214: ARRAY
2215: ADD
2216: ST_TO_ADDR
2217: GO 2169
2219: POP
2220: POP
// result := tmp ;
2221: LD_ADDR_VAR 0 3
2225: PUSH
2226: LD_VAR 0 5
2230: ST_TO_ADDR
// end ;
2231: LD_VAR 0 3
2235: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
2236: LD_INT 0
2238: PPUSH
2239: PPUSH
2240: PPUSH
// if mreg = ToArm then
2241: LD_VAR 0 2
2245: PUSH
2246: LD_STRING ToArm
2248: EQUAL
2249: IFFALSE 2316
// for i = MREG_ToArm [ side ] downto n do
2251: LD_ADDR_VAR 0 5
2255: PUSH
2256: DOUBLE
2257: LD_EXP 25
2261: PUSH
2262: LD_VAR 0 1
2266: ARRAY
2267: INC
2268: ST_TO_ADDR
2269: LD_VAR 0 3
2273: PUSH
2274: FOR_DOWNTO
2275: IFFALSE 2314
// MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
2277: LD_ADDR_EXP 25
2281: PUSH
2282: LD_EXP 25
2286: PPUSH
2287: LD_EXP 25
2291: PUSH
2292: LD_VAR 0 1
2296: ARRAY
2297: PUSH
2298: LD_VAR 0 5
2302: ARRAY
2303: PPUSH
2304: LD_INT 1
2306: PPUSH
2307: CALL 24714 0 3
2311: ST_TO_ADDR
2312: GO 2274
2314: POP
2315: POP
// if mreg = ToDep then
2316: LD_VAR 0 2
2320: PUSH
2321: LD_STRING ToDep
2323: EQUAL
2324: IFFALSE 2391
// for i = MREG_ToDep [ side ] downto n do
2326: LD_ADDR_VAR 0 5
2330: PUSH
2331: DOUBLE
2332: LD_EXP 26
2336: PUSH
2337: LD_VAR 0 1
2341: ARRAY
2342: INC
2343: ST_TO_ADDR
2344: LD_VAR 0 3
2348: PUSH
2349: FOR_DOWNTO
2350: IFFALSE 2389
// MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
2352: LD_ADDR_EXP 26
2356: PUSH
2357: LD_EXP 26
2361: PPUSH
2362: LD_EXP 26
2366: PUSH
2367: LD_VAR 0 1
2371: ARRAY
2372: PUSH
2373: LD_VAR 0 5
2377: ARRAY
2378: PPUSH
2379: LD_INT 1
2381: PPUSH
2382: CALL 24714 0 3
2386: ST_TO_ADDR
2387: GO 2349
2389: POP
2390: POP
// if mreg = ToFac then
2391: LD_VAR 0 2
2395: PUSH
2396: LD_STRING ToFac
2398: EQUAL
2399: IFFALSE 2466
// for i = MREG_ToFac [ side ] downto n do
2401: LD_ADDR_VAR 0 5
2405: PUSH
2406: DOUBLE
2407: LD_EXP 24
2411: PUSH
2412: LD_VAR 0 1
2416: ARRAY
2417: INC
2418: ST_TO_ADDR
2419: LD_VAR 0 3
2423: PUSH
2424: FOR_DOWNTO
2425: IFFALSE 2464
// MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
2427: LD_ADDR_EXP 24
2431: PUSH
2432: LD_EXP 24
2436: PPUSH
2437: LD_EXP 24
2441: PUSH
2442: LD_VAR 0 1
2446: ARRAY
2447: PUSH
2448: LD_VAR 0 5
2452: ARRAY
2453: PPUSH
2454: LD_INT 1
2456: PPUSH
2457: CALL 24714 0 3
2461: ST_TO_ADDR
2462: GO 2424
2464: POP
2465: POP
// if mreg = ToLab then
2466: LD_VAR 0 2
2470: PUSH
2471: LD_STRING ToLab
2473: EQUAL
2474: IFFALSE 2541
// for i = MREG_ToLab [ side ] downto n do
2476: LD_ADDR_VAR 0 5
2480: PUSH
2481: DOUBLE
2482: LD_EXP 23
2486: PUSH
2487: LD_VAR 0 1
2491: ARRAY
2492: INC
2493: ST_TO_ADDR
2494: LD_VAR 0 3
2498: PUSH
2499: FOR_DOWNTO
2500: IFFALSE 2539
// MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
2502: LD_ADDR_EXP 23
2506: PUSH
2507: LD_EXP 23
2511: PPUSH
2512: LD_EXP 23
2516: PUSH
2517: LD_VAR 0 1
2521: ARRAY
2522: PUSH
2523: LD_VAR 0 5
2527: ARRAY
2528: PPUSH
2529: LD_INT 1
2531: PPUSH
2532: CALL 24714 0 3
2536: ST_TO_ADDR
2537: GO 2499
2539: POP
2540: POP
// result := true ;
2541: LD_ADDR_VAR 0 4
2545: PUSH
2546: LD_INT 1
2548: ST_TO_ADDR
// end ;
2549: LD_VAR 0 4
2553: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
// side := GetSide ( unit ) ;
2559: LD_ADDR_VAR 0 4
2563: PUSH
2564: LD_VAR 0 1
2568: PPUSH
2569: CALL_OW 255
2573: ST_TO_ADDR
// tmp := 0 ;
2574: LD_ADDR_VAR 0 3
2578: PUSH
2579: LD_INT 0
2581: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
2582: LD_VAR 0 1
2586: PUSH
2587: LD_EXP 25
2591: PUSH
2592: LD_VAR 0 4
2596: ARRAY
2597: IN
2598: IFFALSE 2608
// tmp := 1 ;
2600: LD_ADDR_VAR 0 3
2604: PUSH
2605: LD_INT 1
2607: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
2608: LD_VAR 0 1
2612: PUSH
2613: LD_EXP 26
2617: PUSH
2618: LD_VAR 0 4
2622: ARRAY
2623: IN
2624: IFFALSE 2634
// tmp := 2 ;
2626: LD_ADDR_VAR 0 3
2630: PUSH
2631: LD_INT 2
2633: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
2634: LD_VAR 0 1
2638: PUSH
2639: LD_EXP 24
2643: PUSH
2644: LD_VAR 0 4
2648: ARRAY
2649: IN
2650: IFFALSE 2660
// tmp := 3 ;
2652: LD_ADDR_VAR 0 3
2656: PUSH
2657: LD_INT 3
2659: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
2660: LD_VAR 0 1
2664: PUSH
2665: LD_EXP 23
2669: PUSH
2670: LD_VAR 0 4
2674: ARRAY
2675: IN
2676: IFFALSE 2686
// tmp := 4 ;
2678: LD_ADDR_VAR 0 3
2682: PUSH
2683: LD_INT 4
2685: ST_TO_ADDR
// result := tmp ;
2686: LD_ADDR_VAR 0 2
2690: PUSH
2691: LD_VAR 0 3
2695: ST_TO_ADDR
// end ;
2696: LD_VAR 0 2
2700: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
2701: LD_INT 0
2703: PPUSH
2704: PPUSH
// if mreg = ToArm then
2705: LD_VAR 0 2
2709: PUSH
2710: LD_STRING ToArm
2712: EQUAL
2713: IFFALSE 2802
// for i = MREG_ToArm [ side ] downto 1 do
2715: LD_ADDR_VAR 0 5
2719: PUSH
2720: DOUBLE
2721: LD_EXP 25
2725: PUSH
2726: LD_VAR 0 1
2730: ARRAY
2731: INC
2732: ST_TO_ADDR
2733: LD_INT 1
2735: PUSH
2736: FOR_DOWNTO
2737: IFFALSE 2800
// if MREG_ToArm [ side ] [ i ] = unit then
2739: LD_EXP 25
2743: PUSH
2744: LD_VAR 0 1
2748: ARRAY
2749: PUSH
2750: LD_VAR 0 5
2754: ARRAY
2755: PUSH
2756: LD_VAR 0 3
2760: EQUAL
2761: IFFALSE 2798
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
2763: LD_ADDR_EXP 25
2767: PUSH
2768: LD_EXP 25
2772: PPUSH
2773: LD_EXP 25
2777: PUSH
2778: LD_VAR 0 1
2782: ARRAY
2783: PUSH
2784: LD_VAR 0 5
2788: ARRAY
2789: PPUSH
2790: LD_INT 1
2792: PPUSH
2793: CALL 24714 0 3
2797: ST_TO_ADDR
// end ;
2798: GO 2736
2800: POP
2801: POP
// if mreg = ToDep then
2802: LD_VAR 0 2
2806: PUSH
2807: LD_STRING ToDep
2809: EQUAL
2810: IFFALSE 2899
// for i = MREG_ToDep [ side ] downto 1 do
2812: LD_ADDR_VAR 0 5
2816: PUSH
2817: DOUBLE
2818: LD_EXP 26
2822: PUSH
2823: LD_VAR 0 1
2827: ARRAY
2828: INC
2829: ST_TO_ADDR
2830: LD_INT 1
2832: PUSH
2833: FOR_DOWNTO
2834: IFFALSE 2897
// if MREG_ToDep [ side ] [ i ] = unit then
2836: LD_EXP 26
2840: PUSH
2841: LD_VAR 0 1
2845: ARRAY
2846: PUSH
2847: LD_VAR 0 5
2851: ARRAY
2852: PUSH
2853: LD_VAR 0 3
2857: EQUAL
2858: IFFALSE 2895
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
2860: LD_ADDR_EXP 26
2864: PUSH
2865: LD_EXP 26
2869: PPUSH
2870: LD_EXP 26
2874: PUSH
2875: LD_VAR 0 1
2879: ARRAY
2880: PUSH
2881: LD_VAR 0 5
2885: ARRAY
2886: PPUSH
2887: LD_INT 1
2889: PPUSH
2890: CALL 24714 0 3
2894: ST_TO_ADDR
// end ;
2895: GO 2833
2897: POP
2898: POP
// if mreg = ToFac then
2899: LD_VAR 0 2
2903: PUSH
2904: LD_STRING ToFac
2906: EQUAL
2907: IFFALSE 2996
// for i = MREG_ToFac [ side ] downto 1 do
2909: LD_ADDR_VAR 0 5
2913: PUSH
2914: DOUBLE
2915: LD_EXP 24
2919: PUSH
2920: LD_VAR 0 1
2924: ARRAY
2925: INC
2926: ST_TO_ADDR
2927: LD_INT 1
2929: PUSH
2930: FOR_DOWNTO
2931: IFFALSE 2994
// if MREG_ToFac [ side ] [ i ] = unit then
2933: LD_EXP 24
2937: PUSH
2938: LD_VAR 0 1
2942: ARRAY
2943: PUSH
2944: LD_VAR 0 5
2948: ARRAY
2949: PUSH
2950: LD_VAR 0 3
2954: EQUAL
2955: IFFALSE 2992
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
2957: LD_ADDR_EXP 24
2961: PUSH
2962: LD_EXP 24
2966: PPUSH
2967: LD_EXP 24
2971: PUSH
2972: LD_VAR 0 1
2976: ARRAY
2977: PUSH
2978: LD_VAR 0 5
2982: ARRAY
2983: PPUSH
2984: LD_INT 1
2986: PPUSH
2987: CALL 24714 0 3
2991: ST_TO_ADDR
// end ;
2992: GO 2930
2994: POP
2995: POP
// if mreg = ToLab then
2996: LD_VAR 0 2
3000: PUSH
3001: LD_STRING ToLab
3003: EQUAL
3004: IFFALSE 3093
// for i = MREG_ToLab [ side ] downto 1 do
3006: LD_ADDR_VAR 0 5
3010: PUSH
3011: DOUBLE
3012: LD_EXP 23
3016: PUSH
3017: LD_VAR 0 1
3021: ARRAY
3022: INC
3023: ST_TO_ADDR
3024: LD_INT 1
3026: PUSH
3027: FOR_DOWNTO
3028: IFFALSE 3091
// if MREG_ToLab [ side ] [ i ] = unit then
3030: LD_EXP 23
3034: PUSH
3035: LD_VAR 0 1
3039: ARRAY
3040: PUSH
3041: LD_VAR 0 5
3045: ARRAY
3046: PUSH
3047: LD_VAR 0 3
3051: EQUAL
3052: IFFALSE 3089
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
3054: LD_ADDR_EXP 23
3058: PUSH
3059: LD_EXP 23
3063: PPUSH
3064: LD_EXP 23
3068: PUSH
3069: LD_VAR 0 1
3073: ARRAY
3074: PUSH
3075: LD_VAR 0 5
3079: ARRAY
3080: PPUSH
3081: LD_INT 1
3083: PPUSH
3084: CALL 24714 0 3
3088: ST_TO_ADDR
// end ;
3089: GO 3027
3091: POP
3092: POP
// end ;
3093: LD_VAR 0 4
3097: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
3098: LD_INT 0
3100: PPUSH
3101: PPUSH
// result := false ;
3102: LD_ADDR_VAR 0 2
3106: PUSH
3107: LD_INT 0
3109: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
3110: LD_ADDR_VAR 0 3
3114: PUSH
3115: DOUBLE
3116: LD_INT 1
3118: DEC
3119: ST_TO_ADDR
3120: LD_EXP 15
3124: PUSH
3125: FOR_TO
3126: IFFALSE 3190
// if MREG_ToBuild [ i ] [ 1 ] = side then
3128: LD_EXP 15
3132: PUSH
3133: LD_VAR 0 3
3137: ARRAY
3138: PUSH
3139: LD_INT 1
3141: ARRAY
3142: PUSH
3143: LD_VAR 0 1
3147: EQUAL
3148: IFFALSE 3188
// begin if MREG_ToBuild [ i ] [ 1 ] then
3150: LD_EXP 15
3154: PUSH
3155: LD_VAR 0 3
3159: ARRAY
3160: PUSH
3161: LD_INT 1
3163: ARRAY
3164: IFFALSE 3188
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
3166: LD_ADDR_VAR 0 2
3170: PUSH
3171: LD_EXP 15
3175: PUSH
3176: LD_VAR 0 3
3180: ARRAY
3181: PUSH
3182: LD_INT 1
3184: ARRAY
3185: ST_TO_ADDR
// break ;
3186: GO 3190
// end ; end ;
3188: GO 3125
3190: POP
3191: POP
// for i = 1 to MREG_ToRepair do
3192: LD_ADDR_VAR 0 3
3196: PUSH
3197: DOUBLE
3198: LD_INT 1
3200: DEC
3201: ST_TO_ADDR
3202: LD_EXP 16
3206: PUSH
3207: FOR_TO
3208: IFFALSE 3272
// if MREG_ToRepair [ i ] [ 1 ] = side then
3210: LD_EXP 16
3214: PUSH
3215: LD_VAR 0 3
3219: ARRAY
3220: PUSH
3221: LD_INT 1
3223: ARRAY
3224: PUSH
3225: LD_VAR 0 1
3229: EQUAL
3230: IFFALSE 3270
// begin if MREG_ToRepair [ i ] [ 1 ] then
3232: LD_EXP 16
3236: PUSH
3237: LD_VAR 0 3
3241: ARRAY
3242: PUSH
3243: LD_INT 1
3245: ARRAY
3246: IFFALSE 3270
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
3248: LD_ADDR_VAR 0 2
3252: PUSH
3253: LD_EXP 16
3257: PUSH
3258: LD_VAR 0 3
3262: ARRAY
3263: PUSH
3264: LD_INT 1
3266: ARRAY
3267: ST_TO_ADDR
// break ;
3268: GO 3272
// end ; end ;
3270: GO 3207
3272: POP
3273: POP
// if MCF_Get ( side , [ f_constructed ] ) then
3274: LD_VAR 0 1
3278: PPUSH
3279: LD_INT 57
3281: PUSH
3282: EMPTY
3283: LIST
3284: PPUSH
3285: CALL 0 0 2
3289: IFFALSE 3316
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
3291: LD_ADDR_VAR 0 2
3295: PUSH
3296: LD_VAR 0 1
3300: PPUSH
3301: LD_INT 57
3303: PUSH
3304: EMPTY
3305: LIST
3306: PPUSH
3307: CALL 0 0 2
3311: PUSH
3312: LD_INT 1
3314: ARRAY
3315: ST_TO_ADDR
// end ;
3316: LD_VAR 0 2
3320: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
3321: LD_INT 0
3323: PPUSH
3324: PPUSH
3325: PPUSH
3326: PPUSH
3327: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
3328: LD_ADDR_VAR 0 6
3332: PUSH
3333: LD_VAR 0 1
3337: PPUSH
3338: LD_INT 21
3340: PUSH
3341: LD_INT 3
3343: PUSH
3344: EMPTY
3345: LIST
3346: LIST
3347: PPUSH
3348: CALL 0 0 2
3352: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
3353: LD_ADDR_VAR 0 7
3357: PUSH
3358: LD_VAR 0 1
3362: PPUSH
3363: LD_INT 81
3365: PUSH
3366: LD_VAR 0 1
3370: PUSH
3371: EMPTY
3372: LIST
3373: LIST
3374: PPUSH
3375: CALL 0 0 2
3379: ST_TO_ADDR
// if not enemy then
3380: LD_VAR 0 7
3384: NOT
3385: IFFALSE 3397
// result := false else
3387: LD_ADDR_VAR 0 3
3391: PUSH
3392: LD_INT 0
3394: ST_TO_ADDR
3395: GO 3451
// begin scan := NearestUnit ( b , enemy ) ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_VAR 0 6
3406: PPUSH
3407: LD_VAR 0 7
3411: PPUSH
3412: CALL 26039 0 2
3416: ST_TO_ADDR
// if scan [ 2 ] < dist then
3417: LD_VAR 0 5
3421: PUSH
3422: LD_INT 2
3424: ARRAY
3425: PUSH
3426: LD_VAR 0 2
3430: LESS
3431: IFFALSE 3443
// result := true else
3433: LD_ADDR_VAR 0 3
3437: PUSH
3438: LD_INT 1
3440: ST_TO_ADDR
3441: GO 3451
// result := false ;
3443: LD_ADDR_VAR 0 3
3447: PUSH
3448: LD_INT 0
3450: ST_TO_ADDR
// end ; end ;
3451: LD_VAR 0 3
3455: RET
// export function MCF_Info ( ) ; begin
3456: LD_INT 0
3458: PPUSH
// MC_Show ( MCF to zbiór funkcji s³u¿¹cych do operacji na listach i filtrach: ^ - MCF_Class -> Wyœwietla dan¹ klasê [mo¿liwe do³¹czenie dodatkowych filtrów] ^ - MCF_Tag -> Wyœwietla wszystkie jednostki z danymi tagiem [mo¿liwe do³¹czenie dodatkowych filtrów] ^ - MCF_SetTag -> Umo¿liwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortujê listê rosn¹co ^ - MCF_SortListDesc -> Sortujê listê malej¹co ^ - MCF_SortLevelAsc -> Sortujê dan¹ grupê jednnostek wg. danej umiejetnoœci wg. poziomu rosn¹co ^ - MCF_SortLevelDesc -> Sortujê dan¹ grupê jednostek wg. danej umiejetnoœci wg. poziomu malej¹co ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
3459: LD_STRING MCF to zbiór funkcji s³u¿¹cych do operacji na listach i filtrach:
3461: PUSH
3462: LD_STRING - MCF_Class -> Wyœwietla dan¹ klasê [mo¿liwe do³¹czenie dodatkowych filtrów]
3464: ADD
3465: PUSH
3466: LD_STRING - MCF_Tag -> Wyœwietla wszystkie jednostki z danymi tagiem [mo¿liwe do³¹czenie dodatkowych filtrów]
3468: ADD
3469: PUSH
3470: LD_STRING - MCF_SetTag -> Umo¿liwia nadanie tagu danej grupie jednostek
3472: ADD
3473: PUSH
3474: LD_STRING - MCF_ClearTag -> Kasuje dany tag
3476: ADD
3477: PUSH
3478: LD_STRING - MCF_SortListAsc -> Sortujê listê rosn¹co
3480: ADD
3481: PUSH
3482: LD_STRING - MCF_SortListDesc -> Sortujê listê malej¹co
3484: ADD
3485: PUSH
3486: LD_STRING - MCF_SortLevelAsc -> Sortujê dan¹ grupê jednnostek wg. danej umiejetnoœci wg. poziomu rosn¹co
3488: ADD
3489: PUSH
3490: LD_STRING - MCF_SortLevelDesc -> Sortujê dan¹ grupê jednostek wg. danej umiejetnoœci wg. poziomu malej¹co
3492: ADD
3493: PUSH
3494: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
3496: ADD
3497: PPUSH
3498: CALL 4025 0 1
// end ; end_of_file
3502: LD_VAR 0 1
3506: RET
// export function FakePep ( ) ; var i , un ; begin
3507: LD_INT 0
3509: PPUSH
3510: PPUSH
3511: PPUSH
// uc_side := 1 ;
3512: LD_ADDR_OWVAR 20
3516: PUSH
3517: LD_INT 1
3519: ST_TO_ADDR
// uc_nation := 1 ;
3520: LD_ADDR_OWVAR 21
3524: PUSH
3525: LD_INT 1
3527: ST_TO_ADDR
// for i = 1 to 15 do
3528: LD_ADDR_VAR 0 2
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_INT 15
3540: PUSH
3541: FOR_TO
3542: IFFALSE 3591
// begin PrepareHuman ( false , ( i div 4 ) + 1 , 8 ) ;
3544: LD_INT 0
3546: PPUSH
3547: LD_VAR 0 2
3551: PUSH
3552: LD_INT 4
3554: DIV
3555: PUSH
3556: LD_INT 1
3558: PLUS
3559: PPUSH
3560: LD_INT 8
3562: PPUSH
3563: CALL_OW 380
// un := CreateHuman ;
3567: LD_ADDR_VAR 0 3
3571: PUSH
3572: CALL_OW 44
3576: ST_TO_ADDR
// PlaceUnitAnywhere ( un , false ) ;
3577: LD_VAR 0 3
3581: PPUSH
3582: LD_INT 0
3584: PPUSH
3585: CALL_OW 51
// end ;
3589: GO 3541
3591: POP
3592: POP
// end ; end_of_file
3593: LD_VAR 0 1
3597: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
3598: LD_INT 0
3600: PPUSH
3601: PPUSH
3602: PPUSH
3603: PPUSH
3604: PPUSH
3605: PPUSH
3606: PPUSH
3607: PPUSH
// if unit then
3608: LD_VAR 0 1
3612: IFFALSE 4012
// begin if mode = 0 then
3614: LD_VAR 0 3
3618: PUSH
3619: LD_INT 0
3621: EQUAL
3622: IFFALSE 3770
// begin if coords then
3624: LD_VAR 0 2
3628: IFFALSE 3768
// while ( coords > 1 ) do
3630: LD_VAR 0 2
3634: PUSH
3635: LD_INT 1
3637: GREATER
3638: IFFALSE 3768
// if not HasTask ( unit ) then
3640: LD_VAR 0 1
3644: PPUSH
3645: CALL_OW 314
3649: NOT
3650: IFFALSE 3766
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
3652: LD_VAR 0 1
3656: PPUSH
3657: LD_VAR 0 2
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: PPUSH
3666: LD_VAR 0 2
3670: PUSH
3671: LD_INT 2
3673: ARRAY
3674: PPUSH
3675: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
3679: LD_INT 35
3681: PPUSH
3682: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
3686: LD_VAR 0 1
3690: PPUSH
3691: CALL_OW 250
3695: PUSH
3696: LD_VAR 0 2
3700: PUSH
3701: LD_INT 1
3703: ARRAY
3704: EQUAL
3705: PUSH
3706: LD_VAR 0 1
3710: PPUSH
3711: CALL_OW 251
3715: PUSH
3716: LD_VAR 0 2
3720: PUSH
3721: LD_INT 2
3723: ARRAY
3724: EQUAL
3725: AND
3726: IFFALSE 3679
// for i = 1 to 2 do
3728: LD_ADDR_VAR 0 5
3732: PUSH
3733: DOUBLE
3734: LD_INT 1
3736: DEC
3737: ST_TO_ADDR
3738: LD_INT 2
3740: PUSH
3741: FOR_TO
3742: IFFALSE 3764
// coords := Delete ( coords , 1 ) ;
3744: LD_ADDR_VAR 0 2
3748: PUSH
3749: LD_VAR 0 2
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 3
3761: ST_TO_ADDR
3762: GO 3741
3764: POP
3765: POP
// end ;
3766: GO 3630
// end else
3768: GO 4012
// begin if coords then
3770: LD_VAR 0 2
3774: IFFALSE 4012
// begin x := GetX ( unit ) ;
3776: LD_ADDR_VAR 0 6
3780: PUSH
3781: LD_VAR 0 1
3785: PPUSH
3786: CALL_OW 250
3790: ST_TO_ADDR
// y := GetY ( unit ) ;
3791: LD_ADDR_VAR 0 7
3795: PUSH
3796: LD_VAR 0 1
3800: PPUSH
3801: CALL_OW 251
3805: ST_TO_ADDR
// while ( coords > 1 ) do
3806: LD_VAR 0 2
3810: PUSH
3811: LD_INT 1
3813: GREATER
3814: IFFALSE 4012
// begin Wait ( 0 0$0.3 ) ;
3816: LD_INT 10
3818: PPUSH
3819: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
3823: LD_VAR 0 1
3827: PPUSH
3828: CALL_OW 255
3832: PPUSH
3833: LD_VAR 0 1
3837: PPUSH
3838: CALL_OW 250
3842: PPUSH
3843: LD_VAR 0 1
3847: PPUSH
3848: CALL_OW 251
3852: PPUSH
3853: LD_INT 14
3855: PPUSH
3856: CALL 6036 0 4
3860: IFFALSE 3891
// begin ComMoveXY ( unit , x , y ) ;
3862: LD_VAR 0 1
3866: PPUSH
3867: LD_VAR 0 6
3871: PPUSH
3872: LD_VAR 0 7
3876: PPUSH
3877: CALL_OW 111
// result := false ;
3881: LD_ADDR_VAR 0 4
3885: PUSH
3886: LD_INT 0
3888: ST_TO_ADDR
// end else
3889: GO 3930
// if not HasTask ( unit ) then
3891: LD_VAR 0 1
3895: PPUSH
3896: CALL_OW 314
3900: NOT
3901: IFFALSE 3930
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
3903: LD_VAR 0 1
3907: PPUSH
3908: LD_VAR 0 2
3912: PUSH
3913: LD_INT 1
3915: ARRAY
3916: PPUSH
3917: LD_VAR 0 2
3921: PUSH
3922: LD_INT 2
3924: ARRAY
3925: PPUSH
3926: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
3930: LD_VAR 0 1
3934: PPUSH
3935: CALL_OW 250
3939: PUSH
3940: LD_VAR 0 2
3944: PUSH
3945: LD_INT 1
3947: ARRAY
3948: EQUAL
3949: PUSH
3950: LD_VAR 0 1
3954: PPUSH
3955: CALL_OW 251
3959: PUSH
3960: LD_VAR 0 2
3964: PUSH
3965: LD_INT 2
3967: ARRAY
3968: EQUAL
3969: AND
3970: IFFALSE 4010
// for i = 1 to 2 do
3972: LD_ADDR_VAR 0 5
3976: PUSH
3977: DOUBLE
3978: LD_INT 1
3980: DEC
3981: ST_TO_ADDR
3982: LD_INT 2
3984: PUSH
3985: FOR_TO
3986: IFFALSE 4008
// coords := Delete ( coords , 1 ) ;
3988: LD_ADDR_VAR 0 2
3992: PUSH
3993: LD_VAR 0 2
3997: PPUSH
3998: LD_INT 1
4000: PPUSH
4001: CALL_OW 3
4005: ST_TO_ADDR
4006: GO 3985
4008: POP
4009: POP
// end ;
4010: GO 3806
// end ; end ; end ; result := true ;
4012: LD_ADDR_VAR 0 4
4016: PUSH
4017: LD_INT 1
4019: ST_TO_ADDR
// end ;
4020: LD_VAR 0 4
4024: RET
// export function MC_Show ( string ) ; begin
4025: LD_INT 0
4027: PPUSH
// display_strings := string ;
4028: LD_ADDR_OWVAR 47
4032: PUSH
4033: LD_VAR 0 1
4037: ST_TO_ADDR
// end ; end_of_file
4038: LD_VAR 0 2
4042: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Crane , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
4043: LD_INT 0
4045: PPUSH
// MREG_Game := [ ] ;
4046: LD_ADDR_EXP 1
4050: PUSH
4051: EMPTY
4052: ST_TO_ADDR
// MREG_Crates := [ ] ;
4053: LD_ADDR_EXP 2
4057: PUSH
4058: EMPTY
4059: ST_TO_ADDR
// MREG_Heal := [ ] ;
4060: LD_ADDR_EXP 3
4064: PUSH
4065: EMPTY
4066: ST_TO_ADDR
// MREG_Tame := [ ] ;
4067: LD_ADDR_EXP 5
4071: PUSH
4072: EMPTY
4073: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
4074: LD_ADDR_EXP 6
4078: PUSH
4079: EMPTY
4080: ST_TO_ADDR
// MREG_SidesList := [ ] ;
4081: LD_ADDR_EXP 7
4085: PUSH
4086: EMPTY
4087: ST_TO_ADDR
// MREG_LabList := [ ] ;
4088: LD_ADDR_EXP 8
4092: PUSH
4093: EMPTY
4094: ST_TO_ADDR
// MREG_Cargo := [ ] ;
4095: LD_ADDR_EXP 9
4099: PUSH
4100: EMPTY
4101: ST_TO_ADDR
// MREG_Crane := [ ] ;
4102: LD_ADDR_EXP 10
4106: PUSH
4107: EMPTY
4108: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
4109: LD_ADDR_EXP 11
4113: PUSH
4114: EMPTY
4115: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
4116: LD_ADDR_EXP 12
4120: PUSH
4121: EMPTY
4122: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
4123: LD_ADDR_EXP 13
4127: PUSH
4128: EMPTY
4129: ST_TO_ADDR
// MREG_Status := [ ] ;
4130: LD_ADDR_EXP 14
4134: PUSH
4135: EMPTY
4136: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
4137: LD_ADDR_EXP 15
4141: PUSH
4142: EMPTY
4143: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
4144: LD_ADDR_EXP 16
4148: PUSH
4149: EMPTY
4150: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
4151: LD_ADDR_EXP 17
4155: PUSH
4156: EMPTY
4157: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
4158: LD_ADDR_EXP 18
4162: PUSH
4163: EMPTY
4164: ST_TO_ADDR
// MREG_ToRes := [ ] ;
4165: LD_ADDR_EXP 19
4169: PUSH
4170: EMPTY
4171: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
4172: LD_ADDR_EXP 20
4176: PUSH
4177: EMPTY
4178: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
4179: LD_ADDR_EXP 21
4183: PUSH
4184: EMPTY
4185: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
4186: LD_ADDR_EXP 22
4190: PUSH
4191: EMPTY
4192: ST_TO_ADDR
// MREG_ToLab := [ ] ;
4193: LD_ADDR_EXP 23
4197: PUSH
4198: EMPTY
4199: ST_TO_ADDR
// MREG_ToFac := [ ] ;
4200: LD_ADDR_EXP 24
4204: PUSH
4205: EMPTY
4206: ST_TO_ADDR
// MREG_ToArm := [ ] ;
4207: LD_ADDR_EXP 25
4211: PUSH
4212: EMPTY
4213: ST_TO_ADDR
// MREG_ToDep := [ ] ;
4214: LD_ADDR_EXP 26
4218: PUSH
4219: EMPTY
4220: ST_TO_ADDR
// MREG_Parking := [ ] ;
4221: LD_ADDR_EXP 27
4225: PUSH
4226: EMPTY
4227: ST_TO_ADDR
// MREG_VCombat := [ ] ;
4228: LD_ADDR_EXP 28
4232: PUSH
4233: EMPTY
4234: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
4235: LD_ADDR_EXP 31
4239: PUSH
4240: LD_INT 300
4242: PUSH
4243: LD_INT 100
4245: PUSH
4246: LD_INT 25
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: LIST
4253: ST_TO_ADDR
// end ;
4254: LD_VAR 0 1
4258: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
4259: LD_INT 0
4261: PPUSH
// if [ side , unit , mreg ] in mreg_list then
4262: LD_VAR 0 2
4266: PUSH
4267: LD_VAR 0 3
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: EMPTY
4278: LIST
4279: LIST
4280: LIST
4281: PUSH
4282: LD_VAR 0 1
4286: IN
4287: IFFALSE 4301
// result := mreg_list else
4289: LD_ADDR_VAR 0 5
4293: PUSH
4294: LD_VAR 0 1
4298: ST_TO_ADDR
4299: GO 4335
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
4301: LD_ADDR_VAR 0 1
4305: PUSH
4306: LD_VAR 0 1
4310: PUSH
4311: LD_VAR 0 2
4315: PUSH
4316: LD_VAR 0 3
4320: PUSH
4321: LD_VAR 0 4
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: LIST
4330: PUSH
4331: EMPTY
4332: LIST
4333: ADD
4334: ST_TO_ADDR
// result := mreg_list ;
4335: LD_ADDR_VAR 0 5
4339: PUSH
4340: LD_VAR 0 1
4344: ST_TO_ADDR
// end ;
4345: LD_VAR 0 5
4349: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
4350: LD_INT 0
4352: PPUSH
// if [ side , unit , mreg ] in mreg_list then
4353: LD_VAR 0 2
4357: PUSH
4358: LD_VAR 0 3
4362: PUSH
4363: LD_VAR 0 4
4367: PUSH
4368: EMPTY
4369: LIST
4370: LIST
4371: LIST
4372: PUSH
4373: LD_VAR 0 1
4377: IN
4378: IFFALSE 4416
// result := mreg_list diff [ [ side , unit , mreg ] ] else
4380: LD_ADDR_VAR 0 5
4384: PUSH
4385: LD_VAR 0 1
4389: PUSH
4390: LD_VAR 0 2
4394: PUSH
4395: LD_VAR 0 3
4399: PUSH
4400: LD_VAR 0 4
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: LIST
4409: PUSH
4410: EMPTY
4411: LIST
4412: DIFF
4413: ST_TO_ADDR
4414: GO 4426
// result := mreg_list ;
4416: LD_ADDR_VAR 0 5
4420: PUSH
4421: LD_VAR 0 1
4425: ST_TO_ADDR
// end ;
4426: LD_VAR 0 5
4430: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
4431: LD_INT 0
4433: PPUSH
4434: PPUSH
4435: PPUSH
// for j = 1 to 8 do
4436: LD_ADDR_VAR 0 3
4440: PUSH
4441: DOUBLE
4442: LD_INT 1
4444: DEC
4445: ST_TO_ADDR
4446: LD_INT 8
4448: PUSH
4449: FOR_TO
4450: IFFALSE 5346
// begin if MCF_Get ( j , [ f_alive ] ) then
4452: LD_VAR 0 3
4456: PPUSH
4457: LD_INT 51
4459: PUSH
4460: EMPTY
4461: LIST
4462: PPUSH
4463: CALL 0 0 2
4467: IFFALSE 4485
// MREG_SidesList := MREG_SidesList ^ 1 else
4469: LD_ADDR_EXP 7
4473: PUSH
4474: LD_EXP 7
4478: PUSH
4479: LD_INT 1
4481: ADD
4482: ST_TO_ADDR
4483: GO 4499
// MREG_SidesList := MREG_SidesList ^ 0 ;
4485: LD_ADDR_EXP 7
4489: PUSH
4490: LD_EXP 7
4494: PUSH
4495: LD_INT 0
4497: ADD
4498: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
4499: LD_VAR 0 3
4503: PPUSH
4504: LD_INT 2
4506: PUSH
4507: LD_INT 34
4509: PUSH
4510: LD_INT 12
4512: PUSH
4513: EMPTY
4514: LIST
4515: LIST
4516: PUSH
4517: LD_INT 34
4519: PUSH
4520: LD_INT 32
4522: PUSH
4523: EMPTY
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 34
4529: PUSH
4530: LD_INT 51
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: LIST
4541: LIST
4542: PUSH
4543: EMPTY
4544: LIST
4545: PPUSH
4546: CALL 301 0 2
4550: IFFALSE 4651
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
4552: LD_ADDR_VAR 0 2
4556: PUSH
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 2
4564: PUSH
4565: LD_INT 34
4567: PUSH
4568: LD_INT 12
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: PUSH
4575: LD_INT 34
4577: PUSH
4578: LD_INT 32
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PUSH
4585: LD_INT 34
4587: PUSH
4588: LD_INT 51
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: PUSH
4595: EMPTY
4596: LIST
4597: LIST
4598: LIST
4599: PUSH
4600: EMPTY
4601: LIST
4602: LIST
4603: PPUSH
4604: CALL 301 0 2
4608: PUSH
4609: FOR_IN
4610: IFFALSE 4649
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
4612: LD_ADDR_EXP 9
4616: PUSH
4617: LD_EXP 9
4621: PPUSH
4622: LD_VAR 0 3
4626: PPUSH
4627: LD_VAR 0 2
4631: PPUSH
4632: LD_VAR 0 2
4636: PPUSH
4637: CALL_OW 264
4641: PPUSH
4642: CALL 4259 0 4
4646: ST_TO_ADDR
4647: GO 4609
4649: POP
4650: POP
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) then
4651: LD_VAR 0 3
4655: PPUSH
4656: LD_INT 2
4658: PUSH
4659: LD_INT 34
4661: PUSH
4662: LD_INT 13
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 34
4671: PUSH
4672: LD_INT 52
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: LIST
4683: PUSH
4684: EMPTY
4685: LIST
4686: PPUSH
4687: CALL 301 0 2
4691: IFFALSE 4781
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) do
4693: LD_ADDR_VAR 0 2
4697: PUSH
4698: LD_VAR 0 3
4702: PPUSH
4703: LD_INT 2
4705: PUSH
4706: LD_INT 34
4708: PUSH
4709: LD_INT 13
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: PUSH
4716: LD_INT 34
4718: PUSH
4719: LD_INT 52
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL 301 0 2
4738: PUSH
4739: FOR_IN
4740: IFFALSE 4779
// MREG_Crane := MC_RegistryUpdate ( MREG_Crane , j , i , GetWeapon ( i ) ) ;
4742: LD_ADDR_EXP 10
4746: PUSH
4747: LD_EXP 10
4751: PPUSH
4752: LD_VAR 0 3
4756: PPUSH
4757: LD_VAR 0 2
4761: PPUSH
4762: LD_VAR 0 2
4766: PPUSH
4767: CALL_OW 264
4771: PPUSH
4772: CALL 4259 0 4
4776: ST_TO_ADDR
4777: GO 4739
4779: POP
4780: POP
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] ] ] ) then
4781: LD_VAR 0 3
4785: PPUSH
4786: LD_INT 2
4788: PUSH
4789: LD_INT 34
4791: PUSH
4792: LD_INT 14
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: LD_INT 34
4801: PUSH
4802: LD_INT 53
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: LIST
4813: PUSH
4814: EMPTY
4815: LIST
4816: PPUSH
4817: CALL 301 0 2
4821: IFFALSE 4911
// for i in MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] ] ] ) do
4823: LD_ADDR_VAR 0 2
4827: PUSH
4828: LD_VAR 0 3
4832: PPUSH
4833: LD_INT 2
4835: PUSH
4836: LD_INT 34
4838: PUSH
4839: LD_INT 14
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: PUSH
4846: LD_INT 34
4848: PUSH
4849: LD_INT 53
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: LIST
4860: PUSH
4861: EMPTY
4862: LIST
4863: PPUSH
4864: CALL 301 0 2
4868: PUSH
4869: FOR_IN
4870: IFFALSE 4909
// MREG_Bulldozer := MC_RegistryUpdate ( MREG_Bulldozer , j , i , GetWeapon ( i ) ) ;
4872: LD_ADDR_EXP 11
4876: PUSH
4877: LD_EXP 11
4881: PPUSH
4882: LD_VAR 0 3
4886: PPUSH
4887: LD_VAR 0 2
4891: PPUSH
4892: LD_VAR 0 2
4896: PPUSH
4897: CALL_OW 264
4901: PPUSH
4902: CALL 4259 0 4
4906: ST_TO_ADDR
4907: GO 4869
4909: POP
4910: POP
// if MCF_Class ( j , 4 , [ ] ) then
4911: LD_VAR 0 3
4915: PPUSH
4916: LD_INT 4
4918: PPUSH
4919: EMPTY
4920: PPUSH
4921: CALL 83 0 3
4925: IFFALSE 4958
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
4927: LD_ADDR_EXP 23
4931: PUSH
4932: LD_EXP 23
4936: PUSH
4937: LD_VAR 0 3
4941: PPUSH
4942: LD_INT 4
4944: PPUSH
4945: EMPTY
4946: PPUSH
4947: CALL 83 0 3
4951: PUSH
4952: EMPTY
4953: LIST
4954: ADD
4955: ST_TO_ADDR
4956: GO 4975
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
4958: LD_ADDR_EXP 23
4962: PUSH
4963: LD_EXP 23
4967: PUSH
4968: LD_INT 0
4970: PUSH
4971: EMPTY
4972: LIST
4973: ADD
4974: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
4975: LD_VAR 0 3
4979: PPUSH
4980: LD_INT 3
4982: PPUSH
4983: EMPTY
4984: PPUSH
4985: CALL 83 0 3
4989: IFFALSE 5022
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
4991: LD_ADDR_EXP 24
4995: PUSH
4996: LD_EXP 24
5000: PUSH
5001: LD_VAR 0 3
5005: PPUSH
5006: LD_INT 3
5008: PPUSH
5009: EMPTY
5010: PPUSH
5011: CALL 83 0 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: ADD
5019: ST_TO_ADDR
5020: GO 5039
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
5022: LD_ADDR_EXP 24
5026: PUSH
5027: LD_EXP 24
5031: PUSH
5032: LD_INT 0
5034: PUSH
5035: EMPTY
5036: LIST
5037: ADD
5038: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
5039: LD_VAR 0 3
5043: PPUSH
5044: LD_INT 1
5046: PPUSH
5047: EMPTY
5048: PPUSH
5049: CALL 83 0 3
5053: IFFALSE 5086
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
5055: LD_ADDR_EXP 25
5059: PUSH
5060: LD_EXP 25
5064: PUSH
5065: LD_VAR 0 3
5069: PPUSH
5070: LD_INT 1
5072: PPUSH
5073: EMPTY
5074: PPUSH
5075: CALL 83 0 3
5079: PUSH
5080: EMPTY
5081: LIST
5082: ADD
5083: ST_TO_ADDR
5084: GO 5103
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
5086: LD_ADDR_EXP 25
5090: PUSH
5091: LD_EXP 25
5095: PUSH
5096: LD_INT 0
5098: PUSH
5099: EMPTY
5100: LIST
5101: ADD
5102: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
5103: LD_VAR 0 3
5107: PPUSH
5108: LD_INT 2
5110: PPUSH
5111: EMPTY
5112: PPUSH
5113: CALL 83 0 3
5117: IFFALSE 5150
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
5119: LD_ADDR_EXP 26
5123: PUSH
5124: LD_EXP 26
5128: PUSH
5129: LD_VAR 0 3
5133: PPUSH
5134: LD_INT 2
5136: PPUSH
5137: EMPTY
5138: PPUSH
5139: CALL 83 0 3
5143: PUSH
5144: EMPTY
5145: LIST
5146: ADD
5147: ST_TO_ADDR
5148: GO 5167
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
5150: LD_ADDR_EXP 26
5154: PUSH
5155: LD_EXP 26
5159: PUSH
5160: LD_INT 0
5162: PUSH
5163: EMPTY
5164: LIST
5165: ADD
5166: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
5167: LD_ADDR_EXP 16
5171: PUSH
5172: LD_EXP 16
5176: PUSH
5177: LD_INT 0
5179: PUSH
5180: EMPTY
5181: LIST
5182: ADD
5183: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
5184: LD_ADDR_EXP 3
5188: PUSH
5189: LD_EXP 3
5193: PUSH
5194: LD_INT 0
5196: PUSH
5197: EMPTY
5198: LIST
5199: ADD
5200: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
5201: LD_ADDR_EXP 5
5205: PUSH
5206: LD_EXP 5
5210: PUSH
5211: LD_INT 0
5213: PUSH
5214: EMPTY
5215: LIST
5216: ADD
5217: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
5218: LD_ADDR_EXP 27
5222: PUSH
5223: LD_EXP 27
5227: PUSH
5228: LD_INT 0
5230: PUSH
5231: EMPTY
5232: LIST
5233: ADD
5234: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
5235: LD_ADDR_EXP 28
5239: PUSH
5240: LD_EXP 28
5244: PUSH
5245: LD_INT 0
5247: PUSH
5248: EMPTY
5249: LIST
5250: ADD
5251: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
5252: LD_ADDR_EXP 20
5256: PUSH
5257: LD_EXP 20
5261: PUSH
5262: LD_INT 0
5264: PUSH
5265: EMPTY
5266: LIST
5267: ADD
5268: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
5269: LD_ADDR_EXP 6
5273: PUSH
5274: LD_EXP 6
5278: PUSH
5279: LD_INT 0
5281: PUSH
5282: LD_INT 0
5284: PUSH
5285: LD_INT 0
5287: PUSH
5288: LD_INT 0
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: LIST
5296: PUSH
5297: EMPTY
5298: LIST
5299: ADD
5300: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
5301: LD_ADDR_EXP 29
5305: PUSH
5306: LD_EXP 29
5310: PUSH
5311: LD_INT 0
5313: PUSH
5314: EMPTY
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: PUSH
5320: EMPTY
5321: LIST
5322: ADD
5323: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
5324: LD_ADDR_EXP 30
5328: PUSH
5329: LD_EXP 30
5333: PUSH
5334: LD_INT 0
5336: PUSH
5337: EMPTY
5338: LIST
5339: PUSH
5340: EMPTY
5341: LIST
5342: ADD
5343: ST_TO_ADDR
// end ;
5344: GO 4449
5346: POP
5347: POP
// end ;
5348: LD_VAR 0 1
5352: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
5353: LD_INT 0
5355: PPUSH
5356: PPUSH
5357: PPUSH
// m := false ;
5358: LD_ADDR_VAR 0 5
5362: PUSH
5363: LD_INT 0
5365: ST_TO_ADDR
// for i = 1 to mreg do
5366: LD_ADDR_VAR 0 4
5370: PUSH
5371: DOUBLE
5372: LD_INT 1
5374: DEC
5375: ST_TO_ADDR
5376: LD_VAR 0 2
5380: PUSH
5381: FOR_TO
5382: IFFALSE 5418
// if mreg [ i ] [ 1 ] = side then
5384: LD_VAR 0 2
5388: PUSH
5389: LD_VAR 0 4
5393: ARRAY
5394: PUSH
5395: LD_INT 1
5397: ARRAY
5398: PUSH
5399: LD_VAR 0 1
5403: EQUAL
5404: IFFALSE 5416
// begin m := true ;
5406: LD_ADDR_VAR 0 5
5410: PUSH
5411: LD_INT 1
5413: ST_TO_ADDR
// break ;
5414: GO 5418
// end ;
5416: GO 5381
5418: POP
5419: POP
// result := m ;
5420: LD_ADDR_VAR 0 3
5424: PUSH
5425: LD_VAR 0 5
5429: ST_TO_ADDR
// end ;
5430: LD_VAR 0 3
5434: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
5435: LD_INT 0
5437: PPUSH
5438: PPUSH
5439: PPUSH
// m := 0 ;
5440: LD_ADDR_VAR 0 5
5444: PUSH
5445: LD_INT 0
5447: ST_TO_ADDR
// for i = 1 to mreg do
5448: LD_ADDR_VAR 0 4
5452: PUSH
5453: DOUBLE
5454: LD_INT 1
5456: DEC
5457: ST_TO_ADDR
5458: LD_VAR 0 2
5462: PUSH
5463: FOR_TO
5464: IFFALSE 5504
// if mreg [ i ] [ 1 ] = side then
5466: LD_VAR 0 2
5470: PUSH
5471: LD_VAR 0 4
5475: ARRAY
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PUSH
5481: LD_VAR 0 1
5485: EQUAL
5486: IFFALSE 5502
// begin m := m + 1 ;
5488: LD_ADDR_VAR 0 5
5492: PUSH
5493: LD_VAR 0 5
5497: PUSH
5498: LD_INT 1
5500: PLUS
5501: ST_TO_ADDR
// end ;
5502: GO 5463
5504: POP
5505: POP
// result := m ;
5506: LD_ADDR_VAR 0 3
5510: PUSH
5511: LD_VAR 0 5
5515: ST_TO_ADDR
// end ;
5516: LD_VAR 0 3
5520: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
5521: LD_INT 0
5523: PPUSH
5524: PPUSH
// result := 0 ;
5525: LD_ADDR_VAR 0 3
5529: PUSH
5530: LD_INT 0
5532: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
5533: LD_ADDR_VAR 0 4
5537: PUSH
5538: DOUBLE
5539: LD_INT 1
5541: DEC
5542: ST_TO_ADDR
5543: LD_EXP 22
5547: PUSH
5548: FOR_TO
5549: IFFALSE 5611
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
5551: LD_EXP 22
5555: PUSH
5556: LD_VAR 0 4
5560: ARRAY
5561: PUSH
5562: LD_INT 1
5564: ARRAY
5565: PUSH
5566: LD_VAR 0 1
5570: EQUAL
5571: PUSH
5572: LD_EXP 22
5576: PUSH
5577: LD_VAR 0 4
5581: ARRAY
5582: PUSH
5583: LD_INT 2
5585: ARRAY
5586: PUSH
5587: LD_VAR 0 2
5591: EQUAL
5592: AND
5593: IFFALSE 5609
// begin result := result + 1 ;
5595: LD_ADDR_VAR 0 3
5599: PUSH
5600: LD_VAR 0 3
5604: PUSH
5605: LD_INT 1
5607: PLUS
5608: ST_TO_ADDR
// end ;
5609: GO 5548
5611: POP
5612: POP
// end ; end_of_file
5613: LD_VAR 0 3
5617: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
5618: LD_INT 0
5620: PPUSH
// CreateDepositXY ( x , y , t ) ;
5621: LD_VAR 0 1
5625: PPUSH
5626: LD_VAR 0 2
5630: PPUSH
5631: LD_VAR 0 3
5635: PPUSH
5636: CALL_OW 62
// end ;
5640: LD_VAR 0 4
5644: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
5645: LD_INT 0
5647: PPUSH
5648: PPUSH
// c := 1 ;
5649: LD_ADDR_VAR 0 5
5653: PUSH
5654: LD_INT 1
5656: ST_TO_ADDR
// case color of red :
5657: LD_VAR 0 3
5661: PUSH
5662: LD_STRING red
5664: DOUBLE
5665: EQUAL
5666: IFTRUE 5670
5668: GO 5681
5670: POP
// c = 1 ; dark-green :
5671: LD_ADDR_VAR 0 5
5675: PUSH
5676: LD_INT 1
5678: ST_TO_ADDR
5679: GO 5967
5681: LD_STRING dark-green
5683: DOUBLE
5684: EQUAL
5685: IFTRUE 5689
5687: GO 5700
5689: POP
// c = 2 ; purple :
5690: LD_ADDR_VAR 0 5
5694: PUSH
5695: LD_INT 2
5697: ST_TO_ADDR
5698: GO 5967
5700: LD_STRING purple
5702: DOUBLE
5703: EQUAL
5704: IFTRUE 5708
5706: GO 5719
5708: POP
// c = 3 ; aqua :
5709: LD_ADDR_VAR 0 5
5713: PUSH
5714: LD_INT 3
5716: ST_TO_ADDR
5717: GO 5967
5719: LD_STRING aqua
5721: DOUBLE
5722: EQUAL
5723: IFTRUE 5727
5725: GO 5738
5727: POP
// c = 4 ; grey :
5728: LD_ADDR_VAR 0 5
5732: PUSH
5733: LD_INT 4
5735: ST_TO_ADDR
5736: GO 5967
5738: LD_STRING grey
5740: DOUBLE
5741: EQUAL
5742: IFTRUE 5746
5744: GO 5757
5746: POP
// c = 5 ; lime :
5747: LD_ADDR_VAR 0 5
5751: PUSH
5752: LD_INT 5
5754: ST_TO_ADDR
5755: GO 5967
5757: LD_STRING lime
5759: DOUBLE
5760: EQUAL
5761: IFTRUE 5765
5763: GO 5776
5765: POP
// c = 6 ; tan :
5766: LD_ADDR_VAR 0 5
5770: PUSH
5771: LD_INT 6
5773: ST_TO_ADDR
5774: GO 5967
5776: LD_STRING tan
5778: DOUBLE
5779: EQUAL
5780: IFTRUE 5784
5782: GO 5795
5784: POP
// c = 7 ; pink :
5785: LD_ADDR_VAR 0 5
5789: PUSH
5790: LD_INT 7
5792: ST_TO_ADDR
5793: GO 5967
5795: LD_STRING pink
5797: DOUBLE
5798: EQUAL
5799: IFTRUE 5803
5801: GO 5814
5803: POP
// c = 8 ; green :
5804: LD_ADDR_VAR 0 5
5808: PUSH
5809: LD_INT 8
5811: ST_TO_ADDR
5812: GO 5967
5814: LD_STRING green
5816: DOUBLE
5817: EQUAL
5818: IFTRUE 5822
5820: GO 5833
5822: POP
// c = 9 ; blue :
5823: LD_ADDR_VAR 0 5
5827: PUSH
5828: LD_INT 9
5830: ST_TO_ADDR
5831: GO 5967
5833: LD_STRING blue
5835: DOUBLE
5836: EQUAL
5837: IFTRUE 5841
5839: GO 5852
5841: POP
// c = 10 ; yellow :
5842: LD_ADDR_VAR 0 5
5846: PUSH
5847: LD_INT 10
5849: ST_TO_ADDR
5850: GO 5967
5852: LD_STRING yellow
5854: DOUBLE
5855: EQUAL
5856: IFTRUE 5860
5858: GO 5871
5860: POP
// c = 11 ; brown :
5861: LD_ADDR_VAR 0 5
5865: PUSH
5866: LD_INT 11
5868: ST_TO_ADDR
5869: GO 5967
5871: LD_STRING brown
5873: DOUBLE
5874: EQUAL
5875: IFTRUE 5879
5877: GO 5890
5879: POP
// c = 12 ; black :
5880: LD_ADDR_VAR 0 5
5884: PUSH
5885: LD_INT 12
5887: ST_TO_ADDR
5888: GO 5967
5890: LD_STRING black
5892: DOUBLE
5893: EQUAL
5894: IFTRUE 5898
5896: GO 5909
5898: POP
// c = 13 ; aqua2 :
5899: LD_ADDR_VAR 0 5
5903: PUSH
5904: LD_INT 13
5906: ST_TO_ADDR
5907: GO 5967
5909: LD_STRING aqua2
5911: DOUBLE
5912: EQUAL
5913: IFTRUE 5917
5915: GO 5928
5917: POP
// c = 14 ; orange :
5918: LD_ADDR_VAR 0 5
5922: PUSH
5923: LD_INT 14
5925: ST_TO_ADDR
5926: GO 5967
5928: LD_STRING orange
5930: DOUBLE
5931: EQUAL
5932: IFTRUE 5936
5934: GO 5947
5936: POP
// c = 15 ; white :
5937: LD_ADDR_VAR 0 5
5941: PUSH
5942: LD_INT 15
5944: ST_TO_ADDR
5945: GO 5967
5947: LD_STRING white
5949: DOUBLE
5950: EQUAL
5951: IFTRUE 5955
5953: GO 5966
5955: POP
// c = 16 ; end ;
5956: LD_ADDR_VAR 0 5
5960: PUSH
5961: LD_INT 16
5963: ST_TO_ADDR
5964: GO 5967
5966: POP
// if HexInfo ( x , y ) = 0 then
5967: LD_VAR 0 1
5971: PPUSH
5972: LD_VAR 0 2
5976: PPUSH
5977: CALL_OW 428
5981: PUSH
5982: LD_INT 0
5984: EQUAL
5985: IFFALSE 6009
// PlaceEnvironment ( x , y , 58 , c ) ;
5987: LD_VAR 0 1
5991: PPUSH
5992: LD_VAR 0 2
5996: PPUSH
5997: LD_INT 58
5999: PPUSH
6000: LD_VAR 0 5
6004: PPUSH
6005: CALL_OW 349
// end ;
6009: LD_VAR 0 4
6013: RET
// export function MCT_RemovePlace ( x , y ) ; begin
6014: LD_INT 0
6016: PPUSH
// RemoveEnvironment ( x , y ) ;
6017: LD_VAR 0 1
6021: PPUSH
6022: LD_VAR 0 2
6026: PPUSH
6027: CALL_OW 347
// end ;
6031: LD_VAR 0 3
6035: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
6036: LD_INT 0
6038: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
6039: LD_INT 81
6041: PUSH
6042: LD_VAR 0 1
6046: PUSH
6047: EMPTY
6048: LIST
6049: LIST
6050: PPUSH
6051: CALL_OW 69
6055: PUSH
6056: LD_INT 0
6058: EQUAL
6059: IFFALSE 6071
// result := false else
6061: LD_ADDR_VAR 0 5
6065: PUSH
6066: LD_INT 0
6068: ST_TO_ADDR
6069: GO 6135
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
6071: LD_INT 81
6073: PUSH
6074: LD_VAR 0 1
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: PUSH
6083: LD_INT 92
6085: PUSH
6086: LD_VAR 0 2
6090: PUSH
6091: LD_VAR 0 3
6095: PUSH
6096: LD_VAR 0 4
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PPUSH
6111: CALL_OW 69
6115: IFFALSE 6127
// result := true else
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_INT 1
6124: ST_TO_ADDR
6125: GO 6135
// result := false ;
6127: LD_ADDR_VAR 0 5
6131: PUSH
6132: LD_INT 0
6134: ST_TO_ADDR
// end ;
6135: LD_VAR 0 5
6139: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
6140: LD_INT 0
6142: PPUSH
6143: PPUSH
6144: PPUSH
6145: PPUSH
6146: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
6147: LD_VAR 0 1
6151: PPUSH
6152: LD_INT 81
6154: PUSH
6155: LD_VAR 0 1
6159: PPUSH
6160: CALL_OW 255
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PPUSH
6169: CALL_OW 69
6173: PPUSH
6174: LD_VAR 0 1
6178: PPUSH
6179: CALL_OW 74
6183: PPUSH
6184: CALL_OW 119
// dir := GetDir ( un ) ;
6188: LD_ADDR_VAR 0 4
6192: PUSH
6193: LD_VAR 0 1
6197: PPUSH
6198: CALL_OW 254
6202: ST_TO_ADDR
// dir := dir - 3 ;
6203: LD_ADDR_VAR 0 4
6207: PUSH
6208: LD_VAR 0 4
6212: PUSH
6213: LD_INT 3
6215: MINUS
6216: ST_TO_ADDR
// if dir < 0 then
6217: LD_VAR 0 4
6221: PUSH
6222: LD_INT 0
6224: LESS
6225: IFFALSE 6241
// dir := dir + 6 ;
6227: LD_ADDR_VAR 0 4
6231: PUSH
6232: LD_VAR 0 4
6236: PUSH
6237: LD_INT 6
6239: PLUS
6240: ST_TO_ADDR
// while true do
6241: LD_INT 1
6243: IFFALSE 6740
// begin coord_dist := 3 ;
6245: LD_ADDR_VAR 0 3
6249: PUSH
6250: LD_INT 3
6252: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
6253: LD_ADDR_VAR 0 5
6257: PUSH
6258: LD_VAR 0 1
6262: PPUSH
6263: CALL_OW 250
6267: PPUSH
6268: LD_VAR 0 4
6272: PPUSH
6273: LD_VAR 0 3
6277: PPUSH
6278: CALL_OW 272
6282: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
6283: LD_ADDR_VAR 0 6
6287: PUSH
6288: LD_VAR 0 1
6292: PPUSH
6293: CALL_OW 251
6297: PPUSH
6298: LD_VAR 0 4
6302: PPUSH
6303: LD_VAR 0 3
6307: PPUSH
6308: CALL_OW 273
6312: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
6313: LD_VAR 0 1
6317: PPUSH
6318: CALL_OW 255
6322: PPUSH
6323: LD_VAR 0 1
6327: PPUSH
6328: CALL_OW 250
6332: PPUSH
6333: LD_VAR 0 1
6337: PPUSH
6338: CALL_OW 251
6342: PPUSH
6343: LD_INT 14
6345: PPUSH
6346: CALL 6036 0 4
6350: PUSH
6351: LD_VAR 0 5
6355: PPUSH
6356: LD_VAR 0 6
6360: PPUSH
6361: CALL_OW 351
6365: OR
6366: PUSH
6367: LD_VAR 0 5
6371: PPUSH
6372: LD_VAR 0 6
6376: PPUSH
6377: CALL_OW 488
6381: PUSH
6382: LD_INT 0
6384: EQUAL
6385: OR
6386: PUSH
6387: LD_VAR 0 5
6391: PPUSH
6392: LD_VAR 0 6
6396: PPUSH
6397: CALL_OW 546
6401: PUSH
6402: LD_INT 1
6404: EQUAL
6405: OR
6406: PUSH
6407: LD_VAR 0 5
6411: PPUSH
6412: LD_VAR 0 6
6416: PPUSH
6417: CALL_OW 428
6421: PUSH
6422: LD_INT 0
6424: NONEQUAL
6425: OR
6426: IFFALSE 6654
// begin repeat begin Wait ( 0 0$0.3 ) ;
6428: LD_INT 10
6430: PPUSH
6431: CALL_OW 67
// coord_dist := coord_dist + 1 ;
6435: LD_ADDR_VAR 0 3
6439: PUSH
6440: LD_VAR 0 3
6444: PUSH
6445: LD_INT 1
6447: PLUS
6448: ST_TO_ADDR
// dir := dir + 1 ;
6449: LD_ADDR_VAR 0 4
6453: PUSH
6454: LD_VAR 0 4
6458: PUSH
6459: LD_INT 1
6461: PLUS
6462: ST_TO_ADDR
// if dir > 5 then
6463: LD_VAR 0 4
6467: PUSH
6468: LD_INT 5
6470: GREATER
6471: IFFALSE 6481
// dir = 0 ;
6473: LD_ADDR_VAR 0 4
6477: PUSH
6478: LD_INT 0
6480: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
6481: LD_ADDR_VAR 0 5
6485: PUSH
6486: LD_VAR 0 1
6490: PPUSH
6491: CALL_OW 250
6495: PPUSH
6496: LD_VAR 0 4
6500: PPUSH
6501: LD_VAR 0 3
6505: PPUSH
6506: CALL_OW 272
6510: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 1
6520: PPUSH
6521: CALL_OW 251
6525: PPUSH
6526: LD_VAR 0 4
6530: PPUSH
6531: LD_VAR 0 3
6535: PPUSH
6536: CALL_OW 273
6540: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
6541: LD_VAR 0 1
6545: PPUSH
6546: CALL_OW 255
6550: PPUSH
6551: LD_VAR 0 1
6555: PPUSH
6556: CALL_OW 250
6560: PPUSH
6561: LD_VAR 0 1
6565: PPUSH
6566: CALL_OW 251
6570: PPUSH
6571: LD_INT 14
6573: PPUSH
6574: CALL 6036 0 4
6578: NOT
6579: PUSH
6580: LD_VAR 0 5
6584: PPUSH
6585: LD_VAR 0 6
6589: PPUSH
6590: CALL_OW 351
6594: NOT
6595: AND
6596: PUSH
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 6
6606: PPUSH
6607: CALL_OW 488
6611: AND
6612: PUSH
6613: LD_VAR 0 5
6617: PPUSH
6618: LD_VAR 0 6
6622: PPUSH
6623: CALL_OW 546
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: AND
6632: PUSH
6633: LD_VAR 0 5
6637: PPUSH
6638: LD_VAR 0 6
6642: PPUSH
6643: CALL_OW 428
6647: PUSH
6648: LD_INT 0
6650: EQUAL
6651: AND
6652: IFFALSE 6428
// end ; ComMoveXY ( un , x , y ) ;
6654: LD_VAR 0 1
6658: PPUSH
6659: LD_VAR 0 5
6663: PPUSH
6664: LD_VAR 0 6
6668: PPUSH
6669: CALL_OW 111
// Wait ( 0 0$1 ) ;
6673: LD_INT 35
6675: PPUSH
6676: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
6680: LD_VAR 0 1
6684: PPUSH
6685: LD_INT 81
6687: PUSH
6688: LD_VAR 0 1
6692: PPUSH
6693: CALL_OW 255
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 69
6706: PPUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 74
6716: PPUSH
6717: CALL_OW 296
6721: PUSH
6722: LD_INT 14
6724: GREATEREQUAL
6725: IFFALSE 6738
// begin ComStop ( un ) ;
6727: LD_VAR 0 1
6731: PPUSH
6732: CALL_OW 141
// break ;
6736: GO 6740
// end ; end ;
6738: GO 6241
// end ;
6740: LD_VAR 0 2
6744: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
6745: LD_INT 0
6747: PPUSH
6748: PPUSH
6749: PPUSH
6750: PPUSH
6751: PPUSH
6752: PPUSH
6753: PPUSH
6754: PPUSH
// x := GetX ( unit ) ;
6755: LD_ADDR_VAR 0 3
6759: PUSH
6760: LD_VAR 0 1
6764: PPUSH
6765: CALL_OW 250
6769: ST_TO_ADDR
// y := GetY ( unit ) ;
6770: LD_ADDR_VAR 0 4
6774: PUSH
6775: LD_VAR 0 1
6779: PPUSH
6780: CALL_OW 251
6784: ST_TO_ADDR
// i := 0 ;
6785: LD_ADDR_VAR 0 8
6789: PUSH
6790: LD_INT 0
6792: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
6793: LD_VAR 0 1
6797: PPUSH
6798: LD_INT 81
6800: PUSH
6801: LD_VAR 0 1
6805: PPUSH
6806: CALL_OW 255
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: PPUSH
6815: CALL_OW 69
6819: PPUSH
6820: LD_VAR 0 1
6824: PPUSH
6825: CALL_OW 74
6829: PPUSH
6830: CALL_OW 119
// dir := GetDir ( unit ) ;
6834: LD_ADDR_VAR 0 7
6838: PUSH
6839: LD_VAR 0 1
6843: PPUSH
6844: CALL_OW 254
6848: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
6849: LD_ADDR_VAR 0 9
6853: PUSH
6854: LD_INT 0
6856: PPUSH
6857: LD_INT 1
6859: PPUSH
6860: CALL_OW 12
6864: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
6865: LD_INT 10
6867: PPUSH
6868: CALL_OW 67
// if mode then
6872: LD_VAR 0 9
6876: IFFALSE 6894
// dir := dir + 1 else
6878: LD_ADDR_VAR 0 7
6882: PUSH
6883: LD_VAR 0 7
6887: PUSH
6888: LD_INT 1
6890: PLUS
6891: ST_TO_ADDR
6892: GO 6908
// dir := dir - 1 ;
6894: LD_ADDR_VAR 0 7
6898: PUSH
6899: LD_VAR 0 7
6903: PUSH
6904: LD_INT 1
6906: MINUS
6907: ST_TO_ADDR
// if ( dir < 0 ) then
6908: LD_VAR 0 7
6912: PUSH
6913: LD_INT 0
6915: LESS
6916: IFFALSE 6926
// dir := 5 ;
6918: LD_ADDR_VAR 0 7
6922: PUSH
6923: LD_INT 5
6925: ST_TO_ADDR
// if ( dir > 5 ) then
6926: LD_VAR 0 7
6930: PUSH
6931: LD_INT 5
6933: GREATER
6934: IFFALSE 6944
// dir := 0 ;
6936: LD_ADDR_VAR 0 7
6940: PUSH
6941: LD_INT 0
6943: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
6944: LD_ADDR_VAR 0 5
6948: PUSH
6949: LD_VAR 0 3
6953: PPUSH
6954: LD_VAR 0 7
6958: PPUSH
6959: LD_INT 4
6961: PPUSH
6962: CALL_OW 272
6966: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
6967: LD_ADDR_VAR 0 6
6971: PUSH
6972: LD_VAR 0 4
6976: PPUSH
6977: LD_VAR 0 7
6981: PPUSH
6982: LD_INT 4
6984: PPUSH
6985: CALL_OW 273
6989: ST_TO_ADDR
// i := i + 1 ;
6990: LD_ADDR_VAR 0 8
6994: PUSH
6995: LD_VAR 0 8
6999: PUSH
7000: LD_INT 1
7002: PLUS
7003: ST_TO_ADDR
// MC_Show ( [ x , y , dir ] ^ [ x2 , y2 ] ) ;
7004: LD_VAR 0 3
7008: PUSH
7009: LD_VAR 0 4
7013: PUSH
7014: LD_VAR 0 7
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: LIST
7023: PUSH
7024: LD_VAR 0 5
7028: PUSH
7029: LD_VAR 0 6
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: ADD
7038: PPUSH
7039: CALL 4025 0 1
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
7043: LD_VAR 0 1
7047: PPUSH
7048: CALL_OW 255
7052: PPUSH
7053: LD_VAR 0 5
7057: PPUSH
7058: LD_VAR 0 6
7062: PPUSH
7063: LD_INT 14
7065: PPUSH
7066: CALL 6036 0 4
7070: PUSH
7071: LD_INT 0
7073: EQUAL
7074: PUSH
7075: LD_VAR 0 5
7079: PPUSH
7080: LD_VAR 0 6
7084: PPUSH
7085: CALL_OW 546
7089: PUSH
7090: LD_INT 0
7092: EQUAL
7093: AND
7094: PUSH
7095: LD_VAR 0 5
7099: PPUSH
7100: LD_VAR 0 6
7104: PPUSH
7105: CALL_OW 428
7109: PUSH
7110: LD_INT 0
7112: EQUAL
7113: AND
7114: IFFALSE 7118
// break ;
7116: GO 7128
// end until i > 4 ;
7118: LD_VAR 0 8
7122: PUSH
7123: LD_INT 4
7125: GREATER
7126: IFFALSE 6865
// if x2 and y2 then
7128: LD_VAR 0 5
7132: PUSH
7133: LD_VAR 0 6
7137: AND
7138: IFFALSE 7161
// result := [ x2 , y2 ] else
7140: LD_ADDR_VAR 0 2
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: LD_VAR 0 6
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: ST_TO_ADDR
7159: GO 7190
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
7161: LD_ADDR_VAR 0 2
7165: PUSH
7166: LD_VAR 0 1
7170: PPUSH
7171: CALL_OW 250
7175: PUSH
7176: LD_VAR 0 1
7180: PPUSH
7181: CALL_OW 251
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: ST_TO_ADDR
// end ;
7190: LD_VAR 0 2
7194: RET
// export function MCT_Hex ( x , y ) ; begin
7195: LD_INT 0
7197: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
7198: LD_ADDR_VAR 0 3
7202: PUSH
7203: LD_VAR 0 1
7207: PPUSH
7208: LD_VAR 0 2
7212: PPUSH
7213: CALL_OW 546
7217: PUSH
7218: LD_VAR 0 1
7222: PPUSH
7223: LD_VAR 0 2
7227: PPUSH
7228: CALL_OW 428
7232: PUSH
7233: EMPTY
7234: LIST
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: ST_TO_ADDR
// end ;
7240: LD_VAR 0 3
7244: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
7245: LD_INT 0
7247: PPUSH
7248: PPUSH
7249: PPUSH
7250: PPUSH
7251: PPUSH
7252: PPUSH
7253: PPUSH
7254: PPUSH
7255: PPUSH
7256: PPUSH
7257: PPUSH
7258: PPUSH
7259: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
7260: LD_ADDR_VAR 0 10
7264: PUSH
7265: LD_EXP 29
7269: PUSH
7270: LD_VAR 0 1
7274: ARRAY
7275: PUSH
7276: LD_INT 1
7278: ARRAY
7279: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
7280: LD_ADDR_VAR 0 11
7284: PUSH
7285: LD_EXP 29
7289: PUSH
7290: LD_VAR 0 1
7294: ARRAY
7295: PUSH
7296: LD_INT 2
7298: ARRAY
7299: ST_TO_ADDR
// collectors := [ ] ;
7300: LD_ADDR_VAR 0 12
7304: PUSH
7305: EMPTY
7306: ST_TO_ADDR
// is_cargo := false ;
7307: LD_ADDR_VAR 0 13
7311: PUSH
7312: LD_INT 0
7314: ST_TO_ADDR
// if isEditor then
7315: LD_INT 1
7317: IFFALSE 7323
// TimerStart ( ) ;
7319: CALL_OW 548
// if MCF_Cargo ( side ) then
7323: LD_VAR 0 1
7327: PPUSH
7328: CALL 351 0 1
7332: IFFALSE 7359
// begin collectors := MCF_Cargo ( side ) ;
7334: LD_ADDR_VAR 0 12
7338: PUSH
7339: LD_VAR 0 1
7343: PPUSH
7344: CALL 351 0 1
7348: ST_TO_ADDR
// is_cargo := true ;
7349: LD_ADDR_VAR 0 13
7353: PUSH
7354: LD_INT 1
7356: ST_TO_ADDR
// end else
7357: GO 7508
// begin if MCF_ApeSpec ( side , engineer ) then
7359: LD_VAR 0 1
7363: PPUSH
7364: LD_STRING engineer
7366: PPUSH
7367: CALL 497 0 2
7371: IFFALSE 7391
// collectors := MCF_ApeSpec ( side , engineer ) ;
7373: LD_ADDR_VAR 0 12
7377: PUSH
7378: LD_VAR 0 1
7382: PPUSH
7383: LD_STRING engineer
7385: PPUSH
7386: CALL 497 0 2
7390: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
7391: LD_VAR 0 1
7395: PPUSH
7396: LD_INT 2
7398: PPUSH
7399: EMPTY
7400: PPUSH
7401: CALL 83 0 3
7405: IFFALSE 7508
// begin z := MCF_Class ( side , 2 , [ ] ) ;
7407: LD_ADDR_VAR 0 7
7411: PUSH
7412: LD_VAR 0 1
7416: PPUSH
7417: LD_INT 2
7419: PPUSH
7420: EMPTY
7421: PPUSH
7422: CALL 83 0 3
7426: ST_TO_ADDR
// if z > 5 then
7427: LD_VAR 0 7
7431: PUSH
7432: LD_INT 5
7434: GREATER
7435: IFFALSE 7447
// t1 := 5 else
7437: LD_ADDR_VAR 0 8
7441: PUSH
7442: LD_INT 5
7444: ST_TO_ADDR
7445: GO 7457
// t1 := z ;
7447: LD_ADDR_VAR 0 8
7451: PUSH
7452: LD_VAR 0 7
7456: ST_TO_ADDR
// for t2 = 1 to t1 do
7457: LD_ADDR_VAR 0 9
7461: PUSH
7462: DOUBLE
7463: LD_INT 1
7465: DEC
7466: ST_TO_ADDR
7467: LD_VAR 0 8
7471: PUSH
7472: FOR_TO
7473: IFFALSE 7506
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
7475: LD_ADDR_VAR 0 12
7479: PUSH
7480: LD_VAR 0 12
7484: PPUSH
7485: LD_INT 1
7487: PPUSH
7488: LD_VAR 0 7
7492: PUSH
7493: LD_VAR 0 9
7497: ARRAY
7498: PPUSH
7499: CALL_OW 2
7503: ST_TO_ADDR
7504: GO 7472
7506: POP
7507: POP
// end ; end ; if not mode then
7508: LD_VAR 0 10
7512: NOT
7513: IFFALSE 7519
// exit else
7515: GO 7776
7517: GO 7776
// begin if collectors then
7519: LD_VAR 0 12
7523: IFFALSE 7776
// for i in areas do
7525: LD_ADDR_VAR 0 3
7529: PUSH
7530: LD_VAR 0 11
7534: PUSH
7535: FOR_IN
7536: IFFALSE 7774
// if GetListOfCratesInArea ( i ) then
7538: LD_VAR 0 3
7542: PPUSH
7543: CALL_OW 435
7547: IFFALSE 7772
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
7549: LD_ADDR_VAR 0 5
7553: PUSH
7554: LD_VAR 0 3
7558: PPUSH
7559: CALL_OW 435
7563: PUSH
7564: LD_INT 1
7566: ARRAY
7567: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
7568: LD_ADDR_VAR 0 6
7572: PUSH
7573: LD_VAR 0 3
7577: PPUSH
7578: CALL_OW 435
7582: PUSH
7583: LD_INT 2
7585: ARRAY
7586: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
7587: LD_VAR 0 13
7591: PUSH
7592: LD_VAR 0 12
7596: PUSH
7597: LD_INT 1
7599: ARRAY
7600: PPUSH
7601: CALL_OW 110
7605: PUSH
7606: LD_INT 0
7608: EQUAL
7609: AND
7610: IFFALSE 7672
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
7612: LD_VAR 0 12
7616: PUSH
7617: LD_INT 1
7619: ARRAY
7620: PPUSH
7621: CALL_OW 314
7625: NOT
7626: PUSH
7627: LD_VAR 0 12
7631: PUSH
7632: LD_INT 1
7634: ARRAY
7635: PPUSH
7636: CALL_OW 110
7640: PUSH
7641: LD_INT 0
7643: EQUAL
7644: AND
7645: IFFALSE 7670
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
7647: LD_VAR 0 12
7651: PUSH
7652: LD_INT 1
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 5
7660: PPUSH
7661: LD_VAR 0 6
7665: PPUSH
7666: CALL_OW 117
// end ; end else
7670: GO 7758
// begin for j = 1 to collectors do
7672: LD_ADDR_VAR 0 4
7676: PUSH
7677: DOUBLE
7678: LD_INT 1
7680: DEC
7681: ST_TO_ADDR
7682: LD_VAR 0 12
7686: PUSH
7687: FOR_TO
7688: IFFALSE 7756
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
7690: LD_VAR 0 12
7694: PUSH
7695: LD_VAR 0 4
7699: ARRAY
7700: PPUSH
7701: CALL_OW 314
7705: NOT
7706: PUSH
7707: LD_VAR 0 12
7711: PUSH
7712: LD_VAR 0 4
7716: ARRAY
7717: PPUSH
7718: CALL_OW 110
7722: PUSH
7723: LD_INT 0
7725: EQUAL
7726: AND
7727: IFFALSE 7754
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
7729: LD_VAR 0 12
7733: PUSH
7734: LD_VAR 0 4
7738: ARRAY
7739: PPUSH
7740: LD_VAR 0 5
7744: PPUSH
7745: LD_VAR 0 6
7749: PPUSH
7750: CALL 8137 0 3
// end ;
7754: GO 7687
7756: POP
7757: POP
// end ; if isEditor then
7758: LD_INT 1
7760: IFFALSE 7772
// begin debug_time := TimerEnd ( ) ;
7762: LD_ADDR_VAR 0 14
7766: PUSH
7767: CALL_OW 549
7771: ST_TO_ADDR
// end ; end ;
7772: GO 7535
7774: POP
7775: POP
// end ; end ;
7776: LD_VAR 0 2
7780: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
7781: LD_INT 0
7783: PPUSH
7784: PPUSH
7785: PPUSH
7786: PPUSH
7787: PPUSH
7788: PPUSH
// if not area then
7789: LD_VAR 0 1
7793: NOT
7794: IFFALSE 7800
// exit else
7796: GO 8052
7798: GO 8052
// if tick mod interval = 0 and Prob ( percent ) then
7800: LD_OWVAR 1
7804: PUSH
7805: LD_VAR 0 4
7809: MOD
7810: PUSH
7811: LD_INT 0
7813: EQUAL
7814: PUSH
7815: LD_VAR 0 3
7819: PPUSH
7820: CALL_OW 13
7824: AND
7825: IFFALSE 8052
// begin if GetListOfCratesInArea ( area ) < limit then
7827: LD_VAR 0 1
7831: PPUSH
7832: CALL_OW 435
7836: PUSH
7837: LD_VAR 0 5
7841: LESS
7842: IFFALSE 8052
// begin Randomize ;
7844: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
7848: LD_ADDR_VAR 0 7
7852: PUSH
7853: LD_INT 1
7855: PPUSH
7856: LD_VAR 0 2
7860: PPUSH
7861: CALL_OW 12
7865: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
7866: LD_ADDR_VAR 0 9
7870: PUSH
7871: LD_VAR 0 1
7875: PPUSH
7876: LD_INT 0
7878: PPUSH
7879: CALL_OW 517
7883: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
7884: LD_ADDR_VAR 0 8
7888: PUSH
7889: LD_INT 1
7891: PPUSH
7892: LD_VAR 0 9
7896: PUSH
7897: LD_INT 1
7899: ARRAY
7900: PPUSH
7901: CALL_OW 12
7905: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
7906: LD_VAR 0 9
7910: PUSH
7911: LD_INT 1
7913: ARRAY
7914: PUSH
7915: LD_VAR 0 8
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 9
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_VAR 0 8
7934: ARRAY
7935: PPUSH
7936: CALL_OW 428
7940: PUSH
7941: LD_INT 0
7943: GREATER
7944: PUSH
7945: LD_VAR 0 9
7949: PUSH
7950: LD_INT 1
7952: ARRAY
7953: PUSH
7954: LD_VAR 0 8
7958: ARRAY
7959: PPUSH
7960: LD_VAR 0 9
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PUSH
7969: LD_VAR 0 8
7973: ARRAY
7974: PPUSH
7975: CALL_OW 284
7979: PUSH
7980: LD_INT 0
7982: GREATER
7983: AND
7984: IFFALSE 8010
// c := Rand ( 1 , tmp [ 1 ] ) ;
7986: LD_ADDR_VAR 0 8
7990: PUSH
7991: LD_INT 1
7993: PPUSH
7994: LD_VAR 0 9
7998: PUSH
7999: LD_INT 1
8001: ARRAY
8002: PPUSH
8003: CALL_OW 12
8007: ST_TO_ADDR
8008: GO 7906
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
8010: LD_VAR 0 7
8014: PPUSH
8015: LD_VAR 0 9
8019: PUSH
8020: LD_INT 1
8022: ARRAY
8023: PUSH
8024: LD_VAR 0 8
8028: ARRAY
8029: PPUSH
8030: LD_VAR 0 9
8034: PUSH
8035: LD_INT 2
8037: ARRAY
8038: PUSH
8039: LD_VAR 0 8
8043: ARRAY
8044: PPUSH
8045: LD_INT 1
8047: PPUSH
8048: CALL_OW 54
// end ; end ; end ;
8052: LD_VAR 0 6
8056: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
8057: LD_INT 0
8059: PPUSH
8060: PPUSH
// if not MREG_Crates then
8061: LD_EXP 2
8065: NOT
8066: IFFALSE 8070
// exit ;
8068: GO 8132
// for i = MREG_Crates downto 1 do
8070: LD_ADDR_VAR 0 2
8074: PUSH
8075: DOUBLE
8076: LD_EXP 2
8080: INC
8081: ST_TO_ADDR
8082: LD_INT 1
8084: PUSH
8085: FOR_DOWNTO
8086: IFFALSE 8130
// if MREG_Crates [ i ] [ 3 ] = 0 then
8088: LD_EXP 2
8092: PUSH
8093: LD_VAR 0 2
8097: ARRAY
8098: PUSH
8099: LD_INT 3
8101: ARRAY
8102: PUSH
8103: LD_INT 0
8105: EQUAL
8106: IFFALSE 8128
// MREG_Crates := Delete ( MREG_Crates , i ) ;
8108: LD_ADDR_EXP 2
8112: PUSH
8113: LD_EXP 2
8117: PPUSH
8118: LD_VAR 0 2
8122: PPUSH
8123: CALL_OW 3
8127: ST_TO_ADDR
8128: GO 8085
8130: POP
8131: POP
// end ;
8132: LD_VAR 0 1
8136: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
8137: LD_INT 0
8139: PPUSH
8140: PPUSH
8141: PPUSH
8142: PPUSH
// if not unit then
8143: LD_VAR 0 1
8147: NOT
8148: IFFALSE 8152
// exit ;
8150: GO 8287
// if HasTask ( unit ) or not CanCarry ( unit ) then
8152: LD_VAR 0 1
8156: PPUSH
8157: CALL_OW 314
8161: PUSH
8162: LD_VAR 0 1
8166: PPUSH
8167: CALL_OW 280
8171: NOT
8172: OR
8173: IFFALSE 8177
// exit ;
8175: GO 8287
// side := GetSide ( unit ) ;
8177: LD_ADDR_VAR 0 6
8181: PUSH
8182: LD_VAR 0 1
8186: PPUSH
8187: CALL_OW 255
8191: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
8192: LD_ADDR_VAR 0 7
8196: PUSH
8197: LD_VAR 0 6
8201: PPUSH
8202: LD_INT 30
8204: PUSH
8205: LD_INT 1
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PPUSH
8212: CALL 0 0 2
8216: ST_TO_ADDR
// if Carry ( unit ) or not dep then
8217: LD_VAR 0 1
8221: PPUSH
8222: CALL_OW 281
8226: PUSH
8227: LD_VAR 0 7
8231: NOT
8232: OR
8233: IFFALSE 8239
// exit else
8235: GO 8287
8237: GO 8287
// if GetResourceAmountXY ( x , y ) then
8239: LD_VAR 0 2
8243: PPUSH
8244: LD_VAR 0 3
8248: PPUSH
8249: CALL_OW 284
8253: IFFALSE 8285
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
8255: LD_VAR 0 1
8259: PPUSH
8260: LD_VAR 0 2
8264: PPUSH
8265: LD_VAR 0 3
8269: PPUSH
8270: LD_VAR 0 7
8274: PUSH
8275: LD_INT 1
8277: ARRAY
8278: PPUSH
8279: CALL 25719 0 4
// end else
8283: GO 8287
// exit ;
8285: GO 8287
// end ; end_of_file
8287: LD_VAR 0 4
8291: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
8292: LD_INT 0
8294: PPUSH
8295: PPUSH
8296: PPUSH
// pom := GetBase ( bdepot ) ;
8297: LD_ADDR_VAR 0 3
8301: PUSH
8302: LD_VAR 0 1
8306: PPUSH
8307: CALL_OW 274
8311: ST_TO_ADDR
// sor := [ ] ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: EMPTY
8318: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
8319: LD_ADDR_VAR 0 4
8323: PUSH
8324: LD_VAR 0 4
8328: PUSH
8329: LD_VAR 0 3
8333: PPUSH
8334: LD_INT 1
8336: PPUSH
8337: CALL_OW 275
8341: ADD
8342: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
8343: LD_ADDR_VAR 0 4
8347: PUSH
8348: LD_VAR 0 4
8352: PUSH
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 2
8360: PPUSH
8361: CALL_OW 275
8365: ADD
8366: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
8367: LD_ADDR_VAR 0 4
8371: PUSH
8372: LD_VAR 0 4
8376: PUSH
8377: LD_VAR 0 3
8381: PPUSH
8382: LD_INT 3
8384: PPUSH
8385: CALL_OW 275
8389: ADD
8390: ST_TO_ADDR
// result := sor ;
8391: LD_ADDR_VAR 0 2
8395: PUSH
8396: LD_VAR 0 4
8400: ST_TO_ADDR
// end ;
8401: LD_VAR 0 2
8405: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
8406: LD_INT 0
8408: PPUSH
8409: PPUSH
// while ( coord_list ) do
8410: LD_VAR 0 3
8414: IFFALSE 8588
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
8416: LD_ADDR_EXP 15
8420: PUSH
8421: LD_EXP 15
8425: PPUSH
8426: LD_VAR 0 1
8430: PPUSH
8431: LD_VAR 0 2
8435: PPUSH
8436: LD_VAR 0 3
8440: PUSH
8441: LD_INT 1
8443: ARRAY
8444: PUSH
8445: LD_VAR 0 3
8449: PUSH
8450: LD_INT 2
8452: ARRAY
8453: PUSH
8454: LD_VAR 0 3
8458: PUSH
8459: LD_INT 3
8461: ARRAY
8462: PUSH
8463: EMPTY
8464: LIST
8465: LIST
8466: LIST
8467: PPUSH
8468: CALL 4259 0 4
8472: ST_TO_ADDR
// if weapon_list then
8473: LD_VAR 0 4
8477: IFFALSE 8548
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
8479: LD_ADDR_EXP 12
8483: PUSH
8484: LD_EXP 12
8488: PPUSH
8489: LD_VAR 0 1
8493: PPUSH
8494: LD_VAR 0 4
8498: PUSH
8499: LD_INT 1
8501: ARRAY
8502: PPUSH
8503: LD_VAR 0 3
8507: PUSH
8508: LD_INT 1
8510: ARRAY
8511: PUSH
8512: LD_VAR 0 3
8516: PUSH
8517: LD_INT 2
8519: ARRAY
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: PPUSH
8525: CALL 4259 0 4
8529: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
8530: LD_ADDR_VAR 0 4
8534: PUSH
8535: LD_VAR 0 4
8539: PPUSH
8540: LD_INT 1
8542: PPUSH
8543: CALL_OW 3
8547: ST_TO_ADDR
// end ; for i = 1 to 3 do
8548: LD_ADDR_VAR 0 6
8552: PUSH
8553: DOUBLE
8554: LD_INT 1
8556: DEC
8557: ST_TO_ADDR
8558: LD_INT 3
8560: PUSH
8561: FOR_TO
8562: IFFALSE 8584
// coord_list := Delete ( coord_list , 1 ) ;
8564: LD_ADDR_VAR 0 3
8568: PUSH
8569: LD_VAR 0 3
8573: PPUSH
8574: LD_INT 1
8576: PPUSH
8577: CALL_OW 3
8581: ST_TO_ADDR
8582: GO 8561
8584: POP
8585: POP
// end ;
8586: GO 8410
// result := true ;
8588: LD_ADDR_VAR 0 5
8592: PUSH
8593: LD_INT 1
8595: ST_TO_ADDR
// end ;
8596: LD_VAR 0 5
8600: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
8601: LD_INT 0
8603: PPUSH
8604: PPUSH
// if not weapon_list then
8605: LD_VAR 0 3
8609: NOT
8610: IFFALSE 8614
// exit ;
8612: GO 8729
// while ( coord_list ) do
8614: LD_VAR 0 2
8618: IFFALSE 8729
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
8620: LD_ADDR_EXP 12
8624: PUSH
8625: LD_EXP 12
8629: PPUSH
8630: LD_VAR 0 1
8634: PPUSH
8635: LD_VAR 0 3
8639: PUSH
8640: LD_INT 1
8642: ARRAY
8643: PPUSH
8644: LD_VAR 0 2
8648: PUSH
8649: LD_INT 1
8651: ARRAY
8652: PUSH
8653: LD_VAR 0 2
8657: PUSH
8658: LD_INT 2
8660: ARRAY
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PPUSH
8666: CALL 4259 0 4
8670: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
8671: LD_ADDR_VAR 0 3
8675: PUSH
8676: LD_VAR 0 3
8680: PPUSH
8681: LD_INT 1
8683: PPUSH
8684: CALL_OW 3
8688: ST_TO_ADDR
// for i = 1 to 2 do
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: DOUBLE
8695: LD_INT 1
8697: DEC
8698: ST_TO_ADDR
8699: LD_INT 2
8701: PUSH
8702: FOR_TO
8703: IFFALSE 8725
// coord_list := Delete ( coord_list , 1 ) ;
8705: LD_ADDR_VAR 0 2
8709: PUSH
8710: LD_VAR 0 2
8714: PPUSH
8715: LD_INT 1
8717: PPUSH
8718: CALL_OW 3
8722: ST_TO_ADDR
8723: GO 8702
8725: POP
8726: POP
// end ;
8727: GO 8614
// end ;
8729: LD_VAR 0 4
8733: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
8734: LD_INT 0
8736: PPUSH
8737: PPUSH
// while ( coord_list ) do
8738: LD_VAR 0 2
8742: IFFALSE 8897
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
8744: LD_VAR 0 2
8748: PUSH
8749: LD_INT 1
8751: ARRAY
8752: PPUSH
8753: LD_VAR 0 2
8757: PUSH
8758: LD_INT 2
8760: ARRAY
8761: PPUSH
8762: CALL_OW 428
8766: IFFALSE 8857
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
8768: LD_VAR 0 2
8772: PUSH
8773: LD_INT 1
8775: ARRAY
8776: PPUSH
8777: LD_VAR 0 2
8781: PUSH
8782: LD_INT 2
8784: ARRAY
8785: PPUSH
8786: CALL_OW 428
8790: PPUSH
8791: CALL_OW 266
8795: PUSH
8796: LD_INT 31
8798: PUSH
8799: LD_INT 32
8801: PUSH
8802: LD_INT 33
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: IN
8810: IFFALSE 8857
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
8812: LD_ADDR_EXP 21
8816: PUSH
8817: LD_EXP 21
8821: PPUSH
8822: LD_VAR 0 1
8826: PPUSH
8827: LD_VAR 0 2
8831: PUSH
8832: LD_INT 1
8834: ARRAY
8835: PPUSH
8836: LD_VAR 0 2
8840: PUSH
8841: LD_INT 2
8843: ARRAY
8844: PPUSH
8845: CALL_OW 428
8849: PPUSH
8850: EMPTY
8851: PPUSH
8852: CALL 4259 0 4
8856: ST_TO_ADDR
// for i = 1 to 3 do
8857: LD_ADDR_VAR 0 4
8861: PUSH
8862: DOUBLE
8863: LD_INT 1
8865: DEC
8866: ST_TO_ADDR
8867: LD_INT 3
8869: PUSH
8870: FOR_TO
8871: IFFALSE 8893
// coord_list := Delete ( coord_list , 1 ) ;
8873: LD_ADDR_VAR 0 2
8877: PUSH
8878: LD_VAR 0 2
8882: PPUSH
8883: LD_INT 1
8885: PPUSH
8886: CALL_OW 3
8890: ST_TO_ADDR
8891: GO 8870
8893: POP
8894: POP
// end ;
8895: GO 8738
// result := true ;
8897: LD_ADDR_VAR 0 3
8901: PUSH
8902: LD_INT 1
8904: ST_TO_ADDR
// end ;
8905: LD_VAR 0 3
8909: RET
// export function MCS_Depot ( side , coord_list ) ; begin
8910: LD_INT 0
8912: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
8913: LD_ADDR_EXP 15
8917: PUSH
8918: LD_EXP 15
8922: PPUSH
8923: LD_VAR 0 1
8927: PPUSH
8928: LD_INT 0
8930: PPUSH
8931: LD_VAR 0 2
8935: PPUSH
8936: CALL 4259 0 4
8940: ST_TO_ADDR
// end ;
8941: LD_VAR 0 3
8945: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
8946: LD_INT 0
8948: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
8949: LD_ADDR_EXP 15
8953: PUSH
8954: LD_EXP 15
8958: PPUSH
8959: LD_VAR 0 1
8963: PPUSH
8964: LD_INT 6
8966: PPUSH
8967: LD_VAR 0 2
8971: PPUSH
8972: CALL 4259 0 4
8976: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
8977: LD_ADDR_EXP 18
8981: PUSH
8982: LD_EXP 18
8986: PPUSH
8987: LD_VAR 0 1
8991: PPUSH
8992: LD_VAR 0 3
8996: PUSH
8997: LD_INT 1
8999: ARRAY
9000: PPUSH
9001: LD_VAR 0 3
9005: PUSH
9006: LD_INT 2
9008: ARRAY
9009: PPUSH
9010: CALL 4259 0 4
9014: ST_TO_ADDR
// end ;
9015: LD_VAR 0 4
9019: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
9020: LD_INT 0
9022: PPUSH
9023: PPUSH
// if ext_list > 5 then
9024: LD_VAR 0 3
9028: PUSH
9029: LD_INT 5
9031: GREATER
9032: IFFALSE 9076
// for i = 6 to ext_list do
9034: LD_ADDR_VAR 0 5
9038: PUSH
9039: DOUBLE
9040: LD_INT 6
9042: DEC
9043: ST_TO_ADDR
9044: LD_VAR 0 3
9048: PUSH
9049: FOR_TO
9050: IFFALSE 9074
// ext_list := Delete ( ext_list , ext_list ) ;
9052: LD_ADDR_VAR 0 3
9056: PUSH
9057: LD_VAR 0 3
9061: PPUSH
9062: LD_VAR 0 3
9066: PPUSH
9067: CALL_OW 3
9071: ST_TO_ADDR
9072: GO 9049
9074: POP
9075: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
9076: LD_VAR 0 1
9080: PPUSH
9081: LD_VAR 0 2
9085: PUSH
9086: LD_INT 1
9088: ARRAY
9089: PPUSH
9090: LD_VAR 0 2
9094: PUSH
9095: LD_INT 2
9097: ARRAY
9098: PPUSH
9099: LD_VAR 0 2
9103: PUSH
9104: LD_INT 3
9106: ARRAY
9107: PPUSH
9108: LD_VAR 0 3
9112: PPUSH
9113: CALL 10835 0 5
// end ;
9117: LD_VAR 0 4
9121: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
9122: LD_INT 0
9124: PPUSH
9125: PPUSH
9126: PPUSH
// p := 1 ;
9127: LD_ADDR_VAR 0 6
9131: PUSH
9132: LD_INT 1
9134: ST_TO_ADDR
// if type_list = [ ] then
9135: LD_VAR 0 3
9139: PUSH
9140: EMPTY
9141: EQUAL
9142: IFFALSE 9152
// type_list := b_oil_power ;
9144: LD_ADDR_VAR 0 3
9148: PUSH
9149: LD_INT 26
9151: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
9152: LD_ADDR_VAR 0 5
9156: PUSH
9157: DOUBLE
9158: LD_INT 1
9160: DEC
9161: ST_TO_ADDR
9162: LD_VAR 0 2
9166: PUSH
9167: LD_INT 3
9169: DIVREAL
9170: PUSH
9171: FOR_TO
9172: IFFALSE 9275
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
9174: LD_ADDR_EXP 15
9178: PUSH
9179: LD_EXP 15
9183: PPUSH
9184: LD_VAR 0 1
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_INT 1
9196: PPUSH
9197: LD_VAR 0 3
9201: PPUSH
9202: CALL_OW 12
9206: ARRAY
9207: PPUSH
9208: LD_VAR 0 2
9212: PUSH
9213: LD_VAR 0 6
9217: ARRAY
9218: PUSH
9219: LD_VAR 0 2
9223: PUSH
9224: LD_VAR 0 6
9228: PUSH
9229: LD_INT 1
9231: PLUS
9232: ARRAY
9233: PUSH
9234: LD_VAR 0 2
9238: PUSH
9239: LD_VAR 0 6
9243: PUSH
9244: LD_INT 2
9246: PLUS
9247: ARRAY
9248: PUSH
9249: EMPTY
9250: LIST
9251: LIST
9252: LIST
9253: PPUSH
9254: CALL 4259 0 4
9258: ST_TO_ADDR
// p := p + 3 ;
9259: LD_ADDR_VAR 0 6
9263: PUSH
9264: LD_VAR 0 6
9268: PUSH
9269: LD_INT 3
9271: PLUS
9272: ST_TO_ADDR
// end ;
9273: GO 9171
9275: POP
9276: POP
// end ;
9277: LD_VAR 0 4
9281: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
9282: LD_INT 0
9284: PPUSH
9285: PPUSH
9286: PPUSH
9287: PPUSH
// if not MREG_Deposit [ side ] then
9288: LD_EXP 30
9292: PUSH
9293: LD_VAR 0 1
9297: ARRAY
9298: NOT
9299: IFFALSE 9303
// exit ;
9301: GO 9480
// p := 1 ;
9303: LD_ADDR_VAR 0 4
9307: PUSH
9308: LD_INT 1
9310: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
9311: LD_ADDR_VAR 0 3
9315: PUSH
9316: DOUBLE
9317: LD_INT 1
9319: DEC
9320: ST_TO_ADDR
9321: LD_EXP 30
9325: PUSH
9326: LD_VAR 0 1
9330: ARRAY
9331: PUSH
9332: LD_INT 3
9334: DIVREAL
9335: PUSH
9336: FOR_TO
9337: IFFALSE 9478
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
9339: LD_EXP 30
9343: PUSH
9344: LD_VAR 0 1
9348: ARRAY
9349: PUSH
9350: LD_VAR 0 4
9354: PUSH
9355: LD_INT 2
9357: PLUS
9358: ARRAY
9359: PUSH
9360: LD_INT 2
9362: EQUAL
9363: IFFALSE 9375
// b := b_oil_mine else
9365: LD_ADDR_VAR 0 5
9369: PUSH
9370: LD_INT 29
9372: ST_TO_ADDR
9373: GO 9383
// b := b_siberite_mine ;
9375: LD_ADDR_VAR 0 5
9379: PUSH
9380: LD_INT 30
9382: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
9383: LD_ADDR_EXP 15
9387: PUSH
9388: LD_EXP 15
9392: PPUSH
9393: LD_VAR 0 1
9397: PPUSH
9398: LD_VAR 0 5
9402: PPUSH
9403: LD_EXP 30
9407: PUSH
9408: LD_VAR 0 1
9412: ARRAY
9413: PUSH
9414: LD_VAR 0 4
9418: ARRAY
9419: PUSH
9420: LD_EXP 30
9424: PUSH
9425: LD_VAR 0 1
9429: ARRAY
9430: PUSH
9431: LD_VAR 0 4
9435: PUSH
9436: LD_INT 1
9438: PLUS
9439: ARRAY
9440: PUSH
9441: LD_INT 0
9443: PPUSH
9444: LD_INT 5
9446: PPUSH
9447: CALL_OW 12
9451: PUSH
9452: EMPTY
9453: LIST
9454: LIST
9455: LIST
9456: PPUSH
9457: CALL 4259 0 4
9461: ST_TO_ADDR
// p := p + 3 ;
9462: LD_ADDR_VAR 0 4
9466: PUSH
9467: LD_VAR 0 4
9471: PUSH
9472: LD_INT 3
9474: PLUS
9475: ST_TO_ADDR
// end ;
9476: GO 9336
9478: POP
9479: POP
// end ;
9480: LD_VAR 0 2
9484: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
9485: LD_INT 0
9487: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
9488: LD_ADDR_EXP 15
9492: PUSH
9493: LD_EXP 15
9497: PPUSH
9498: LD_VAR 0 1
9502: PPUSH
9503: LD_INT 4
9505: PPUSH
9506: LD_VAR 0 2
9510: PPUSH
9511: CALL 4259 0 4
9515: ST_TO_ADDR
// end ;
9516: LD_VAR 0 3
9520: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
9521: LD_INT 0
9523: PPUSH
// case nation of 1 , us :
9524: LD_VAR 0 2
9528: PUSH
9529: LD_INT 1
9531: DOUBLE
9532: EQUAL
9533: IFTRUE 9543
9535: LD_STRING us
9537: DOUBLE
9538: EQUAL
9539: IFTRUE 9543
9541: GO 9574
9543: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
9544: LD_ADDR_EXP 15
9548: PUSH
9549: LD_EXP 15
9553: PPUSH
9554: LD_VAR 0 1
9558: PPUSH
9559: LD_INT 36
9561: PPUSH
9562: LD_VAR 0 3
9566: PPUSH
9567: CALL 4259 0 4
9571: ST_TO_ADDR
9572: GO 9625
9574: LD_INT 2
9576: DOUBLE
9577: EQUAL
9578: IFTRUE 9588
9580: LD_STRING ar
9582: DOUBLE
9583: EQUAL
9584: IFTRUE 9588
9586: GO 9624
9588: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
9589: LD_ADDR_EXP 15
9593: PUSH
9594: LD_VAR 0 1
9598: PPUSH
9599: LD_INT 14
9601: PUSH
9602: LD_INT 2
9604: PUSH
9605: LD_INT 1
9607: PUSH
9608: LD_INT 31
9610: PUSH
9611: EMPTY
9612: LIST
9613: LIST
9614: LIST
9615: LIST
9616: PPUSH
9617: CALL 9630 0 2
9621: ST_TO_ADDR
9622: GO 9625
9624: POP
// end ;
9625: LD_VAR 0 4
9629: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
9630: LD_INT 0
9632: PPUSH
9633: PPUSH
// for i = 1 to list do
9634: LD_ADDR_VAR 0 4
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: LD_VAR 0 2
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9700
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
9652: LD_ADDR_EXP 20
9656: PUSH
9657: LD_EXP 20
9661: PPUSH
9662: LD_VAR 0 1
9666: PPUSH
9667: LD_EXP 20
9671: PUSH
9672: LD_VAR 0 1
9676: ARRAY
9677: PUSH
9678: LD_INT 1
9680: PLUS
9681: PPUSH
9682: LD_VAR 0 2
9686: PUSH
9687: LD_VAR 0 4
9691: ARRAY
9692: PPUSH
9693: CALL 24638 0 4
9697: ST_TO_ADDR
9698: GO 9649
9700: POP
9701: POP
// end ;
9702: LD_VAR 0 3
9706: RET
// export function MCS_GetVehicleList ( side ) ; begin
9707: LD_INT 0
9709: PPUSH
// result := MREG_ToConstruct [ side ] ;
9710: LD_ADDR_VAR 0 2
9714: PUSH
9715: LD_EXP 20
9719: PUSH
9720: LD_VAR 0 1
9724: ARRAY
9725: ST_TO_ADDR
// end ;
9726: LD_VAR 0 2
9730: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
9731: LD_INT 0
9733: PPUSH
9734: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
9735: LD_ADDR_EXP 27
9739: PUSH
9740: LD_EXP 27
9744: PPUSH
9745: LD_VAR 0 1
9749: PPUSH
9750: LD_VAR 0 2
9754: PPUSH
9755: CALL_OW 1
9759: ST_TO_ADDR
// end ;
9760: LD_VAR 0 3
9764: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
9765: LD_INT 0
9767: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
9768: LD_ADDR_EXP 5
9772: PUSH
9773: LD_EXP 5
9777: PPUSH
9778: LD_VAR 0 1
9782: PPUSH
9783: LD_VAR 0 2
9787: PPUSH
9788: CALL_OW 1
9792: ST_TO_ADDR
// end ;
9793: LD_VAR 0 3
9797: RET
// export function MCS_ApeOptions ( side , options ) ; begin
9798: LD_INT 0
9800: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
9801: LD_ADDR_EXP 6
9805: PUSH
9806: LD_EXP 6
9810: PPUSH
9811: LD_VAR 0 1
9815: PPUSH
9816: LD_VAR 0 2
9820: PPUSH
9821: CALL_OW 1
9825: ST_TO_ADDR
// end ;
9826: LD_VAR 0 3
9830: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
9831: LD_INT 0
9833: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
9834: LD_ADDR_EXP 29
9838: PUSH
9839: LD_EXP 29
9843: PPUSH
9844: LD_VAR 0 1
9848: PPUSH
9849: LD_INT 1
9851: PPUSH
9852: LD_VAR 0 2
9856: PPUSH
9857: CALL 24638 0 4
9861: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
9862: LD_ADDR_EXP 29
9866: PUSH
9867: LD_EXP 29
9871: PPUSH
9872: LD_VAR 0 1
9876: PPUSH
9877: LD_INT 2
9879: PPUSH
9880: LD_VAR 0 3
9884: PPUSH
9885: CALL 24638 0 4
9889: ST_TO_ADDR
// end ;
9890: LD_VAR 0 4
9894: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
9895: LD_INT 0
9897: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
9898: LD_ADDR_EXP 31
9902: PUSH
9903: LD_EXP 31
9907: PPUSH
9908: LD_INT 1
9910: PPUSH
9911: LD_VAR 0 1
9915: PPUSH
9916: CALL_OW 1
9920: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
9921: LD_ADDR_EXP 31
9925: PUSH
9926: LD_EXP 31
9930: PPUSH
9931: LD_INT 2
9933: PPUSH
9934: LD_VAR 0 2
9938: PPUSH
9939: CALL_OW 1
9943: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
9944: LD_ADDR_EXP 31
9948: PUSH
9949: LD_EXP 31
9953: PPUSH
9954: LD_INT 3
9956: PPUSH
9957: LD_VAR 0 3
9961: PPUSH
9962: CALL_OW 1
9966: ST_TO_ADDR
// end ;
9967: LD_VAR 0 4
9971: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
9972: LD_INT 0
9974: PPUSH
9975: PPUSH
9976: PPUSH
// if not side or not list then
9977: LD_VAR 0 1
9981: NOT
9982: PUSH
9983: LD_VAR 0 2
9987: NOT
9988: OR
9989: IFFALSE 9993
// exit ;
9991: GO 10159
// SetTech ( 20 , side , state_researched ) ;
9993: LD_INT 20
9995: PPUSH
9996: LD_VAR 0 1
10000: PPUSH
10001: LD_INT 2
10003: PPUSH
10004: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
10008: LD_ADDR_EXP 30
10012: PUSH
10013: LD_EXP 30
10017: PPUSH
10018: LD_VAR 0 1
10022: PPUSH
10023: LD_VAR 0 2
10027: PPUSH
10028: CALL_OW 2
10032: ST_TO_ADDR
// p := 1 ;
10033: LD_ADDR_VAR 0 5
10037: PUSH
10038: LD_INT 1
10040: ST_TO_ADDR
// for i = 1 to list / 3 do
10041: LD_ADDR_VAR 0 4
10045: PUSH
10046: DOUBLE
10047: LD_INT 1
10049: DEC
10050: ST_TO_ADDR
10051: LD_VAR 0 2
10055: PUSH
10056: LD_INT 3
10058: DIVREAL
10059: PUSH
10060: FOR_TO
10061: IFFALSE 10157
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
10063: LD_VAR 0 2
10067: PUSH
10068: LD_VAR 0 5
10072: ARRAY
10073: PPUSH
10074: LD_VAR 0 2
10078: PUSH
10079: LD_VAR 0 5
10083: PUSH
10084: LD_INT 1
10086: PLUS
10087: ARRAY
10088: PPUSH
10089: LD_VAR 0 2
10093: PUSH
10094: LD_VAR 0 5
10098: PUSH
10099: LD_INT 2
10101: PLUS
10102: ARRAY
10103: PPUSH
10104: CALL 5618 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , true ) ;
10108: LD_VAR 0 2
10112: PUSH
10113: LD_VAR 0 5
10117: ARRAY
10118: PPUSH
10119: LD_VAR 0 2
10123: PUSH
10124: LD_VAR 0 5
10128: PUSH
10129: LD_INT 1
10131: PLUS
10132: ARRAY
10133: PPUSH
10134: LD_INT 1
10136: PPUSH
10137: CALL_OW 441
// p := p + 3 ;
10141: LD_ADDR_VAR 0 5
10145: PUSH
10146: LD_VAR 0 5
10150: PUSH
10151: LD_INT 3
10153: PLUS
10154: ST_TO_ADDR
// end ;
10155: GO 10060
10157: POP
10158: POP
// end ;
10159: LD_VAR 0 3
10163: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
10164: LD_INT 0
10166: PPUSH
10167: PPUSH
// if nat = nation_arabian then
10168: LD_VAR 0 2
10172: PUSH
10173: LD_INT 2
10175: EQUAL
10176: IFFALSE 10182
// exit else
10178: GO 10254
10180: GO 10240
// if nat = nation_american then
10182: LD_VAR 0 2
10186: PUSH
10187: LD_INT 1
10189: EQUAL
10190: IFFALSE 10217
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
10192: LD_ADDR_VAR 0 4
10196: PUSH
10197: LD_INT 4
10199: PUSH
10200: LD_INT 3
10202: PUSH
10203: LD_INT 1
10205: PUSH
10206: LD_INT 8
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: LIST
10213: LIST
10214: ST_TO_ADDR
10215: GO 10240
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
10217: LD_ADDR_VAR 0 4
10221: PUSH
10222: LD_INT 24
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 1
10230: PUSH
10231: LD_INT 48
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: LIST
10238: LIST
10239: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
10240: LD_VAR 0 1
10244: PPUSH
10245: LD_VAR 0 4
10249: PPUSH
10250: CALL 9630 0 2
// end ; end_of_file
10254: LD_VAR 0 3
10258: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
10259: LD_INT 0
10261: PPUSH
10262: PPUSH
10263: PPUSH
10264: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10265: LD_ADDR_VAR 0 8
10269: PUSH
10270: LD_VAR 0 1
10274: PPUSH
10275: LD_INT 2
10277: PPUSH
10278: EMPTY
10279: PPUSH
10280: CALL 83 0 3
10284: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
10285: LD_VAR 0 8
10289: PUSH
10290: LD_VAR 0 2
10294: PPUSH
10295: LD_VAR 0 3
10299: PPUSH
10300: CALL_OW 428
10304: PUSH
10305: LD_INT 0
10307: EQUAL
10308: AND
10309: IFFALSE 10383
// for i = 1 to plist do
10311: LD_ADDR_VAR 0 6
10315: PUSH
10316: DOUBLE
10317: LD_INT 1
10319: DEC
10320: ST_TO_ADDR
10321: LD_VAR 0 8
10325: PUSH
10326: FOR_TO
10327: IFFALSE 10381
// if NotTask ( plist [ i ] ) then
10329: LD_VAR 0 8
10333: PUSH
10334: LD_VAR 0 6
10338: ARRAY
10339: PPUSH
10340: CALL 25894 0 1
10344: IFFALSE 10379
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
10346: LD_VAR 0 8
10350: PUSH
10351: LD_VAR 0 6
10355: ARRAY
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: LD_VAR 0 2
10364: PPUSH
10365: LD_VAR 0 3
10369: PPUSH
10370: LD_VAR 0 4
10374: PPUSH
10375: CALL_OW 145
// end ;
10379: GO 10326
10381: POP
10382: POP
// end ;
10383: LD_VAR 0 5
10387: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
10388: LD_INT 0
10390: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
10391: LD_VAR 0 1
10395: PPUSH
10396: LD_INT 6
10398: PPUSH
10399: LD_VAR 0 2
10403: PPUSH
10404: LD_VAR 0 3
10408: PPUSH
10409: LD_VAR 0 4
10413: PPUSH
10414: CALL 11892 0 5
// end ;
10418: LD_VAR 0 5
10422: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
10423: LD_INT 0
10425: PPUSH
10426: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
10427: LD_ADDR_VAR 0 4
10431: PUSH
10432: LD_INT 22
10434: PUSH
10435: LD_VAR 0 1
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 2
10446: PUSH
10447: LD_INT 30
10449: PUSH
10450: LD_INT 0
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: PUSH
10457: LD_INT 30
10459: PUSH
10460: LD_INT 1
10462: PUSH
10463: EMPTY
10464: LIST
10465: LIST
10466: PUSH
10467: EMPTY
10468: LIST
10469: LIST
10470: LIST
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: PUSH
10476: EMPTY
10477: LIST
10478: PPUSH
10479: CALL_OW 69
10483: PPUSH
10484: LD_VAR 0 2
10488: PPUSH
10489: CALL_OW 250
10493: PPUSH
10494: LD_VAR 0 2
10498: PPUSH
10499: CALL_OW 251
10503: PPUSH
10504: CALL_OW 73
10508: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
10509: LD_VAR 0 4
10513: PPUSH
10514: LD_VAR 0 2
10518: PPUSH
10519: CALL 12181 0 2
10523: IFFALSE 10582
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
10525: LD_VAR 0 1
10529: PPUSH
10530: LD_INT 30
10532: PUSH
10533: LD_VAR 0 2
10537: PUSH
10538: EMPTY
10539: LIST
10540: LIST
10541: PPUSH
10542: CALL 0 0 2
10546: PUSH
10547: LD_INT 1
10549: ARRAY
10550: PPUSH
10551: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
10555: LD_ADDR_EXP 17
10559: PUSH
10560: LD_EXP 17
10564: PPUSH
10565: LD_VAR 0 1
10569: PPUSH
10570: LD_VAR 0 2
10574: PPUSH
10575: EMPTY
10576: PPUSH
10577: CALL 4350 0 4
10581: ST_TO_ADDR
// end ; end ;
10582: LD_VAR 0 3
10586: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
10587: LD_INT 0
10589: PPUSH
10590: PPUSH
10591: PPUSH
10592: PPUSH
10593: PPUSH
10594: PPUSH
// result := false ;
10595: LD_ADDR_VAR 0 4
10599: PUSH
10600: LD_INT 0
10602: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_EXP 8
10612: PPUSH
10613: CALL 5353 0 2
10617: IFFALSE 10830
// for i = 1 to MREG_LabList do
10619: LD_ADDR_VAR 0 5
10623: PUSH
10624: DOUBLE
10625: LD_INT 1
10627: DEC
10628: ST_TO_ADDR
10629: LD_EXP 8
10633: PUSH
10634: FOR_TO
10635: IFFALSE 10828
// begin if MREG_LabList [ i ] [ 1 ] = side then
10637: LD_EXP 8
10641: PUSH
10642: LD_VAR 0 5
10646: ARRAY
10647: PUSH
10648: LD_INT 1
10650: ARRAY
10651: PUSH
10652: LD_VAR 0 1
10656: EQUAL
10657: IFFALSE 10826
// begin lab := MREG_LabList [ i ] [ 2 ] ;
10659: LD_ADDR_VAR 0 7
10663: PUSH
10664: LD_EXP 8
10668: PUSH
10669: LD_VAR 0 5
10673: ARRAY
10674: PUSH
10675: LD_INT 2
10677: ARRAY
10678: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
10679: LD_ADDR_VAR 0 9
10683: PUSH
10684: LD_INT 22
10686: PUSH
10687: LD_VAR 0 1
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: PUSH
10696: LD_INT 2
10698: PUSH
10699: LD_INT 30
10701: PUSH
10702: LD_INT 0
10704: PUSH
10705: EMPTY
10706: LIST
10707: LIST
10708: PUSH
10709: LD_INT 30
10711: PUSH
10712: LD_INT 1
10714: PUSH
10715: EMPTY
10716: LIST
10717: LIST
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: LIST
10723: PUSH
10724: EMPTY
10725: LIST
10726: LIST
10727: PUSH
10728: EMPTY
10729: LIST
10730: PPUSH
10731: CALL_OW 69
10735: PPUSH
10736: LD_VAR 0 7
10740: PPUSH
10741: CALL_OW 250
10745: PPUSH
10746: LD_VAR 0 7
10750: PPUSH
10751: CALL_OW 251
10755: PPUSH
10756: CALL_OW 73
10760: ST_TO_ADDR
// if dep then
10761: LD_VAR 0 9
10765: IFFALSE 10824
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
10767: LD_VAR 0 9
10771: PPUSH
10772: LD_VAR 0 2
10776: PPUSH
10777: LD_VAR 0 3
10781: PPUSH
10782: CALL 12297 0 3
10786: IFFALSE 10824
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
10788: LD_VAR 0 7
10792: PPUSH
10793: LD_VAR 0 2
10797: PPUSH
10798: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
10802: LD_VAR 0 7
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 207
// result := true ;
10816: LD_ADDR_VAR 0 4
10820: PUSH
10821: LD_INT 1
10823: ST_TO_ADDR
// end ; end ; break ;
10824: GO 10828
// end ; end ;
10826: GO 10634
10828: POP
10829: POP
// end ;
10830: LD_VAR 0 4
10834: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
10835: LD_INT 0
10837: PPUSH
10838: PPUSH
10839: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
10840: LD_ADDR_VAR 0 7
10844: PUSH
10845: LD_VAR 0 2
10849: PPUSH
10850: LD_VAR 0 3
10854: PPUSH
10855: LD_VAR 0 4
10859: PPUSH
10860: CALL 11022 0 3
10864: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
10865: LD_ADDR_EXP 15
10869: PUSH
10870: LD_EXP 15
10874: PPUSH
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_INT 2
10882: PPUSH
10883: LD_VAR 0 2
10887: PUSH
10888: LD_VAR 0 3
10892: PUSH
10893: LD_VAR 0 4
10897: PUSH
10898: EMPTY
10899: LIST
10900: LIST
10901: LIST
10902: PPUSH
10903: CALL 4259 0 4
10907: ST_TO_ADDR
// if ext_list then
10908: LD_VAR 0 5
10912: IFFALSE 11017
// for i = 1 to ext_list do
10914: LD_ADDR_VAR 0 8
10918: PUSH
10919: DOUBLE
10920: LD_INT 1
10922: DEC
10923: ST_TO_ADDR
10924: LD_VAR 0 5
10928: PUSH
10929: FOR_TO
10930: IFFALSE 11015
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
10932: LD_ADDR_EXP 15
10936: PUSH
10937: LD_EXP 15
10941: PPUSH
10942: LD_VAR 0 1
10946: PPUSH
10947: LD_VAR 0 5
10951: PUSH
10952: LD_VAR 0 8
10956: ARRAY
10957: PPUSH
10958: LD_VAR 0 7
10962: PUSH
10963: LD_VAR 0 8
10967: ARRAY
10968: PUSH
10969: LD_INT 1
10971: ARRAY
10972: PUSH
10973: LD_VAR 0 7
10977: PUSH
10978: LD_VAR 0 8
10982: ARRAY
10983: PUSH
10984: LD_INT 2
10986: ARRAY
10987: PUSH
10988: LD_VAR 0 7
10992: PUSH
10993: LD_VAR 0 8
10997: ARRAY
10998: PUSH
10999: LD_INT 3
11001: ARRAY
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL 4259 0 4
11012: ST_TO_ADDR
11013: GO 10929
11015: POP
11016: POP
// end ;
11017: LD_VAR 0 6
11021: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
11022: LD_INT 0
11024: PPUSH
11025: PPUSH
// list := [ ] ;
11026: LD_ADDR_VAR 0 5
11030: PUSH
11031: EMPTY
11032: ST_TO_ADDR
// case d of 0 :
11033: LD_VAR 0 3
11037: PUSH
11038: LD_INT 0
11040: DOUBLE
11041: EQUAL
11042: IFTRUE 11046
11044: GO 11179
11046: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
11047: LD_ADDR_VAR 0 5
11051: PUSH
11052: LD_VAR 0 1
11056: PUSH
11057: LD_INT 4
11059: MINUS
11060: PUSH
11061: LD_VAR 0 2
11065: PUSH
11066: LD_INT 4
11068: MINUS
11069: PUSH
11070: LD_INT 2
11072: PUSH
11073: EMPTY
11074: LIST
11075: LIST
11076: LIST
11077: PUSH
11078: LD_VAR 0 1
11082: PUSH
11083: LD_INT 3
11085: MINUS
11086: PUSH
11087: LD_VAR 0 2
11091: PUSH
11092: LD_INT 1
11094: PUSH
11095: EMPTY
11096: LIST
11097: LIST
11098: LIST
11099: PUSH
11100: LD_VAR 0 1
11104: PUSH
11105: LD_INT 4
11107: PLUS
11108: PUSH
11109: LD_VAR 0 2
11113: PUSH
11114: LD_INT 4
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: LIST
11121: PUSH
11122: LD_VAR 0 1
11126: PUSH
11127: LD_INT 3
11129: PLUS
11130: PUSH
11131: LD_VAR 0 2
11135: PUSH
11136: LD_INT 3
11138: PLUS
11139: PUSH
11140: LD_INT 5
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: LIST
11147: PUSH
11148: LD_VAR 0 1
11152: PUSH
11153: LD_VAR 0 2
11157: PUSH
11158: LD_INT 4
11160: PLUS
11161: PUSH
11162: LD_INT 0
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: LIST
11169: PUSH
11170: EMPTY
11171: LIST
11172: LIST
11173: LIST
11174: LIST
11175: LIST
11176: ST_TO_ADDR
// end ; 1 :
11177: GO 11877
11179: LD_INT 1
11181: DOUBLE
11182: EQUAL
11183: IFTRUE 11187
11185: GO 11320
11187: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 3 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
11188: LD_ADDR_VAR 0 5
11192: PUSH
11193: LD_VAR 0 1
11197: PUSH
11198: LD_VAR 0 2
11202: PUSH
11203: LD_INT 4
11205: MINUS
11206: PUSH
11207: LD_INT 3
11209: PUSH
11210: EMPTY
11211: LIST
11212: LIST
11213: LIST
11214: PUSH
11215: LD_VAR 0 1
11219: PUSH
11220: LD_INT 3
11222: MINUS
11223: PUSH
11224: LD_VAR 0 2
11228: PUSH
11229: LD_INT 3
11231: MINUS
11232: PUSH
11233: LD_INT 2
11235: PUSH
11236: EMPTY
11237: LIST
11238: LIST
11239: LIST
11240: PUSH
11241: LD_VAR 0 1
11245: PUSH
11246: LD_INT 3
11248: MINUS
11249: PUSH
11250: LD_VAR 0 2
11254: PUSH
11255: LD_INT 1
11257: PUSH
11258: EMPTY
11259: LIST
11260: LIST
11261: LIST
11262: PUSH
11263: LD_VAR 0 1
11267: PUSH
11268: LD_VAR 0 2
11272: PUSH
11273: LD_INT 3
11275: PLUS
11276: PUSH
11277: LD_INT 0
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: LIST
11284: PUSH
11285: LD_VAR 0 1
11289: PUSH
11290: LD_INT 4
11292: PLUS
11293: PUSH
11294: LD_VAR 0 2
11298: PUSH
11299: LD_INT 4
11301: PLUS
11302: PUSH
11303: LD_INT 5
11305: PUSH
11306: EMPTY
11307: LIST
11308: LIST
11309: LIST
11310: PUSH
11311: EMPTY
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: ST_TO_ADDR
// end ; 2 :
11318: GO 11877
11320: LD_INT 2
11322: DOUBLE
11323: EQUAL
11324: IFTRUE 11328
11326: GO 11457
11328: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 3 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
11329: LD_ADDR_VAR 0 5
11333: PUSH
11334: LD_VAR 0 1
11338: PUSH
11339: LD_VAR 0 2
11343: PUSH
11344: LD_INT 3
11346: MINUS
11347: PUSH
11348: LD_INT 3
11350: PUSH
11351: EMPTY
11352: LIST
11353: LIST
11354: LIST
11355: PUSH
11356: LD_VAR 0 1
11360: PUSH
11361: LD_INT 3
11363: PLUS
11364: PUSH
11365: LD_VAR 0 2
11369: PUSH
11370: LD_INT 4
11372: PUSH
11373: EMPTY
11374: LIST
11375: LIST
11376: LIST
11377: PUSH
11378: LD_VAR 0 1
11382: PUSH
11383: LD_VAR 0 2
11387: PUSH
11388: LD_INT 4
11390: PLUS
11391: PUSH
11392: LD_INT 0
11394: PUSH
11395: EMPTY
11396: LIST
11397: LIST
11398: LIST
11399: PUSH
11400: LD_VAR 0 1
11404: PUSH
11405: LD_INT 3
11407: MINUS
11408: PUSH
11409: LD_VAR 0 2
11413: PUSH
11414: LD_INT 1
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: LIST
11421: PUSH
11422: LD_VAR 0 1
11426: PUSH
11427: LD_INT 4
11429: MINUS
11430: PUSH
11431: LD_VAR 0 2
11435: PUSH
11436: LD_INT 4
11438: MINUS
11439: PUSH
11440: LD_INT 2
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: LIST
11447: PUSH
11448: EMPTY
11449: LIST
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: ST_TO_ADDR
// end ; 3 :
11455: GO 11877
11457: LD_INT 3
11459: DOUBLE
11460: EQUAL
11461: IFTRUE 11465
11463: GO 11598
11465: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
11466: LD_ADDR_VAR 0 5
11470: PUSH
11471: LD_VAR 0 1
11475: PUSH
11476: LD_INT 3
11478: PLUS
11479: PUSH
11480: LD_VAR 0 2
11484: PUSH
11485: LD_INT 4
11487: PUSH
11488: EMPTY
11489: LIST
11490: LIST
11491: LIST
11492: PUSH
11493: LD_VAR 0 1
11497: PUSH
11498: LD_INT 4
11500: PLUS
11501: PUSH
11502: LD_VAR 0 2
11506: PUSH
11507: LD_INT 4
11509: PLUS
11510: PUSH
11511: LD_INT 5
11513: PUSH
11514: EMPTY
11515: LIST
11516: LIST
11517: LIST
11518: PUSH
11519: LD_VAR 0 1
11523: PUSH
11524: LD_INT 4
11526: MINUS
11527: PUSH
11528: LD_VAR 0 2
11532: PUSH
11533: LD_INT 1
11535: PUSH
11536: EMPTY
11537: LIST
11538: LIST
11539: LIST
11540: PUSH
11541: LD_VAR 0 1
11545: PUSH
11546: LD_VAR 0 2
11550: PUSH
11551: LD_INT 4
11553: MINUS
11554: PUSH
11555: LD_INT 3
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: LIST
11562: PUSH
11563: LD_VAR 0 1
11567: PUSH
11568: LD_INT 3
11570: MINUS
11571: PUSH
11572: LD_VAR 0 2
11576: PUSH
11577: LD_INT 3
11579: MINUS
11580: PUSH
11581: LD_INT 2
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: LIST
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: LIST
11593: LIST
11594: LIST
11595: ST_TO_ADDR
// end ; 4 :
11596: GO 11877
11598: LD_INT 4
11600: DOUBLE
11601: EQUAL
11602: IFTRUE 11606
11604: GO 11739
11606: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
11607: LD_ADDR_VAR 0 5
11611: PUSH
11612: LD_VAR 0 1
11616: PUSH
11617: LD_VAR 0 2
11621: PUSH
11622: LD_INT 4
11624: PLUS
11625: PUSH
11626: LD_INT 0
11628: PUSH
11629: EMPTY
11630: LIST
11631: LIST
11632: LIST
11633: PUSH
11634: LD_VAR 0 1
11638: PUSH
11639: LD_INT 3
11641: PLUS
11642: PUSH
11643: LD_VAR 0 2
11647: PUSH
11648: LD_INT 3
11650: PLUS
11651: PUSH
11652: LD_INT 5
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: LIST
11659: PUSH
11660: LD_VAR 0 1
11664: PUSH
11665: LD_INT 3
11667: PLUS
11668: PUSH
11669: LD_VAR 0 2
11673: PUSH
11674: LD_INT 4
11676: PUSH
11677: EMPTY
11678: LIST
11679: LIST
11680: LIST
11681: PUSH
11682: LD_VAR 0 1
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: LD_INT 3
11694: MINUS
11695: PUSH
11696: LD_INT 3
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: LIST
11703: PUSH
11704: LD_VAR 0 1
11708: PUSH
11709: LD_INT 4
11711: MINUS
11712: PUSH
11713: LD_VAR 0 2
11717: PUSH
11718: LD_INT 4
11720: MINUS
11721: PUSH
11722: LD_INT 2
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: ST_TO_ADDR
// end ; 5 :
11737: GO 11877
11739: LD_INT 5
11741: DOUBLE
11742: EQUAL
11743: IFTRUE 11747
11745: GO 11876
11747: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
11748: LD_ADDR_VAR 0 5
11752: PUSH
11753: LD_VAR 0 1
11757: PUSH
11758: LD_INT 4
11760: MINUS
11761: PUSH
11762: LD_VAR 0 2
11766: PUSH
11767: LD_INT 1
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: LD_VAR 0 1
11779: PUSH
11780: LD_VAR 0 2
11784: PUSH
11785: LD_INT 4
11787: MINUS
11788: PUSH
11789: LD_INT 3
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: LIST
11796: PUSH
11797: LD_VAR 0 1
11801: PUSH
11802: LD_INT 4
11804: PLUS
11805: PUSH
11806: LD_VAR 0 2
11810: PUSH
11811: LD_INT 4
11813: PLUS
11814: PUSH
11815: LD_INT 5
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: LIST
11822: PUSH
11823: LD_VAR 0 1
11827: PUSH
11828: LD_INT 3
11830: PLUS
11831: PUSH
11832: LD_VAR 0 2
11836: PUSH
11837: LD_INT 4
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: LIST
11844: PUSH
11845: LD_VAR 0 1
11849: PUSH
11850: LD_VAR 0 2
11854: PUSH
11855: LD_INT 3
11857: PLUS
11858: PUSH
11859: LD_INT 0
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: PUSH
11867: EMPTY
11868: LIST
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: ST_TO_ADDR
// end ; end ;
11874: GO 11877
11876: POP
// result := list ;
11877: LD_ADDR_VAR 0 4
11881: PUSH
11882: LD_VAR 0 5
11886: ST_TO_ADDR
// end ;
11887: LD_VAR 0 4
11891: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
11892: LD_INT 0
11894: PPUSH
11895: PPUSH
11896: PPUSH
11897: PPUSH
11898: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11899: LD_ADDR_VAR 0 10
11903: PUSH
11904: LD_VAR 0 1
11908: PPUSH
11909: LD_INT 2
11911: PPUSH
11912: EMPTY
11913: PPUSH
11914: CALL 83 0 3
11918: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
11919: LD_ADDR_VAR 0 9
11923: PUSH
11924: LD_INT 22
11926: PUSH
11927: LD_VAR 0 1
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: PUSH
11936: LD_INT 2
11938: PUSH
11939: LD_INT 30
11941: PUSH
11942: LD_INT 0
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: PUSH
11949: LD_INT 30
11951: PUSH
11952: LD_INT 1
11954: PUSH
11955: EMPTY
11956: LIST
11957: LIST
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: LIST
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: EMPTY
11969: LIST
11970: PPUSH
11971: CALL_OW 69
11975: PPUSH
11976: LD_VAR 0 3
11980: PPUSH
11981: LD_VAR 0 4
11985: PPUSH
11986: CALL_OW 73
11990: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
11991: LD_ADDR_VAR 0 8
11995: PUSH
11996: LD_VAR 0 9
12000: PPUSH
12001: LD_VAR 0 2
12005: PPUSH
12006: CALL 12181 0 2
12010: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
12011: LD_VAR 0 10
12015: PUSH
12016: LD_VAR 0 8
12020: AND
12021: PUSH
12022: LD_VAR 0 9
12026: PPUSH
12027: LD_VAR 0 3
12031: PPUSH
12032: LD_VAR 0 4
12036: PPUSH
12037: CALL_OW 297
12041: PUSH
12042: LD_INT 26
12044: LESSEQUAL
12045: AND
12046: PUSH
12047: LD_VAR 0 3
12051: PPUSH
12052: LD_VAR 0 4
12056: PPUSH
12057: CALL_OW 428
12061: PUSH
12062: LD_INT 0
12064: EQUAL
12065: AND
12066: IFFALSE 12176
// for i = 1 to plist do
12068: LD_ADDR_VAR 0 7
12072: PUSH
12073: DOUBLE
12074: LD_INT 1
12076: DEC
12077: ST_TO_ADDR
12078: LD_VAR 0 10
12082: PUSH
12083: FOR_TO
12084: IFFALSE 12174
// if IsInUnit ( plist [ i ] ) then
12086: LD_VAR 0 10
12090: PUSH
12091: LD_VAR 0 7
12095: ARRAY
12096: PPUSH
12097: CALL_OW 310
12101: IFFALSE 12120
// ComExitBuilding ( plist [ i ] ) else
12103: LD_VAR 0 10
12107: PUSH
12108: LD_VAR 0 7
12112: ARRAY
12113: PPUSH
12114: CALL_OW 122
12118: GO 12172
// if NotTask ( plist [ i ] ) then
12120: LD_VAR 0 10
12124: PUSH
12125: LD_VAR 0 7
12129: ARRAY
12130: PPUSH
12131: CALL 25894 0 1
12135: IFFALSE 12172
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
12137: LD_VAR 0 10
12141: PUSH
12142: LD_VAR 0 7
12146: ARRAY
12147: PPUSH
12148: LD_VAR 0 2
12152: PPUSH
12153: LD_VAR 0 3
12157: PPUSH
12158: LD_VAR 0 4
12162: PPUSH
12163: LD_VAR 0 5
12167: PPUSH
12168: CALL_OW 145
// end ;
12172: GO 12083
12174: POP
12175: POP
// end ;
12176: LD_VAR 0 6
12180: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
12181: LD_INT 0
12183: PPUSH
12184: PPUSH
12185: PPUSH
// pom := GetBase ( bdepot ) ;
12186: LD_ADDR_VAR 0 4
12190: PUSH
12191: LD_VAR 0 1
12195: PPUSH
12196: CALL_OW 274
12200: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
12201: LD_ADDR_VAR 0 5
12205: PUSH
12206: LD_VAR 0 2
12210: PPUSH
12211: LD_VAR 0 1
12215: PPUSH
12216: CALL_OW 248
12220: PPUSH
12221: CALL_OW 450
12225: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
12226: LD_VAR 0 4
12230: PPUSH
12231: LD_INT 1
12233: PPUSH
12234: CALL_OW 275
12238: PUSH
12239: LD_VAR 0 5
12243: PUSH
12244: LD_INT 1
12246: ARRAY
12247: GREATEREQUAL
12248: PUSH
12249: LD_VAR 0 4
12253: PPUSH
12254: LD_INT 3
12256: PPUSH
12257: CALL_OW 275
12261: PUSH
12262: LD_VAR 0 5
12266: PUSH
12267: LD_INT 3
12269: ARRAY
12270: GREATEREQUAL
12271: AND
12272: IFFALSE 12284
// result := true else
12274: LD_ADDR_VAR 0 3
12278: PUSH
12279: LD_INT 1
12281: ST_TO_ADDR
12282: GO 12292
// result := false ;
12284: LD_ADDR_VAR 0 3
12288: PUSH
12289: LD_INT 0
12291: ST_TO_ADDR
// end ;
12292: LD_VAR 0 3
12296: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
12297: LD_INT 0
12299: PPUSH
12300: PPUSH
12301: PPUSH
12302: PPUSH
12303: PPUSH
// pom := GetBase ( bdepot ) ;
12304: LD_ADDR_VAR 0 5
12308: PUSH
12309: LD_VAR 0 1
12313: PPUSH
12314: CALL_OW 274
12318: ST_TO_ADDR
// cost := [ ] ;
12319: LD_ADDR_VAR 0 8
12323: PUSH
12324: EMPTY
12325: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
12326: LD_ADDR_VAR 0 6
12330: PUSH
12331: LD_VAR 0 2
12335: PPUSH
12336: LD_VAR 0 1
12340: PPUSH
12341: CALL_OW 248
12345: PPUSH
12346: CALL_OW 450
12350: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
12351: LD_ADDR_VAR 0 7
12355: PUSH
12356: LD_VAR 0 3
12360: PPUSH
12361: LD_VAR 0 1
12365: PPUSH
12366: CALL_OW 248
12370: PPUSH
12371: CALL_OW 450
12375: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
12376: LD_ADDR_VAR 0 8
12380: PUSH
12381: LD_VAR 0 8
12385: PPUSH
12386: LD_INT 1
12388: PPUSH
12389: LD_VAR 0 6
12393: PUSH
12394: LD_INT 1
12396: ARRAY
12397: PUSH
12398: LD_VAR 0 7
12402: PUSH
12403: LD_INT 1
12405: ARRAY
12406: PLUS
12407: PPUSH
12408: CALL_OW 1
12412: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
12413: LD_ADDR_VAR 0 8
12417: PUSH
12418: LD_VAR 0 8
12422: PPUSH
12423: LD_INT 2
12425: PPUSH
12426: LD_VAR 0 6
12430: PUSH
12431: LD_INT 2
12433: ARRAY
12434: PUSH
12435: LD_VAR 0 7
12439: PUSH
12440: LD_INT 2
12442: ARRAY
12443: PLUS
12444: PPUSH
12445: CALL_OW 1
12449: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
12450: LD_ADDR_VAR 0 8
12454: PUSH
12455: LD_VAR 0 8
12459: PPUSH
12460: LD_INT 3
12462: PPUSH
12463: LD_VAR 0 6
12467: PUSH
12468: LD_INT 3
12470: ARRAY
12471: PUSH
12472: LD_VAR 0 7
12476: PUSH
12477: LD_INT 3
12479: ARRAY
12480: PLUS
12481: PPUSH
12482: CALL_OW 1
12486: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
12487: LD_VAR 0 5
12491: PPUSH
12492: LD_INT 1
12494: PPUSH
12495: CALL_OW 275
12499: PUSH
12500: LD_VAR 0 8
12504: PUSH
12505: LD_INT 1
12507: ARRAY
12508: GREATEREQUAL
12509: PUSH
12510: LD_VAR 0 5
12514: PPUSH
12515: LD_INT 3
12517: PPUSH
12518: CALL_OW 275
12522: PUSH
12523: LD_VAR 0 8
12527: PUSH
12528: LD_INT 3
12530: ARRAY
12531: GREATEREQUAL
12532: AND
12533: IFFALSE 12545
// result := true else
12535: LD_ADDR_VAR 0 4
12539: PUSH
12540: LD_INT 1
12542: ST_TO_ADDR
12543: GO 12553
// result := false ;
12545: LD_ADDR_VAR 0 4
12549: PUSH
12550: LD_INT 0
12552: ST_TO_ADDR
// end ;
12553: LD_VAR 0 4
12557: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
12558: LD_INT 0
12560: PPUSH
12561: PPUSH
12562: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
12563: LD_ADDR_VAR 0 5
12567: PUSH
12568: LD_VAR 0 1
12572: PPUSH
12573: LD_INT 2
12575: PPUSH
12576: EMPTY
12577: PPUSH
12578: CALL 83 0 3
12582: ST_TO_ADDR
// if unit and plist then
12583: LD_VAR 0 2
12587: PUSH
12588: LD_VAR 0 5
12592: AND
12593: IFFALSE 12654
// for i = 1 to plist do
12595: LD_ADDR_VAR 0 4
12599: PUSH
12600: DOUBLE
12601: LD_INT 1
12603: DEC
12604: ST_TO_ADDR
12605: LD_VAR 0 5
12609: PUSH
12610: FOR_TO
12611: IFFALSE 12652
// if NotTask ( plist [ i ] ) then
12613: LD_VAR 0 5
12617: PUSH
12618: LD_VAR 0 4
12622: ARRAY
12623: PPUSH
12624: CALL 25894 0 1
12628: IFFALSE 12650
// ComDismantle ( plist [ i ] , unit ) ;
12630: LD_VAR 0 5
12634: PUSH
12635: LD_VAR 0 4
12639: ARRAY
12640: PPUSH
12641: LD_VAR 0 2
12645: PPUSH
12646: CALL_OW 167
12650: GO 12610
12652: POP
12653: POP
// result := true ;
12654: LD_ADDR_VAR 0 3
12658: PUSH
12659: LD_INT 1
12661: ST_TO_ADDR
// end ;
12662: LD_VAR 0 3
12666: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
12667: LD_INT 0
12669: PPUSH
12670: PPUSH
12671: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
12672: LD_ADDR_VAR 0 5
12676: PUSH
12677: LD_VAR 0 1
12681: PPUSH
12682: LD_INT 2
12684: PPUSH
12685: EMPTY
12686: PPUSH
12687: CALL 83 0 3
12691: ST_TO_ADDR
// if unit and plist then
12692: LD_VAR 0 2
12696: PUSH
12697: LD_VAR 0 5
12701: AND
12702: IFFALSE 12763
// for i = 1 to plist do
12704: LD_ADDR_VAR 0 4
12708: PUSH
12709: DOUBLE
12710: LD_INT 1
12712: DEC
12713: ST_TO_ADDR
12714: LD_VAR 0 5
12718: PUSH
12719: FOR_TO
12720: IFFALSE 12761
// if NotTask ( plist [ i ] ) then
12722: LD_VAR 0 5
12726: PUSH
12727: LD_VAR 0 4
12731: ARRAY
12732: PPUSH
12733: CALL 25894 0 1
12737: IFFALSE 12759
// ComComplete ( plist [ i ] , unit ) ;
12739: LD_VAR 0 5
12743: PUSH
12744: LD_VAR 0 4
12748: ARRAY
12749: PPUSH
12750: LD_VAR 0 2
12754: PPUSH
12755: CALL 25430 0 2
12759: GO 12719
12761: POP
12762: POP
// result := true ;
12763: LD_ADDR_VAR 0 3
12767: PUSH
12768: LD_INT 1
12770: ST_TO_ADDR
// end ;
12771: LD_VAR 0 3
12775: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
12776: LD_INT 0
12778: PPUSH
12779: PPUSH
12780: PPUSH
12781: PPUSH
12782: PPUSH
12783: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12784: LD_ADDR_VAR 0 5
12788: PUSH
12789: LD_INT 22
12791: PUSH
12792: LD_VAR 0 1
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PUSH
12801: LD_INT 21
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: PUSH
12811: LD_INT 3
12813: PUSH
12814: LD_INT 57
12816: PUSH
12817: EMPTY
12818: LIST
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: LD_INT 3
12826: PUSH
12827: LD_INT 24
12829: PUSH
12830: LD_INT 1000
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: LIST
12845: LIST
12846: PPUSH
12847: CALL_OW 69
12851: ST_TO_ADDR
// r := [ ] ;
12852: LD_ADDR_VAR 0 6
12856: PUSH
12857: EMPTY
12858: ST_TO_ADDR
// if not tmp then
12859: LD_VAR 0 5
12863: NOT
12864: IFFALSE 12870
// exit else
12866: GO 13058
12868: GO 13038
// begin r := [ tmp [ 1 ] ] ;
12870: LD_ADDR_VAR 0 6
12874: PUSH
12875: LD_VAR 0 5
12879: PUSH
12880: LD_INT 1
12882: ARRAY
12883: PUSH
12884: EMPTY
12885: LIST
12886: ST_TO_ADDR
// for i = 2 to tmp do
12887: LD_ADDR_VAR 0 3
12891: PUSH
12892: DOUBLE
12893: LD_INT 2
12895: DEC
12896: ST_TO_ADDR
12897: LD_VAR 0 5
12901: PUSH
12902: FOR_TO
12903: IFFALSE 13036
// begin m := false ;
12905: LD_ADDR_VAR 0 7
12909: PUSH
12910: LD_INT 0
12912: ST_TO_ADDR
// for j = 1 to r do
12913: LD_ADDR_VAR 0 4
12917: PUSH
12918: DOUBLE
12919: LD_INT 1
12921: DEC
12922: ST_TO_ADDR
12923: LD_VAR 0 6
12927: PUSH
12928: FOR_TO
12929: IFFALSE 13003
// if GetLives ( tmp [ i ] ) < r [ j ] then
12931: LD_VAR 0 5
12935: PUSH
12936: LD_VAR 0 3
12940: ARRAY
12941: PPUSH
12942: CALL_OW 256
12946: PUSH
12947: LD_VAR 0 6
12951: PUSH
12952: LD_VAR 0 4
12956: ARRAY
12957: LESS
12958: IFFALSE 13001
// begin r := Insert ( r , j , tmp [ i ] ) ;
12960: LD_ADDR_VAR 0 6
12964: PUSH
12965: LD_VAR 0 6
12969: PPUSH
12970: LD_VAR 0 4
12974: PPUSH
12975: LD_VAR 0 5
12979: PUSH
12980: LD_VAR 0 3
12984: ARRAY
12985: PPUSH
12986: CALL_OW 2
12990: ST_TO_ADDR
// m := true ;
12991: LD_ADDR_VAR 0 7
12995: PUSH
12996: LD_INT 1
12998: ST_TO_ADDR
// break ;
12999: GO 13003
// end ;
13001: GO 12928
13003: POP
13004: POP
// if not m then
13005: LD_VAR 0 7
13009: NOT
13010: IFFALSE 13034
// r := r ^ tmp [ i ] ;
13012: LD_ADDR_VAR 0 6
13016: PUSH
13017: LD_VAR 0 6
13021: PUSH
13022: LD_VAR 0 5
13026: PUSH
13027: LD_VAR 0 3
13031: ARRAY
13032: ADD
13033: ST_TO_ADDR
// end ;
13034: GO 12902
13036: POP
13037: POP
// end ; if r then
13038: LD_VAR 0 6
13042: IFFALSE 13056
// result := r else
13044: LD_ADDR_VAR 0 2
13048: PUSH
13049: LD_VAR 0 6
13053: ST_TO_ADDR
13054: GO 13058
// exit ;
13056: GO 13058
// end ;
13058: LD_VAR 0 2
13062: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
13063: LD_INT 0
13065: PPUSH
13066: PPUSH
13067: PPUSH
13068: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
13069: LD_ADDR_VAR 0 5
13073: PUSH
13074: LD_INT 22
13076: PUSH
13077: LD_VAR 0 1
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: PUSH
13086: LD_INT 2
13088: PUSH
13089: LD_INT 25
13091: PUSH
13092: LD_INT 2
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: LD_INT 25
13101: PUSH
13102: LD_INT 16
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: PUSH
13109: LD_INT 34
13111: PUSH
13112: LD_INT 13
13114: PUSH
13115: EMPTY
13116: LIST
13117: LIST
13118: PUSH
13119: LD_INT 34
13121: PUSH
13122: LD_INT 52
13124: PUSH
13125: EMPTY
13126: LIST
13127: LIST
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_INT 24
13138: PUSH
13139: LD_INT 650
13141: PUSH
13142: EMPTY
13143: LIST
13144: LIST
13145: PUSH
13146: EMPTY
13147: LIST
13148: LIST
13149: LIST
13150: PPUSH
13151: CALL_OW 69
13155: ST_TO_ADDR
// p := 1 ;
13156: LD_ADDR_VAR 0 4
13160: PUSH
13161: LD_INT 1
13163: ST_TO_ADDR
// for i = 1 to repairs do
13164: LD_ADDR_VAR 0 3
13168: PUSH
13169: DOUBLE
13170: LD_INT 1
13172: DEC
13173: ST_TO_ADDR
13174: LD_VAR 0 5
13178: PUSH
13179: FOR_TO
13180: IFFALSE 13316
// begin if IsInUnit ( repairs [ i ] ) then
13182: LD_VAR 0 5
13186: PUSH
13187: LD_VAR 0 3
13191: ARRAY
13192: PPUSH
13193: CALL_OW 310
13197: IFFALSE 13216
// ComExitBuilding ( repairs [ i ] ) else
13199: LD_VAR 0 5
13203: PUSH
13204: LD_VAR 0 3
13208: ARRAY
13209: PPUSH
13210: CALL_OW 122
13214: GO 13314
// if not HasTask ( repairs [ i ] ) then
13216: LD_VAR 0 5
13220: PUSH
13221: LD_VAR 0 3
13225: ARRAY
13226: PPUSH
13227: CALL_OW 314
13231: NOT
13232: IFFALSE 13314
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
13234: LD_VAR 0 5
13238: PUSH
13239: LD_VAR 0 3
13243: ARRAY
13244: PPUSH
13245: LD_EXP 16
13249: PUSH
13250: LD_VAR 0 1
13254: ARRAY
13255: PUSH
13256: LD_VAR 0 4
13260: ARRAY
13261: PPUSH
13262: CALL_OW 130
// if i mod 3 = 0 then
13266: LD_VAR 0 3
13270: PUSH
13271: LD_INT 3
13273: MOD
13274: PUSH
13275: LD_INT 0
13277: EQUAL
13278: IFFALSE 13294
// p := p + 1 ;
13280: LD_ADDR_VAR 0 4
13284: PUSH
13285: LD_VAR 0 4
13289: PUSH
13290: LD_INT 1
13292: PLUS
13293: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
13294: LD_EXP 16
13298: PUSH
13299: LD_VAR 0 1
13303: ARRAY
13304: PUSH
13305: LD_VAR 0 4
13309: LESS
13310: IFFALSE 13314
// break ;
13312: GO 13316
// end ; end ;
13314: GO 13179
13316: POP
13317: POP
// end ; end_of_file
13318: LD_VAR 0 2
13322: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
13323: LD_INT 0
13325: PPUSH
13326: PPUSH
13327: PPUSH
13328: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
13329: LD_ADDR_VAR 0 5
13333: PUSH
13334: LD_INT 35
13336: PUSH
13337: LD_INT 45
13339: PUSH
13340: LD_INT 46
13342: PUSH
13343: LD_INT 47
13345: PUSH
13346: LD_INT 1
13348: PUSH
13349: LD_INT 2
13351: PUSH
13352: LD_INT 48
13354: PUSH
13355: LD_INT 49
13357: PUSH
13358: LD_INT 50
13360: PUSH
13361: LD_INT 20
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: ST_TO_ADDR
// if MCF_Lab ( side ) then
13376: LD_VAR 0 1
13380: PPUSH
13381: CALL 39 0 1
13385: IFFALSE 13624
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
13387: LD_VAR 0 1
13391: PPUSH
13392: CALL 39 0 1
13396: PUSH
13397: LD_INT 1
13399: ARRAY
13400: PPUSH
13401: CALL_OW 461
13405: PUSH
13406: LD_INT 2
13408: EQUAL
13409: IFFALSE 13548
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
13411: LD_VAR 0 1
13415: PPUSH
13416: CALL 39 0 1
13420: PUSH
13421: LD_INT 1
13423: ARRAY
13424: PPUSH
13425: LD_VAR 0 2
13429: PPUSH
13430: CALL 13720 0 2
13434: IFFALSE 13461
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
13436: LD_VAR 0 1
13440: PPUSH
13441: CALL 39 0 1
13445: PUSH
13446: LD_INT 1
13448: ARRAY
13449: PPUSH
13450: LD_VAR 0 2
13454: PPUSH
13455: CALL_OW 124
13459: GO 13548
// if MCF_Lab ( side ) > 1 then
13461: LD_VAR 0 1
13465: PPUSH
13466: CALL 39 0 1
13470: PUSH
13471: LD_INT 1
13473: GREATER
13474: IFFALSE 13548
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
13476: LD_VAR 0 1
13480: PPUSH
13481: CALL 39 0 1
13485: PUSH
13486: LD_INT 2
13488: ARRAY
13489: PPUSH
13490: CALL_OW 461
13494: PUSH
13495: LD_INT 2
13497: EQUAL
13498: IFFALSE 13548
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
13500: LD_VAR 0 1
13504: PPUSH
13505: CALL 39 0 1
13509: PUSH
13510: LD_INT 2
13512: ARRAY
13513: PPUSH
13514: LD_VAR 0 2
13518: PPUSH
13519: CALL 13720 0 2
13523: IFFALSE 13548
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: CALL 39 0 1
13534: PUSH
13535: LD_INT 2
13537: ARRAY
13538: PPUSH
13539: LD_VAR 0 2
13543: PPUSH
13544: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
13548: LD_VAR 0 2
13552: PUSH
13553: LD_INT 2
13555: PUSH
13556: LD_INT 11
13558: PUSH
13559: LD_INT 4
13561: PUSH
13562: LD_INT 3
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: IN
13571: IFFALSE 13624
// begin for lab in MCF_Lab ( side ) do
13573: LD_ADDR_VAR 0 6
13577: PUSH
13578: LD_VAR 0 1
13582: PPUSH
13583: CALL 39 0 1
13587: PUSH
13588: FOR_IN
13589: IFFALSE 13622
// if BuildingStatus ( lab ) = bs_need_ape then
13591: LD_VAR 0 6
13595: PPUSH
13596: CALL_OW 461
13600: PUSH
13601: LD_INT 10
13603: EQUAL
13604: IFFALSE 13620
// MCL_ResTame ( side , lab ) ;
13606: LD_VAR 0 1
13610: PPUSH
13611: LD_VAR 0 6
13615: PPUSH
13616: CALL 13845 0 2
13620: GO 13588
13622: POP
13623: POP
// end ; end ; end ;
13624: LD_VAR 0 3
13628: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
13629: LD_INT 0
13631: PPUSH
13632: PPUSH
// tmp := [ ] ;
13633: LD_ADDR_VAR 0 3
13637: PUSH
13638: EMPTY
13639: ST_TO_ADDR
// if not lab then
13640: LD_VAR 0 1
13644: NOT
13645: IFFALSE 13657
// result := false else
13647: LD_ADDR_VAR 0 2
13651: PUSH
13652: LD_INT 0
13654: ST_TO_ADDR
13655: GO 13715
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
13657: LD_ADDR_VAR 0 3
13661: PUSH
13662: LD_VAR 0 3
13666: PUSH
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_INT 1
13674: PPUSH
13675: CALL_OW 268
13679: ADD
13680: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
13681: LD_ADDR_VAR 0 3
13685: PUSH
13686: LD_VAR 0 3
13690: PUSH
13691: LD_VAR 0 1
13695: PPUSH
13696: LD_INT 2
13698: PPUSH
13699: CALL_OW 268
13703: ADD
13704: ST_TO_ADDR
// result := tmp ;
13705: LD_ADDR_VAR 0 2
13709: PUSH
13710: LD_VAR 0 3
13714: ST_TO_ADDR
// end ; end ;
13715: LD_VAR 0 2
13719: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
13720: LD_INT 0
13722: PPUSH
13723: PPUSH
13724: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
13725: LD_ADDR_VAR 0 5
13729: PUSH
13730: LD_INT 35
13732: PUSH
13733: LD_INT 45
13735: PUSH
13736: LD_INT 46
13738: PUSH
13739: LD_INT 47
13741: PUSH
13742: LD_INT 1
13744: PUSH
13745: LD_INT 2
13747: PUSH
13748: LD_INT 48
13750: PUSH
13751: LD_INT 49
13753: PUSH
13754: LD_INT 50
13756: PUSH
13757: LD_INT 20
13759: PUSH
13760: EMPTY
13761: LIST
13762: LIST
13763: LIST
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: ST_TO_ADDR
// if lab then
13772: LD_VAR 0 1
13776: IFFALSE 13832
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
13778: LD_VAR 0 2
13782: PUSH
13783: LD_VAR 0 5
13787: IN
13788: PUSH
13789: LD_VAR 0 2
13793: PPUSH
13794: CALL_OW 481
13798: PUSH
13799: LD_VAR 0 1
13803: PPUSH
13804: CALL 13629 0 1
13808: IN
13809: OR
13810: IFFALSE 13822
// result := true else
13812: LD_ADDR_VAR 0 3
13816: PUSH
13817: LD_INT 1
13819: ST_TO_ADDR
13820: GO 13830
// result := false ;
13822: LD_ADDR_VAR 0 3
13826: PUSH
13827: LD_INT 0
13829: ST_TO_ADDR
// end else
13830: GO 13840
// result := false ;
13832: LD_ADDR_VAR 0 3
13836: PUSH
13837: LD_INT 0
13839: ST_TO_ADDR
// end ;
13840: LD_VAR 0 3
13844: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
13845: LD_INT 0
13847: PPUSH
13848: PPUSH
13849: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
13850: LD_ADDR_VAR 0 4
13854: PUSH
13855: LD_VAR 0 1
13859: PPUSH
13860: LD_INT 171
13862: PPUSH
13863: EMPTY
13864: PPUSH
13865: CALL 703 0 3
13869: ST_TO_ADDR
// if not ape then
13870: LD_VAR 0 4
13874: NOT
13875: IFFALSE 13907
// if MCF_Ape ( side ) then
13877: LD_VAR 0 1
13881: PPUSH
13882: CALL 413 0 1
13886: IFFALSE 13907
// ape := MCF_Ape ( side ) [ 1 ] ;
13888: LD_ADDR_VAR 0 4
13892: PUSH
13893: LD_VAR 0 1
13897: PPUSH
13898: CALL 413 0 1
13902: PUSH
13903: LD_INT 1
13905: ARRAY
13906: ST_TO_ADDR
// if ape then
13907: LD_VAR 0 4
13911: IFFALSE 13962
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
13913: LD_VAR 0 4
13917: PUSH
13918: LD_INT 1
13920: ARRAY
13921: PPUSH
13922: CALL_OW 310
13926: PUSH
13927: LD_VAR 0 4
13931: PUSH
13932: LD_INT 1
13934: ARRAY
13935: PPUSH
13936: CALL_OW 310
13940: PUSH
13941: LD_VAR 0 2
13945: NONEQUAL
13946: AND
13947: IFFALSE 13962
// ComExitBuilding ( ape [ 1 ] ) ;
13949: LD_VAR 0 4
13953: PUSH
13954: LD_INT 1
13956: ARRAY
13957: PPUSH
13958: CALL_OW 122
// if not lab then
13962: LD_VAR 0 2
13966: NOT
13967: IFFALSE 13973
// exit else
13969: GO 14121
13971: GO 14081
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
13973: LD_VAR 0 1
13977: PPUSH
13978: LD_INT 16
13980: PPUSH
13981: LD_INT 25
13983: PUSH
13984: LD_INT 4
13986: PUSH
13987: EMPTY
13988: LIST
13989: LIST
13990: PPUSH
13991: CALL 703 0 3
13995: PUSH
13996: LD_INT 0
13998: EQUAL
13999: PUSH
14000: LD_VAR 0 2
14004: PPUSH
14005: CALL_OW 313
14009: PUSH
14010: LD_INT 6
14012: EQUAL
14013: AND
14014: IFFALSE 14081
// begin tmp := UnitsInside ( lab ) ;
14016: LD_ADDR_VAR 0 5
14020: PUSH
14021: LD_VAR 0 2
14025: PPUSH
14026: CALL_OW 313
14030: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
14031: LD_VAR 0 5
14035: PUSH
14036: LD_VAR 0 5
14040: ARRAY
14041: PPUSH
14042: LD_INT 16
14044: PPUSH
14045: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
14049: LD_VAR 0 5
14053: PUSH
14054: LD_VAR 0 5
14058: ARRAY
14059: PPUSH
14060: CALL_OW 310
14064: IFFALSE 14081
// ComExitBuilding ( tmp [ tmp ] ) ;
14066: LD_VAR 0 5
14070: PUSH
14071: LD_VAR 0 5
14075: ARRAY
14076: PPUSH
14077: CALL_OW 122
// end ; if ape then
14081: LD_VAR 0 4
14085: IFFALSE 14121
// if not IsInUnit ( ape [ 1 ] ) then
14087: LD_VAR 0 4
14091: PUSH
14092: LD_INT 1
14094: ARRAY
14095: PPUSH
14096: CALL_OW 310
14100: NOT
14101: IFFALSE 14121
// ComEnterUnit ( ape [ 1 ] , lab ) ;
14103: LD_VAR 0 4
14107: PUSH
14108: LD_INT 1
14110: ARRAY
14111: PPUSH
14112: LD_VAR 0 2
14116: PPUSH
14117: CALL_OW 120
// end ;
14121: LD_VAR 0 3
14125: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
14126: LD_INT 0
14128: PPUSH
14129: PPUSH
14130: PPUSH
// result := false ;
14131: LD_ADDR_VAR 0 2
14135: PUSH
14136: LD_INT 0
14138: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
14139: LD_ADDR_VAR 0 3
14143: PUSH
14144: LD_VAR 0 1
14148: PPUSH
14149: CALL 14288 0 1
14153: ST_TO_ADDR
// if techs then
14154: LD_VAR 0 3
14158: IFFALSE 14188
// if techs [ 2 ] then
14160: LD_VAR 0 3
14164: PUSH
14165: LD_INT 2
14167: ARRAY
14168: IFFALSE 14180
// result := true else
14170: LD_ADDR_VAR 0 2
14174: PUSH
14175: LD_INT 1
14177: ST_TO_ADDR
14178: GO 14188
// result := false ;
14180: LD_ADDR_VAR 0 2
14184: PUSH
14185: LD_INT 0
14187: ST_TO_ADDR
// end ;
14188: LD_VAR 0 2
14192: RET
// export function MCL_Start ( side ) ; var i ; begin
14193: LD_INT 0
14195: PPUSH
14196: PPUSH
// if MREG_ForSide ( side , MREG_ToRes ) then
14197: LD_VAR 0 1
14201: PPUSH
14202: LD_EXP 19
14206: PPUSH
14207: CALL 5353 0 2
14211: IFFALSE 14283
// for i = 1 to MREG_ToRes do
14213: LD_ADDR_VAR 0 3
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_EXP 19
14227: PUSH
14228: FOR_TO
14229: IFFALSE 14281
// if MREG_ToRes [ i ] [ 1 ] = side then
14231: LD_EXP 19
14235: PUSH
14236: LD_VAR 0 3
14240: ARRAY
14241: PUSH
14242: LD_INT 1
14244: ARRAY
14245: PUSH
14246: LD_VAR 0 1
14250: EQUAL
14251: IFFALSE 14279
// begin MCL_Research ( side , MREG_ToRes [ i ] [ 2 ] ) ;
14253: LD_VAR 0 1
14257: PPUSH
14258: LD_EXP 19
14262: PUSH
14263: LD_VAR 0 3
14267: ARRAY
14268: PUSH
14269: LD_INT 2
14271: ARRAY
14272: PPUSH
14273: CALL 13323 0 2
// break ;
14277: GO 14281
// end ;
14279: GO 14228
14281: POP
14282: POP
// end ;
14283: LD_VAR 0 2
14287: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
14288: LD_INT 0
14290: PPUSH
14291: PPUSH
14292: PPUSH
// if MREG_ToRes then
14293: LD_EXP 19
14297: IFFALSE 14371
// for i = 1 to MREG_ToRes do
14299: LD_ADDR_VAR 0 3
14303: PUSH
14304: DOUBLE
14305: LD_INT 1
14307: DEC
14308: ST_TO_ADDR
14309: LD_EXP 19
14313: PUSH
14314: FOR_TO
14315: IFFALSE 14369
// if MREG_ToRes [ i ] [ 1 ] = side then
14317: LD_EXP 19
14321: PUSH
14322: LD_VAR 0 3
14326: ARRAY
14327: PUSH
14328: LD_INT 1
14330: ARRAY
14331: PUSH
14332: LD_VAR 0 1
14336: EQUAL
14337: IFFALSE 14367
// begin techs := techs ^ MREG_ToRes [ i ] [ 2 ] ;
14339: LD_ADDR_VAR 0 4
14343: PUSH
14344: LD_VAR 0 4
14348: PUSH
14349: LD_EXP 19
14353: PUSH
14354: LD_VAR 0 3
14358: ARRAY
14359: PUSH
14360: LD_INT 2
14362: ARRAY
14363: ADD
14364: ST_TO_ADDR
// break ;
14365: GO 14369
// end ;
14367: GO 14314
14369: POP
14370: POP
// result := techs ;
14371: LD_ADDR_VAR 0 2
14375: PUSH
14376: LD_VAR 0 4
14380: ST_TO_ADDR
// end ;
14381: LD_VAR 0 2
14385: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
14386: LD_INT 0
14388: PPUSH
14389: PPUSH
// for i = 1 to tech_list do
14390: LD_ADDR_VAR 0 4
14394: PUSH
14395: DOUBLE
14396: LD_INT 1
14398: DEC
14399: ST_TO_ADDR
14400: LD_VAR 0 2
14404: PUSH
14405: FOR_TO
14406: IFFALSE 14460
// if not tech_list [ i ] = 20 then
14408: LD_VAR 0 2
14412: PUSH
14413: LD_VAR 0 4
14417: ARRAY
14418: PUSH
14419: LD_INT 20
14421: EQUAL
14422: NOT
14423: IFFALSE 14458
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
14425: LD_ADDR_EXP 19
14429: PUSH
14430: LD_EXP 19
14434: PPUSH
14435: LD_VAR 0 1
14439: PPUSH
14440: LD_VAR 0 2
14444: PUSH
14445: LD_VAR 0 4
14449: ARRAY
14450: PPUSH
14451: EMPTY
14452: PPUSH
14453: CALL 4259 0 4
14457: ST_TO_ADDR
14458: GO 14405
14460: POP
14461: POP
// result := true ;
14462: LD_ADDR_VAR 0 3
14466: PUSH
14467: LD_INT 1
14469: ST_TO_ADDR
// end ;
14470: LD_VAR 0 3
14474: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
14475: LD_INT 0
14477: PPUSH
14478: PPUSH
// for i = MREG_ToRes downto 1 do
14479: LD_ADDR_VAR 0 3
14483: PUSH
14484: DOUBLE
14485: LD_EXP 19
14489: INC
14490: ST_TO_ADDR
14491: LD_INT 1
14493: PUSH
14494: FOR_DOWNTO
14495: IFFALSE 14541
// if MREG_ToRes [ i ] [ 1 ] = side then
14497: LD_EXP 19
14501: PUSH
14502: LD_VAR 0 3
14506: ARRAY
14507: PUSH
14508: LD_INT 1
14510: ARRAY
14511: PUSH
14512: LD_VAR 0 1
14516: EQUAL
14517: IFFALSE 14539
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
14519: LD_ADDR_EXP 19
14523: PUSH
14524: LD_EXP 19
14528: PPUSH
14529: LD_VAR 0 3
14533: PPUSH
14534: CALL_OW 3
14538: ST_TO_ADDR
14539: GO 14494
14541: POP
14542: POP
// result := true ;
14543: LD_ADDR_VAR 0 2
14547: PUSH
14548: LD_INT 1
14550: ST_TO_ADDR
// end ;
14551: LD_VAR 0 2
14555: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
14556: LD_INT 0
14558: PPUSH
// result := GetTechProgress ( side , tech ) ;
14559: LD_ADDR_VAR 0 3
14563: PUSH
14564: LD_VAR 0 1
14568: PPUSH
14569: LD_VAR 0 2
14573: PPUSH
14574: CALL_OW 326
14578: ST_TO_ADDR
// end ;
14579: LD_VAR 0 3
14583: RET
// export function MCL_Require ( tech ) ; begin
14584: LD_INT 0
14586: PPUSH
// result := GetTechTechsReq ( tech ) ;
14587: LD_ADDR_VAR 0 2
14591: PUSH
14592: LD_VAR 0 1
14596: PPUSH
14597: CALL_OW 480
14601: ST_TO_ADDR
// end ; end_of_file
14602: LD_VAR 0 2
14606: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
14607: LD_INT 0
14609: PPUSH
14610: PPUSH
14611: PPUSH
// pom := GetBase ( fac ) ;
14612: LD_ADDR_VAR 0 5
14616: PUSH
14617: LD_VAR 0 1
14621: PPUSH
14622: CALL_OW 274
14626: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
14627: LD_ADDR_VAR 0 4
14631: PUSH
14632: LD_VAR 0 2
14636: PUSH
14637: LD_INT 1
14639: ARRAY
14640: PPUSH
14641: LD_VAR 0 2
14645: PUSH
14646: LD_INT 2
14648: ARRAY
14649: PPUSH
14650: LD_VAR 0 2
14654: PUSH
14655: LD_INT 3
14657: ARRAY
14658: PPUSH
14659: LD_VAR 0 2
14663: PUSH
14664: LD_INT 4
14666: ARRAY
14667: PPUSH
14668: CALL_OW 449
14672: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
14673: LD_VAR 0 5
14677: PPUSH
14678: LD_INT 1
14680: PPUSH
14681: CALL_OW 275
14685: PUSH
14686: LD_VAR 0 4
14690: PUSH
14691: LD_INT 1
14693: ARRAY
14694: GREATEREQUAL
14695: PUSH
14696: LD_VAR 0 5
14700: PPUSH
14701: LD_INT 2
14703: PPUSH
14704: CALL_OW 275
14708: PUSH
14709: LD_VAR 0 4
14713: PUSH
14714: LD_INT 2
14716: ARRAY
14717: GREATEREQUAL
14718: AND
14719: PUSH
14720: LD_VAR 0 5
14724: PPUSH
14725: LD_INT 3
14727: PPUSH
14728: CALL_OW 275
14732: PUSH
14733: LD_VAR 0 4
14737: PUSH
14738: LD_INT 3
14740: ARRAY
14741: GREATEREQUAL
14742: AND
14743: IFFALSE 14755
// result := true else
14745: LD_ADDR_VAR 0 3
14749: PUSH
14750: LD_INT 1
14752: ST_TO_ADDR
14753: GO 14763
// result := false ;
14755: LD_ADDR_VAR 0 3
14759: PUSH
14760: LD_INT 0
14762: ST_TO_ADDR
// end ;
14763: LD_VAR 0 3
14767: RET
// export function MCV_Produce ( side , fac , list ) ; var i ; begin
14768: LD_INT 0
14770: PPUSH
14771: PPUSH
// if fac then
14772: LD_VAR 0 2
14776: IFFALSE 14970
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
14778: LD_VAR 0 2
14782: PPUSH
14783: LD_VAR 0 3
14787: PPUSH
14788: CALL 14607 0 2
14792: PUSH
14793: LD_VAR 0 2
14797: PPUSH
14798: CALL_OW 461
14802: PUSH
14803: LD_INT 2
14805: EQUAL
14806: AND
14807: PUSH
14808: LD_VAR 0 2
14812: PPUSH
14813: LD_VAR 0 3
14817: PUSH
14818: LD_INT 1
14820: ARRAY
14821: PPUSH
14822: LD_VAR 0 3
14826: PUSH
14827: LD_INT 2
14829: ARRAY
14830: PPUSH
14831: LD_VAR 0 3
14835: PUSH
14836: LD_INT 3
14838: ARRAY
14839: PPUSH
14840: LD_VAR 0 3
14844: PUSH
14845: LD_INT 4
14847: ARRAY
14848: PPUSH
14849: CALL_OW 448
14853: AND
14854: IFFALSE 14960
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
14856: LD_VAR 0 2
14860: PPUSH
14861: LD_VAR 0 3
14865: PUSH
14866: LD_INT 1
14868: ARRAY
14869: PPUSH
14870: LD_VAR 0 3
14874: PUSH
14875: LD_INT 2
14877: ARRAY
14878: PPUSH
14879: LD_VAR 0 3
14883: PUSH
14884: LD_INT 3
14886: ARRAY
14887: PPUSH
14888: LD_VAR 0 3
14892: PUSH
14893: LD_INT 4
14895: ARRAY
14896: PPUSH
14897: CALL_OW 125
// for i = 1 to 4 do
14901: LD_ADDR_VAR 0 5
14905: PUSH
14906: DOUBLE
14907: LD_INT 1
14909: DEC
14910: ST_TO_ADDR
14911: LD_INT 4
14913: PUSH
14914: FOR_TO
14915: IFFALSE 14948
// MREG_ToConstruct := Remove ( MREG_ToConstruct , list [ i ] , true ) ;
14917: LD_ADDR_EXP 20
14921: PUSH
14922: LD_EXP 20
14926: PPUSH
14927: LD_VAR 0 3
14931: PUSH
14932: LD_VAR 0 5
14936: ARRAY
14937: PPUSH
14938: LD_INT 1
14940: PPUSH
14941: CALL 24714 0 3
14945: ST_TO_ADDR
14946: GO 14914
14948: POP
14949: POP
// result := true ;
14950: LD_ADDR_VAR 0 4
14954: PUSH
14955: LD_INT 1
14957: ST_TO_ADDR
// end else
14958: GO 14968
// result := false ;
14960: LD_ADDR_VAR 0 4
14964: PUSH
14965: LD_INT 0
14967: ST_TO_ADDR
// end else
14968: GO 14978
// result := false ;
14970: LD_ADDR_VAR 0 4
14974: PUSH
14975: LD_INT 0
14977: ST_TO_ADDR
// end ;
14978: LD_VAR 0 4
14982: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
14983: LD_INT 0
14985: PPUSH
14986: PPUSH
// if MREG_Parking [ side ] then
14987: LD_EXP 27
14991: PUSH
14992: LD_VAR 0 1
14996: ARRAY
14997: IFFALSE 15150
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
14999: LD_VAR 0 2
15003: PPUSH
15004: LD_EXP 27
15008: PUSH
15009: LD_VAR 0 1
15013: ARRAY
15014: PPUSH
15015: CALL_OW 308
15019: NOT
15020: IFFALSE 15150
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
15022: LD_VAR 0 2
15026: PPUSH
15027: LD_EXP 27
15031: PUSH
15032: LD_VAR 0 1
15036: ARRAY
15037: PPUSH
15038: CALL_OW 113
// if GetControl ( veh ) = control_manual then
15042: LD_VAR 0 2
15046: PPUSH
15047: CALL_OW 263
15051: PUSH
15052: LD_INT 1
15054: EQUAL
15055: IFFALSE 15150
// begin i := GetDriver ( veh ) ;
15057: LD_ADDR_VAR 0 4
15061: PUSH
15062: LD_VAR 0 2
15066: PPUSH
15067: CALL 25249 0 1
15071: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
15072: LD_INT 35
15074: PPUSH
15075: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) ;
15079: LD_VAR 0 2
15083: PPUSH
15084: LD_EXP 27
15088: PUSH
15089: LD_VAR 0 1
15093: ARRAY
15094: PPUSH
15095: CALL_OW 308
15099: IFFALSE 15072
// ComExitVehicle ( i ) ;
15101: LD_VAR 0 4
15105: PPUSH
15106: CALL_OW 121
// Wait ( 1 ) ;
15110: LD_INT 1
15112: PPUSH
15113: CALL_OW 67
// ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
15117: LD_VAR 0 4
15121: PPUSH
15122: LD_VAR 0 1
15126: PPUSH
15127: LD_INT 30
15129: PUSH
15130: LD_INT 3
15132: PUSH
15133: EMPTY
15134: LIST
15135: LIST
15136: PPUSH
15137: CALL 0 0 2
15141: PUSH
15142: LD_INT 1
15144: ARRAY
15145: PPUSH
15146: CALL_OW 120
// end ; end ; end ;
15150: LD_VAR 0 3
15154: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
15155: LD_INT 0
15157: PPUSH
15158: PPUSH
15159: PPUSH
15160: PPUSH
15161: PPUSH
15162: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
15163: LD_VAR 0 1
15167: PPUSH
15168: LD_INT 30
15170: PUSH
15171: LD_INT 3
15173: PUSH
15174: EMPTY
15175: LIST
15176: LIST
15177: PPUSH
15178: CALL 0 0 2
15182: IFFALSE 15421
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
15184: LD_VAR 0 1
15188: PPUSH
15189: LD_INT 30
15191: PUSH
15192: LD_INT 3
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: PPUSH
15199: CALL 0 0 2
15203: PUSH
15204: LD_INT 1
15206: ARRAY
15207: PPUSH
15208: CALL_OW 461
15212: PUSH
15213: LD_INT 2
15215: EQUAL
15216: IFFALSE 15421
// begin if MREG_ForSide ( side , MREG_TurretWeapon ) then
15218: LD_VAR 0 1
15222: PPUSH
15223: LD_EXP 12
15227: PPUSH
15228: CALL 5353 0 2
15232: IFFALSE 15421
// for i = 1 to MREG_TurretWeapon do
15234: LD_ADDR_VAR 0 3
15238: PUSH
15239: DOUBLE
15240: LD_INT 1
15242: DEC
15243: ST_TO_ADDR
15244: LD_EXP 12
15248: PUSH
15249: FOR_TO
15250: IFFALSE 15419
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
15252: LD_EXP 12
15256: PUSH
15257: LD_VAR 0 3
15261: ARRAY
15262: PUSH
15263: LD_INT 1
15265: ARRAY
15266: PUSH
15267: LD_VAR 0 1
15271: EQUAL
15272: IFFALSE 15417
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
15274: LD_ADDR_VAR 0 5
15278: PUSH
15279: LD_EXP 12
15283: PUSH
15284: LD_VAR 0 3
15288: ARRAY
15289: PUSH
15290: LD_INT 2
15292: ARRAY
15293: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
15294: LD_ADDR_VAR 0 6
15298: PUSH
15299: LD_EXP 12
15303: PUSH
15304: LD_VAR 0 3
15308: ARRAY
15309: PUSH
15310: LD_INT 3
15312: ARRAY
15313: PUSH
15314: LD_INT 1
15316: ARRAY
15317: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
15318: LD_ADDR_VAR 0 7
15322: PUSH
15323: LD_EXP 12
15327: PUSH
15328: LD_VAR 0 3
15332: ARRAY
15333: PUSH
15334: LD_INT 3
15336: ARRAY
15337: PUSH
15338: LD_INT 2
15340: ARRAY
15341: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
15342: LD_ADDR_VAR 0 4
15346: PUSH
15347: LD_VAR 0 6
15351: PPUSH
15352: LD_VAR 0 7
15356: PPUSH
15357: CALL_OW 428
15361: ST_TO_ADDR
// AddComPlaceWeapon ( turret , weapon ) ;
15362: LD_VAR 0 4
15366: PPUSH
15367: LD_VAR 0 5
15371: PPUSH
15372: CALL_OW 208
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , side , weapon , [ x , y ] ) ;
15376: LD_ADDR_EXP 12
15380: PUSH
15381: LD_EXP 12
15385: PPUSH
15386: LD_VAR 0 1
15390: PPUSH
15391: LD_VAR 0 5
15395: PPUSH
15396: LD_VAR 0 6
15400: PUSH
15401: LD_VAR 0 7
15405: PUSH
15406: EMPTY
15407: LIST
15408: LIST
15409: PPUSH
15410: CALL 4350 0 4
15414: ST_TO_ADDR
// break ;
15415: GO 15419
// end ;
15417: GO 15249
15419: POP
15420: POP
// end ; end ;
15421: LD_VAR 0 2
15425: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
15426: LD_INT 0
15428: PPUSH
15429: PPUSH
15430: PPUSH
15431: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
15432: LD_ADDR_VAR 0 4
15436: PUSH
15437: LD_VAR 0 1
15441: PPUSH
15442: LD_INT 32
15444: PUSH
15445: LD_INT 1
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: PPUSH
15452: CALL 0 0 2
15456: ST_TO_ADDR
// if not tmp then
15457: LD_VAR 0 4
15461: NOT
15462: IFFALSE 15468
// exit else
15464: GO 15550
15466: GO 15550
// begin for i = 1 to tmp do
15468: LD_ADDR_VAR 0 3
15472: PUSH
15473: DOUBLE
15474: LD_INT 1
15476: DEC
15477: ST_TO_ADDR
15478: LD_VAR 0 4
15482: PUSH
15483: FOR_TO
15484: IFFALSE 15548
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
15486: LD_VAR 0 4
15490: PUSH
15491: LD_VAR 0 3
15495: ARRAY
15496: PPUSH
15497: CALL_OW 261
15501: PUSH
15502: LD_INT 20
15504: LESS
15505: PUSH
15506: LD_VAR 0 4
15510: PUSH
15511: LD_VAR 0 3
15515: ARRAY
15516: PPUSH
15517: CALL_OW 110
15521: PUSH
15522: LD_INT 0
15524: EQUAL
15525: AND
15526: IFFALSE 15546
// begin SetTag ( tmp [ i ] , 21 ) ;
15528: LD_VAR 0 4
15532: PUSH
15533: LD_VAR 0 3
15537: ARRAY
15538: PPUSH
15539: LD_INT 21
15541: PPUSH
15542: CALL_OW 109
// end ;
15546: GO 15483
15548: POP
15549: POP
// end ; end ;
15550: LD_VAR 0 2
15554: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
15555: LD_INT 0
15557: PPUSH
15558: PPUSH
15559: PPUSH
15560: PPUSH
15561: PPUSH
// if not unit then
15562: LD_VAR 0 1
15566: NOT
15567: IFFALSE 15571
// exit ;
15569: GO 15776
// side := GetSide ( unit ) ;
15571: LD_ADDR_VAR 0 3
15575: PUSH
15576: LD_VAR 0 1
15580: PPUSH
15581: CALL_OW 255
15585: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
15586: LD_ADDR_VAR 0 5
15590: PUSH
15591: LD_VAR 0 3
15595: PPUSH
15596: LD_INT 2
15598: PUSH
15599: LD_INT 30
15601: PUSH
15602: LD_INT 1
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PUSH
15609: LD_INT 30
15611: PUSH
15612: LD_INT 3
15614: PUSH
15615: EMPTY
15616: LIST
15617: LIST
15618: PUSH
15619: LD_INT 30
15621: PUSH
15622: LD_INT 29
15624: PUSH
15625: EMPTY
15626: LIST
15627: LIST
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: LIST
15633: LIST
15634: PPUSH
15635: CALL 0 0 2
15639: ST_TO_ADDR
// if not b then
15640: LD_VAR 0 5
15644: NOT
15645: IFFALSE 15651
// exit else
15647: GO 15776
15649: GO 15776
// if GetTag ( unit ) = 21 then
15651: LD_VAR 0 1
15655: PPUSH
15656: CALL_OW 110
15660: PUSH
15661: LD_INT 21
15663: EQUAL
15664: IFFALSE 15776
// begin c := NearestUnitToUnit ( b , unit ) ;
15666: LD_ADDR_VAR 0 6
15670: PUSH
15671: LD_VAR 0 5
15675: PPUSH
15676: LD_VAR 0 1
15680: PPUSH
15681: CALL_OW 74
15685: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
15686: LD_VAR 0 1
15690: PPUSH
15691: LD_VAR 0 6
15695: PPUSH
15696: CALL_OW 250
15700: PPUSH
15701: LD_VAR 0 6
15705: PPUSH
15706: CALL_OW 251
15710: PPUSH
15711: CALL_OW 297
15715: PUSH
15716: LD_INT 6
15718: GREATER
15719: IFFALSE 15752
// ComMoveXY ( unit , GetX ( c ) , GetY ( c ) ) else
15721: LD_VAR 0 1
15725: PPUSH
15726: LD_VAR 0 6
15730: PPUSH
15731: CALL_OW 250
15735: PPUSH
15736: LD_VAR 0 6
15740: PPUSH
15741: CALL_OW 251
15745: PPUSH
15746: CALL_OW 111
15750: GO 15776
// begin SetFuel ( unit , 100 ) ;
15752: LD_VAR 0 1
15756: PPUSH
15757: LD_INT 100
15759: PPUSH
15760: CALL_OW 240
// SetTag ( unit , 0 ) ;
15764: LD_VAR 0 1
15768: PPUSH
15769: LD_INT 0
15771: PPUSH
15772: CALL_OW 109
// end ; end ; end ;
15776: LD_VAR 0 2
15780: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
15781: LD_INT 0
15783: PPUSH
15784: PPUSH
15785: PPUSH
15786: PPUSH
15787: PPUSH
15788: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
15789: LD_ADDR_VAR 0 7
15793: PUSH
15794: LD_VAR 0 1
15798: PPUSH
15799: LD_INT 33
15801: PUSH
15802: LD_INT 2
15804: PUSH
15805: EMPTY
15806: LIST
15807: LIST
15808: PUSH
15809: LD_INT 3
15811: PUSH
15812: LD_INT 61
15814: PUSH
15815: EMPTY
15816: LIST
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PUSH
15822: EMPTY
15823: LIST
15824: LIST
15825: PPUSH
15826: CALL 0 0 2
15830: ST_TO_ADDR
// if not vehs then
15831: LD_VAR 0 7
15835: NOT
15836: IFFALSE 15840
// exit ;
15838: GO 16125
// if nation = 1 then
15840: LD_VAR 0 2
15844: PUSH
15845: LD_INT 1
15847: EQUAL
15848: IFFALSE 16018
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
15850: LD_VAR 0 1
15854: PPUSH
15855: LD_INT 30
15857: PUSH
15858: LD_INT 36
15860: PUSH
15861: EMPTY
15862: LIST
15863: LIST
15864: PPUSH
15865: CALL 0 0 2
15869: NOT
15870: IFFALSE 15876
// exit else
15872: GO 16125
15874: GO 16016
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
15876: LD_ADDR_VAR 0 5
15880: PUSH
15881: LD_VAR 0 1
15885: PPUSH
15886: LD_INT 30
15888: PUSH
15889: LD_INT 36
15891: PUSH
15892: EMPTY
15893: LIST
15894: LIST
15895: PPUSH
15896: CALL 0 0 2
15900: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
15901: LD_ADDR_VAR 0 6
15905: PUSH
15906: LD_VAR 0 5
15910: PUSH
15911: LD_INT 1
15913: ARRAY
15914: PPUSH
15915: CALL_OW 313
15919: ST_TO_ADDR
// for i = vehs downto 1 do
15920: LD_ADDR_VAR 0 4
15924: PUSH
15925: DOUBLE
15926: LD_VAR 0 7
15930: INC
15931: ST_TO_ADDR
15932: LD_INT 1
15934: PUSH
15935: FOR_DOWNTO
15936: IFFALSE 16014
// begin if not IsControledBy ( vehs [ i ] ) then
15938: LD_VAR 0 7
15942: PUSH
15943: LD_VAR 0 4
15947: ARRAY
15948: PPUSH
15949: CALL_OW 312
15953: NOT
15954: IFFALSE 16012
// begin tmp := MCV_RemoteDriver ( oper ) ;
15956: LD_ADDR_VAR 0 8
15960: PUSH
15961: LD_VAR 0 6
15965: PPUSH
15966: CALL 16130 0 1
15970: ST_TO_ADDR
// if not tmp then
15971: LD_VAR 0 8
15975: NOT
15976: IFFALSE 15984
// exit else
15978: POP
15979: POP
15980: GO 16125
15982: GO 16012
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
15984: LD_VAR 0 7
15988: PUSH
15989: LD_VAR 0 4
15993: ARRAY
15994: PPUSH
15995: LD_VAR 0 8
15999: PUSH
16000: LD_INT 1
16002: ARRAY
16003: PUSH
16004: LD_INT 1
16006: ARRAY
16007: PPUSH
16008: CALL_OW 135
// end ; end ;
16012: GO 15935
16014: POP
16015: POP
// end ; end else
16016: GO 16125
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
16018: LD_VAR 0 1
16022: PPUSH
16023: LD_INT 34
16025: PUSH
16026: LD_INT 31
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: PPUSH
16033: CALL 0 0 2
16037: NOT
16038: IFFALSE 16044
// exit else
16040: GO 16125
16042: GO 16125
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
16044: LD_ADDR_VAR 0 5
16048: PUSH
16049: LD_VAR 0 1
16053: PPUSH
16054: LD_INT 34
16056: PUSH
16057: LD_INT 31
16059: PUSH
16060: EMPTY
16061: LIST
16062: LIST
16063: PPUSH
16064: CALL 0 0 2
16068: ST_TO_ADDR
// oper := [ ] ;
16069: LD_ADDR_VAR 0 6
16073: PUSH
16074: EMPTY
16075: ST_TO_ADDR
// for i = 1 to ct do
16076: LD_ADDR_VAR 0 4
16080: PUSH
16081: DOUBLE
16082: LD_INT 1
16084: DEC
16085: ST_TO_ADDR
16086: LD_VAR 0 5
16090: PUSH
16091: FOR_TO
16092: IFFALSE 16123
// oper := oper ^ GetDriver ( ct [ i ] ) ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_VAR 0 6
16103: PUSH
16104: LD_VAR 0 5
16108: PUSH
16109: LD_VAR 0 4
16113: ARRAY
16114: PPUSH
16115: CALL 25249 0 1
16119: ADD
16120: ST_TO_ADDR
16121: GO 16091
16123: POP
16124: POP
// end ; end ; end ;
16125: LD_VAR 0 3
16129: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
16130: LD_INT 0
16132: PPUSH
16133: PPUSH
16134: PPUSH
16135: PPUSH
16136: PPUSH
16137: PPUSH
// if not drivers then
16138: LD_VAR 0 1
16142: NOT
16143: IFFALSE 16149
// exit else
16145: GO 16429
16147: GO 16429
// begin linked := [ ] ;
16149: LD_ADDR_VAR 0 5
16153: PUSH
16154: EMPTY
16155: ST_TO_ADDR
// for i = 1 to drivers do
16156: LD_ADDR_VAR 0 3
16160: PUSH
16161: DOUBLE
16162: LD_INT 1
16164: DEC
16165: ST_TO_ADDR
16166: LD_VAR 0 1
16170: PUSH
16171: FOR_TO
16172: IFFALSE 16417
// begin if CanControl ( drivers [ i ] ) then
16174: LD_VAR 0 1
16178: PUSH
16179: LD_VAR 0 3
16183: ARRAY
16184: PPUSH
16185: CALL 25821 0 1
16189: IFFALSE 16415
// if i > 1 then
16191: LD_VAR 0 3
16195: PUSH
16196: LD_INT 1
16198: GREATER
16199: IFFALSE 16376
// begin m := false ;
16201: LD_ADDR_VAR 0 6
16205: PUSH
16206: LD_INT 0
16208: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
16209: LD_ADDR_VAR 0 7
16213: PUSH
16214: LD_VAR 0 1
16218: PUSH
16219: LD_VAR 0 3
16223: ARRAY
16224: PPUSH
16225: CALL_OW 432
16229: ST_TO_ADDR
// for j = 1 to linked do
16230: LD_ADDR_VAR 0 4
16234: PUSH
16235: DOUBLE
16236: LD_INT 1
16238: DEC
16239: ST_TO_ADDR
16240: LD_VAR 0 5
16244: PUSH
16245: FOR_TO
16246: IFFALSE 16320
// begin if l < linked [ j ] [ 2 ] then
16248: LD_VAR 0 7
16252: PUSH
16253: LD_VAR 0 5
16257: PUSH
16258: LD_VAR 0 4
16262: ARRAY
16263: PUSH
16264: LD_INT 2
16266: ARRAY
16267: LESS
16268: IFFALSE 16318
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
16270: LD_ADDR_VAR 0 5
16274: PUSH
16275: LD_VAR 0 5
16279: PPUSH
16280: LD_INT 1
16282: PPUSH
16283: LD_VAR 0 1
16287: PUSH
16288: LD_VAR 0 3
16292: ARRAY
16293: PUSH
16294: LD_VAR 0 7
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PPUSH
16303: CALL_OW 2
16307: ST_TO_ADDR
// m := true ;
16308: LD_ADDR_VAR 0 6
16312: PUSH
16313: LD_INT 1
16315: ST_TO_ADDR
// break ;
16316: GO 16320
// end ; end ;
16318: GO 16245
16320: POP
16321: POP
// if not m then
16322: LD_VAR 0 6
16326: NOT
16327: IFFALSE 16374
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
16329: LD_ADDR_VAR 0 5
16333: PUSH
16334: LD_VAR 0 5
16338: PUSH
16339: LD_VAR 0 1
16343: PUSH
16344: LD_VAR 0 3
16348: ARRAY
16349: PUSH
16350: LD_VAR 0 1
16354: PUSH
16355: LD_VAR 0 3
16359: ARRAY
16360: PPUSH
16361: CALL_OW 432
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: PUSH
16370: EMPTY
16371: LIST
16372: ADD
16373: ST_TO_ADDR
// end else
16374: GO 16415
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
16376: LD_ADDR_VAR 0 5
16380: PUSH
16381: LD_VAR 0 1
16385: PUSH
16386: LD_VAR 0 3
16390: ARRAY
16391: PUSH
16392: LD_VAR 0 1
16396: PUSH
16397: LD_VAR 0 3
16401: ARRAY
16402: PPUSH
16403: CALL_OW 432
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: EMPTY
16413: LIST
16414: ST_TO_ADDR
// end ;
16415: GO 16171
16417: POP
16418: POP
// result := linked ;
16419: LD_ADDR_VAR 0 2
16423: PUSH
16424: LD_VAR 0 5
16428: ST_TO_ADDR
// end ; end ;
16429: LD_VAR 0 2
16433: RET
// export function MCV_ToRepair ( unit ) ; begin
16434: LD_INT 0
16436: PPUSH
// if not unit then
16437: LD_VAR 0 1
16441: NOT
16442: IFFALSE 16448
// exit else
16444: GO 16479
16446: GO 16479
// begin SetTag ( unit , 6 ) ;
16448: LD_VAR 0 1
16452: PPUSH
16453: LD_INT 6
16455: PPUSH
16456: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
16460: LD_VAR 0 1
16464: PPUSH
16465: CALL_OW 255
16469: PPUSH
16470: LD_VAR 0 1
16474: PPUSH
16475: CALL 14983 0 2
// end ; end ;
16479: LD_VAR 0 2
16483: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
16484: LD_INT 0
16486: PPUSH
16487: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
16488: LD_VAR 0 1
16492: PPUSH
16493: LD_INT 6
16495: PPUSH
16496: EMPTY
16497: PPUSH
16498: CALL 703 0 3
16502: IFFALSE 16595
// begin for i = MCF_Tag ( side , 6 , [ ] ) to 1 do
16504: LD_ADDR_VAR 0 3
16508: PUSH
16509: DOUBLE
16510: LD_VAR 0 1
16514: PPUSH
16515: LD_INT 6
16517: PPUSH
16518: EMPTY
16519: PPUSH
16520: CALL 703 0 3
16524: DEC
16525: ST_TO_ADDR
16526: LD_INT 1
16528: PUSH
16529: FOR_TO
16530: IFFALSE 16593
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
16532: LD_VAR 0 1
16536: PPUSH
16537: LD_INT 6
16539: PPUSH
16540: EMPTY
16541: PPUSH
16542: CALL 703 0 3
16546: PUSH
16547: LD_VAR 0 3
16551: ARRAY
16552: PPUSH
16553: CALL_OW 256
16557: PUSH
16558: LD_INT 1000
16560: EQUAL
16561: IFFALSE 16591
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
16563: LD_VAR 0 1
16567: PPUSH
16568: LD_INT 6
16570: PPUSH
16571: EMPTY
16572: PPUSH
16573: CALL 703 0 3
16577: PUSH
16578: LD_VAR 0 3
16582: ARRAY
16583: PPUSH
16584: LD_INT 0
16586: PPUSH
16587: CALL_OW 109
16591: GO 16529
16593: POP
16594: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
16595: LD_ADDR_VAR 0 3
16599: PUSH
16600: LD_VAR 0 1
16604: PPUSH
16605: EMPTY
16606: PPUSH
16607: CALL 301 0 2
16611: PUSH
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_INT 7
16619: PPUSH
16620: EMPTY
16621: PPUSH
16622: CALL 703 0 3
16626: DIFF
16627: PUSH
16628: FOR_IN
16629: IFFALSE 16673
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
16631: LD_VAR 0 3
16635: PPUSH
16636: CALL_OW 256
16640: PUSH
16641: LD_INT 650
16643: LESS
16644: PUSH
16645: LD_VAR 0 3
16649: PPUSH
16650: CALL_OW 110
16654: PUSH
16655: LD_INT 6
16657: EQUAL
16658: NOT
16659: AND
16660: IFFALSE 16671
// MCV_ToRepair ( i ) ;
16662: LD_VAR 0 3
16666: PPUSH
16667: CALL 16434 0 1
16671: GO 16628
16673: POP
16674: POP
// end ; end_of_file
16675: LD_VAR 0 2
16679: RET
// export mc_game_live ; starting begin ResetFog ( ) ;
16680: CALL_OW 335
// RandomizeAll ;
16684: CALL_OW 11
// FakePep ( ) ;
16688: CALL 3507 0 0
// mc_game_live := 1 ;
16692: LD_ADDR_EXP 32
16696: PUSH
16697: LD_INT 1
16699: ST_TO_ADDR
// MC_Registry ( ) ;
16700: CALL 4043 0 0
// MC_RegistryInit ( ) ;
16704: CALL 4431 0 0
// MCT_MarkPlace ( 10 , 7 , aqua ) ;
16708: LD_INT 10
16710: PPUSH
16711: LD_INT 7
16713: PPUSH
16714: LD_STRING aqua
16716: PPUSH
16717: CALL 5645 0 3
// MCN_AddApes ( Area43 , 5 , 10 ) ;
16721: LD_INT 5
16723: PPUSH
16724: LD_INT 5
16726: PPUSH
16727: LD_INT 10
16729: PPUSH
16730: CALL 26185 0 3
// MCS_SetResourcesBonus ( 20 , 16000 , 30 ) ;
16734: LD_INT 20
16736: PPUSH
16737: LD_INT 16000
16739: PPUSH
16740: LD_INT 30
16742: PPUSH
16743: CALL 9895 0 3
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , 20 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_weap3 , tech_comp1 , tech_ai , tech_advai , tech_opto1 , tech_opto2 , tech_radar , tech_remcont , tech_rocket ] ) ;
16747: LD_INT 1
16749: PPUSH
16750: LD_INT 48
16752: PUSH
16753: LD_INT 49
16755: PUSH
16756: LD_INT 20
16758: PUSH
16759: LD_INT 46
16761: PUSH
16762: LD_INT 47
16764: PUSH
16765: LD_INT 35
16767: PUSH
16768: LD_INT 45
16770: PUSH
16771: LD_INT 1
16773: PUSH
16774: LD_INT 50
16776: PUSH
16777: LD_INT 2
16779: PUSH
16780: LD_INT 51
16782: PUSH
16783: LD_INT 52
16785: PUSH
16786: LD_INT 69
16788: PUSH
16789: LD_INT 39
16791: PUSH
16792: LD_INT 53
16794: PUSH
16795: LD_INT 57
16797: PUSH
16798: LD_INT 32
16800: PUSH
16801: LD_INT 27
16803: PUSH
16804: LD_INT 60
16806: PUSH
16807: LD_INT 61
16809: PUSH
16810: LD_INT 6
16812: PUSH
16813: LD_INT 15
16815: PUSH
16816: LD_INT 40
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: LIST
16834: LIST
16835: LIST
16836: LIST
16837: LIST
16838: LIST
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: PPUSH
16844: CALL 14386 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
16848: LD_INT 1
16850: PPUSH
16851: LD_INT 3
16853: PPUSH
16854: CALL 9765 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
16858: LD_INT 1
16860: PPUSH
16861: LD_INT 0
16863: PUSH
16864: LD_INT 1
16866: PUSH
16867: LD_INT 0
16869: PUSH
16870: LD_INT 0
16872: PUSH
16873: EMPTY
16874: LIST
16875: LIST
16876: LIST
16877: LIST
16878: PPUSH
16879: CALL 9798 0 2
// MCS_CreateDeposits ( 1 , [ 9 , 13 , 2 , 29 , 10 , 3 ] ) ;
16883: LD_INT 1
16885: PPUSH
16886: LD_INT 9
16888: PUSH
16889: LD_INT 13
16891: PUSH
16892: LD_INT 2
16894: PUSH
16895: LD_INT 29
16897: PUSH
16898: LD_INT 10
16900: PUSH
16901: LD_INT 3
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: PPUSH
16912: CALL 9972 0 2
// MCS_Collector ( 1 , 1 , [ Area44 ] ) ;
16916: LD_INT 1
16918: PPUSH
16919: LD_INT 1
16921: PPUSH
16922: LD_INT 6
16924: PUSH
16925: EMPTY
16926: LIST
16927: PPUSH
16928: CALL 9831 0 3
// MCS_SetParking ( 1 , area42 ) ;
16932: LD_INT 1
16934: PPUSH
16935: LD_INT 4
16937: PPUSH
16938: CALL 9731 0 2
// MCS_Depot ( 1 , [ 33 , 27 , 1 ] ) ;
16942: LD_INT 1
16944: PPUSH
16945: LD_INT 33
16947: PUSH
16948: LD_INT 27
16950: PUSH
16951: LD_INT 1
16953: PUSH
16954: EMPTY
16955: LIST
16956: LIST
16957: LIST
16958: PPUSH
16959: CALL 8910 0 2
// MCS_Mine ( 1 ) ;
16963: LD_INT 1
16965: PPUSH
16966: CALL 9282 0 1
// MCS_Lab ( 1 , [ 20 , 20 , 3 ] , [ b_lab_weapon , b_lab_opto ] ) ;
16970: LD_INT 1
16972: PPUSH
16973: LD_INT 20
16975: PUSH
16976: LD_INT 20
16978: PUSH
16979: LD_INT 3
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: PPUSH
16987: LD_INT 10
16989: PUSH
16990: LD_INT 15
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: PPUSH
16997: CALL 8946 0 3
// MCS_Lab ( 1 , [ 40 , 17 , 1 ] , [ b_lab_computer , b_lab_siberium ] ) ;
17001: LD_INT 1
17003: PPUSH
17004: LD_INT 40
17006: PUSH
17007: LD_INT 17
17009: PUSH
17010: LD_INT 1
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: LIST
17017: PPUSH
17018: LD_INT 12
17020: PUSH
17021: LD_INT 11
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: PPUSH
17028: CALL 8946 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 10 , 7 , 2 , 37 , 41 , 3 ] , [ us_machine_gun , us_machine_gun ] ) ;
17032: LD_INT 1
17034: PPUSH
17035: LD_INT 32
17037: PPUSH
17038: LD_INT 10
17040: PUSH
17041: LD_INT 7
17043: PUSH
17044: LD_INT 2
17046: PUSH
17047: LD_INT 37
17049: PUSH
17050: LD_INT 41
17052: PUSH
17053: LD_INT 3
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: LIST
17060: LIST
17061: LIST
17062: LIST
17063: PPUSH
17064: LD_INT 2
17066: PUSH
17067: LD_INT 2
17069: PUSH
17070: EMPTY
17071: LIST
17072: LIST
17073: PPUSH
17074: CALL 8406 0 4
// MCS_ChangeFortification ( 1 , [ 10 , 7 ] , [ us_gatling_gun ] ) ;
17078: LD_INT 1
17080: PPUSH
17081: LD_INT 10
17083: PUSH
17084: LD_INT 7
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PPUSH
17091: LD_INT 4
17093: PUSH
17094: EMPTY
17095: LIST
17096: PPUSH
17097: CALL 8601 0 3
// MCS_PowerPlants ( 1 , [ 29 , 13 , 0 , 17 , 10 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
17101: LD_INT 1
17103: PPUSH
17104: LD_INT 29
17106: PUSH
17107: LD_INT 13
17109: PUSH
17110: LD_INT 0
17112: PUSH
17113: LD_INT 17
17115: PUSH
17116: LD_INT 10
17118: PUSH
17119: LD_INT 2
17121: PUSH
17122: EMPTY
17123: LIST
17124: LIST
17125: LIST
17126: LIST
17127: LIST
17128: LIST
17129: PPUSH
17130: LD_INT 27
17132: PUSH
17133: LD_INT 26
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: PPUSH
17140: CALL 9122 0 3
// MCS_Barracks ( 1 , [ 46 , 27 , 5 ] ) ;
17144: LD_INT 1
17146: PPUSH
17147: LD_INT 46
17149: PUSH
17150: LD_INT 27
17152: PUSH
17153: LD_INT 5
17155: PUSH
17156: EMPTY
17157: LIST
17158: LIST
17159: LIST
17160: PPUSH
17161: CALL 9485 0 2
// MCS_Factory ( 1 , [ 48 , 40 , 0 ] , [ b_ext_gun , b_ext_noncombat , b_ext_computer , b_ext_radar , b_ext_track , b_ext_gun ] ) ;
17165: LD_INT 1
17167: PPUSH
17168: LD_INT 48
17170: PUSH
17171: LD_INT 40
17173: PUSH
17174: LD_INT 0
17176: PUSH
17177: EMPTY
17178: LIST
17179: LIST
17180: LIST
17181: PPUSH
17182: LD_INT 17
17184: PUSH
17185: LD_INT 19
17187: PUSH
17188: LD_INT 24
17190: PUSH
17191: LD_INT 20
17193: PUSH
17194: LD_INT 16
17196: PUSH
17197: LD_INT 17
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: LIST
17207: PPUSH
17208: CALL 9020 0 3
// MCS_ControlTower ( 1 , 1 , [ 33 , 49 , 2 ] ) ;
17212: LD_INT 1
17214: PPUSH
17215: LD_INT 1
17217: PPUSH
17218: LD_INT 33
17220: PUSH
17221: LD_INT 49
17223: PUSH
17224: LD_INT 2
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: LIST
17231: PPUSH
17232: CALL 9521 0 3
// MCS_AddVehicle ( 1 , [ us_medium_wheeled , engine_combustion , control_computer , us_cargo_bay ] ) ;
17236: LD_INT 1
17238: PPUSH
17239: LD_INT 2
17241: PUSH
17242: LD_INT 1
17244: PUSH
17245: LD_INT 3
17247: PUSH
17248: LD_INT 12
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: LIST
17255: LIST
17256: PPUSH
17257: CALL 9630 0 2
// MCS_AddVehicle ( 1 , [ us_medium_wheeled , engine_combustion , control_remote , us_gatling_gun ] ) ;
17261: LD_INT 1
17263: PPUSH
17264: LD_INT 2
17266: PUSH
17267: LD_INT 1
17269: PUSH
17270: LD_INT 2
17272: PUSH
17273: LD_INT 4
17275: PUSH
17276: EMPTY
17277: LIST
17278: LIST
17279: LIST
17280: LIST
17281: PPUSH
17282: CALL 9630 0 2
// MC_Game ( 0 0$01 ) ;
17286: LD_INT 35
17288: PPUSH
17289: CALL 17294 0 1
// end ;
17293: END
// function MC_Game ( int ) ; var i , side , un ; begin
17294: LD_INT 0
17296: PPUSH
17297: PPUSH
17298: PPUSH
17299: PPUSH
// while ( mc_game_live ) do
17300: LD_EXP 32
17304: IFFALSE 18867
// begin Wait ( int ) ;
17306: LD_VAR 0 1
17310: PPUSH
17311: CALL_OW 67
// if isEditor then
17315: LD_INT 1
17317: IFFALSE 17334
// MC_Show ( MCF_ScanTeren ( 1 , 40 ) ) ;
17319: LD_INT 1
17321: PPUSH
17322: LD_INT 40
17324: PPUSH
17325: CALL 3321 0 2
17329: PPUSH
17330: CALL 4025 0 1
// MCT_Crates ( area44 , 4 , 66 , 0 0$20 , 20 ) ;
17334: LD_INT 6
17336: PPUSH
17337: LD_INT 4
17339: PPUSH
17340: LD_INT 66
17342: PPUSH
17343: LD_INT 700
17345: PPUSH
17346: LD_INT 20
17348: PPUSH
17349: CALL 7781 0 5
// for side = 1 to 8 do
17353: LD_ADDR_VAR 0 4
17357: PUSH
17358: DOUBLE
17359: LD_INT 1
17361: DEC
17362: ST_TO_ADDR
17363: LD_INT 8
17365: PUSH
17366: FOR_TO
17367: IFFALSE 18863
// begin if MREG_SidesList [ side ] = 0 then
17369: LD_EXP 7
17373: PUSH
17374: LD_VAR 0 4
17378: ARRAY
17379: PUSH
17380: LD_INT 0
17382: EQUAL
17383: IFFALSE 17387
// continue ;
17385: GO 17366
// if MCL_GetTechList ( side ) then
17387: LD_VAR 0 4
17391: PPUSH
17392: CALL 14288 0 1
17396: IFFALSE 17407
// MCL_Start ( side ) ;
17398: LD_VAR 0 4
17402: PPUSH
17403: CALL 14193 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
17407: LD_ADDR_EXP 3
17411: PUSH
17412: LD_EXP 3
17416: PPUSH
17417: LD_VAR 0 4
17421: PPUSH
17422: LD_VAR 0 4
17426: PPUSH
17427: CALL 27112 0 1
17431: PPUSH
17432: CALL_OW 1
17436: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
17437: LD_ADDR_EXP 16
17441: PUSH
17442: LD_EXP 16
17446: PPUSH
17447: LD_VAR 0 4
17451: PPUSH
17452: LD_VAR 0 4
17456: PPUSH
17457: CALL 12776 0 1
17461: PPUSH
17462: CALL_OW 1
17466: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
17467: LD_VAR 0 4
17471: PPUSH
17472: LD_INT 21
17474: PUSH
17475: LD_INT 2
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PPUSH
17482: CALL 0 0 2
17486: IFFALSE 17497
// MCV_CheckStatus ( side ) ;
17488: LD_VAR 0 4
17492: PPUSH
17493: CALL 16484 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
17497: LD_VAR 0 4
17501: PPUSH
17502: LD_EXP 22
17506: PPUSH
17507: CALL 5353 0 2
17511: IFFALSE 17596
// begin for i = MREG_ToChangeClass downto 1 do
17513: LD_ADDR_VAR 0 3
17517: PUSH
17518: DOUBLE
17519: LD_EXP 22
17523: INC
17524: ST_TO_ADDR
17525: LD_INT 1
17527: PUSH
17528: FOR_DOWNTO
17529: IFFALSE 17594
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
17531: LD_EXP 22
17535: PUSH
17536: LD_VAR 0 3
17540: ARRAY
17541: PUSH
17542: LD_INT 1
17544: ARRAY
17545: PUSH
17546: LD_VAR 0 4
17550: EQUAL
17551: IFFALSE 17592
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
17553: LD_VAR 0 4
17557: PPUSH
17558: LD_EXP 22
17562: PUSH
17563: LD_VAR 0 3
17567: ARRAY
17568: PUSH
17569: LD_INT 2
17571: ARRAY
17572: PPUSH
17573: LD_EXP 22
17577: PUSH
17578: LD_VAR 0 3
17582: ARRAY
17583: PUSH
17584: LD_INT 3
17586: ARRAY
17587: PPUSH
17588: CALL 24074 0 3
// end ; end ;
17592: GO 17528
17594: POP
17595: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
17596: LD_INT 1
17598: PUSH
17599: LD_EXP 6
17603: PUSH
17604: LD_VAR 0 4
17608: ARRAY
17609: IN
17610: IFFALSE 17621
// begin MCN_TrainApe ( side ) ;
17612: LD_VAR 0 4
17616: PPUSH
17617: CALL 26765 0 1
// end ; if MREG_ToConstruct [ side ] then
17621: LD_EXP 20
17625: PUSH
17626: LD_VAR 0 4
17630: ARRAY
17631: IFFALSE 17753
// begin if MCF_Get ( side , [ f_btype , b_factory ] ) then
17633: LD_VAR 0 4
17637: PPUSH
17638: LD_INT 30
17640: PUSH
17641: LD_INT 3
17643: PUSH
17644: EMPTY
17645: LIST
17646: LIST
17647: PPUSH
17648: CALL 0 0 2
17652: IFFALSE 17753
// MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
17654: LD_VAR 0 4
17658: PPUSH
17659: LD_VAR 0 4
17663: PPUSH
17664: LD_INT 30
17666: PUSH
17667: LD_INT 3
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PPUSH
17674: CALL 0 0 2
17678: PUSH
17679: LD_INT 1
17681: ARRAY
17682: PPUSH
17683: LD_EXP 20
17687: PUSH
17688: LD_VAR 0 4
17692: ARRAY
17693: PUSH
17694: LD_INT 1
17696: ARRAY
17697: PUSH
17698: LD_EXP 20
17702: PUSH
17703: LD_VAR 0 4
17707: ARRAY
17708: PUSH
17709: LD_INT 2
17711: ARRAY
17712: PUSH
17713: LD_EXP 20
17717: PUSH
17718: LD_VAR 0 4
17722: ARRAY
17723: PUSH
17724: LD_INT 3
17726: ARRAY
17727: PUSH
17728: LD_EXP 20
17732: PUSH
17733: LD_VAR 0 4
17737: ARRAY
17738: PUSH
17739: LD_INT 4
17741: ARRAY
17742: PUSH
17743: EMPTY
17744: LIST
17745: LIST
17746: LIST
17747: LIST
17748: PPUSH
17749: CALL 14768 0 3
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) then
17753: LD_VAR 0 4
17757: PPUSH
17758: LD_INT 30
17760: PUSH
17761: LD_INT 3
17763: PUSH
17764: EMPTY
17765: LIST
17766: LIST
17767: PPUSH
17768: CALL 0 0 2
17772: PUSH
17773: LD_VAR 0 4
17777: PPUSH
17778: LD_EXP 12
17782: PPUSH
17783: CALL 5353 0 2
17787: AND
17788: IFFALSE 17799
// MCV_Turret ( side ) ;
17790: LD_VAR 0 4
17794: PPUSH
17795: CALL 15155 0 1
// if MCF_Get ( side , [ f_engine , engine_combustion ] ) then
17799: LD_VAR 0 4
17803: PPUSH
17804: LD_INT 32
17806: PUSH
17807: LD_INT 1
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: PPUSH
17814: CALL 0 0 2
17818: IFFALSE 17868
// begin MCV_CheckFuel ( side ) ;
17820: LD_VAR 0 4
17824: PPUSH
17825: CALL 15426 0 1
// if MCF_Tag ( side , 21 , [ ] ) then
17829: LD_VAR 0 4
17833: PPUSH
17834: LD_INT 21
17836: PPUSH
17837: EMPTY
17838: PPUSH
17839: CALL 703 0 3
17843: IFFALSE 17868
// MCV_Refuel ( MCF_Tag ( side , 21 , [ ] ) [ 1 ] ) ;
17845: LD_VAR 0 4
17849: PPUSH
17850: LD_INT 21
17852: PPUSH
17853: EMPTY
17854: PPUSH
17855: CALL 703 0 3
17859: PUSH
17860: LD_INT 1
17862: ARRAY
17863: PPUSH
17864: CALL 15555 0 1
// end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
17868: LD_VAR 0 4
17872: PPUSH
17873: LD_INT 33
17875: PUSH
17876: LD_INT 2
17878: PUSH
17879: EMPTY
17880: LIST
17881: LIST
17882: PPUSH
17883: CALL 0 0 2
17887: IFFALSE 17927
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
17889: LD_VAR 0 4
17893: PPUSH
17894: LD_VAR 0 4
17898: PPUSH
17899: LD_INT 33
17901: PUSH
17902: LD_INT 2
17904: PUSH
17905: EMPTY
17906: LIST
17907: LIST
17908: PPUSH
17909: CALL 0 0 2
17913: PUSH
17914: LD_INT 1
17916: ARRAY
17917: PPUSH
17918: CALL_OW 248
17922: PPUSH
17923: CALL 15781 0 2
// if MREG_ToRepair [ side ] then
17927: LD_EXP 16
17931: PUSH
17932: LD_VAR 0 4
17936: ARRAY
17937: IFFALSE 17950
// begin MCB_Repair ( side ) ;
17939: LD_VAR 0 4
17943: PPUSH
17944: CALL 13063 0 1
// end else
17948: GO 18831
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
17950: LD_VAR 0 4
17954: PPUSH
17955: LD_EXP 18
17959: PPUSH
17960: CALL 5353 0 2
17964: PUSH
17965: LD_VAR 0 4
17969: PPUSH
17970: LD_EXP 8
17974: PPUSH
17975: CALL 5353 0 2
17979: AND
17980: IFFALSE 18188
// begin for i = 1 to MREG_ToUpLab do
17982: LD_ADDR_VAR 0 3
17986: PUSH
17987: DOUBLE
17988: LD_INT 1
17990: DEC
17991: ST_TO_ADDR
17992: LD_EXP 18
17996: PUSH
17997: FOR_TO
17998: IFFALSE 18184
// if MREG_ToUpLab [ i ] [ 1 ] = side then
18000: LD_EXP 18
18004: PUSH
18005: LD_VAR 0 3
18009: ARRAY
18010: PUSH
18011: LD_INT 1
18013: ARRAY
18014: PUSH
18015: LD_VAR 0 4
18019: EQUAL
18020: IFFALSE 18182
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
18022: LD_EXP 18
18026: PUSH
18027: LD_VAR 0 3
18031: ARRAY
18032: PUSH
18033: LD_INT 2
18035: ARRAY
18036: PUSH
18037: LD_EXP 18
18041: PUSH
18042: LD_VAR 0 3
18046: ARRAY
18047: PUSH
18048: LD_INT 3
18050: ARRAY
18051: AND
18052: IFFALSE 18180
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
18054: LD_VAR 0 4
18058: PPUSH
18059: LD_EXP 18
18063: PUSH
18064: LD_VAR 0 3
18068: ARRAY
18069: PUSH
18070: LD_INT 2
18072: ARRAY
18073: PPUSH
18074: LD_EXP 18
18078: PUSH
18079: LD_VAR 0 3
18083: ARRAY
18084: PUSH
18085: LD_INT 3
18087: ARRAY
18088: PPUSH
18089: CALL 10587 0 3
18093: IFFALSE 18180
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
18095: LD_ADDR_EXP 18
18099: PUSH
18100: LD_EXP 18
18104: PPUSH
18105: LD_VAR 0 4
18109: PPUSH
18110: LD_EXP 18
18114: PUSH
18115: LD_VAR 0 3
18119: ARRAY
18120: PUSH
18121: LD_INT 2
18123: ARRAY
18124: PPUSH
18125: LD_EXP 18
18129: PUSH
18130: LD_VAR 0 3
18134: ARRAY
18135: PUSH
18136: LD_INT 3
18138: ARRAY
18139: PPUSH
18140: CALL 4350 0 4
18144: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
18145: LD_ADDR_EXP 8
18149: PUSH
18150: LD_EXP 8
18154: PPUSH
18155: LD_VAR 0 4
18159: PPUSH
18160: LD_EXP 8
18164: PUSH
18165: LD_INT 1
18167: ARRAY
18168: PUSH
18169: LD_INT 2
18171: ARRAY
18172: PPUSH
18173: EMPTY
18174: PPUSH
18175: CALL 4350 0 4
18179: ST_TO_ADDR
// end ; break ;
18180: GO 18184
// end ;
18182: GO 17997
18184: POP
18185: POP
// end else
18186: GO 18831
// if MREG_ForSide ( side , MREG_ToUpdate ) then
18188: LD_VAR 0 4
18192: PPUSH
18193: LD_EXP 17
18197: PPUSH
18198: CALL 5353 0 2
18202: IFFALSE 18276
// begin for i = 1 to MREG_ToUpdate do
18204: LD_ADDR_VAR 0 3
18208: PUSH
18209: DOUBLE
18210: LD_INT 1
18212: DEC
18213: ST_TO_ADDR
18214: LD_EXP 17
18218: PUSH
18219: FOR_TO
18220: IFFALSE 18272
// if MREG_ToUpdate [ i ] [ 1 ] = side then
18222: LD_EXP 17
18226: PUSH
18227: LD_VAR 0 3
18231: ARRAY
18232: PUSH
18233: LD_INT 1
18235: ARRAY
18236: PUSH
18237: LD_VAR 0 4
18241: EQUAL
18242: IFFALSE 18270
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
18244: LD_VAR 0 4
18248: PPUSH
18249: LD_EXP 17
18253: PUSH
18254: LD_VAR 0 3
18258: ARRAY
18259: PUSH
18260: LD_INT 2
18262: ARRAY
18263: PPUSH
18264: CALL 10423 0 2
// break ;
18268: GO 18272
// end ;
18270: GO 18219
18272: POP
18273: POP
// end else
18274: GO 18831
// if MCF_Get ( side , [ f_constructed ] ) then
18276: LD_VAR 0 4
18280: PPUSH
18281: LD_INT 57
18283: PUSH
18284: EMPTY
18285: LIST
18286: PPUSH
18287: CALL 0 0 2
18291: IFFALSE 18324
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
18293: LD_VAR 0 4
18297: PPUSH
18298: LD_VAR 0 4
18302: PPUSH
18303: LD_INT 57
18305: PUSH
18306: EMPTY
18307: LIST
18308: PPUSH
18309: CALL 0 0 2
18313: PUSH
18314: LD_INT 1
18316: ARRAY
18317: PPUSH
18318: CALL 12667 0 2
18322: GO 18831
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) then
18324: LD_VAR 0 4
18328: PPUSH
18329: LD_EXP 15
18333: PPUSH
18334: CALL 5353 0 2
18338: PUSH
18339: LD_VAR 0 4
18343: PPUSH
18344: CALL_OW 345
18348: NOT
18349: AND
18350: IFFALSE 18747
// begin for i = 1 to MREG_ToBuild do
18352: LD_ADDR_VAR 0 3
18356: PUSH
18357: DOUBLE
18358: LD_INT 1
18360: DEC
18361: ST_TO_ADDR
18362: LD_EXP 15
18366: PUSH
18367: FOR_TO
18368: IFFALSE 18743
// if MREG_ToBuild [ i ] [ 1 ] = side then
18370: LD_EXP 15
18374: PUSH
18375: LD_VAR 0 3
18379: ARRAY
18380: PUSH
18381: LD_INT 1
18383: ARRAY
18384: PUSH
18385: LD_VAR 0 4
18389: EQUAL
18390: IFFALSE 18741
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
18392: LD_INT 1
18394: PUSH
18395: LD_EXP 15
18399: PUSH
18400: LD_VAR 0 3
18404: ARRAY
18405: PUSH
18406: LD_INT 3
18408: ARRAY
18409: PUSH
18410: LD_INT 1
18412: ARRAY
18413: PPUSH
18414: LD_EXP 15
18418: PUSH
18419: LD_VAR 0 3
18423: ARRAY
18424: PUSH
18425: LD_INT 3
18427: ARRAY
18428: PUSH
18429: LD_INT 2
18431: ARRAY
18432: PPUSH
18433: CALL_OW 351
18437: AND
18438: IFFALSE 18482
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
18440: LD_EXP 15
18444: PUSH
18445: LD_VAR 0 3
18449: ARRAY
18450: PUSH
18451: LD_INT 3
18453: ARRAY
18454: PUSH
18455: LD_INT 1
18457: ARRAY
18458: PPUSH
18459: LD_EXP 15
18463: PUSH
18464: LD_VAR 0 3
18468: ARRAY
18469: PUSH
18470: LD_INT 3
18472: ARRAY
18473: PUSH
18474: LD_INT 2
18476: ARRAY
18477: PPUSH
18478: CALL 6014 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
18482: LD_EXP 15
18486: PUSH
18487: LD_VAR 0 3
18491: ARRAY
18492: PUSH
18493: LD_INT 2
18495: ARRAY
18496: PUSH
18497: LD_INT 0
18499: EQUAL
18500: IFFALSE 18570
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
18502: LD_VAR 0 4
18506: PPUSH
18507: LD_EXP 15
18511: PUSH
18512: LD_VAR 0 3
18516: ARRAY
18517: PUSH
18518: LD_INT 3
18520: ARRAY
18521: PUSH
18522: LD_INT 1
18524: ARRAY
18525: PPUSH
18526: LD_EXP 15
18530: PUSH
18531: LD_VAR 0 3
18535: ARRAY
18536: PUSH
18537: LD_INT 3
18539: ARRAY
18540: PUSH
18541: LD_INT 2
18543: ARRAY
18544: PPUSH
18545: LD_EXP 15
18549: PUSH
18550: LD_VAR 0 3
18554: ARRAY
18555: PUSH
18556: LD_INT 3
18558: ARRAY
18559: PUSH
18560: LD_INT 3
18562: ARRAY
18563: PPUSH
18564: CALL 10259 0 4
18568: GO 18739
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
18570: LD_EXP 15
18574: PUSH
18575: LD_VAR 0 3
18579: ARRAY
18580: PUSH
18581: LD_INT 2
18583: ARRAY
18584: PUSH
18585: LD_INT 6
18587: EQUAL
18588: IFFALSE 18658
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
18590: LD_VAR 0 4
18594: PPUSH
18595: LD_EXP 15
18599: PUSH
18600: LD_VAR 0 3
18604: ARRAY
18605: PUSH
18606: LD_INT 3
18608: ARRAY
18609: PUSH
18610: LD_INT 1
18612: ARRAY
18613: PPUSH
18614: LD_EXP 15
18618: PUSH
18619: LD_VAR 0 3
18623: ARRAY
18624: PUSH
18625: LD_INT 3
18627: ARRAY
18628: PUSH
18629: LD_INT 2
18631: ARRAY
18632: PPUSH
18633: LD_EXP 15
18637: PUSH
18638: LD_VAR 0 3
18642: ARRAY
18643: PUSH
18644: LD_INT 3
18646: ARRAY
18647: PUSH
18648: LD_INT 3
18650: ARRAY
18651: PPUSH
18652: CALL 10388 0 4
18656: GO 18739
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
18658: LD_VAR 0 4
18662: PPUSH
18663: LD_EXP 15
18667: PUSH
18668: LD_VAR 0 3
18672: ARRAY
18673: PUSH
18674: LD_INT 2
18676: ARRAY
18677: PPUSH
18678: LD_EXP 15
18682: PUSH
18683: LD_VAR 0 3
18687: ARRAY
18688: PUSH
18689: LD_INT 3
18691: ARRAY
18692: PUSH
18693: LD_INT 1
18695: ARRAY
18696: PPUSH
18697: LD_EXP 15
18701: PUSH
18702: LD_VAR 0 3
18706: ARRAY
18707: PUSH
18708: LD_INT 3
18710: ARRAY
18711: PUSH
18712: LD_INT 2
18714: ARRAY
18715: PPUSH
18716: LD_EXP 15
18720: PUSH
18721: LD_VAR 0 3
18725: ARRAY
18726: PUSH
18727: LD_INT 3
18729: ARRAY
18730: PUSH
18731: LD_INT 3
18733: ARRAY
18734: PPUSH
18735: CALL 11892 0 5
// break ;
18739: GO 18743
// end ;
18741: GO 18367
18743: POP
18744: POP
// end else
18745: GO 18831
// if MREG_ForSide ( side , MREG_ToDismantle ) then
18747: LD_VAR 0 4
18751: PPUSH
18752: LD_EXP 21
18756: PPUSH
18757: CALL 5353 0 2
18761: IFFALSE 18831
// begin for i = 1 to MREG_ToDismantle do
18763: LD_ADDR_VAR 0 3
18767: PUSH
18768: DOUBLE
18769: LD_INT 1
18771: DEC
18772: ST_TO_ADDR
18773: LD_EXP 21
18777: PUSH
18778: FOR_TO
18779: IFFALSE 18829
// if MREG_ToDismantle [ i ] [ 1 ] = side then
18781: LD_EXP 21
18785: PUSH
18786: LD_VAR 0 3
18790: ARRAY
18791: PUSH
18792: LD_INT 1
18794: ARRAY
18795: PUSH
18796: LD_VAR 0 4
18800: EQUAL
18801: IFFALSE 18827
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
18803: LD_VAR 0 4
18807: PPUSH
18808: LD_EXP 21
18812: PUSH
18813: LD_VAR 0 3
18817: ARRAY
18818: PUSH
18819: LD_INT 2
18821: ARRAY
18822: PPUSH
18823: CALL 12558 0 2
// end ;
18827: GO 18778
18829: POP
18830: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18831: LD_VAR 0 4
18835: PPUSH
18836: LD_INT 30
18838: PUSH
18839: LD_INT 1
18841: PUSH
18842: EMPTY
18843: LIST
18844: LIST
18845: PPUSH
18846: CALL 0 0 2
18850: IFFALSE 18861
// MCT_CollectCrates ( side ) ;
18852: LD_VAR 0 4
18856: PPUSH
18857: CALL 7245 0 1
// end ;
18861: GO 17366
18863: POP
18864: POP
// end ;
18865: GO 17300
// end ;
18867: LD_VAR 0 2
18871: RET
// every 0 0$03 trigger mc_game_live do var i , j , un , side , b , v , c , e , f , k , x , y , all , eng , mech , sci , ct , tmp , at_war ;
18872: LD_EXP 32
18876: IFFALSE 21327
18878: GO 18880
18880: DISABLE
18881: LD_INT 0
18883: PPUSH
18884: PPUSH
18885: PPUSH
18886: PPUSH
18887: PPUSH
18888: PPUSH
18889: PPUSH
18890: PPUSH
18891: PPUSH
18892: PPUSH
18893: PPUSH
18894: PPUSH
18895: PPUSH
18896: PPUSH
18897: PPUSH
18898: PPUSH
18899: PPUSH
18900: PPUSH
18901: PPUSH
// begin enable ;
18902: ENABLE
// for i = 1 to 8 do
18903: LD_ADDR_VAR 0 1
18907: PUSH
18908: DOUBLE
18909: LD_INT 1
18911: DEC
18912: ST_TO_ADDR
18913: LD_INT 8
18915: PUSH
18916: FOR_TO
18917: IFFALSE 21325
// begin if MREG_SidesList [ i ] = 0 then
18919: LD_EXP 7
18923: PUSH
18924: LD_VAR 0 1
18928: ARRAY
18929: PUSH
18930: LD_INT 0
18932: EQUAL
18933: IFFALSE 18937
// continue ;
18935: GO 18916
// at_war := false ;
18937: LD_ADDR_VAR 0 19
18941: PUSH
18942: LD_INT 0
18944: ST_TO_ADDR
// if MREG_Heal [ i ] then
18945: LD_EXP 3
18949: PUSH
18950: LD_VAR 0 1
18954: ARRAY
18955: IFFALSE 19103
// begin if MCF_Class ( i , 4 , [ ] ) then
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_INT 4
18964: PPUSH
18965: EMPTY
18966: PPUSH
18967: CALL 83 0 3
18971: IFFALSE 19101
// for j in MCF_Class ( i , 4 , [ ] ) do
18973: LD_ADDR_VAR 0 2
18977: PUSH
18978: LD_VAR 0 1
18982: PPUSH
18983: LD_INT 4
18985: PPUSH
18986: EMPTY
18987: PPUSH
18988: CALL 83 0 3
18992: PUSH
18993: FOR_IN
18994: IFFALSE 19099
// if not GetTag ( j ) = 4 then
18996: LD_VAR 0 2
19000: PPUSH
19001: CALL_OW 110
19005: PUSH
19006: LD_INT 4
19008: EQUAL
19009: NOT
19010: IFFALSE 19046
// begin SetTag ( j , 4 ) ;
19012: LD_VAR 0 2
19016: PPUSH
19017: LD_INT 4
19019: PPUSH
19020: CALL_OW 109
// if IsInUnit ( j ) then
19024: LD_VAR 0 2
19028: PPUSH
19029: CALL_OW 310
19033: IFFALSE 19044
// ComExitBuilding ( j ) ;
19035: LD_VAR 0 2
19039: PPUSH
19040: CALL_OW 122
// end else
19044: GO 19097
// if not WantHeal ( j , MREG_Heal [ i ] [ 1 ] ) then
19046: LD_VAR 0 2
19050: PPUSH
19051: LD_EXP 3
19055: PUSH
19056: LD_VAR 0 1
19060: ARRAY
19061: PUSH
19062: LD_INT 1
19064: ARRAY
19065: PPUSH
19066: CALL 25940 0 2
19070: NOT
19071: IFFALSE 19097
// MCP_Heal ( j , MREG_Heal [ i ] [ 1 ] ) ;
19073: LD_VAR 0 2
19077: PPUSH
19078: LD_EXP 3
19082: PUSH
19083: LD_VAR 0 1
19087: ARRAY
19088: PUSH
19089: LD_INT 1
19091: ARRAY
19092: PPUSH
19093: CALL 27042 0 2
19097: GO 18993
19099: POP
19100: POP
// end else
19101: GO 19335
// if MCF_Class ( i , 4 , [ ] ) and MCF_Tag ( i , 4 , [ ] ) then
19103: LD_VAR 0 1
19107: PPUSH
19108: LD_INT 4
19110: PPUSH
19111: EMPTY
19112: PPUSH
19113: CALL 83 0 3
19117: PUSH
19118: LD_VAR 0 1
19122: PPUSH
19123: LD_INT 4
19125: PPUSH
19126: EMPTY
19127: PPUSH
19128: CALL 703 0 3
19132: AND
19133: IFFALSE 19335
// for j in MCF_Class ( i , 4 , [ ] ) do
19135: LD_ADDR_VAR 0 2
19139: PUSH
19140: LD_VAR 0 1
19144: PPUSH
19145: LD_INT 4
19147: PPUSH
19148: EMPTY
19149: PPUSH
19150: CALL 83 0 3
19154: PUSH
19155: FOR_IN
19156: IFFALSE 19333
// begin if GetTag ( j ) = 4 then
19158: LD_VAR 0 2
19162: PPUSH
19163: CALL_OW 110
19167: PUSH
19168: LD_INT 4
19170: EQUAL
19171: IFFALSE 19331
// begin SetTag ( j , 0 ) ;
19173: LD_VAR 0 2
19177: PPUSH
19178: LD_INT 0
19180: PPUSH
19181: CALL_OW 109
// if MCF_Lab ( i ) and not MCL_GetTechList ( i ) then
19185: LD_VAR 0 1
19189: PPUSH
19190: CALL 39 0 1
19194: PUSH
19195: LD_VAR 0 1
19199: PPUSH
19200: CALL 14288 0 1
19204: NOT
19205: AND
19206: IFFALSE 19231
// ComEnterUnit ( j , MCF_Lab ( i ) [ 1 ] ) ;
19208: LD_VAR 0 2
19212: PPUSH
19213: LD_VAR 0 1
19217: PPUSH
19218: CALL 39 0 1
19222: PUSH
19223: LD_INT 1
19225: ARRAY
19226: PPUSH
19227: CALL_OW 120
// if not MCF_Lab ( i ) and MCF_Get ( i , [ f_btype , b_warehouse ] ) then
19231: LD_VAR 0 1
19235: PPUSH
19236: CALL 39 0 1
19240: NOT
19241: PUSH
19242: LD_VAR 0 1
19246: PPUSH
19247: LD_INT 30
19249: PUSH
19250: LD_INT 1
19252: PUSH
19253: EMPTY
19254: LIST
19255: LIST
19256: PPUSH
19257: CALL 0 0 2
19261: AND
19262: IFFALSE 19331
// ComMoveXY ( j , GetX ( MCF_Get ( i , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( i , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
19264: LD_VAR 0 2
19268: PPUSH
19269: LD_VAR 0 1
19273: PPUSH
19274: LD_INT 30
19276: PUSH
19277: LD_INT 1
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PPUSH
19284: CALL 0 0 2
19288: PUSH
19289: LD_INT 1
19291: ARRAY
19292: PPUSH
19293: CALL_OW 250
19297: PPUSH
19298: LD_VAR 0 1
19302: PPUSH
19303: LD_INT 30
19305: PUSH
19306: LD_INT 1
19308: PUSH
19309: EMPTY
19310: LIST
19311: LIST
19312: PPUSH
19313: CALL 0 0 2
19317: PUSH
19318: LD_INT 1
19320: ARRAY
19321: PPUSH
19322: CALL_OW 251
19326: PPUSH
19327: CALL_OW 111
// end ; end ;
19331: GO 19155
19333: POP
19334: POP
// if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and not at_war and not MREG_Heal [ i ] and not MCL_GetTechList ( i ) and MCF_Class ( i , 4 , [ ] ) then
19335: LD_INT 1
19337: PPUSH
19338: LD_VAR 0 2
19342: PPUSH
19343: CALL_OW 255
19347: PPUSH
19348: CALL_OW 321
19352: PUSH
19353: LD_INT 2
19355: EQUAL
19356: PUSH
19357: LD_VAR 0 19
19361: NOT
19362: AND
19363: PUSH
19364: LD_EXP 3
19368: PUSH
19369: LD_VAR 0 1
19373: ARRAY
19374: NOT
19375: AND
19376: PUSH
19377: LD_VAR 0 1
19381: PPUSH
19382: CALL 14288 0 1
19386: NOT
19387: AND
19388: PUSH
19389: LD_VAR 0 1
19393: PPUSH
19394: LD_INT 4
19396: PPUSH
19397: EMPTY
19398: PPUSH
19399: CALL 83 0 3
19403: AND
19404: IFFALSE 19452
// for j in MCF_Class ( i , 4 , [ ] ) do
19406: LD_ADDR_VAR 0 2
19410: PUSH
19411: LD_VAR 0 1
19415: PPUSH
19416: LD_INT 4
19418: PPUSH
19419: EMPTY
19420: PPUSH
19421: CALL 83 0 3
19425: PUSH
19426: FOR_IN
19427: IFFALSE 19450
// MCN_Tame ( GetSide ( j ) , j ) ;
19429: LD_VAR 0 2
19433: PPUSH
19434: CALL_OW 255
19438: PPUSH
19439: LD_VAR 0 2
19443: PPUSH
19444: CALL 26374 0 2
19448: GO 19426
19450: POP
19451: POP
// if at_war then
19452: LD_VAR 0 19
19456: IFFALSE 19460
// begin end else
19458: GO 21323
// begin all := MCF_All ( i , [ ] ) ;
19460: LD_ADDR_VAR 0 13
19464: PUSH
19465: LD_VAR 0 1
19469: PPUSH
19470: EMPTY
19471: PPUSH
19472: CALL 135 0 2
19476: ST_TO_ADDR
// eng := MREG_ToDep [ i ] ;
19477: LD_ADDR_VAR 0 14
19481: PUSH
19482: LD_EXP 26
19486: PUSH
19487: LD_VAR 0 1
19491: ARRAY
19492: ST_TO_ADDR
// mech := MREG_ToFac [ i ] ;
19493: LD_ADDR_VAR 0 15
19497: PUSH
19498: LD_EXP 24
19502: PUSH
19503: LD_VAR 0 1
19507: ARRAY
19508: ST_TO_ADDR
// sci := MREG_ToLab [ i ] ;
19509: LD_ADDR_VAR 0 16
19513: PUSH
19514: LD_EXP 23
19518: PUSH
19519: LD_VAR 0 1
19523: ARRAY
19524: ST_TO_ADDR
// if not at_war and MREG_ToArm [ i ] then
19525: LD_VAR 0 19
19529: NOT
19530: PUSH
19531: LD_EXP 25
19535: PUSH
19536: LD_VAR 0 1
19540: ARRAY
19541: AND
19542: IFFALSE 19559
// MCF_RemoveClass ( i , ToArm , 1 ) ;
19544: LD_VAR 0 1
19548: PPUSH
19549: LD_STRING ToArm
19551: PPUSH
19552: LD_INT 1
19554: PPUSH
19555: CALL 2236 0 3
// if MCL_GetTechList ( i ) and MCF_Lab ( i ) and not MREG_Heal [ i ] then
19559: LD_VAR 0 1
19563: PPUSH
19564: CALL 14288 0 1
19568: PUSH
19569: LD_VAR 0 1
19573: PPUSH
19574: CALL 39 0 1
19578: AND
19579: PUSH
19580: LD_EXP 3
19584: PUSH
19585: LD_VAR 0 1
19589: ARRAY
19590: NOT
19591: AND
19592: IFFALSE 20024
// begin for j = 1 to MCF_Lab ( i ) do
19594: LD_ADDR_VAR 0 2
19598: PUSH
19599: DOUBLE
19600: LD_INT 1
19602: DEC
19603: ST_TO_ADDR
19604: LD_VAR 0 1
19608: PPUSH
19609: CALL 39 0 1
19613: PUSH
19614: FOR_TO
19615: IFFALSE 19675
// if BuildingStatus ( MCF_Lab ( i ) [ j ] ) in [ bs_working , bs_need_people ] then
19617: LD_VAR 0 1
19621: PPUSH
19622: CALL 39 0 1
19626: PUSH
19627: LD_VAR 0 2
19631: ARRAY
19632: PPUSH
19633: CALL_OW 461
19637: PUSH
19638: LD_INT 3
19640: PUSH
19641: LD_INT 6
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: IN
19648: IFFALSE 19673
// begin b := MCF_Lab ( i ) [ j ] ;
19650: LD_ADDR_VAR 0 5
19654: PUSH
19655: LD_VAR 0 1
19659: PPUSH
19660: CALL 39 0 1
19664: PUSH
19665: LD_VAR 0 2
19669: ARRAY
19670: ST_TO_ADDR
// break ;
19671: GO 19675
// end ;
19673: GO 19614
19675: POP
19676: POP
// if MCF_Class ( i , 4 , [ ] ) then
19677: LD_VAR 0 1
19681: PPUSH
19682: LD_INT 4
19684: PPUSH
19685: EMPTY
19686: PPUSH
19687: CALL 83 0 3
19691: IFFALSE 19866
// for j in MCF_Class ( i , 4 , [ ] ) do
19693: LD_ADDR_VAR 0 2
19697: PUSH
19698: LD_VAR 0 1
19702: PPUSH
19703: LD_INT 4
19705: PPUSH
19706: EMPTY
19707: PPUSH
19708: CALL 83 0 3
19712: PUSH
19713: FOR_IN
19714: IFFALSE 19864
// begin if GetTag ( j ) = 0 then
19716: LD_VAR 0 2
19720: PPUSH
19721: CALL_OW 110
19725: PUSH
19726: LD_INT 0
19728: EQUAL
19729: IFFALSE 19820
// begin if IsInUnit ( j ) and b then
19731: LD_VAR 0 2
19735: PPUSH
19736: CALL_OW 310
19740: PUSH
19741: LD_VAR 0 5
19745: AND
19746: IFFALSE 19794
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
19748: LD_VAR 0 2
19752: PPUSH
19753: CALL_OW 310
19757: PPUSH
19758: CALL_OW 461
19762: PUSH
19763: LD_INT 2
19765: EQUAL
19766: PUSH
19767: LD_VAR 0 2
19771: PPUSH
19772: CALL_OW 310
19776: PUSH
19777: LD_VAR 0 5
19781: NONEQUAL
19782: AND
19783: IFFALSE 19794
// ComExitBuilding ( j ) ;
19785: LD_VAR 0 2
19789: PPUSH
19790: CALL_OW 122
// if not IsInUnit ( j ) then
19794: LD_VAR 0 2
19798: PPUSH
19799: CALL_OW 310
19803: NOT
19804: IFFALSE 19820
// ComEnterUnit ( j , b ) ;
19806: LD_VAR 0 2
19810: PPUSH
19811: LD_VAR 0 5
19815: PPUSH
19816: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched then
19820: LD_INT 1
19822: PPUSH
19823: LD_VAR 0 2
19827: PPUSH
19828: CALL_OW 255
19832: PPUSH
19833: CALL_OW 321
19837: PUSH
19838: LD_INT 2
19840: EQUAL
19841: IFFALSE 19862
// MCN_Tame ( GetSide ( j ) , j ) ;
19843: LD_VAR 0 2
19847: PPUSH
19848: CALL_OW 255
19852: PPUSH
19853: LD_VAR 0 2
19857: PPUSH
19858: CALL 26374 0 2
// end ;
19862: GO 19713
19864: POP
19865: POP
// if all > 6 then
19866: LD_VAR 0 13
19870: PUSH
19871: LD_INT 6
19873: GREATER
19874: IFFALSE 19982
// begin if sci < 6 then
19876: LD_VAR 0 16
19880: PUSH
19881: LD_INT 6
19883: LESS
19884: IFFALSE 19980
// begin if MCF_Get ( i , [ f_btype , b_warehouse ] ) then
19886: LD_VAR 0 1
19890: PPUSH
19891: LD_INT 30
19893: PUSH
19894: LD_INT 1
19896: PUSH
19897: EMPTY
19898: LIST
19899: LIST
19900: PPUSH
19901: CALL 0 0 2
19905: IFFALSE 19922
// MCF_RemoveClass ( i , ToDep , 1 ) ;
19907: LD_VAR 0 1
19911: PPUSH
19912: LD_STRING ToDep
19914: PPUSH
19915: LD_INT 1
19917: PPUSH
19918: CALL 2236 0 3
// if MCF_Get ( i , [ f_btype , b_factory ] ) = 0 then
19922: LD_VAR 0 1
19926: PPUSH
19927: LD_INT 30
19929: PUSH
19930: LD_INT 3
19932: PUSH
19933: EMPTY
19934: LIST
19935: LIST
19936: PPUSH
19937: CALL 0 0 2
19941: PUSH
19942: LD_INT 0
19944: EQUAL
19945: IFFALSE 19962
// MCF_RemoveClass ( i , ToFac , 1 ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_STRING ToFac
19954: PPUSH
19955: LD_INT 1
19957: PPUSH
19958: CALL 2236 0 3
// MCH_TrainScientist ( i , 6 - sci ) ;
19962: LD_VAR 0 1
19966: PPUSH
19967: LD_INT 6
19969: PUSH
19970: LD_VAR 0 16
19974: MINUS
19975: PPUSH
19976: CALL 23635 0 2
// end ; end else
19980: GO 20022
// if sci < all - 1 then
19982: LD_VAR 0 16
19986: PUSH
19987: LD_VAR 0 13
19991: PUSH
19992: LD_INT 1
19994: MINUS
19995: LESS
19996: IFFALSE 20022
// MCH_TrainScientist ( i , ( all - 1 ) - sci ) ;
19998: LD_VAR 0 1
20002: PPUSH
20003: LD_VAR 0 13
20007: PUSH
20008: LD_INT 1
20010: MINUS
20011: PUSH
20012: LD_VAR 0 16
20016: MINUS
20017: PPUSH
20018: CALL 23635 0 2
// end else
20022: GO 20118
// if MCL_GetTechList ( i ) = 0 then
20024: LD_VAR 0 1
20028: PPUSH
20029: CALL 14288 0 1
20033: PUSH
20034: LD_INT 0
20036: EQUAL
20037: IFFALSE 20118
// begin if all <= 6 then
20039: LD_VAR 0 13
20043: PUSH
20044: LD_INT 6
20046: LESSEQUAL
20047: IFFALSE 20066
// MCF_RemoveClass ( i , ToLab , 1 ) else
20049: LD_VAR 0 1
20053: PPUSH
20054: LD_STRING ToLab
20056: PPUSH
20057: LD_INT 1
20059: PPUSH
20060: CALL 2236 0 3
20064: GO 20118
// if all > 6 and all < 12 then
20066: LD_VAR 0 13
20070: PUSH
20071: LD_INT 6
20073: GREATER
20074: PUSH
20075: LD_VAR 0 13
20079: PUSH
20080: LD_INT 12
20082: LESS
20083: AND
20084: IFFALSE 20103
// MCF_RemoveClass ( i , ToLab , 2 ) else
20086: LD_VAR 0 1
20090: PPUSH
20091: LD_STRING ToLab
20093: PPUSH
20094: LD_INT 2
20096: PPUSH
20097: CALL 2236 0 3
20101: GO 20118
// MCF_RemoveClass ( i , ToLab , 3 ) ;
20103: LD_VAR 0 1
20107: PPUSH
20108: LD_STRING ToLab
20110: PPUSH
20111: LD_INT 3
20113: PPUSH
20114: CALL 2236 0 3
// end ; if MCF_Get ( i , [ f_btype , b_factory ] ) then
20118: LD_VAR 0 1
20122: PPUSH
20123: LD_INT 30
20125: PUSH
20126: LD_INT 3
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: PPUSH
20133: CALL 0 0 2
20137: IFFALSE 20689
// begin b := MCF_Get ( i , [ f_btype , b_factory ] ) [ 1 ] ;
20139: LD_ADDR_VAR 0 5
20143: PUSH
20144: LD_VAR 0 1
20148: PPUSH
20149: LD_INT 30
20151: PUSH
20152: LD_INT 3
20154: PUSH
20155: EMPTY
20156: LIST
20157: LIST
20158: PPUSH
20159: CALL 0 0 2
20163: PUSH
20164: LD_INT 1
20166: ARRAY
20167: ST_TO_ADDR
// if MCF_Class ( i , 3 , [ f_not , [ f_inside ] ] ) then
20168: LD_VAR 0 1
20172: PPUSH
20173: LD_INT 3
20175: PPUSH
20176: LD_INT 3
20178: PUSH
20179: LD_INT 54
20181: PUSH
20182: EMPTY
20183: LIST
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: PPUSH
20189: CALL 83 0 3
20193: IFFALSE 20262
// for j in MCF_Class ( i , 3 , [ f_not , [ f_inside ] ] ) do
20195: LD_ADDR_VAR 0 2
20199: PUSH
20200: LD_VAR 0 1
20204: PPUSH
20205: LD_INT 3
20207: PPUSH
20208: LD_INT 3
20210: PUSH
20211: LD_INT 54
20213: PUSH
20214: EMPTY
20215: LIST
20216: PUSH
20217: EMPTY
20218: LIST
20219: LIST
20220: PPUSH
20221: CALL 83 0 3
20225: PUSH
20226: FOR_IN
20227: IFFALSE 20260
// if GetTag ( j ) = 0 then
20229: LD_VAR 0 2
20233: PPUSH
20234: CALL_OW 110
20238: PUSH
20239: LD_INT 0
20241: EQUAL
20242: IFFALSE 20258
// ComEnterUnit ( j , b ) ;
20244: LD_VAR 0 2
20248: PPUSH
20249: LD_VAR 0 5
20253: PPUSH
20254: CALL_OW 120
20258: GO 20226
20260: POP
20261: POP
// if all - sci > 1 and BuildingStatus ( b ) = bs_need_people then
20262: LD_VAR 0 13
20266: PUSH
20267: LD_VAR 0 16
20271: MINUS
20272: PUSH
20273: LD_INT 1
20275: GREATER
20276: PUSH
20277: LD_VAR 0 5
20281: PPUSH
20282: CALL_OW 461
20286: PUSH
20287: LD_INT 6
20289: EQUAL
20290: AND
20291: IFFALSE 20403
// begin if mech < 6 then
20293: LD_VAR 0 15
20297: PUSH
20298: LD_INT 6
20300: LESS
20301: IFFALSE 20403
// begin if MCF_Get ( i , [ f_btype , b_warehouse ] ) then
20303: LD_VAR 0 1
20307: PPUSH
20308: LD_INT 30
20310: PUSH
20311: LD_INT 1
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: PPUSH
20318: CALL 0 0 2
20322: IFFALSE 20339
// MCF_RemoveClass ( i , ToDep , 2 ) ;
20324: LD_VAR 0 1
20328: PPUSH
20329: LD_STRING ToDep
20331: PPUSH
20332: LD_INT 2
20334: PPUSH
20335: CALL 2236 0 3
// if all - ( sci + 1 ) > 6 then
20339: LD_VAR 0 13
20343: PUSH
20344: LD_VAR 0 16
20348: PUSH
20349: LD_INT 1
20351: PLUS
20352: MINUS
20353: PUSH
20354: LD_INT 6
20356: GREATER
20357: IFFALSE 20369
// v := 6 else
20359: LD_ADDR_VAR 0 6
20363: PUSH
20364: LD_INT 6
20366: ST_TO_ADDR
20367: GO 20389
// v := all - ( sci + 1 ) ;
20369: LD_ADDR_VAR 0 6
20373: PUSH
20374: LD_VAR 0 13
20378: PUSH
20379: LD_VAR 0 16
20383: PUSH
20384: LD_INT 1
20386: PLUS
20387: MINUS
20388: ST_TO_ADDR
// MCH_TrainMechanic ( i , v ) ;
20389: LD_VAR 0 1
20393: PPUSH
20394: LD_VAR 0 6
20398: PPUSH
20399: CALL 23397 0 2
// end ; end ; ct := MCF_Get ( i , [ f_btype , b_control_tower ] ) ;
20403: LD_ADDR_VAR 0 17
20407: PUSH
20408: LD_VAR 0 1
20412: PPUSH
20413: LD_INT 30
20415: PUSH
20416: LD_INT 36
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: PPUSH
20423: CALL 0 0 2
20427: ST_TO_ADDR
// if ct and mech and MCF_Class ( i , 3 , [ ] ) then
20428: LD_VAR 0 17
20432: PUSH
20433: LD_VAR 0 15
20437: AND
20438: PUSH
20439: LD_VAR 0 1
20443: PPUSH
20444: LD_INT 3
20446: PPUSH
20447: EMPTY
20448: PPUSH
20449: CALL 83 0 3
20453: AND
20454: IFFALSE 20596
// if MCF_Tag ( i , 9 , [ ] ) < 3 then
20456: LD_VAR 0 1
20460: PPUSH
20461: LD_INT 9
20463: PPUSH
20464: EMPTY
20465: PPUSH
20466: CALL 703 0 3
20470: PUSH
20471: LD_INT 3
20473: LESS
20474: IFFALSE 20596
// begin if mech < 3 then
20476: LD_VAR 0 15
20480: PUSH
20481: LD_INT 3
20483: LESS
20484: IFFALSE 20498
// f := mech else
20486: LD_ADDR_VAR 0 9
20490: PUSH
20491: LD_VAR 0 15
20495: ST_TO_ADDR
20496: GO 20506
// f := 3 ;
20498: LD_ADDR_VAR 0 9
20502: PUSH
20503: LD_INT 3
20505: ST_TO_ADDR
// for c = 1 to f do
20506: LD_ADDR_VAR 0 7
20510: PUSH
20511: DOUBLE
20512: LD_INT 1
20514: DEC
20515: ST_TO_ADDR
20516: LD_VAR 0 9
20520: PUSH
20521: FOR_TO
20522: IFFALSE 20580
// if GetClass ( mech [ c ] ) = 3 then
20524: LD_VAR 0 15
20528: PUSH
20529: LD_VAR 0 7
20533: ARRAY
20534: PPUSH
20535: CALL_OW 257
20539: PUSH
20540: LD_INT 3
20542: EQUAL
20543: IFFALSE 20578
// begin SetTag ( mech [ c ] , 9 ) ;
20545: LD_VAR 0 15
20549: PUSH
20550: LD_VAR 0 7
20554: ARRAY
20555: PPUSH
20556: LD_INT 9
20558: PPUSH
20559: CALL_OW 109
// ComExitBuilding ( mech [ c ] ) ;
20563: LD_VAR 0 15
20567: PUSH
20568: LD_VAR 0 7
20572: ARRAY
20573: PPUSH
20574: CALL_OW 122
// end ;
20578: GO 20521
20580: POP
20581: POP
// MCH_TrainMechanic ( i , f ) ;
20582: LD_VAR 0 1
20586: PPUSH
20587: LD_VAR 0 9
20591: PPUSH
20592: CALL 23397 0 2
// end ; if MCF_Tag ( i , 9 , [ ] ) then
20596: LD_VAR 0 1
20600: PPUSH
20601: LD_INT 9
20603: PPUSH
20604: EMPTY
20605: PPUSH
20606: CALL 703 0 3
20610: IFFALSE 20689
// for c in MCF_Tag ( i , 9 , [ ] ) do
20612: LD_ADDR_VAR 0 7
20616: PUSH
20617: LD_VAR 0 1
20621: PPUSH
20622: LD_INT 9
20624: PPUSH
20625: EMPTY
20626: PPUSH
20627: CALL 703 0 3
20631: PUSH
20632: FOR_IN
20633: IFFALSE 20687
// if not IsInUnit ( c ) then
20635: LD_VAR 0 7
20639: PPUSH
20640: CALL_OW 310
20644: NOT
20645: IFFALSE 20685
// if ct then
20647: LD_VAR 0 17
20651: IFFALSE 20673
// ComEnterUnit ( c , ct [ 1 ] ) else
20653: LD_VAR 0 7
20657: PPUSH
20658: LD_VAR 0 17
20662: PUSH
20663: LD_INT 1
20665: ARRAY
20666: PPUSH
20667: CALL_OW 120
20671: GO 20685
// SetTag ( c , 0 ) ;
20673: LD_VAR 0 7
20677: PPUSH
20678: LD_INT 0
20680: PPUSH
20681: CALL_OW 109
20685: GO 20632
20687: POP
20688: POP
// end ; if MCF_Class ( i , 3 , [ ] ) and MREG_Parking [ i ] and MCF_Tag ( i , 6 , [ ] ) then
20689: LD_VAR 0 1
20693: PPUSH
20694: LD_INT 3
20696: PPUSH
20697: EMPTY
20698: PPUSH
20699: CALL 83 0 3
20703: PUSH
20704: LD_EXP 27
20708: PUSH
20709: LD_VAR 0 1
20713: ARRAY
20714: AND
20715: PUSH
20716: LD_VAR 0 1
20720: PPUSH
20721: LD_INT 6
20723: PPUSH
20724: EMPTY
20725: PPUSH
20726: CALL 703 0 3
20730: AND
20731: IFFALSE 21104
// begin x := AreaToList ( MREG_Parking [ i ] , 0 ) [ 1 ] [ 1 ] ;
20733: LD_ADDR_VAR 0 11
20737: PUSH
20738: LD_EXP 27
20742: PUSH
20743: LD_VAR 0 1
20747: ARRAY
20748: PPUSH
20749: LD_INT 0
20751: PPUSH
20752: CALL_OW 517
20756: PUSH
20757: LD_INT 1
20759: ARRAY
20760: PUSH
20761: LD_INT 1
20763: ARRAY
20764: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ i ] , 0 ) [ 2 ] [ 1 ] ;
20765: LD_ADDR_VAR 0 12
20769: PUSH
20770: LD_EXP 27
20774: PUSH
20775: LD_VAR 0 1
20779: ARRAY
20780: PPUSH
20781: LD_INT 0
20783: PPUSH
20784: CALL_OW 517
20788: PUSH
20789: LD_INT 2
20791: ARRAY
20792: PUSH
20793: LD_INT 1
20795: ARRAY
20796: ST_TO_ADDR
// if MCF_Tag ( i , 6 , [ ] ) then
20797: LD_VAR 0 1
20801: PPUSH
20802: LD_INT 6
20804: PPUSH
20805: EMPTY
20806: PPUSH
20807: CALL 703 0 3
20811: IFFALSE 21102
// begin for k in MCF_Tag ( i , 6 , [ ] ) do
20813: LD_ADDR_VAR 0 10
20817: PUSH
20818: LD_VAR 0 1
20822: PPUSH
20823: LD_INT 6
20825: PPUSH
20826: EMPTY
20827: PPUSH
20828: CALL 703 0 3
20832: PUSH
20833: FOR_IN
20834: IFFALSE 20865
// if GetLives ( k ) = 1000 then
20836: LD_VAR 0 10
20840: PPUSH
20841: CALL_OW 256
20845: PUSH
20846: LD_INT 1000
20848: EQUAL
20849: IFFALSE 20863
// SetTag ( k , 0 ) ;
20851: LD_VAR 0 10
20855: PPUSH
20856: LD_INT 0
20858: PPUSH
20859: CALL_OW 109
20863: GO 20833
20865: POP
20866: POP
// if MCF_Tag ( i , 0 , [ f_class , 3 ] ) then
20867: LD_VAR 0 1
20871: PPUSH
20872: LD_INT 0
20874: PPUSH
20875: LD_INT 25
20877: PUSH
20878: LD_INT 3
20880: PUSH
20881: EMPTY
20882: LIST
20883: LIST
20884: PPUSH
20885: CALL 703 0 3
20889: IFFALSE 20953
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
20891: LD_ADDR_VAR 0 10
20895: PUSH
20896: LD_VAR 0 1
20900: PPUSH
20901: LD_INT 0
20903: PPUSH
20904: LD_INT 25
20906: PUSH
20907: LD_INT 3
20909: PUSH
20910: EMPTY
20911: LIST
20912: LIST
20913: PPUSH
20914: CALL 703 0 3
20918: PUSH
20919: FOR_IN
20920: IFFALSE 20951
// if GetTag ( k ) = 0 then
20922: LD_VAR 0 10
20926: PPUSH
20927: CALL_OW 110
20931: PUSH
20932: LD_INT 0
20934: EQUAL
20935: IFFALSE 20949
// begin SetTag ( k , 8 ) ;
20937: LD_VAR 0 10
20941: PPUSH
20942: LD_INT 8
20944: PPUSH
20945: CALL_OW 109
// end ;
20949: GO 20919
20951: POP
20952: POP
// end ; if MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( i , 8 , [ ] ) then
20953: LD_VAR 0 1
20957: PPUSH
20958: LD_INT 6
20960: PPUSH
20961: LD_INT 92
20963: PUSH
20964: LD_VAR 0 11
20968: PUSH
20969: LD_VAR 0 12
20973: PUSH
20974: LD_INT 10
20976: PUSH
20977: EMPTY
20978: LIST
20979: LIST
20980: LIST
20981: LIST
20982: PPUSH
20983: CALL 703 0 3
20987: PUSH
20988: LD_VAR 0 1
20992: PPUSH
20993: LD_INT 8
20995: PPUSH
20996: EMPTY
20997: PPUSH
20998: CALL 703 0 3
21002: AND
21003: IFFALSE 21102
// for j in MCF_Tag ( i , 8 , [ ] ) do
21005: LD_ADDR_VAR 0 2
21009: PUSH
21010: LD_VAR 0 1
21014: PPUSH
21015: LD_INT 8
21017: PPUSH
21018: EMPTY
21019: PPUSH
21020: CALL 703 0 3
21024: PUSH
21025: FOR_IN
21026: IFFALSE 21100
// begin if IsInUnit ( j ) then
21028: LD_VAR 0 2
21032: PPUSH
21033: CALL_OW 310
21037: IFFALSE 21050
// ComExitBuilding ( j ) else
21039: LD_VAR 0 2
21043: PPUSH
21044: CALL_OW 122
21048: GO 21098
// ComRepairVehicle ( j , MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
21050: LD_VAR 0 2
21054: PPUSH
21055: LD_VAR 0 1
21059: PPUSH
21060: LD_INT 6
21062: PPUSH
21063: LD_INT 92
21065: PUSH
21066: LD_VAR 0 11
21070: PUSH
21071: LD_VAR 0 12
21075: PUSH
21076: LD_INT 10
21078: PUSH
21079: EMPTY
21080: LIST
21081: LIST
21082: LIST
21083: LIST
21084: PPUSH
21085: CALL 703 0 3
21089: PUSH
21090: LD_INT 1
21092: ARRAY
21093: PPUSH
21094: CALL_OW 129
// end ;
21098: GO 21025
21100: POP
21101: POP
// end ; end else
21102: GO 21159
// if MCF_Tag ( i , 8 , [ ] ) then
21104: LD_VAR 0 1
21108: PPUSH
21109: LD_INT 8
21111: PPUSH
21112: EMPTY
21113: PPUSH
21114: CALL 703 0 3
21118: IFFALSE 21159
// for k in MCF_Tag ( i , 8 , [ ] ) do
21120: LD_ADDR_VAR 0 10
21124: PUSH
21125: LD_VAR 0 1
21129: PPUSH
21130: LD_INT 8
21132: PPUSH
21133: EMPTY
21134: PPUSH
21135: CALL 703 0 3
21139: PUSH
21140: FOR_IN
21141: IFFALSE 21157
// SetTag ( k , 0 ) ;
21143: LD_VAR 0 10
21147: PPUSH
21148: LD_INT 0
21150: PPUSH
21151: CALL_OW 109
21155: GO 21140
21157: POP
21158: POP
// if MCF_Get ( i , [ f_btype , b_warehouse ] ) then
21159: LD_VAR 0 1
21163: PPUSH
21164: LD_INT 30
21166: PUSH
21167: LD_INT 1
21169: PUSH
21170: EMPTY
21171: LIST
21172: LIST
21173: PPUSH
21174: CALL 0 0 2
21178: IFFALSE 21323
// begin b := MCF_Get ( i , [ f_btype , b_warehouse ] ) ;
21180: LD_ADDR_VAR 0 5
21184: PUSH
21185: LD_VAR 0 1
21189: PPUSH
21190: LD_INT 30
21192: PUSH
21193: LD_INT 1
21195: PUSH
21196: EMPTY
21197: LIST
21198: LIST
21199: PPUSH
21200: CALL 0 0 2
21204: ST_TO_ADDR
// if BuildingStatus ( b ) <> bs_build then
21205: LD_VAR 0 5
21209: PPUSH
21210: CALL_OW 461
21214: PUSH
21215: LD_INT 1
21217: NONEQUAL
21218: IFFALSE 21323
// begin if eng < all - sci - mech then
21220: LD_VAR 0 14
21224: PUSH
21225: LD_VAR 0 13
21229: PUSH
21230: LD_VAR 0 16
21234: MINUS
21235: PUSH
21236: LD_VAR 0 15
21240: MINUS
21241: LESS
21242: IFFALSE 21270
// MCH_TrainEngineer ( i , all - sci - mech ) ;
21244: LD_VAR 0 1
21248: PPUSH
21249: LD_VAR 0 13
21253: PUSH
21254: LD_VAR 0 16
21258: MINUS
21259: PUSH
21260: LD_VAR 0 15
21264: MINUS
21265: PPUSH
21266: CALL 23159 0 2
// if UnitsInside ( b ) and MCF_UnfinishedBuilding ( i ) then
21270: LD_VAR 0 5
21274: PPUSH
21275: CALL_OW 313
21279: PUSH
21280: LD_VAR 0 1
21284: PPUSH
21285: CALL 3098 0 1
21289: AND
21290: IFFALSE 21323
// for e in UnitsInside ( b ) do
21292: LD_ADDR_VAR 0 8
21296: PUSH
21297: LD_VAR 0 5
21301: PPUSH
21302: CALL_OW 313
21306: PUSH
21307: FOR_IN
21308: IFFALSE 21321
// ComExitBuilding ( e ) ;
21310: LD_VAR 0 8
21314: PPUSH
21315: CALL_OW 122
21319: GO 21307
21321: POP
21322: POP
// end ; end ; end ; end ;
21323: GO 18916
21325: POP
21326: POP
// end ; end_of_file
21327: PPOPN 19
21329: END
// on SailEvent ( event ) do begin if isEditor then
21330: LD_INT 1
21332: IFFALSE 21343
// MC_Show ( event ) ;
21334: LD_VAR 0 1
21338: PPUSH
21339: CALL 4025 0 1
// end ;
21343: PPOPN 1
21345: END
// on BuildingStarted ( b , unit ) do var side , i ;
21346: LD_INT 0
21348: PPUSH
21349: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
21350: LD_EXP 7
21354: PUSH
21355: LD_VAR 0 1
21359: PPUSH
21360: CALL_OW 255
21364: ARRAY
21365: IFFALSE 21496
// begin side := GetSide ( b ) ;
21367: LD_ADDR_VAR 0 3
21371: PUSH
21372: LD_VAR 0 1
21376: PPUSH
21377: CALL_OW 255
21381: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
21382: LD_VAR 0 3
21386: PPUSH
21387: LD_INT 21
21389: PUSH
21390: LD_INT 3
21392: PUSH
21393: EMPTY
21394: LIST
21395: LIST
21396: PPUSH
21397: CALL 0 0 2
21401: PUSH
21402: LD_INT 1
21404: EQUAL
21405: IFFALSE 21496
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
21407: LD_ADDR_VAR 0 4
21411: PUSH
21412: LD_VAR 0 3
21416: PPUSH
21417: LD_INT 21
21419: PUSH
21420: LD_INT 1
21422: PUSH
21423: EMPTY
21424: LIST
21425: LIST
21426: PPUSH
21427: CALL 0 0 2
21431: PUSH
21432: LD_VAR 0 3
21436: PPUSH
21437: LD_INT 2
21439: PPUSH
21440: EMPTY
21441: PPUSH
21442: CALL 83 0 3
21446: DIFF
21447: PUSH
21448: FOR_IN
21449: IFFALSE 21494
// if not HasTask ( i ) then
21451: LD_VAR 0 4
21455: PPUSH
21456: CALL_OW 314
21460: NOT
21461: IFFALSE 21492
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
21463: LD_VAR 0 4
21467: PPUSH
21468: LD_VAR 0 1
21472: PPUSH
21473: CALL_OW 250
21477: PPUSH
21478: LD_VAR 0 1
21482: PPUSH
21483: CALL_OW 251
21487: PPUSH
21488: CALL_OW 111
21492: GO 21448
21494: POP
21495: POP
// end ;
21496: PPOPN 4
21498: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
21499: LD_EXP 7
21503: PUSH
21504: LD_VAR 0 1
21508: PPUSH
21509: CALL_OW 255
21513: ARRAY
21514: IFFALSE 21846
// begin MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
21516: LD_ADDR_EXP 15
21520: PUSH
21521: LD_EXP 15
21525: PPUSH
21526: LD_VAR 0 1
21530: PPUSH
21531: CALL_OW 255
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: CALL_OW 266
21545: PPUSH
21546: LD_VAR 0 1
21550: PPUSH
21551: CALL_OW 250
21555: PUSH
21556: LD_VAR 0 1
21560: PPUSH
21561: CALL_OW 251
21565: PUSH
21566: LD_VAR 0 1
21570: PPUSH
21571: CALL_OW 254
21575: PUSH
21576: EMPTY
21577: LIST
21578: LIST
21579: LIST
21580: PPUSH
21581: CALL 4350 0 4
21585: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
21586: LD_VAR 0 1
21590: PPUSH
21591: CALL_OW 266
21595: PUSH
21596: LD_INT 6
21598: EQUAL
21599: IFFALSE 21633
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
21601: LD_ADDR_EXP 8
21605: PUSH
21606: LD_EXP 8
21610: PPUSH
21611: LD_VAR 0 1
21615: PPUSH
21616: CALL_OW 255
21620: PPUSH
21621: LD_VAR 0 1
21625: PPUSH
21626: EMPTY
21627: PPUSH
21628: CALL 4259 0 4
21632: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
21633: LD_VAR 0 1
21637: PPUSH
21638: CALL_OW 266
21642: PUSH
21643: LD_INT 0
21645: EQUAL
21646: IFFALSE 21756
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
21648: LD_ADDR_EXP 17
21652: PUSH
21653: LD_EXP 17
21657: PPUSH
21658: LD_VAR 0 1
21662: PPUSH
21663: CALL_OW 255
21667: PPUSH
21668: LD_INT 0
21670: PPUSH
21671: EMPTY
21672: PPUSH
21673: CALL 4259 0 4
21677: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
21678: LD_VAR 0 1
21682: PPUSH
21683: CALL_OW 274
21687: PPUSH
21688: LD_INT 1
21690: PPUSH
21691: LD_EXP 31
21695: PUSH
21696: LD_INT 1
21698: ARRAY
21699: PPUSH
21700: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 274
21713: PPUSH
21714: LD_INT 2
21716: PPUSH
21717: LD_EXP 31
21721: PUSH
21722: LD_INT 2
21724: ARRAY
21725: PPUSH
21726: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
21730: LD_VAR 0 1
21734: PPUSH
21735: CALL_OW 274
21739: PPUSH
21740: LD_INT 3
21742: PPUSH
21743: LD_EXP 31
21747: PUSH
21748: LD_INT 3
21750: ARRAY
21751: PPUSH
21752: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
21756: LD_VAR 0 1
21760: PPUSH
21761: CALL_OW 266
21765: PUSH
21766: LD_INT 2
21768: EQUAL
21769: IFFALSE 21801
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
21771: LD_ADDR_EXP 17
21775: PUSH
21776: LD_EXP 17
21780: PPUSH
21781: LD_VAR 0 1
21785: PPUSH
21786: CALL_OW 255
21790: PPUSH
21791: LD_INT 2
21793: PPUSH
21794: EMPTY
21795: PPUSH
21796: CALL 4259 0 4
21800: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
21801: LD_VAR 0 1
21805: PPUSH
21806: CALL_OW 266
21810: PUSH
21811: LD_INT 4
21813: EQUAL
21814: IFFALSE 21846
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
21816: LD_ADDR_EXP 17
21820: PUSH
21821: LD_EXP 17
21825: PPUSH
21826: LD_VAR 0 1
21830: PPUSH
21831: CALL_OW 255
21835: PPUSH
21836: LD_INT 4
21838: PPUSH
21839: EMPTY
21840: PPUSH
21841: CALL 4259 0 4
21845: ST_TO_ADDR
// end ;
21846: PPOPN 1
21848: END
// on ResearchComplete ( tech , lab ) do var i ;
21849: LD_INT 0
21851: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
21852: LD_EXP 7
21856: PUSH
21857: LD_VAR 0 2
21861: PPUSH
21862: CALL_OW 255
21866: ARRAY
21867: IFFALSE 22114
// begin for i = 1 to MREG_ToRes do
21869: LD_ADDR_VAR 0 3
21873: PUSH
21874: DOUBLE
21875: LD_INT 1
21877: DEC
21878: ST_TO_ADDR
21879: LD_EXP 19
21883: PUSH
21884: FOR_TO
21885: IFFALSE 21972
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
21887: LD_EXP 19
21891: PUSH
21892: LD_VAR 0 3
21896: ARRAY
21897: PUSH
21898: LD_INT 1
21900: ARRAY
21901: PUSH
21902: LD_VAR 0 2
21906: PPUSH
21907: CALL_OW 255
21911: EQUAL
21912: PUSH
21913: LD_EXP 19
21917: PUSH
21918: LD_VAR 0 3
21922: ARRAY
21923: PUSH
21924: LD_INT 2
21926: ARRAY
21927: PUSH
21928: LD_VAR 0 1
21932: EQUAL
21933: AND
21934: IFFALSE 21970
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
21936: LD_ADDR_EXP 19
21940: PUSH
21941: LD_EXP 19
21945: PPUSH
21946: LD_VAR 0 2
21950: PPUSH
21951: CALL_OW 255
21955: PPUSH
21956: LD_VAR 0 1
21960: PPUSH
21961: EMPTY
21962: PPUSH
21963: CALL 4350 0 4
21967: ST_TO_ADDR
// break ;
21968: GO 21972
// end ;
21970: GO 21884
21972: POP
21973: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
21974: LD_VAR 0 1
21978: PUSH
21979: LD_INT 2
21981: PUSH
21982: LD_INT 11
21984: PUSH
21985: LD_INT 4
21987: PUSH
21988: LD_INT 3
21990: PUSH
21991: EMPTY
21992: LIST
21993: LIST
21994: LIST
21995: LIST
21996: IN
21997: IFFALSE 22114
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
21999: LD_ADDR_VAR 0 3
22003: PUSH
22004: LD_VAR 0 2
22008: PPUSH
22009: CALL_OW 255
22013: PPUSH
22014: LD_INT 16
22016: PPUSH
22017: LD_INT 25
22019: PUSH
22020: LD_INT 4
22022: PUSH
22023: EMPTY
22024: LIST
22025: LIST
22026: PPUSH
22027: CALL 703 0 3
22031: ST_TO_ADDR
// if i then
22032: LD_VAR 0 3
22036: IFFALSE 22054
// SetTag ( i [ 1 ] , 0 ) ;
22038: LD_VAR 0 3
22042: PUSH
22043: LD_INT 1
22045: ARRAY
22046: PPUSH
22047: LD_INT 0
22049: PPUSH
22050: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
22054: LD_ADDR_VAR 0 3
22058: PUSH
22059: LD_VAR 0 2
22063: PPUSH
22064: CALL_OW 255
22068: PPUSH
22069: LD_INT 171
22071: PPUSH
22072: EMPTY
22073: PPUSH
22074: CALL 703 0 3
22078: ST_TO_ADDR
// if i then
22079: LD_VAR 0 3
22083: IFFALSE 22114
// begin SetTag ( i [ 1 ] , 0 ) ;
22085: LD_VAR 0 3
22089: PUSH
22090: LD_INT 1
22092: ARRAY
22093: PPUSH
22094: LD_INT 0
22096: PPUSH
22097: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
22101: LD_VAR 0 3
22105: PUSH
22106: LD_INT 1
22108: ARRAY
22109: PPUSH
22110: CALL_OW 122
// end ; end ; end ;
22114: PPOPN 3
22116: END
// on VehicleConstructed ( veh , b ) do var i , side ;
22117: LD_INT 0
22119: PPUSH
22120: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
22121: LD_EXP 7
22125: PUSH
22126: LD_VAR 0 2
22130: PPUSH
22131: CALL_OW 255
22135: ARRAY
22136: IFFALSE 22287
// begin side := GetSide ( veh ) ;
22138: LD_ADDR_VAR 0 4
22142: PUSH
22143: LD_VAR 0 1
22147: PPUSH
22148: CALL_OW 255
22152: ST_TO_ADDR
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
22153: LD_VAR 0 1
22157: PPUSH
22158: CALL_OW 264
22162: PUSH
22163: LD_INT 13
22165: PUSH
22166: LD_INT 12
22168: PUSH
22169: LD_INT 14
22171: PUSH
22172: LD_INT 51
22174: PUSH
22175: LD_INT 53
22177: PUSH
22178: LD_INT 52
22180: PUSH
22181: LD_INT 32
22183: PUSH
22184: EMPTY
22185: LIST
22186: LIST
22187: LIST
22188: LIST
22189: LIST
22190: LIST
22191: LIST
22192: IN
22193: NOT
22194: IFFALSE 22236
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
22196: LD_ADDR_EXP 28
22200: PUSH
22201: LD_EXP 28
22205: PPUSH
22206: LD_VAR 0 4
22210: PPUSH
22211: LD_EXP 28
22215: PUSH
22216: LD_VAR 0 4
22220: ARRAY
22221: PUSH
22222: LD_INT 1
22224: PLUS
22225: PPUSH
22226: LD_VAR 0 1
22230: PPUSH
22231: CALL 24638 0 4
22235: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
22236: LD_VAR 0 1
22240: PPUSH
22241: CALL_OW 264
22245: PUSH
22246: LD_INT 31
22248: EQUAL
22249: IFFALSE 22268
// SetTag ( GetDriver ( veh ) , 9 ) ;
22251: LD_VAR 0 1
22255: PPUSH
22256: CALL 25249 0 1
22260: PPUSH
22261: LD_INT 9
22263: PPUSH
22264: CALL_OW 109
// MCV_Parking ( GetSide ( veh ) , veh ) ;
22268: LD_VAR 0 1
22272: PPUSH
22273: CALL_OW 255
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: CALL 14983 0 2
// end ;
22287: PPOPN 4
22289: END
// on ApemanTamed ( ape , unit ) do begin if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
22290: LD_INT 11
22292: PPUSH
22293: LD_VAR 0 2
22297: PPUSH
22298: CALL_OW 255
22302: PPUSH
22303: CALL_OW 321
22307: PUSH
22308: LD_INT 2
22310: EQUAL
22311: NOT
22312: PUSH
22313: LD_INT 2
22315: PPUSH
22316: LD_VAR 0 2
22320: PPUSH
22321: CALL_OW 255
22325: PPUSH
22326: CALL_OW 321
22330: PUSH
22331: LD_INT 2
22333: EQUAL
22334: NOT
22335: OR
22336: PUSH
22337: LD_VAR 0 2
22341: PPUSH
22342: CALL_OW 255
22346: PPUSH
22347: LD_INT 171
22349: PPUSH
22350: EMPTY
22351: PPUSH
22352: CALL 703 0 3
22356: PUSH
22357: LD_INT 0
22359: EQUAL
22360: AND
22361: IFFALSE 22375
// begin SetTag ( ape , 171 ) ;
22363: LD_VAR 0 1
22367: PPUSH
22368: LD_INT 171
22370: PPUSH
22371: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
22375: LD_VAR 0 2
22379: PPUSH
22380: CALL_OW 255
22384: PPUSH
22385: LD_INT 30
22387: PUSH
22388: LD_INT 1
22390: PUSH
22391: EMPTY
22392: LIST
22393: LIST
22394: PPUSH
22395: CALL 0 0 2
22399: IFFALSE 22478
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
22401: LD_VAR 0 1
22405: PPUSH
22406: LD_VAR 0 2
22410: PPUSH
22411: CALL_OW 255
22415: PPUSH
22416: LD_INT 30
22418: PUSH
22419: LD_INT 1
22421: PUSH
22422: EMPTY
22423: LIST
22424: LIST
22425: PPUSH
22426: CALL 0 0 2
22430: PUSH
22431: LD_INT 1
22433: ARRAY
22434: PPUSH
22435: CALL_OW 250
22439: PPUSH
22440: LD_VAR 0 2
22444: PPUSH
22445: CALL_OW 255
22449: PPUSH
22450: LD_INT 30
22452: PUSH
22453: LD_INT 1
22455: PUSH
22456: EMPTY
22457: LIST
22458: LIST
22459: PPUSH
22460: CALL 0 0 2
22464: PUSH
22465: LD_INT 1
22467: ARRAY
22468: PPUSH
22469: CALL_OW 251
22473: PPUSH
22474: CALL_OW 111
// end ;
22478: PPOPN 2
22480: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
22481: LD_EXP 7
22485: PUSH
22486: LD_VAR 0 1
22490: PPUSH
22491: CALL_OW 255
22495: ARRAY
22496: IFFALSE 22668
// begin if un in MCF_Ape ( GetSide ( un ) ) then
22498: LD_VAR 0 2
22502: PUSH
22503: LD_VAR 0 2
22507: PPUSH
22508: CALL_OW 255
22512: PPUSH
22513: CALL 413 0 1
22517: IN
22518: IFFALSE 22668
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
22520: LD_VAR 0 1
22524: PPUSH
22525: CALL_OW 266
22529: PUSH
22530: LD_INT 0
22532: PUSH
22533: LD_INT 1
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: IN
22540: IFFALSE 22570
// begin Wait ( 0 0$0.3 ) ;
22542: LD_INT 10
22544: PPUSH
22545: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
22549: LD_VAR 0 2
22553: PPUSH
22554: LD_INT 16
22556: PPUSH
22557: CALL_OW 336
// ComExitBuilding ( un ) ;
22561: LD_VAR 0 2
22565: PPUSH
22566: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
22570: LD_VAR 0 1
22574: PPUSH
22575: CALL_OW 266
22579: PUSH
22580: LD_INT 4
22582: PUSH
22583: LD_INT 5
22585: PUSH
22586: EMPTY
22587: LIST
22588: LIST
22589: IN
22590: IFFALSE 22668
// begin Wait ( 0 0$0.3 ) ;
22592: LD_INT 10
22594: PPUSH
22595: CALL_OW 67
// if GetTag ( un ) = 0 then
22599: LD_VAR 0 2
22603: PPUSH
22604: CALL_OW 110
22608: PUSH
22609: LD_INT 0
22611: EQUAL
22612: IFFALSE 22628
// SetClass ( un , class_apeman_soldier ) else
22614: LD_VAR 0 2
22618: PPUSH
22619: LD_INT 15
22621: PPUSH
22622: CALL_OW 336
22626: GO 22659
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
22628: LD_INT 3
22630: PPUSH
22631: LD_VAR 0 2
22635: PPUSH
22636: CALL_OW 255
22640: PPUSH
22641: CALL_OW 321
22645: IFFALSE 22659
// SetClass ( un , class_apeman_kamikaze ) ;
22647: LD_VAR 0 2
22651: PPUSH
22652: LD_INT 17
22654: PPUSH
22655: CALL_OW 336
// ComExitBuilding ( un ) ;
22659: LD_VAR 0 2
22663: PPUSH
22664: CALL_OW 122
// end ; end ; end ;
22668: PPOPN 2
22670: END
// on UnitDestroyed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
22671: LD_EXP 7
22675: PUSH
22676: LD_VAR 0 1
22680: PPUSH
22681: CALL_OW 255
22685: ARRAY
22686: IFFALSE 22874
// begin if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
22688: LD_VAR 0 1
22692: PUSH
22693: LD_VAR 0 1
22697: PPUSH
22698: CALL_OW 255
22702: PPUSH
22703: LD_INT 21
22705: PUSH
22706: LD_INT 1
22708: PUSH
22709: EMPTY
22710: LIST
22711: LIST
22712: PPUSH
22713: CALL 0 0 2
22717: IN
22718: IFFALSE 22874
// begin if MCF_HasClass ( un ) then
22720: LD_VAR 0 1
22724: PPUSH
22725: CALL 2554 0 1
22729: IFFALSE 22874
// case MCF_HasClass ( un ) of 1 :
22731: LD_VAR 0 1
22735: PPUSH
22736: CALL 2554 0 1
22740: PUSH
22741: LD_INT 1
22743: DOUBLE
22744: EQUAL
22745: IFTRUE 22749
22747: GO 22774
22749: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
22750: LD_VAR 0 1
22754: PPUSH
22755: CALL_OW 255
22759: PPUSH
22760: LD_STRING ToArm
22762: PPUSH
22763: LD_VAR 0 1
22767: PPUSH
22768: CALL 2701 0 3
22772: GO 22874
22774: LD_INT 2
22776: DOUBLE
22777: EQUAL
22778: IFTRUE 22782
22780: GO 22807
22782: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
22783: LD_VAR 0 1
22787: PPUSH
22788: CALL_OW 255
22792: PPUSH
22793: LD_STRING ToDep
22795: PPUSH
22796: LD_VAR 0 1
22800: PPUSH
22801: CALL 2701 0 3
22805: GO 22874
22807: LD_INT 3
22809: DOUBLE
22810: EQUAL
22811: IFTRUE 22815
22813: GO 22840
22815: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
22816: LD_VAR 0 1
22820: PPUSH
22821: CALL_OW 255
22825: PPUSH
22826: LD_STRING ToFac
22828: PPUSH
22829: LD_VAR 0 1
22833: PPUSH
22834: CALL 2701 0 3
22838: GO 22874
22840: LD_INT 4
22842: DOUBLE
22843: EQUAL
22844: IFTRUE 22848
22846: GO 22873
22848: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
22849: LD_VAR 0 1
22853: PPUSH
22854: CALL_OW 255
22858: PPUSH
22859: LD_STRING ToLab
22861: PPUSH
22862: LD_VAR 0 1
22866: PPUSH
22867: CALL 2701 0 3
22871: GO 22874
22873: POP
// end ; end ;
22874: PPOPN 1
22876: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
22877: LD_EXP 7
22881: PUSH
22882: LD_VAR 0 1
22886: PPUSH
22887: CALL_OW 255
22891: ARRAY
22892: IFFALSE 22918
// begin if GetControl ( un ) = control_remote then
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 263
22903: PUSH
22904: LD_INT 2
22906: EQUAL
22907: IFFALSE 22918
// ComUnlink ( un ) ;
22909: LD_VAR 0 1
22913: PPUSH
22914: CALL_OW 136
// end ; end_of_file
22918: PPOPN 1
22920: END
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
22921: LD_INT 0
22923: PPUSH
22924: PPUSH
22925: PPUSH
22926: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
22927: LD_ADDR_VAR 0 5
22931: PUSH
22932: LD_VAR 0 1
22936: PPUSH
22937: LD_INT 2
22939: PUSH
22940: LD_INT 25
22942: PUSH
22943: LD_INT 2
22945: PUSH
22946: EMPTY
22947: LIST
22948: LIST
22949: PUSH
22950: LD_INT 25
22952: PUSH
22953: LD_INT 3
22955: PUSH
22956: EMPTY
22957: LIST
22958: LIST
22959: PUSH
22960: LD_INT 25
22962: PUSH
22963: LD_INT 4
22965: PUSH
22966: EMPTY
22967: LIST
22968: LIST
22969: PUSH
22970: EMPTY
22971: LIST
22972: LIST
22973: LIST
22974: LIST
22975: PPUSH
22976: CALL 0 0 2
22980: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
22981: LD_ADDR_VAR 0 5
22985: PUSH
22986: LD_VAR 0 5
22990: PPUSH
22991: LD_INT 0
22993: PPUSH
22994: CALL 2149 0 2
22998: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
22999: LD_ADDR_VAR 0 6
23003: PUSH
23004: LD_VAR 0 1
23008: PPUSH
23009: LD_VAR 0 5
23013: PPUSH
23014: LD_INT 1
23016: PPUSH
23017: CALL 1769 0 3
23021: ST_TO_ADDR
// if n > sk then
23022: LD_VAR 0 2
23026: PUSH
23027: LD_VAR 0 6
23031: GREATER
23032: IFFALSE 23044
// n := sk ;
23034: LD_ADDR_VAR 0 2
23038: PUSH
23039: LD_VAR 0 6
23043: ST_TO_ADDR
// for i = 1 to n do
23044: LD_ADDR_VAR 0 4
23048: PUSH
23049: DOUBLE
23050: LD_INT 1
23052: DEC
23053: ST_TO_ADDR
23054: LD_VAR 0 2
23058: PUSH
23059: FOR_TO
23060: IFFALSE 23152
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
23062: LD_ADDR_EXP 22
23066: PUSH
23067: LD_EXP 22
23071: PPUSH
23072: LD_VAR 0 1
23076: PPUSH
23077: LD_VAR 0 6
23081: PUSH
23082: LD_VAR 0 4
23086: ARRAY
23087: PUSH
23088: LD_INT 1
23090: ARRAY
23091: PPUSH
23092: LD_INT 1
23094: PPUSH
23095: CALL 4259 0 4
23099: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
23100: LD_ADDR_EXP 25
23104: PUSH
23105: LD_EXP 25
23109: PPUSH
23110: LD_VAR 0 1
23114: PPUSH
23115: LD_EXP 25
23119: PUSH
23120: LD_VAR 0 1
23124: ARRAY
23125: PUSH
23126: LD_INT 1
23128: PLUS
23129: PPUSH
23130: LD_VAR 0 6
23134: PUSH
23135: LD_VAR 0 4
23139: ARRAY
23140: PUSH
23141: LD_INT 1
23143: ARRAY
23144: PPUSH
23145: CALL 24638 0 4
23149: ST_TO_ADDR
// end ;
23150: GO 23059
23152: POP
23153: POP
// end ;
23154: LD_VAR 0 3
23158: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
23159: LD_INT 0
23161: PPUSH
23162: PPUSH
23163: PPUSH
23164: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
23165: LD_ADDR_VAR 0 5
23169: PUSH
23170: LD_VAR 0 1
23174: PPUSH
23175: LD_INT 2
23177: PUSH
23178: LD_INT 25
23180: PUSH
23181: LD_INT 1
23183: PUSH
23184: EMPTY
23185: LIST
23186: LIST
23187: PUSH
23188: LD_INT 25
23190: PUSH
23191: LD_INT 3
23193: PUSH
23194: EMPTY
23195: LIST
23196: LIST
23197: PUSH
23198: LD_INT 25
23200: PUSH
23201: LD_INT 4
23203: PUSH
23204: EMPTY
23205: LIST
23206: LIST
23207: PUSH
23208: EMPTY
23209: LIST
23210: LIST
23211: LIST
23212: LIST
23213: PPUSH
23214: CALL 0 0 2
23218: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
23219: LD_ADDR_VAR 0 5
23223: PUSH
23224: LD_VAR 0 5
23228: PPUSH
23229: LD_INT 0
23231: PPUSH
23232: CALL 2149 0 2
23236: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
23237: LD_ADDR_VAR 0 6
23241: PUSH
23242: LD_VAR 0 1
23246: PPUSH
23247: LD_VAR 0 5
23251: PPUSH
23252: LD_INT 2
23254: PPUSH
23255: CALL 1769 0 3
23259: ST_TO_ADDR
// if n > sk then
23260: LD_VAR 0 2
23264: PUSH
23265: LD_VAR 0 6
23269: GREATER
23270: IFFALSE 23282
// n := sk ;
23272: LD_ADDR_VAR 0 2
23276: PUSH
23277: LD_VAR 0 6
23281: ST_TO_ADDR
// for i = 1 to n do
23282: LD_ADDR_VAR 0 4
23286: PUSH
23287: DOUBLE
23288: LD_INT 1
23290: DEC
23291: ST_TO_ADDR
23292: LD_VAR 0 2
23296: PUSH
23297: FOR_TO
23298: IFFALSE 23390
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
23300: LD_ADDR_EXP 22
23304: PUSH
23305: LD_EXP 22
23309: PPUSH
23310: LD_VAR 0 1
23314: PPUSH
23315: LD_VAR 0 6
23319: PUSH
23320: LD_VAR 0 4
23324: ARRAY
23325: PUSH
23326: LD_INT 1
23328: ARRAY
23329: PPUSH
23330: LD_INT 2
23332: PPUSH
23333: CALL 4259 0 4
23337: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
23338: LD_ADDR_EXP 26
23342: PUSH
23343: LD_EXP 26
23347: PPUSH
23348: LD_VAR 0 1
23352: PPUSH
23353: LD_EXP 26
23357: PUSH
23358: LD_VAR 0 1
23362: ARRAY
23363: PUSH
23364: LD_INT 1
23366: PLUS
23367: PPUSH
23368: LD_VAR 0 6
23372: PUSH
23373: LD_VAR 0 4
23377: ARRAY
23378: PUSH
23379: LD_INT 1
23381: ARRAY
23382: PPUSH
23383: CALL 24638 0 4
23387: ST_TO_ADDR
// end ;
23388: GO 23297
23390: POP
23391: POP
// end ;
23392: LD_VAR 0 3
23396: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
23397: LD_INT 0
23399: PPUSH
23400: PPUSH
23401: PPUSH
23402: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
23403: LD_ADDR_VAR 0 5
23407: PUSH
23408: LD_VAR 0 1
23412: PPUSH
23413: LD_INT 2
23415: PUSH
23416: LD_INT 25
23418: PUSH
23419: LD_INT 1
23421: PUSH
23422: EMPTY
23423: LIST
23424: LIST
23425: PUSH
23426: LD_INT 25
23428: PUSH
23429: LD_INT 2
23431: PUSH
23432: EMPTY
23433: LIST
23434: LIST
23435: PUSH
23436: LD_INT 25
23438: PUSH
23439: LD_INT 4
23441: PUSH
23442: EMPTY
23443: LIST
23444: LIST
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: PPUSH
23452: CALL 0 0 2
23456: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
23457: LD_ADDR_VAR 0 5
23461: PUSH
23462: LD_VAR 0 5
23466: PPUSH
23467: LD_INT 0
23469: PPUSH
23470: CALL 2149 0 2
23474: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
23475: LD_ADDR_VAR 0 6
23479: PUSH
23480: LD_VAR 0 1
23484: PPUSH
23485: LD_VAR 0 5
23489: PPUSH
23490: LD_INT 3
23492: PPUSH
23493: CALL 1769 0 3
23497: ST_TO_ADDR
// if n > sk then
23498: LD_VAR 0 2
23502: PUSH
23503: LD_VAR 0 6
23507: GREATER
23508: IFFALSE 23520
// n := sk ;
23510: LD_ADDR_VAR 0 2
23514: PUSH
23515: LD_VAR 0 6
23519: ST_TO_ADDR
// for i = 1 to n do
23520: LD_ADDR_VAR 0 4
23524: PUSH
23525: DOUBLE
23526: LD_INT 1
23528: DEC
23529: ST_TO_ADDR
23530: LD_VAR 0 2
23534: PUSH
23535: FOR_TO
23536: IFFALSE 23628
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
23538: LD_ADDR_EXP 22
23542: PUSH
23543: LD_EXP 22
23547: PPUSH
23548: LD_VAR 0 1
23552: PPUSH
23553: LD_VAR 0 6
23557: PUSH
23558: LD_VAR 0 4
23562: ARRAY
23563: PUSH
23564: LD_INT 1
23566: ARRAY
23567: PPUSH
23568: LD_INT 3
23570: PPUSH
23571: CALL 4259 0 4
23575: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
23576: LD_ADDR_EXP 24
23580: PUSH
23581: LD_EXP 24
23585: PPUSH
23586: LD_VAR 0 1
23590: PPUSH
23591: LD_EXP 24
23595: PUSH
23596: LD_VAR 0 1
23600: ARRAY
23601: PUSH
23602: LD_INT 1
23604: PLUS
23605: PPUSH
23606: LD_VAR 0 6
23610: PUSH
23611: LD_VAR 0 4
23615: ARRAY
23616: PUSH
23617: LD_INT 1
23619: ARRAY
23620: PPUSH
23621: CALL 24638 0 4
23625: ST_TO_ADDR
// end ;
23626: GO 23535
23628: POP
23629: POP
// end ;
23630: LD_VAR 0 3
23634: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
23635: LD_INT 0
23637: PPUSH
23638: PPUSH
23639: PPUSH
23640: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] ) ;
23641: LD_ADDR_VAR 0 5
23645: PUSH
23646: LD_VAR 0 1
23650: PPUSH
23651: LD_INT 2
23653: PUSH
23654: LD_INT 25
23656: PUSH
23657: LD_INT 1
23659: PUSH
23660: EMPTY
23661: LIST
23662: LIST
23663: PUSH
23664: LD_INT 25
23666: PUSH
23667: LD_INT 2
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: PUSH
23674: LD_INT 25
23676: PUSH
23677: LD_INT 3
23679: PUSH
23680: EMPTY
23681: LIST
23682: LIST
23683: PUSH
23684: EMPTY
23685: LIST
23686: LIST
23687: LIST
23688: LIST
23689: PPUSH
23690: CALL 0 0 2
23694: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
23695: LD_ADDR_VAR 0 5
23699: PUSH
23700: LD_VAR 0 5
23704: PPUSH
23705: LD_INT 0
23707: PPUSH
23708: CALL 2149 0 2
23712: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
23713: LD_ADDR_VAR 0 6
23717: PUSH
23718: LD_VAR 0 1
23722: PPUSH
23723: LD_VAR 0 5
23727: PPUSH
23728: LD_INT 4
23730: PPUSH
23731: CALL 1769 0 3
23735: ST_TO_ADDR
// if n > sk then
23736: LD_VAR 0 2
23740: PUSH
23741: LD_VAR 0 6
23745: GREATER
23746: IFFALSE 23758
// n := sk ;
23748: LD_ADDR_VAR 0 2
23752: PUSH
23753: LD_VAR 0 6
23757: ST_TO_ADDR
// for i = 1 to n do
23758: LD_ADDR_VAR 0 4
23762: PUSH
23763: DOUBLE
23764: LD_INT 1
23766: DEC
23767: ST_TO_ADDR
23768: LD_VAR 0 2
23772: PUSH
23773: FOR_TO
23774: IFFALSE 23866
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
23776: LD_ADDR_EXP 22
23780: PUSH
23781: LD_EXP 22
23785: PPUSH
23786: LD_VAR 0 1
23790: PPUSH
23791: LD_VAR 0 6
23795: PUSH
23796: LD_VAR 0 4
23800: ARRAY
23801: PUSH
23802: LD_INT 1
23804: ARRAY
23805: PPUSH
23806: LD_INT 4
23808: PPUSH
23809: CALL 4259 0 4
23813: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
23814: LD_ADDR_EXP 23
23818: PUSH
23819: LD_EXP 23
23823: PPUSH
23824: LD_VAR 0 1
23828: PPUSH
23829: LD_EXP 23
23833: PUSH
23834: LD_VAR 0 1
23838: ARRAY
23839: PUSH
23840: LD_INT 1
23842: PLUS
23843: PPUSH
23844: LD_VAR 0 6
23848: PUSH
23849: LD_VAR 0 4
23853: ARRAY
23854: PUSH
23855: LD_INT 1
23857: ARRAY
23858: PPUSH
23859: CALL 24638 0 4
23863: ST_TO_ADDR
// end ;
23864: GO 23773
23866: POP
23867: POP
// end ;
23868: LD_VAR 0 3
23872: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
23873: LD_INT 0
23875: PPUSH
23876: PPUSH
23877: PPUSH
23878: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
23879: LD_ADDR_VAR 0 6
23883: PUSH
23884: LD_VAR 0 1
23888: PPUSH
23889: LD_INT 2
23891: PUSH
23892: LD_INT 25
23894: PUSH
23895: LD_INT 1
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: PUSH
23902: LD_INT 25
23904: PUSH
23905: LD_INT 2
23907: PUSH
23908: EMPTY
23909: LIST
23910: LIST
23911: PUSH
23912: LD_INT 25
23914: PUSH
23915: LD_INT 3
23917: PUSH
23918: EMPTY
23919: LIST
23920: LIST
23921: PUSH
23922: LD_INT 25
23924: PUSH
23925: LD_INT 4
23927: PUSH
23928: EMPTY
23929: LIST
23930: LIST
23931: PUSH
23932: EMPTY
23933: LIST
23934: LIST
23935: LIST
23936: LIST
23937: LIST
23938: PPUSH
23939: CALL 0 0 2
23943: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
23944: LD_ADDR_VAR 0 6
23948: PUSH
23949: LD_VAR 0 6
23953: PPUSH
23954: LD_INT 0
23956: PPUSH
23957: CALL 2149 0 2
23961: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
23962: LD_ADDR_VAR 0 7
23966: PUSH
23967: LD_VAR 0 1
23971: PPUSH
23972: LD_VAR 0 6
23976: PPUSH
23977: LD_INT 1
23979: PPUSH
23980: CALL 1769 0 3
23984: ST_TO_ADDR
// if n > sk then
23985: LD_VAR 0 2
23989: PUSH
23990: LD_VAR 0 7
23994: GREATER
23995: IFFALSE 24007
// n := sk ;
23997: LD_ADDR_VAR 0 2
24001: PUSH
24002: LD_VAR 0 7
24006: ST_TO_ADDR
// for i = 1 to n do
24007: LD_ADDR_VAR 0 5
24011: PUSH
24012: DOUBLE
24013: LD_INT 1
24015: DEC
24016: ST_TO_ADDR
24017: LD_VAR 0 2
24021: PUSH
24022: FOR_TO
24023: IFFALSE 24067
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
24025: LD_ADDR_EXP 22
24029: PUSH
24030: LD_EXP 22
24034: PPUSH
24035: LD_VAR 0 1
24039: PPUSH
24040: LD_VAR 0 7
24044: PUSH
24045: LD_VAR 0 5
24049: ARRAY
24050: PUSH
24051: LD_INT 1
24053: ARRAY
24054: PPUSH
24055: LD_VAR 0 3
24059: PPUSH
24060: CALL 4259 0 4
24064: ST_TO_ADDR
// end ;
24065: GO 24022
24067: POP
24068: POP
// end ;
24069: LD_VAR 0 4
24073: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
24074: LD_INT 0
24076: PPUSH
24077: PPUSH
24078: PPUSH
// b := false ;
24079: LD_ADDR_VAR 0 6
24083: PUSH
24084: LD_INT 0
24086: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
24087: LD_VAR 0 3
24091: PUSH
24092: LD_INT 1
24094: PUSH
24095: LD_INT 9
24097: PUSH
24098: LD_INT 5
24100: PUSH
24101: LD_INT 8
24103: PUSH
24104: EMPTY
24105: LIST
24106: LIST
24107: LIST
24108: LIST
24109: IN
24110: IFFALSE 24198
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
24112: LD_VAR 0 1
24116: PPUSH
24117: LD_INT 2
24119: PUSH
24120: LD_INT 30
24122: PUSH
24123: LD_INT 4
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: PUSH
24130: LD_INT 30
24132: PUSH
24133: LD_INT 5
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: LIST
24144: PPUSH
24145: CALL 0 0 2
24149: IFFALSE 24198
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
24151: LD_ADDR_VAR 0 6
24155: PUSH
24156: LD_VAR 0 1
24160: PPUSH
24161: LD_INT 2
24163: PUSH
24164: LD_INT 30
24166: PUSH
24167: LD_INT 4
24169: PUSH
24170: EMPTY
24171: LIST
24172: LIST
24173: PUSH
24174: LD_INT 30
24176: PUSH
24177: LD_INT 5
24179: PUSH
24180: EMPTY
24181: LIST
24182: LIST
24183: PUSH
24184: EMPTY
24185: LIST
24186: LIST
24187: LIST
24188: PPUSH
24189: CALL 0 0 2
24193: PUSH
24194: LD_INT 1
24196: ARRAY
24197: ST_TO_ADDR
// if class = class_engineer then
24198: LD_VAR 0 3
24202: PUSH
24203: LD_INT 2
24205: EQUAL
24206: IFFALSE 24294
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24208: LD_VAR 0 1
24212: PPUSH
24213: LD_INT 2
24215: PUSH
24216: LD_INT 30
24218: PUSH
24219: LD_INT 0
24221: PUSH
24222: EMPTY
24223: LIST
24224: LIST
24225: PUSH
24226: LD_INT 30
24228: PUSH
24229: LD_INT 1
24231: PUSH
24232: EMPTY
24233: LIST
24234: LIST
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: LIST
24240: PPUSH
24241: CALL 0 0 2
24245: IFFALSE 24294
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
24247: LD_ADDR_VAR 0 6
24251: PUSH
24252: LD_VAR 0 1
24256: PPUSH
24257: LD_INT 2
24259: PUSH
24260: LD_INT 30
24262: PUSH
24263: LD_INT 0
24265: PUSH
24266: EMPTY
24267: LIST
24268: LIST
24269: PUSH
24270: LD_INT 30
24272: PUSH
24273: LD_INT 1
24275: PUSH
24276: EMPTY
24277: LIST
24278: LIST
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: LIST
24284: PPUSH
24285: CALL 0 0 2
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: ST_TO_ADDR
// if class = class_mechanic then
24294: LD_VAR 0 3
24298: PUSH
24299: LD_INT 3
24301: EQUAL
24302: IFFALSE 24372
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
24304: LD_VAR 0 1
24308: PPUSH
24309: LD_INT 30
24311: PUSH
24312: LD_INT 3
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PPUSH
24319: CALL 0 0 2
24323: IFFALSE 24372
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24325: LD_ADDR_VAR 0 6
24329: PUSH
24330: LD_VAR 0 1
24334: PPUSH
24335: LD_INT 2
24337: PUSH
24338: LD_INT 30
24340: PUSH
24341: LD_INT 2
24343: PUSH
24344: EMPTY
24345: LIST
24346: LIST
24347: PUSH
24348: LD_INT 30
24350: PUSH
24351: LD_INT 3
24353: PUSH
24354: EMPTY
24355: LIST
24356: LIST
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: LIST
24362: PPUSH
24363: CALL 0 0 2
24367: PUSH
24368: LD_INT 1
24370: ARRAY
24371: ST_TO_ADDR
// if class = class_scientistic then
24372: LD_VAR 0 3
24376: PUSH
24377: LD_INT 4
24379: EQUAL
24380: IFFALSE 24490
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
24382: LD_VAR 0 1
24386: PPUSH
24387: LD_INT 2
24389: PUSH
24390: LD_INT 30
24392: PUSH
24393: LD_INT 6
24395: PUSH
24396: EMPTY
24397: LIST
24398: LIST
24399: PUSH
24400: LD_INT 30
24402: PUSH
24403: LD_INT 7
24405: PUSH
24406: EMPTY
24407: LIST
24408: LIST
24409: PUSH
24410: LD_INT 30
24412: PUSH
24413: LD_INT 8
24415: PUSH
24416: EMPTY
24417: LIST
24418: LIST
24419: PUSH
24420: EMPTY
24421: LIST
24422: LIST
24423: LIST
24424: LIST
24425: PPUSH
24426: CALL 0 0 2
24430: IFFALSE 24490
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
24432: LD_ADDR_VAR 0 6
24436: PUSH
24437: LD_VAR 0 1
24441: PPUSH
24442: LD_INT 2
24444: PUSH
24445: LD_INT 30
24447: PUSH
24448: LD_INT 6
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: PUSH
24455: LD_INT 30
24457: PUSH
24458: LD_INT 7
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: PUSH
24465: LD_INT 30
24467: PUSH
24468: LD_INT 8
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: PUSH
24475: EMPTY
24476: LIST
24477: LIST
24478: LIST
24479: LIST
24480: PPUSH
24481: CALL 0 0 2
24485: PUSH
24486: LD_INT 1
24488: ARRAY
24489: ST_TO_ADDR
// if GetClass ( unit ) = class then
24490: LD_VAR 0 2
24494: PPUSH
24495: CALL_OW 257
24499: PUSH
24500: LD_VAR 0 3
24504: EQUAL
24505: IFFALSE 24539
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
24507: LD_ADDR_EXP 22
24511: PUSH
24512: LD_EXP 22
24516: PPUSH
24517: LD_VAR 0 1
24521: PPUSH
24522: LD_VAR 0 2
24526: PPUSH
24527: LD_VAR 0 3
24531: PPUSH
24532: CALL 4350 0 4
24536: ST_TO_ADDR
// end else
24537: GO 24633
// if b then
24539: LD_VAR 0 6
24543: IFFALSE 24625
// begin if IsInUnit ( unit ) and not unit in UnitsInside ( b ) then
24545: LD_VAR 0 2
24549: PPUSH
24550: CALL_OW 310
24554: PUSH
24555: LD_VAR 0 2
24559: PUSH
24560: LD_VAR 0 6
24564: PPUSH
24565: CALL_OW 313
24569: IN
24570: NOT
24571: AND
24572: IFFALSE 24583
// ComExitBuilding ( unit ) ;
24574: LD_VAR 0 2
24578: PPUSH
24579: CALL_OW 122
// if not IsInUnit ( unit ) then
24583: LD_VAR 0 2
24587: PPUSH
24588: CALL_OW 310
24592: NOT
24593: IFFALSE 24609
// AddComEnterUnit ( unit , b ) ;
24595: LD_VAR 0 2
24599: PPUSH
24600: LD_VAR 0 6
24604: PPUSH
24605: CALL_OW 180
// AddComChangeProfession ( unit , class ) ;
24609: LD_VAR 0 2
24613: PPUSH
24614: LD_VAR 0 3
24618: PPUSH
24619: CALL_OW 183
// end else
24623: GO 24633
// result := false ;
24625: LD_ADDR_VAR 0 4
24629: PUSH
24630: LD_INT 0
24632: ST_TO_ADDR
// end ; end_of_file end_of_file
24633: LD_VAR 0 4
24637: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
24638: LD_INT 0
24640: PPUSH
24641: PPUSH
24642: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
24643: LD_ADDR_VAR 0 7
24647: PUSH
24648: LD_VAR 0 1
24652: PUSH
24653: LD_VAR 0 2
24657: ARRAY
24658: PPUSH
24659: LD_VAR 0 3
24663: PPUSH
24664: LD_VAR 0 4
24668: PPUSH
24669: CALL_OW 1
24673: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
24674: LD_ADDR_VAR 0 1
24678: PUSH
24679: LD_VAR 0 1
24683: PPUSH
24684: LD_VAR 0 2
24688: PPUSH
24689: LD_VAR 0 7
24693: PPUSH
24694: CALL_OW 1
24698: ST_TO_ADDR
// result := tab ;
24699: LD_ADDR_VAR 0 5
24703: PUSH
24704: LD_VAR 0 1
24708: ST_TO_ADDR
// end ;
24709: LD_VAR 0 5
24713: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
24714: LD_INT 0
24716: PPUSH
24717: PPUSH
24718: PPUSH
24719: PPUSH
// i := 1 ;
24720: LD_ADDR_VAR 0 5
24724: PUSH
24725: LD_INT 1
24727: ST_TO_ADDR
// while ( i <= tab ) do
24728: LD_VAR 0 5
24732: PUSH
24733: LD_VAR 0 1
24737: LESSEQUAL
24738: IFFALSE 25113
// begin if not tab [ i ] then
24740: LD_VAR 0 1
24744: PUSH
24745: LD_VAR 0 5
24749: ARRAY
24750: NOT
24751: IFFALSE 24755
// break ;
24753: GO 25113
// if value in tab then
24755: LD_VAR 0 2
24759: PUSH
24760: LD_VAR 0 1
24764: IN
24765: IFFALSE 24878
// begin if not mode then
24767: LD_VAR 0 3
24771: NOT
24772: IFFALSE 24792
// tab := tab diff value else
24774: LD_ADDR_VAR 0 1
24778: PUSH
24779: LD_VAR 0 1
24783: PUSH
24784: LD_VAR 0 2
24788: DIFF
24789: ST_TO_ADDR
24790: GO 24854
// for j = 1 to tab do
24792: LD_ADDR_VAR 0 6
24796: PUSH
24797: DOUBLE
24798: LD_INT 1
24800: DEC
24801: ST_TO_ADDR
24802: LD_VAR 0 1
24806: PUSH
24807: FOR_TO
24808: IFFALSE 24852
// if tab [ j ] = value then
24810: LD_VAR 0 1
24814: PUSH
24815: LD_VAR 0 6
24819: ARRAY
24820: PUSH
24821: LD_VAR 0 2
24825: EQUAL
24826: IFFALSE 24850
// begin tab := Delete ( tab , j ) ;
24828: LD_ADDR_VAR 0 1
24832: PUSH
24833: LD_VAR 0 1
24837: PPUSH
24838: LD_VAR 0 6
24842: PPUSH
24843: CALL_OW 3
24847: ST_TO_ADDR
// break ;
24848: GO 24852
// end ;
24850: GO 24807
24852: POP
24853: POP
// i := i - 1 ;
24854: LD_ADDR_VAR 0 5
24858: PUSH
24859: LD_VAR 0 5
24863: PUSH
24864: LD_INT 1
24866: MINUS
24867: ST_TO_ADDR
// if mode then
24868: LD_VAR 0 3
24872: IFFALSE 24876
// break ;
24874: GO 25113
// end else
24876: GO 25097
// if tab [ i ] and value in tab [ i ] then
24878: LD_VAR 0 1
24882: PUSH
24883: LD_VAR 0 5
24887: ARRAY
24888: PUSH
24889: LD_VAR 0 2
24893: PUSH
24894: LD_VAR 0 1
24898: PUSH
24899: LD_VAR 0 5
24903: ARRAY
24904: IN
24905: AND
24906: IFFALSE 25097
// begin if not mode then
24908: LD_VAR 0 3
24912: NOT
24913: IFFALSE 24939
// tmp := tab [ i ] diff value else
24915: LD_ADDR_VAR 0 7
24919: PUSH
24920: LD_VAR 0 1
24924: PUSH
24925: LD_VAR 0 5
24929: ARRAY
24930: PUSH
24931: LD_VAR 0 2
24935: DIFF
24936: ST_TO_ADDR
24937: GO 25019
// for j = 1 to tab [ i ] do
24939: LD_ADDR_VAR 0 6
24943: PUSH
24944: DOUBLE
24945: LD_INT 1
24947: DEC
24948: ST_TO_ADDR
24949: LD_VAR 0 1
24953: PUSH
24954: LD_VAR 0 5
24958: ARRAY
24959: PUSH
24960: FOR_TO
24961: IFFALSE 25017
// if value = tab [ i ] [ j ] then
24963: LD_VAR 0 2
24967: PUSH
24968: LD_VAR 0 1
24972: PUSH
24973: LD_VAR 0 5
24977: ARRAY
24978: PUSH
24979: LD_VAR 0 6
24983: ARRAY
24984: EQUAL
24985: IFFALSE 25015
// begin tmp := Delete ( tab [ i ] , j ) ;
24987: LD_ADDR_VAR 0 7
24991: PUSH
24992: LD_VAR 0 1
24996: PUSH
24997: LD_VAR 0 5
25001: ARRAY
25002: PPUSH
25003: LD_VAR 0 6
25007: PPUSH
25008: CALL_OW 3
25012: ST_TO_ADDR
// break ;
25013: GO 25017
// end ;
25015: GO 24960
25017: POP
25018: POP
// if tmp = [ ] then
25019: LD_VAR 0 7
25023: PUSH
25024: EMPTY
25025: EQUAL
25026: IFFALSE 25050
// begin tab := Delete ( tab , i ) ;
25028: LD_ADDR_VAR 0 1
25032: PUSH
25033: LD_VAR 0 1
25037: PPUSH
25038: LD_VAR 0 5
25042: PPUSH
25043: CALL_OW 3
25047: ST_TO_ADDR
// end else
25048: GO 25075
// tab := Replace ( tab , i , tmp ) ;
25050: LD_ADDR_VAR 0 1
25054: PUSH
25055: LD_VAR 0 1
25059: PPUSH
25060: LD_VAR 0 5
25064: PPUSH
25065: LD_VAR 0 7
25069: PPUSH
25070: CALL_OW 1
25074: ST_TO_ADDR
// i := i - 1 ;
25075: LD_ADDR_VAR 0 5
25079: PUSH
25080: LD_VAR 0 5
25084: PUSH
25085: LD_INT 1
25087: MINUS
25088: ST_TO_ADDR
// if mode then
25089: LD_VAR 0 3
25093: IFFALSE 25097
// break ;
25095: GO 25113
// end ; i := i + 1 ;
25097: LD_ADDR_VAR 0 5
25101: PUSH
25102: LD_VAR 0 5
25106: PUSH
25107: LD_INT 1
25109: PLUS
25110: ST_TO_ADDR
// end ;
25111: GO 24728
// result := tab ;
25113: LD_ADDR_VAR 0 4
25117: PUSH
25118: LD_VAR 0 1
25122: ST_TO_ADDR
// end ;
25123: LD_VAR 0 4
25127: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
25128: LD_INT 0
25130: PPUSH
25131: PPUSH
// for i = 1 to values do
25132: LD_ADDR_VAR 0 4
25136: PUSH
25137: DOUBLE
25138: LD_INT 1
25140: DEC
25141: ST_TO_ADDR
25142: LD_VAR 0 2
25146: PUSH
25147: FOR_TO
25148: IFFALSE 25181
// tab := Remove ( tab , values [ i ] , false ) ;
25150: LD_ADDR_VAR 0 1
25154: PUSH
25155: LD_VAR 0 1
25159: PPUSH
25160: LD_VAR 0 2
25164: PUSH
25165: LD_VAR 0 4
25169: ARRAY
25170: PPUSH
25171: LD_INT 0
25173: PPUSH
25174: CALL 24714 0 3
25178: ST_TO_ADDR
25179: GO 25147
25181: POP
25182: POP
// result := tab ;
25183: LD_ADDR_VAR 0 3
25187: PUSH
25188: LD_VAR 0 1
25192: ST_TO_ADDR
// end ;
25193: LD_VAR 0 3
25197: RET
// export function IsDriver ( unit ) ; begin
25198: LD_INT 0
25200: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
25201: LD_VAR 0 1
25205: PUSH
25206: LD_INT 55
25208: PUSH
25209: EMPTY
25210: LIST
25211: PPUSH
25212: CALL_OW 69
25216: IN
25217: IFFALSE 25236
// result := IsInUnit ( unit ) else
25219: LD_ADDR_VAR 0 2
25223: PUSH
25224: LD_VAR 0 1
25228: PPUSH
25229: CALL_OW 310
25233: ST_TO_ADDR
25234: GO 25244
// result := false ;
25236: LD_ADDR_VAR 0 2
25240: PUSH
25241: LD_INT 0
25243: ST_TO_ADDR
// end ;
25244: LD_VAR 0 2
25248: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
25249: LD_INT 0
25251: PPUSH
25252: PPUSH
25253: PPUSH
// if not GetControl ( veh ) = control_manual then
25254: LD_VAR 0 1
25258: PPUSH
25259: CALL_OW 263
25263: PUSH
25264: LD_INT 1
25266: EQUAL
25267: NOT
25268: IFFALSE 25280
// result := false else
25270: LD_ADDR_VAR 0 2
25274: PUSH
25275: LD_INT 0
25277: ST_TO_ADDR
25278: GO 25425
// if veh in FilterAllUnits ( [ f_empty ] ) then
25280: LD_VAR 0 1
25284: PUSH
25285: LD_INT 58
25287: PUSH
25288: EMPTY
25289: LIST
25290: PPUSH
25291: CALL_OW 69
25295: IN
25296: IFFALSE 25308
// result := false else
25298: LD_ADDR_VAR 0 2
25302: PUSH
25303: LD_INT 0
25305: ST_TO_ADDR
25306: GO 25425
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
25308: LD_ADDR_VAR 0 4
25312: PUSH
25313: LD_INT 22
25315: PUSH
25316: LD_VAR 0 1
25320: PPUSH
25321: CALL_OW 255
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: PUSH
25330: LD_INT 55
25332: PUSH
25333: EMPTY
25334: LIST
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PPUSH
25340: CALL_OW 69
25344: ST_TO_ADDR
// if not filter then
25345: LD_VAR 0 4
25349: NOT
25350: IFFALSE 25362
// result := false else
25352: LD_ADDR_VAR 0 2
25356: PUSH
25357: LD_INT 0
25359: ST_TO_ADDR
25360: GO 25425
// for i = 1 to filter do
25362: LD_ADDR_VAR 0 3
25366: PUSH
25367: DOUBLE
25368: LD_INT 1
25370: DEC
25371: ST_TO_ADDR
25372: LD_VAR 0 4
25376: PUSH
25377: FOR_TO
25378: IFFALSE 25423
// if IsDriver ( filter [ i ] ) = veh then
25380: LD_VAR 0 4
25384: PUSH
25385: LD_VAR 0 3
25389: ARRAY
25390: PPUSH
25391: CALL 25198 0 1
25395: PUSH
25396: LD_VAR 0 1
25400: EQUAL
25401: IFFALSE 25421
// begin result := filter [ i ] ;
25403: LD_ADDR_VAR 0 2
25407: PUSH
25408: LD_VAR 0 4
25412: PUSH
25413: LD_VAR 0 3
25417: ARRAY
25418: ST_TO_ADDR
// break ;
25419: GO 25423
// end ;
25421: GO 25377
25423: POP
25424: POP
// end ; end ;
25425: LD_VAR 0 2
25429: RET
// export function ComComplete ( unit , b ) ; var i ; begin
25430: LD_INT 0
25432: PPUSH
25433: PPUSH
// if BuildingStatus ( b ) = bs_build then
25434: LD_VAR 0 2
25438: PPUSH
25439: CALL_OW 461
25443: PUSH
25444: LD_INT 1
25446: EQUAL
25447: IFFALSE 25507
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25449: LD_VAR 0 1
25453: PPUSH
25454: LD_STRING h
25456: PUSH
25457: LD_VAR 0 2
25461: PPUSH
25462: CALL_OW 250
25466: PUSH
25467: LD_VAR 0 2
25471: PPUSH
25472: CALL_OW 251
25476: PUSH
25477: LD_VAR 0 2
25481: PUSH
25482: LD_INT 0
25484: PUSH
25485: LD_INT 0
25487: PUSH
25488: LD_INT 0
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: LIST
25495: LIST
25496: LIST
25497: LIST
25498: LIST
25499: PUSH
25500: EMPTY
25501: LIST
25502: PPUSH
25503: CALL_OW 446
// end ;
25507: LD_VAR 0 3
25511: RET
// export function Compare ( val1 , val2 ) ; begin
25512: LD_INT 0
25514: PPUSH
// if val1 = val2 then
25515: LD_VAR 0 1
25519: PUSH
25520: LD_VAR 0 2
25524: EQUAL
25525: IFFALSE 25537
// result := true else
25527: LD_ADDR_VAR 0 3
25531: PUSH
25532: LD_INT 1
25534: ST_TO_ADDR
25535: GO 25545
// result := false ;
25537: LD_ADDR_VAR 0 3
25541: PUSH
25542: LD_INT 0
25544: ST_TO_ADDR
// end ;
25545: LD_VAR 0 3
25549: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25550: LD_INT 0
25552: PPUSH
25553: PPUSH
// result := true ;
25554: LD_ADDR_VAR 0 3
25558: PUSH
25559: LD_INT 1
25561: ST_TO_ADDR
// if array1 = array2 then
25562: LD_VAR 0 1
25566: PUSH
25567: LD_VAR 0 2
25571: EQUAL
25572: IFFALSE 25637
// begin for i = 1 to array1 do
25574: LD_ADDR_VAR 0 4
25578: PUSH
25579: DOUBLE
25580: LD_INT 1
25582: DEC
25583: ST_TO_ADDR
25584: LD_VAR 0 1
25588: PUSH
25589: FOR_TO
25590: IFFALSE 25633
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
25592: LD_VAR 0 1
25596: PUSH
25597: LD_VAR 0 4
25601: ARRAY
25602: PPUSH
25603: LD_VAR 0 2
25607: PUSH
25608: LD_VAR 0 4
25612: ARRAY
25613: PPUSH
25614: CALL 25512 0 2
25618: NOT
25619: IFFALSE 25631
// begin result := false ;
25621: LD_ADDR_VAR 0 3
25625: PUSH
25626: LD_INT 0
25628: ST_TO_ADDR
// break ;
25629: GO 25633
// end ;
25631: GO 25589
25633: POP
25634: POP
// end else
25635: GO 25645
// result := false ;
25637: LD_ADDR_VAR 0 3
25641: PUSH
25642: LD_INT 0
25644: ST_TO_ADDR
// end ;
25645: LD_VAR 0 3
25649: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
25650: LD_INT 0
25652: PPUSH
25653: PPUSH
// result := false ;
25654: LD_ADDR_VAR 0 3
25658: PUSH
25659: LD_INT 0
25661: ST_TO_ADDR
// for j = 1 to e2 do
25662: LD_ADDR_VAR 0 4
25666: PUSH
25667: DOUBLE
25668: LD_INT 1
25670: DEC
25671: ST_TO_ADDR
25672: LD_VAR 0 2
25676: PUSH
25677: FOR_TO
25678: IFFALSE 25712
// if Compare ( e1 , e2 [ j ] ) then
25680: LD_VAR 0 1
25684: PPUSH
25685: LD_VAR 0 2
25689: PUSH
25690: LD_VAR 0 4
25694: ARRAY
25695: PPUSH
25696: CALL 25512 0 2
25700: IFFALSE 25710
// result := true ;
25702: LD_ADDR_VAR 0 3
25706: PUSH
25707: LD_INT 1
25709: ST_TO_ADDR
25710: GO 25677
25712: POP
25713: POP
// end ;
25714: LD_VAR 0 3
25718: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
25719: LD_INT 0
25721: PPUSH
25722: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
25723: LD_VAR 0 1
25727: PPUSH
25728: LD_STRING C
25730: PUSH
25731: LD_VAR 0 2
25735: PUSH
25736: LD_VAR 0 3
25740: PUSH
25741: LD_INT 0
25743: PUSH
25744: LD_INT 0
25746: PUSH
25747: LD_INT 0
25749: PUSH
25750: LD_INT 0
25752: PUSH
25753: EMPTY
25754: LIST
25755: LIST
25756: LIST
25757: LIST
25758: LIST
25759: LIST
25760: LIST
25761: PUSH
25762: LD_STRING v
25764: PUSH
25765: LD_VAR 0 4
25769: PPUSH
25770: CALL_OW 250
25774: PUSH
25775: LD_VAR 0 4
25779: PPUSH
25780: CALL_OW 251
25784: PUSH
25785: LD_VAR 0 4
25789: PUSH
25790: LD_INT 0
25792: PUSH
25793: LD_INT 0
25795: PUSH
25796: LD_INT 0
25798: PUSH
25799: EMPTY
25800: LIST
25801: LIST
25802: LIST
25803: LIST
25804: LIST
25805: LIST
25806: LIST
25807: PUSH
25808: EMPTY
25809: LIST
25810: LIST
25811: PPUSH
25812: CALL_OW 446
// end ;
25816: LD_VAR 0 5
25820: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
25821: LD_INT 0
25823: PPUSH
25824: PPUSH
25825: PPUSH
// linked := UnitsLinked ( unit ) ;
25826: LD_ADDR_VAR 0 4
25830: PUSH
25831: LD_VAR 0 1
25835: PPUSH
25836: CALL_OW 432
25840: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
25841: LD_ADDR_VAR 0 3
25845: PUSH
25846: LD_VAR 0 1
25850: PPUSH
25851: LD_INT 3
25853: PPUSH
25854: CALL_OW 259
25858: ST_TO_ADDR
// if sk > linked then
25859: LD_VAR 0 3
25863: PUSH
25864: LD_VAR 0 4
25868: GREATER
25869: IFFALSE 25881
// result := true else
25871: LD_ADDR_VAR 0 2
25875: PUSH
25876: LD_INT 1
25878: ST_TO_ADDR
25879: GO 25889
// result := false ;
25881: LD_ADDR_VAR 0 2
25885: PUSH
25886: LD_INT 0
25888: ST_TO_ADDR
// end ;
25889: LD_VAR 0 2
25893: RET
// export function NotTask ( unit ) ; begin
25894: LD_INT 0
25896: PPUSH
// result := true ;
25897: LD_ADDR_VAR 0 2
25901: PUSH
25902: LD_INT 1
25904: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
25905: LD_VAR 0 1
25909: PPUSH
25910: CALL_OW 437
25914: PUSH
25915: LD_VAR 0 1
25919: PPUSH
25920: CALL_OW 314
25924: OR
25925: IFFALSE 25935
// result := false ;
25927: LD_ADDR_VAR 0 2
25931: PUSH
25932: LD_INT 0
25934: ST_TO_ADDR
// end ;
25935: LD_VAR 0 2
25939: RET
// export function WantHeal ( sci , unit ) ; begin
25940: LD_INT 0
25942: PPUSH
// if GetTaskList ( sci ) > 0 then
25943: LD_VAR 0 1
25947: PPUSH
25948: CALL_OW 437
25952: PUSH
25953: LD_INT 0
25955: GREATER
25956: IFFALSE 26026
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
25958: LD_VAR 0 1
25962: PPUSH
25963: CALL_OW 437
25967: PUSH
25968: LD_INT 1
25970: ARRAY
25971: PUSH
25972: LD_INT 1
25974: ARRAY
25975: PUSH
25976: LD_STRING l
25978: EQUAL
25979: PUSH
25980: LD_VAR 0 1
25984: PPUSH
25985: CALL_OW 437
25989: PUSH
25990: LD_INT 1
25992: ARRAY
25993: PUSH
25994: LD_INT 4
25996: ARRAY
25997: PUSH
25998: LD_VAR 0 2
26002: EQUAL
26003: AND
26004: IFFALSE 26016
// result := true else
26006: LD_ADDR_VAR 0 3
26010: PUSH
26011: LD_INT 1
26013: ST_TO_ADDR
26014: GO 26024
// result := false ;
26016: LD_ADDR_VAR 0 3
26020: PUSH
26021: LD_INT 0
26023: ST_TO_ADDR
// end else
26024: GO 26034
// result := false ;
26026: LD_ADDR_VAR 0 3
26030: PUSH
26031: LD_INT 0
26033: ST_TO_ADDR
// end ;
26034: LD_VAR 0 3
26038: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
26039: LD_INT 0
26041: PPUSH
26042: PPUSH
26043: PPUSH
26044: PPUSH
26045: PPUSH
// dist := 99999 ;
26046: LD_ADDR_VAR 0 7
26050: PUSH
26051: LD_INT 99999
26053: ST_TO_ADDR
// un := - 1 ;
26054: LD_ADDR_VAR 0 6
26058: PUSH
26059: LD_INT 1
26061: NEG
26062: ST_TO_ADDR
// if units1 and units2 then
26063: LD_VAR 0 1
26067: PUSH
26068: LD_VAR 0 2
26072: AND
26073: IFFALSE 26161
// for i in units1 do
26075: LD_ADDR_VAR 0 4
26079: PUSH
26080: LD_VAR 0 1
26084: PUSH
26085: FOR_IN
26086: IFFALSE 26159
// for j in units2 do
26088: LD_ADDR_VAR 0 5
26092: PUSH
26093: LD_VAR 0 2
26097: PUSH
26098: FOR_IN
26099: IFFALSE 26155
// if GetDistUnits ( i , j ) < dist then
26101: LD_VAR 0 4
26105: PPUSH
26106: LD_VAR 0 5
26110: PPUSH
26111: CALL_OW 296
26115: PUSH
26116: LD_VAR 0 7
26120: LESS
26121: IFFALSE 26153
// begin un := i ;
26123: LD_ADDR_VAR 0 6
26127: PUSH
26128: LD_VAR 0 4
26132: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
26133: LD_ADDR_VAR 0 7
26137: PUSH
26138: LD_VAR 0 4
26142: PPUSH
26143: LD_VAR 0 5
26147: PPUSH
26148: CALL_OW 296
26152: ST_TO_ADDR
// end ;
26153: GO 26098
26155: POP
26156: POP
26157: GO 26085
26159: POP
26160: POP
// result := [ un , dist ] ;
26161: LD_ADDR_VAR 0 3
26165: PUSH
26166: LD_VAR 0 6
26170: PUSH
26171: LD_VAR 0 7
26175: PUSH
26176: EMPTY
26177: LIST
26178: LIST
26179: ST_TO_ADDR
// end ; end_of_file
26180: LD_VAR 0 3
26184: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
26185: LD_INT 0
26187: PPUSH
26188: PPUSH
26189: PPUSH
// uc_side := 0 ;
26190: LD_ADDR_OWVAR 20
26194: PUSH
26195: LD_INT 0
26197: ST_TO_ADDR
// uc_nation := 0 ;
26198: LD_ADDR_OWVAR 21
26202: PUSH
26203: LD_INT 0
26205: ST_TO_ADDR
// for i = 1 to n do
26206: LD_ADDR_VAR 0 5
26210: PUSH
26211: DOUBLE
26212: LD_INT 1
26214: DEC
26215: ST_TO_ADDR
26216: LD_VAR 0 2
26220: PUSH
26221: FOR_TO
26222: IFFALSE 26367
// begin hc_importance := 0 ;
26224: LD_ADDR_OWVAR 32
26228: PUSH
26229: LD_INT 0
26231: ST_TO_ADDR
// hc_gallery :=  ;
26232: LD_ADDR_OWVAR 33
26236: PUSH
26237: LD_STRING 
26239: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
26240: LD_ADDR_OWVAR 35
26244: PUSH
26245: LD_VAR 0 3
26249: PUSH
26250: LD_INT 20
26252: MINUS
26253: PPUSH
26254: LD_VAR 0 3
26258: PUSH
26259: LD_INT 20
26261: PLUS
26262: PPUSH
26263: CALL_OW 12
26267: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
26268: LD_ADDR_OWVAR 31
26272: PUSH
26273: LD_INT 0
26275: PPUSH
26276: LD_INT 2
26278: PPUSH
26279: CALL_OW 12
26283: PUSH
26284: LD_INT 0
26286: PUSH
26287: LD_INT 0
26289: PUSH
26290: LD_INT 0
26292: PUSH
26293: EMPTY
26294: LIST
26295: LIST
26296: LIST
26297: LIST
26298: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
26299: LD_ADDR_OWVAR 30
26303: PUSH
26304: LD_INT 0
26306: PUSH
26307: LD_INT 0
26309: PUSH
26310: LD_INT 0
26312: PUSH
26313: LD_INT 0
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: LIST
26320: LIST
26321: ST_TO_ADDR
// hc_name :=  ;
26322: LD_ADDR_OWVAR 26
26326: PUSH
26327: LD_STRING 
26329: ST_TO_ADDR
// hc_class := class_apeman ;
26330: LD_ADDR_OWVAR 28
26334: PUSH
26335: LD_INT 12
26337: ST_TO_ADDR
// ape := CreateHuman ;
26338: LD_ADDR_VAR 0 6
26342: PUSH
26343: CALL_OW 44
26347: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
26348: LD_VAR 0 6
26352: PPUSH
26353: LD_VAR 0 1
26357: PPUSH
26358: LD_INT 0
26360: PPUSH
26361: CALL_OW 49
// end ;
26365: GO 26221
26367: POP
26368: POP
// end ;
26369: LD_VAR 0 4
26373: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
26374: LD_INT 0
26376: PPUSH
26377: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
26378: LD_VAR 0 1
26382: PPUSH
26383: CALL 413 0 1
26387: PUSH
26388: LD_EXP 5
26392: PUSH
26393: LD_VAR 0 1
26397: ARRAY
26398: GREATEREQUAL
26399: IFFALSE 26576
// begin if GetTag ( unit ) = 17 then
26401: LD_VAR 0 2
26405: PPUSH
26406: CALL_OW 110
26410: PUSH
26411: LD_INT 17
26413: EQUAL
26414: IFFALSE 26574
// begin SetTag ( unit , 0 ) ;
26416: LD_VAR 0 2
26420: PPUSH
26421: LD_INT 0
26423: PPUSH
26424: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
26428: LD_VAR 0 1
26432: PPUSH
26433: CALL 39 0 1
26437: PUSH
26438: LD_VAR 0 1
26442: PPUSH
26443: CALL 14288 0 1
26447: NOT
26448: AND
26449: IFFALSE 26474
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
26451: LD_VAR 0 2
26455: PPUSH
26456: LD_VAR 0 1
26460: PPUSH
26461: CALL 39 0 1
26465: PUSH
26466: LD_INT 1
26468: ARRAY
26469: PPUSH
26470: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
26474: LD_VAR 0 1
26478: PPUSH
26479: CALL 39 0 1
26483: NOT
26484: PUSH
26485: LD_VAR 0 1
26489: PPUSH
26490: LD_INT 30
26492: PUSH
26493: LD_INT 1
26495: PUSH
26496: EMPTY
26497: LIST
26498: LIST
26499: PPUSH
26500: CALL 0 0 2
26504: AND
26505: IFFALSE 26574
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
26507: LD_VAR 0 2
26511: PPUSH
26512: LD_VAR 0 1
26516: PPUSH
26517: LD_INT 30
26519: PUSH
26520: LD_INT 1
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL 0 0 2
26531: PUSH
26532: LD_INT 1
26534: ARRAY
26535: PPUSH
26536: CALL_OW 250
26540: PPUSH
26541: LD_VAR 0 1
26545: PPUSH
26546: LD_INT 30
26548: PUSH
26549: LD_INT 1
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: PPUSH
26556: CALL 0 0 2
26560: PUSH
26561: LD_INT 1
26563: ARRAY
26564: PPUSH
26565: CALL_OW 251
26569: PPUSH
26570: CALL_OW 111
// end ; end else
26574: GO 26760
// if GetClass ( unit ) <> 4 then
26576: LD_VAR 0 2
26580: PPUSH
26581: CALL_OW 257
26585: PUSH
26586: LD_INT 4
26588: NONEQUAL
26589: IFFALSE 26595
// exit else
26591: GO 26760
26593: GO 26760
// if GetTag ( unit ) = 0 then
26595: LD_VAR 0 2
26599: PPUSH
26600: CALL_OW 110
26604: PUSH
26605: LD_INT 0
26607: EQUAL
26608: IFFALSE 26624
// SetTag ( unit , 17 ) else
26610: LD_VAR 0 2
26614: PPUSH
26615: LD_INT 17
26617: PPUSH
26618: CALL_OW 109
26622: GO 26760
// begin if IsInUnit ( unit ) then
26624: LD_VAR 0 2
26628: PPUSH
26629: CALL_OW 310
26633: IFFALSE 26644
// ComExitBuilding ( unit ) ;
26635: LD_VAR 0 2
26639: PPUSH
26640: CALL_OW 122
// Wait ( 1 ) ;
26644: LD_INT 1
26646: PPUSH
26647: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
26651: LD_ADDR_VAR 0 4
26655: PUSH
26656: LD_INT 22
26658: PUSH
26659: LD_INT 0
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: PUSH
26666: LD_INT 25
26668: PUSH
26669: LD_INT 12
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: PPUSH
26680: CALL_OW 69
26684: PPUSH
26685: LD_VAR 0 2
26689: PPUSH
26690: CALL_OW 74
26694: ST_TO_ADDR
// if not ape then
26695: LD_VAR 0 4
26699: NOT
26700: IFFALSE 26706
// exit else
26702: GO 26760
26704: GO 26715
// ComHold ( ape ) ;
26706: LD_VAR 0 4
26710: PPUSH
26711: CALL_OW 140
// if not HasTask ( unit ) then
26715: LD_VAR 0 2
26719: PPUSH
26720: CALL_OW 314
26724: NOT
26725: IFFALSE 26758
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
26727: LD_VAR 0 2
26731: PPUSH
26732: LD_VAR 0 4
26736: PPUSH
26737: CALL_OW 250
26741: PPUSH
26742: LD_VAR 0 4
26746: PPUSH
26747: CALL_OW 251
26751: PPUSH
26752: CALL_OW 131
26756: GO 26760
// exit ;
26758: GO 26760
// end ; end ;
26760: LD_VAR 0 3
26764: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
26765: LD_INT 0
26767: PPUSH
26768: PPUSH
26769: PPUSH
26770: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
26771: LD_ADDR_VAR 0 4
26775: PUSH
26776: LD_EXP 6
26780: PUSH
26781: LD_VAR 0 1
26785: ARRAY
26786: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
26787: LD_ADDR_VAR 0 5
26791: PUSH
26792: LD_VAR 0 1
26796: PPUSH
26797: LD_STRING normal
26799: PPUSH
26800: CALL 497 0 2
26804: ST_TO_ADDR
// if apes then
26805: LD_VAR 0 5
26809: IFFALSE 27037
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
26811: LD_INT 2
26813: PPUSH
26814: LD_VAR 0 1
26818: PPUSH
26819: CALL_OW 321
26823: PUSH
26824: LD_INT 2
26826: EQUAL
26827: PUSH
26828: LD_VAR 0 4
26832: PUSH
26833: LD_INT 2
26835: ARRAY
26836: PUSH
26837: LD_INT 1
26839: EQUAL
26840: AND
26841: PUSH
26842: LD_VAR 0 1
26846: PPUSH
26847: LD_STRING engineer
26849: PPUSH
26850: CALL 497 0 2
26854: PUSH
26855: LD_INT 3
26857: LESS
26858: AND
26859: PUSH
26860: LD_VAR 0 1
26864: PPUSH
26865: LD_INT 30
26867: PUSH
26868: LD_INT 1
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: PPUSH
26875: CALL 0 0 2
26879: AND
26880: IFFALSE 26934
// begin for i in apes do
26882: LD_ADDR_VAR 0 3
26886: PUSH
26887: LD_VAR 0 5
26891: PUSH
26892: FOR_IN
26893: IFFALSE 26930
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
26895: LD_VAR 0 3
26899: PPUSH
26900: LD_VAR 0 1
26904: PPUSH
26905: LD_INT 30
26907: PUSH
26908: LD_INT 1
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PPUSH
26915: CALL 0 0 2
26919: PUSH
26920: LD_INT 1
26922: ARRAY
26923: PPUSH
26924: CALL_OW 120
// end ;
26928: GO 26892
26930: POP
26931: POP
// end else
26932: GO 27037
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
26934: LD_INT 11
26936: PPUSH
26937: LD_VAR 0 1
26941: PPUSH
26942: CALL_OW 321
26946: PUSH
26947: LD_INT 2
26949: EQUAL
26950: PUSH
26951: LD_VAR 0 4
26955: PUSH
26956: LD_INT 1
26958: ARRAY
26959: PUSH
26960: LD_INT 1
26962: EQUAL
26963: AND
26964: PUSH
26965: LD_VAR 0 1
26969: PPUSH
26970: LD_INT 30
26972: PUSH
26973: LD_INT 5
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PPUSH
26980: CALL 0 0 2
26984: AND
26985: IFFALSE 27037
// begin for i in apes do
26987: LD_ADDR_VAR 0 3
26991: PUSH
26992: LD_VAR 0 5
26996: PUSH
26997: FOR_IN
26998: IFFALSE 27035
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
27000: LD_VAR 0 3
27004: PPUSH
27005: LD_VAR 0 1
27009: PPUSH
27010: LD_INT 30
27012: PUSH
27013: LD_INT 5
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: PPUSH
27020: CALL 0 0 2
27024: PUSH
27025: LD_INT 1
27027: ARRAY
27028: PPUSH
27029: CALL_OW 120
// end ;
27033: GO 26997
27035: POP
27036: POP
// end ; end ; end ; end_of_file
27037: LD_VAR 0 2
27041: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
27042: LD_INT 0
27044: PPUSH
27045: PPUSH
// if not GetClass ( unit ) = 4 or not target then
27046: LD_VAR 0 1
27050: PPUSH
27051: CALL_OW 257
27055: PUSH
27056: LD_INT 4
27058: EQUAL
27059: NOT
27060: PUSH
27061: LD_VAR 0 2
27065: NOT
27066: OR
27067: IFFALSE 27073
// exit else
27069: GO 27107
27071: GO 27107
// if not GetTag ( unit ) = 4 then
27073: LD_VAR 0 1
27077: PPUSH
27078: CALL_OW 110
27082: PUSH
27083: LD_INT 4
27085: EQUAL
27086: NOT
27087: IFFALSE 27093
// exit else
27089: GO 27107
27091: GO 27107
// ComHeal ( unit , target ) ;
27093: LD_VAR 0 1
27097: PPUSH
27098: LD_VAR 0 2
27102: PPUSH
27103: CALL_OW 128
// end ;
27107: LD_VAR 0 3
27111: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
27112: LD_INT 0
27114: PPUSH
27115: PPUSH
27116: PPUSH
27117: PPUSH
27118: PPUSH
27119: PPUSH
27120: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
27121: LD_ADDR_VAR 0 5
27125: PUSH
27126: LD_INT 22
27128: PUSH
27129: LD_VAR 0 1
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: LD_INT 21
27140: PUSH
27141: LD_INT 1
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 3
27150: PUSH
27151: LD_INT 24
27153: PUSH
27154: LD_INT 1000
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: EMPTY
27162: LIST
27163: LIST
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: LIST
27169: PPUSH
27170: CALL_OW 69
27174: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
27175: LD_ADDR_VAR 0 8
27179: PUSH
27180: LD_VAR 0 1
27184: PPUSH
27185: LD_INT 30
27187: PUSH
27188: LD_INT 1
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PPUSH
27195: CALL 0 0 2
27199: ST_TO_ADDR
// r := [ ] ;
27200: LD_ADDR_VAR 0 6
27204: PUSH
27205: EMPTY
27206: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
27207: LD_VAR 0 1
27211: PPUSH
27212: LD_INT 5
27214: PPUSH
27215: EMPTY
27216: PPUSH
27217: CALL 703 0 3
27221: IFFALSE 27277
// for j in MCF_Tag ( side , 5 , [ ] ) do
27223: LD_ADDR_VAR 0 4
27227: PUSH
27228: LD_VAR 0 1
27232: PPUSH
27233: LD_INT 5
27235: PPUSH
27236: EMPTY
27237: PPUSH
27238: CALL 703 0 3
27242: PUSH
27243: FOR_IN
27244: IFFALSE 27275
// if GetLives ( j ) = 1000 then
27246: LD_VAR 0 4
27250: PPUSH
27251: CALL_OW 256
27255: PUSH
27256: LD_INT 1000
27258: EQUAL
27259: IFFALSE 27273
// SetTag ( j , 0 ) ;
27261: LD_VAR 0 4
27265: PPUSH
27266: LD_INT 0
27268: PPUSH
27269: CALL_OW 109
27273: GO 27243
27275: POP
27276: POP
// if tmp then
27277: LD_VAR 0 5
27281: IFFALSE 27610
// begin r := [ tmp [ 1 ] ] ;
27283: LD_ADDR_VAR 0 6
27287: PUSH
27288: LD_VAR 0 5
27292: PUSH
27293: LD_INT 1
27295: ARRAY
27296: PUSH
27297: EMPTY
27298: LIST
27299: ST_TO_ADDR
// for i = 2 to tmp do
27300: LD_ADDR_VAR 0 3
27304: PUSH
27305: DOUBLE
27306: LD_INT 2
27308: DEC
27309: ST_TO_ADDR
27310: LD_VAR 0 5
27314: PUSH
27315: FOR_TO
27316: IFFALSE 27608
// begin m := false ;
27318: LD_ADDR_VAR 0 7
27322: PUSH
27323: LD_INT 0
27325: ST_TO_ADDR
// if d then
27326: LD_VAR 0 8
27330: IFFALSE 27485
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
27332: LD_VAR 0 5
27336: PUSH
27337: LD_VAR 0 3
27341: ARRAY
27342: PPUSH
27343: CALL_OW 256
27347: PUSH
27348: LD_INT 650
27350: LESS
27351: PUSH
27352: LD_VAR 0 5
27356: PUSH
27357: LD_VAR 0 3
27361: ARRAY
27362: PPUSH
27363: LD_VAR 0 8
27367: PUSH
27368: LD_INT 1
27370: ARRAY
27371: PPUSH
27372: CALL_OW 250
27376: PPUSH
27377: LD_VAR 0 8
27381: PUSH
27382: LD_INT 1
27384: ARRAY
27385: PPUSH
27386: CALL_OW 251
27390: PPUSH
27391: CALL_OW 297
27395: PUSH
27396: LD_INT 10
27398: GREATER
27399: AND
27400: IFFALSE 27485
// begin if not GetTag ( tmp [ i ] ) = 5 then
27402: LD_VAR 0 5
27406: PUSH
27407: LD_VAR 0 3
27411: ARRAY
27412: PPUSH
27413: CALL_OW 110
27417: PUSH
27418: LD_INT 5
27420: EQUAL
27421: NOT
27422: IFFALSE 27442
// SetTag ( tmp [ i ] , 5 ) ;
27424: LD_VAR 0 5
27428: PUSH
27429: LD_VAR 0 3
27433: ARRAY
27434: PPUSH
27435: LD_INT 5
27437: PPUSH
27438: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
27442: LD_VAR 0 5
27446: PUSH
27447: LD_VAR 0 3
27451: ARRAY
27452: PPUSH
27453: LD_VAR 0 8
27457: PUSH
27458: LD_INT 1
27460: ARRAY
27461: PPUSH
27462: CALL_OW 250
27466: PPUSH
27467: LD_VAR 0 8
27471: PUSH
27472: LD_INT 1
27474: ARRAY
27475: PPUSH
27476: CALL_OW 251
27480: PPUSH
27481: CALL_OW 111
// end ; for j = 1 to r do
27485: LD_ADDR_VAR 0 4
27489: PUSH
27490: DOUBLE
27491: LD_INT 1
27493: DEC
27494: ST_TO_ADDR
27495: LD_VAR 0 6
27499: PUSH
27500: FOR_TO
27501: IFFALSE 27575
// if GetLives ( tmp [ i ] ) < r [ j ] then
27503: LD_VAR 0 5
27507: PUSH
27508: LD_VAR 0 3
27512: ARRAY
27513: PPUSH
27514: CALL_OW 256
27518: PUSH
27519: LD_VAR 0 6
27523: PUSH
27524: LD_VAR 0 4
27528: ARRAY
27529: LESS
27530: IFFALSE 27573
// begin r := Insert ( r , j , tmp [ i ] ) ;
27532: LD_ADDR_VAR 0 6
27536: PUSH
27537: LD_VAR 0 6
27541: PPUSH
27542: LD_VAR 0 4
27546: PPUSH
27547: LD_VAR 0 5
27551: PUSH
27552: LD_VAR 0 3
27556: ARRAY
27557: PPUSH
27558: CALL_OW 2
27562: ST_TO_ADDR
// m := true ;
27563: LD_ADDR_VAR 0 7
27567: PUSH
27568: LD_INT 1
27570: ST_TO_ADDR
// break ;
27571: GO 27575
// end ;
27573: GO 27500
27575: POP
27576: POP
// if not m then
27577: LD_VAR 0 7
27581: NOT
27582: IFFALSE 27606
// r := r ^ tmp [ i ] ;
27584: LD_ADDR_VAR 0 6
27588: PUSH
27589: LD_VAR 0 6
27593: PUSH
27594: LD_VAR 0 5
27598: PUSH
27599: LD_VAR 0 3
27603: ARRAY
27604: ADD
27605: ST_TO_ADDR
// end ;
27606: GO 27315
27608: POP
27609: POP
// end ; result := r end ;
27610: LD_ADDR_VAR 0 2
27614: PUSH
27615: LD_VAR 0 6
27619: ST_TO_ADDR
27620: LD_VAR 0 2
27624: RET
