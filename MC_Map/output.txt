// export function MCF_Get ( side , filter ) ; begin
   0: LD_INT 0
   2: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
   3: LD_ADDR_VAR 0 3
   7: PUSH
   8: LD_INT 22
  10: PUSH
  11: LD_VAR 0 1
  15: PUSH
  16: EMPTY
  17: LIST
  18: LIST
  19: PUSH
  20: LD_VAR 0 2
  24: PUSH
  25: EMPTY
  26: LIST
  27: LIST
  28: PPUSH
  29: CALL_OW 69
  33: ST_TO_ADDR
// end ;
  34: LD_VAR 0 3
  38: RET
// export function MCF_Lab ( side ) ; begin
  39: LD_INT 0
  41: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
  42: LD_ADDR_VAR 0 2
  46: PUSH
  47: LD_INT 22
  49: PUSH
  50: LD_VAR 0 1
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 8
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: PUSH
  69: EMPTY
  70: LIST
  71: LIST
  72: PPUSH
  73: CALL_OW 69
  77: ST_TO_ADDR
// end ;
  78: LD_VAR 0 2
  82: RET
// export function MCF_Class ( side , class , filter ) ; begin
  83: LD_INT 0
  85: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
  86: LD_ADDR_VAR 0 4
  90: PUSH
  91: LD_INT 22
  93: PUSH
  94: LD_VAR 0 1
  98: PUSH
  99: EMPTY
 100: LIST
 101: LIST
 102: PUSH
 103: LD_INT 25
 105: PUSH
 106: LD_VAR 0 2
 110: PUSH
 111: EMPTY
 112: LIST
 113: LIST
 114: PUSH
 115: LD_VAR 0 3
 119: PUSH
 120: EMPTY
 121: LIST
 122: LIST
 123: LIST
 124: PPUSH
 125: CALL_OW 69
 129: ST_TO_ADDR
// end ;
 130: LD_VAR 0 4
 134: RET
// export function MCF_All ( side , filter ) ; begin
 135: LD_INT 0
 137: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
 138: LD_ADDR_VAR 0 3
 142: PUSH
 143: LD_INT 22
 145: PUSH
 146: LD_VAR 0 1
 150: PUSH
 151: EMPTY
 152: LIST
 153: LIST
 154: PUSH
 155: LD_INT 2
 157: PUSH
 158: LD_INT 25
 160: PUSH
 161: LD_INT 1
 163: PUSH
 164: EMPTY
 165: LIST
 166: LIST
 167: PUSH
 168: LD_INT 25
 170: PUSH
 171: LD_INT 2
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: PUSH
 178: LD_INT 25
 180: PUSH
 181: LD_INT 3
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PUSH
 188: LD_INT 25
 190: PUSH
 191: LD_INT 4
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: PUSH
 198: EMPTY
 199: LIST
 200: LIST
 201: LIST
 202: LIST
 203: LIST
 204: PUSH
 205: LD_VAR 0 2
 209: PUSH
 210: EMPTY
 211: LIST
 212: LIST
 213: LIST
 214: PPUSH
 215: CALL_OW 69
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 3
 224: RET
// export function MCF_Vehicle ( side , filter ) ; begin
 225: LD_INT 0
 227: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
 228: LD_ADDR_VAR 0 3
 232: PUSH
 233: LD_INT 22
 235: PUSH
 236: LD_VAR 0 1
 240: PUSH
 241: EMPTY
 242: LIST
 243: LIST
 244: PUSH
 245: LD_INT 21
 247: PUSH
 248: LD_INT 2
 250: PUSH
 251: EMPTY
 252: LIST
 253: LIST
 254: PUSH
 255: LD_VAR 0 2
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: PPUSH
 265: CALL_OW 69
 269: ST_TO_ADDR
// end ;
 270: LD_VAR 0 3
 274: RET
// export function MCF_Cargo ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
 278: LD_ADDR_VAR 0 2
 282: PUSH
 283: LD_VAR 0 1
 287: PPUSH
 288: LD_INT 2
 290: PUSH
 291: LD_INT 34
 293: PUSH
 294: LD_INT 12
 296: PUSH
 297: EMPTY
 298: LIST
 299: LIST
 300: PUSH
 301: LD_INT 34
 303: PUSH
 304: LD_INT 32
 306: PUSH
 307: EMPTY
 308: LIST
 309: LIST
 310: PUSH
 311: LD_INT 34
 313: PUSH
 314: LD_INT 51
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: EMPTY
 322: LIST
 323: LIST
 324: LIST
 325: LIST
 326: PPUSH
 327: CALL 225 0 2
 331: ST_TO_ADDR
// end ;
 332: LD_VAR 0 2
 336: RET
// export function MCF_Ape ( side ) ; begin
 337: LD_INT 0
 339: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
 340: LD_ADDR_VAR 0 2
 344: PUSH
 345: LD_INT 22
 347: PUSH
 348: LD_VAR 0 1
 352: PUSH
 353: EMPTY
 354: LIST
 355: LIST
 356: PUSH
 357: LD_INT 2
 359: PUSH
 360: LD_INT 25
 362: PUSH
 363: LD_INT 12
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: PUSH
 370: LD_INT 25
 372: PUSH
 373: LD_INT 15
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: PUSH
 380: LD_INT 25
 382: PUSH
 383: LD_INT 16
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: PUSH
 390: LD_INT 25
 392: PUSH
 393: LD_INT 17
 395: PUSH
 396: EMPTY
 397: LIST
 398: LIST
 399: PUSH
 400: EMPTY
 401: LIST
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: EMPTY
 408: LIST
 409: LIST
 410: PPUSH
 411: CALL_OW 69
 415: ST_TO_ADDR
// end ;
 416: LD_VAR 0 2
 420: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
 421: LD_INT 0
 423: PPUSH
 424: PPUSH
 425: PPUSH
 426: PPUSH
// result := [ ] ;
 427: LD_ADDR_VAR 0 3
 431: PUSH
 432: EMPTY
 433: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
 434: LD_ADDR_VAR 0 4
 438: PUSH
 439: LD_VAR 0 1
 443: PPUSH
 444: CALL 337 0 1
 448: ST_TO_ADDR
// case type of 0 , normal :
 449: LD_VAR 0 2
 453: PUSH
 454: LD_INT 0
 456: DOUBLE
 457: EQUAL
 458: IFTRUE 468
 460: LD_STRING normal
 462: DOUBLE
 463: EQUAL
 464: IFTRUE 468
 466: GO 479
 468: POP
// cl := class_apeman ; 1 , soldier :
 469: LD_ADDR_VAR 0 5
 473: PUSH
 474: LD_INT 12
 476: ST_TO_ADDR
 477: GO 555
 479: LD_INT 1
 481: DOUBLE
 482: EQUAL
 483: IFTRUE 493
 485: LD_STRING soldier
 487: DOUBLE
 488: EQUAL
 489: IFTRUE 493
 491: GO 504
 493: POP
// cl := class_apeman_soldier ; 2 , engineer :
 494: LD_ADDR_VAR 0 5
 498: PUSH
 499: LD_INT 15
 501: ST_TO_ADDR
 502: GO 555
 504: LD_INT 2
 506: DOUBLE
 507: EQUAL
 508: IFTRUE 518
 510: LD_STRING engineer
 512: DOUBLE
 513: EQUAL
 514: IFTRUE 518
 516: GO 529
 518: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
 519: LD_ADDR_VAR 0 5
 523: PUSH
 524: LD_INT 16
 526: ST_TO_ADDR
 527: GO 555
 529: LD_INT 3
 531: DOUBLE
 532: EQUAL
 533: IFTRUE 543
 535: LD_STRING kamikaze
 537: DOUBLE
 538: EQUAL
 539: IFTRUE 543
 541: GO 554
 543: POP
// cl := class_apeman_kamikaze ; end ;
 544: LD_ADDR_VAR 0 5
 548: PUSH
 549: LD_INT 17
 551: ST_TO_ADDR
 552: GO 555
 554: POP
// for i = 1 to tmp do
 555: LD_ADDR_VAR 0 6
 559: PUSH
 560: DOUBLE
 561: LD_INT 1
 563: DEC
 564: ST_TO_ADDR
 565: LD_VAR 0 4
 569: PUSH
 570: FOR_TO
 571: IFFALSE 620
// if GetClass ( tmp [ i ] ) = cl then
 573: LD_VAR 0 4
 577: PUSH
 578: LD_VAR 0 6
 582: ARRAY
 583: PPUSH
 584: CALL_OW 257
 588: PUSH
 589: LD_VAR 0 5
 593: EQUAL
 594: IFFALSE 618
// result := result ^ tmp [ i ] ;
 596: LD_ADDR_VAR 0 3
 600: PUSH
 601: LD_VAR 0 3
 605: PUSH
 606: LD_VAR 0 4
 610: PUSH
 611: LD_VAR 0 6
 615: ARRAY
 616: ADD
 617: ST_TO_ADDR
 618: GO 570
 620: POP
 621: POP
// end ;
 622: LD_VAR 0 3
 626: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
 627: LD_INT 0
 629: PPUSH
 630: PPUSH
 631: PPUSH
 632: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
 633: LD_ADDR_VAR 0 5
 637: PUSH
 638: LD_INT 22
 640: PUSH
 641: LD_VAR 0 1
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: PUSH
 650: LD_VAR 0 3
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: PPUSH
 659: CALL_OW 69
 663: ST_TO_ADDR
// r := [ ] ;
 664: LD_ADDR_VAR 0 6
 668: PUSH
 669: EMPTY
 670: ST_TO_ADDR
// if tmp then
 671: LD_VAR 0 5
 675: IFFALSE 744
// for i = 1 to tmp do
 677: LD_ADDR_VAR 0 7
 681: PUSH
 682: DOUBLE
 683: LD_INT 1
 685: DEC
 686: ST_TO_ADDR
 687: LD_VAR 0 5
 691: PUSH
 692: FOR_TO
 693: IFFALSE 742
// if GetTag ( tmp [ i ] ) = tag then
 695: LD_VAR 0 5
 699: PUSH
 700: LD_VAR 0 7
 704: ARRAY
 705: PPUSH
 706: CALL_OW 110
 710: PUSH
 711: LD_VAR 0 2
 715: EQUAL
 716: IFFALSE 740
// r := r ^ tmp [ i ] ;
 718: LD_ADDR_VAR 0 6
 722: PUSH
 723: LD_VAR 0 6
 727: PUSH
 728: LD_VAR 0 5
 732: PUSH
 733: LD_VAR 0 7
 737: ARRAY
 738: ADD
 739: ST_TO_ADDR
 740: GO 692
 742: POP
 743: POP
// result := r ;
 744: LD_ADDR_VAR 0 4
 748: PUSH
 749: LD_VAR 0 6
 753: ST_TO_ADDR
// end ;
 754: LD_VAR 0 4
 758: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
 759: LD_INT 0
 761: PPUSH
 762: PPUSH
 763: PPUSH
// tmp := plist ;
 764: LD_ADDR_VAR 0 5
 768: PUSH
 769: LD_VAR 0 2
 773: ST_TO_ADDR
// if tmp then
 774: LD_VAR 0 5
 778: IFFALSE 855
// begin for i = 1 to tmp do
 780: LD_ADDR_VAR 0 6
 784: PUSH
 785: DOUBLE
 786: LD_INT 1
 788: DEC
 789: ST_TO_ADDR
 790: LD_VAR 0 5
 794: PUSH
 795: FOR_TO
 796: IFFALSE 843
// if GetTag ( tmp [ i ] ) <> tag then
 798: LD_VAR 0 5
 802: PUSH
 803: LD_VAR 0 6
 807: ARRAY
 808: PPUSH
 809: CALL_OW 110
 813: PUSH
 814: LD_VAR 0 3
 818: NONEQUAL
 819: IFFALSE 841
// SetTag ( tmp [ i ] , tag ) ;
 821: LD_VAR 0 5
 825: PUSH
 826: LD_VAR 0 6
 830: ARRAY
 831: PPUSH
 832: LD_VAR 0 3
 836: PPUSH
 837: CALL_OW 109
 841: GO 795
 843: POP
 844: POP
// result := true ;
 845: LD_ADDR_VAR 0 4
 849: PUSH
 850: LD_INT 1
 852: ST_TO_ADDR
// end else
 853: GO 863
// result := false ;
 855: LD_ADDR_VAR 0 4
 859: PUSH
 860: LD_INT 0
 862: ST_TO_ADDR
// end ;
 863: LD_VAR 0 4
 867: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
 868: LD_INT 0
 870: PPUSH
 871: PPUSH
 872: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
 873: LD_ADDR_VAR 0 4
 877: PUSH
 878: LD_VAR 0 1
 882: PPUSH
 883: LD_VAR 0 2
 887: PPUSH
 888: EMPTY
 889: PPUSH
 890: CALL 627 0 3
 894: ST_TO_ADDR
// if tmp then
 895: LD_VAR 0 4
 899: IFFALSE 951
// begin for i = 1 to tmp do
 901: LD_ADDR_VAR 0 5
 905: PUSH
 906: DOUBLE
 907: LD_INT 1
 909: DEC
 910: ST_TO_ADDR
 911: LD_VAR 0 4
 915: PUSH
 916: FOR_TO
 917: IFFALSE 939
// SetTag ( tmp [ i ] , 0 ) ;
 919: LD_VAR 0 4
 923: PUSH
 924: LD_VAR 0 5
 928: ARRAY
 929: PPUSH
 930: LD_INT 0
 932: PPUSH
 933: CALL_OW 109
 937: GO 916
 939: POP
 940: POP
// result := true ;
 941: LD_ADDR_VAR 0 3
 945: PUSH
 946: LD_INT 1
 948: ST_TO_ADDR
// end else
 949: GO 959
// result := false ;
 951: LD_ADDR_VAR 0 3
 955: PUSH
 956: LD_INT 0
 958: ST_TO_ADDR
// end ;
 959: LD_VAR 0 3
 963: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
 964: LD_INT 0
 966: PPUSH
 967: PPUSH
 968: PPUSH
 969: PPUSH
 970: PPUSH
// sort_list := [ ] ;
 971: LD_ADDR_VAR 0 5
 975: PUSH
 976: EMPTY
 977: ST_TO_ADDR
// for i = 1 to list do
 978: LD_ADDR_VAR 0 3
 982: PUSH
 983: DOUBLE
 984: LD_INT 1
 986: DEC
 987: ST_TO_ADDR
 988: LD_VAR 0 1
 992: PUSH
 993: FOR_TO
 994: IFFALSE 1156
// begin if i = 1 then
 996: LD_VAR 0 3
1000: PUSH
1001: LD_INT 1
1003: EQUAL
1004: IFFALSE 1030
// sort_list := sort_list ^ list [ i ] else
1006: LD_ADDR_VAR 0 5
1010: PUSH
1011: LD_VAR 0 5
1015: PUSH
1016: LD_VAR 0 1
1020: PUSH
1021: LD_VAR 0 3
1025: ARRAY
1026: ADD
1027: ST_TO_ADDR
1028: GO 1154
// begin for j = 1 to sort_list do
1030: LD_ADDR_VAR 0 4
1034: PUSH
1035: DOUBLE
1036: LD_INT 1
1038: DEC
1039: ST_TO_ADDR
1040: LD_VAR 0 5
1044: PUSH
1045: FOR_TO
1046: IFFALSE 1123
// begin add := false ;
1048: LD_ADDR_VAR 0 6
1052: PUSH
1053: LD_INT 0
1055: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
1056: LD_VAR 0 1
1060: PUSH
1061: LD_VAR 0 3
1065: ARRAY
1066: PUSH
1067: LD_VAR 0 5
1071: PUSH
1072: LD_VAR 0 4
1076: ARRAY
1077: LESS
1078: IFFALSE 1121
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
1080: LD_ADDR_VAR 0 5
1084: PUSH
1085: LD_VAR 0 5
1089: PPUSH
1090: LD_VAR 0 4
1094: PPUSH
1095: LD_VAR 0 1
1099: PUSH
1100: LD_VAR 0 3
1104: ARRAY
1105: PPUSH
1106: CALL_OW 2
1110: ST_TO_ADDR
// add := true ;
1111: LD_ADDR_VAR 0 6
1115: PUSH
1116: LD_INT 1
1118: ST_TO_ADDR
// break ;
1119: GO 1123
// end ; end ;
1121: GO 1045
1123: POP
1124: POP
// if not add then
1125: LD_VAR 0 6
1129: NOT
1130: IFFALSE 1154
// sort_list := sort_list ^ list [ i ] ;
1132: LD_ADDR_VAR 0 5
1136: PUSH
1137: LD_VAR 0 5
1141: PUSH
1142: LD_VAR 0 1
1146: PUSH
1147: LD_VAR 0 3
1151: ARRAY
1152: ADD
1153: ST_TO_ADDR
// end ; end ;
1154: GO 993
1156: POP
1157: POP
// result := sort_list ;
1158: LD_ADDR_VAR 0 2
1162: PUSH
1163: LD_VAR 0 5
1167: ST_TO_ADDR
// end ;
1168: LD_VAR 0 2
1172: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
1173: LD_INT 0
1175: PPUSH
1176: PPUSH
1177: PPUSH
1178: PPUSH
1179: PPUSH
// sort_list := [ ] ;
1180: LD_ADDR_VAR 0 5
1184: PUSH
1185: EMPTY
1186: ST_TO_ADDR
// for i = 1 to list do
1187: LD_ADDR_VAR 0 3
1191: PUSH
1192: DOUBLE
1193: LD_INT 1
1195: DEC
1196: ST_TO_ADDR
1197: LD_VAR 0 1
1201: PUSH
1202: FOR_TO
1203: IFFALSE 1365
// begin if i = 1 then
1205: LD_VAR 0 3
1209: PUSH
1210: LD_INT 1
1212: EQUAL
1213: IFFALSE 1239
// sort_list := sort_list ^ list [ i ] else
1215: LD_ADDR_VAR 0 5
1219: PUSH
1220: LD_VAR 0 5
1224: PUSH
1225: LD_VAR 0 1
1229: PUSH
1230: LD_VAR 0 3
1234: ARRAY
1235: ADD
1236: ST_TO_ADDR
1237: GO 1363
// begin for j = 1 to sort_list do
1239: LD_ADDR_VAR 0 4
1243: PUSH
1244: DOUBLE
1245: LD_INT 1
1247: DEC
1248: ST_TO_ADDR
1249: LD_VAR 0 5
1253: PUSH
1254: FOR_TO
1255: IFFALSE 1332
// begin add := false ;
1257: LD_ADDR_VAR 0 6
1261: PUSH
1262: LD_INT 0
1264: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
1265: LD_VAR 0 1
1269: PUSH
1270: LD_VAR 0 3
1274: ARRAY
1275: PUSH
1276: LD_VAR 0 5
1280: PUSH
1281: LD_VAR 0 4
1285: ARRAY
1286: GREATER
1287: IFFALSE 1330
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
1289: LD_ADDR_VAR 0 5
1293: PUSH
1294: LD_VAR 0 5
1298: PPUSH
1299: LD_VAR 0 4
1303: PPUSH
1304: LD_VAR 0 1
1308: PUSH
1309: LD_VAR 0 3
1313: ARRAY
1314: PPUSH
1315: CALL_OW 2
1319: ST_TO_ADDR
// add := true ;
1320: LD_ADDR_VAR 0 6
1324: PUSH
1325: LD_INT 1
1327: ST_TO_ADDR
// break ;
1328: GO 1332
// end ; end ;
1330: GO 1254
1332: POP
1333: POP
// if not add then
1334: LD_VAR 0 6
1338: NOT
1339: IFFALSE 1363
// sort_list := sort_list ^ list [ i ] ;
1341: LD_ADDR_VAR 0 5
1345: PUSH
1346: LD_VAR 0 5
1350: PUSH
1351: LD_VAR 0 1
1355: PUSH
1356: LD_VAR 0 3
1360: ARRAY
1361: ADD
1362: ST_TO_ADDR
// end ; end ;
1363: GO 1202
1365: POP
1366: POP
// result := sort_list ;
1367: LD_ADDR_VAR 0 2
1371: PUSH
1372: LD_VAR 0 5
1376: ST_TO_ADDR
// end ;
1377: LD_VAR 0 2
1381: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
1382: LD_INT 0
1384: PPUSH
1385: PPUSH
1386: PPUSH
1387: PPUSH
1388: PPUSH
1389: PPUSH
// tmp := [ ] ;
1390: LD_ADDR_VAR 0 8
1394: PUSH
1395: EMPTY
1396: ST_TO_ADDR
// r := [ ] ;
1397: LD_ADDR_VAR 0 7
1401: PUSH
1402: EMPTY
1403: ST_TO_ADDR
// add := false ;
1404: LD_ADDR_VAR 0 9
1408: PUSH
1409: LD_INT 0
1411: ST_TO_ADDR
// if plist then
1412: LD_VAR 0 2
1416: IFFALSE 1492
// begin for i = 1 to plist do
1418: LD_ADDR_VAR 0 5
1422: PUSH
1423: DOUBLE
1424: LD_INT 1
1426: DEC
1427: ST_TO_ADDR
1428: LD_VAR 0 2
1432: PUSH
1433: FOR_TO
1434: IFFALSE 1488
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
1436: LD_ADDR_VAR 0 8
1440: PUSH
1441: LD_VAR 0 8
1445: PUSH
1446: LD_VAR 0 2
1450: PUSH
1451: LD_VAR 0 5
1455: ARRAY
1456: PUSH
1457: LD_VAR 0 2
1461: PUSH
1462: LD_VAR 0 5
1466: ARRAY
1467: PPUSH
1468: LD_VAR 0 3
1472: PPUSH
1473: CALL_OW 259
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: EMPTY
1483: LIST
1484: ADD
1485: ST_TO_ADDR
// end ;
1486: GO 1433
1488: POP
1489: POP
// end else
1490: GO 1500
// result := false ;
1492: LD_ADDR_VAR 0 4
1496: PUSH
1497: LD_INT 0
1499: ST_TO_ADDR
// if tmp then
1500: LD_VAR 0 8
1504: IFFALSE 1678
// begin r := r ^ [ tmp [ 1 ] ] ;
1506: LD_ADDR_VAR 0 7
1510: PUSH
1511: LD_VAR 0 7
1515: PUSH
1516: LD_VAR 0 8
1520: PUSH
1521: LD_INT 1
1523: ARRAY
1524: PUSH
1525: EMPTY
1526: LIST
1527: ADD
1528: ST_TO_ADDR
// for i = 2 to tmp do
1529: LD_ADDR_VAR 0 5
1533: PUSH
1534: DOUBLE
1535: LD_INT 2
1537: DEC
1538: ST_TO_ADDR
1539: LD_VAR 0 8
1543: PUSH
1544: FOR_TO
1545: IFFALSE 1676
// begin for j = 1 to r do
1547: LD_ADDR_VAR 0 6
1551: PUSH
1552: DOUBLE
1553: LD_INT 1
1555: DEC
1556: ST_TO_ADDR
1557: LD_VAR 0 7
1561: PUSH
1562: FOR_TO
1563: IFFALSE 1640
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
1565: LD_VAR 0 8
1569: PUSH
1570: LD_VAR 0 5
1574: ARRAY
1575: PUSH
1576: LD_INT 2
1578: ARRAY
1579: PUSH
1580: LD_VAR 0 7
1584: PUSH
1585: LD_VAR 0 6
1589: ARRAY
1590: PUSH
1591: LD_INT 2
1593: ARRAY
1594: LESS
1595: IFFALSE 1638
// begin r := Insert ( r , j , tmp [ i ] ) ;
1597: LD_ADDR_VAR 0 7
1601: PUSH
1602: LD_VAR 0 7
1606: PPUSH
1607: LD_VAR 0 6
1611: PPUSH
1612: LD_VAR 0 8
1616: PUSH
1617: LD_VAR 0 5
1621: ARRAY
1622: PPUSH
1623: CALL_OW 2
1627: ST_TO_ADDR
// add := true ;
1628: LD_ADDR_VAR 0 9
1632: PUSH
1633: LD_INT 1
1635: ST_TO_ADDR
// break ;
1636: GO 1640
// end ; end ;
1638: GO 1562
1640: POP
1641: POP
// if not add then
1642: LD_VAR 0 9
1646: NOT
1647: IFFALSE 1674
// r := r ^ [ tmp [ i ] ] ;
1649: LD_ADDR_VAR 0 7
1653: PUSH
1654: LD_VAR 0 7
1658: PUSH
1659: LD_VAR 0 8
1663: PUSH
1664: LD_VAR 0 5
1668: ARRAY
1669: PUSH
1670: EMPTY
1671: LIST
1672: ADD
1673: ST_TO_ADDR
// end ;
1674: GO 1544
1676: POP
1677: POP
// end ; result := r ;
1678: LD_ADDR_VAR 0 4
1682: PUSH
1683: LD_VAR 0 7
1687: ST_TO_ADDR
// end ;
1688: LD_VAR 0 4
1692: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
1693: LD_INT 0
1695: PPUSH
1696: PPUSH
1697: PPUSH
1698: PPUSH
1699: PPUSH
1700: PPUSH
// tmp := [ ] ;
1701: LD_ADDR_VAR 0 8
1705: PUSH
1706: EMPTY
1707: ST_TO_ADDR
// r := [ ] ;
1708: LD_ADDR_VAR 0 7
1712: PUSH
1713: EMPTY
1714: ST_TO_ADDR
// add := false ;
1715: LD_ADDR_VAR 0 9
1719: PUSH
1720: LD_INT 0
1722: ST_TO_ADDR
// if plist then
1723: LD_VAR 0 2
1727: IFFALSE 1803
// begin for i = 1 to plist do
1729: LD_ADDR_VAR 0 5
1733: PUSH
1734: DOUBLE
1735: LD_INT 1
1737: DEC
1738: ST_TO_ADDR
1739: LD_VAR 0 2
1743: PUSH
1744: FOR_TO
1745: IFFALSE 1799
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
1747: LD_ADDR_VAR 0 8
1751: PUSH
1752: LD_VAR 0 8
1756: PUSH
1757: LD_VAR 0 2
1761: PUSH
1762: LD_VAR 0 5
1766: ARRAY
1767: PUSH
1768: LD_VAR 0 2
1772: PUSH
1773: LD_VAR 0 5
1777: ARRAY
1778: PPUSH
1779: LD_VAR 0 3
1783: PPUSH
1784: CALL_OW 259
1788: PUSH
1789: EMPTY
1790: LIST
1791: LIST
1792: PUSH
1793: EMPTY
1794: LIST
1795: ADD
1796: ST_TO_ADDR
// end ;
1797: GO 1744
1799: POP
1800: POP
// end else
1801: GO 1811
// result := false ;
1803: LD_ADDR_VAR 0 4
1807: PUSH
1808: LD_INT 0
1810: ST_TO_ADDR
// if tmp then
1811: LD_VAR 0 8
1815: IFFALSE 1989
// begin r := r ^ [ tmp [ 1 ] ] ;
1817: LD_ADDR_VAR 0 7
1821: PUSH
1822: LD_VAR 0 7
1826: PUSH
1827: LD_VAR 0 8
1831: PUSH
1832: LD_INT 1
1834: ARRAY
1835: PUSH
1836: EMPTY
1837: LIST
1838: ADD
1839: ST_TO_ADDR
// for i = 2 to tmp do
1840: LD_ADDR_VAR 0 5
1844: PUSH
1845: DOUBLE
1846: LD_INT 2
1848: DEC
1849: ST_TO_ADDR
1850: LD_VAR 0 8
1854: PUSH
1855: FOR_TO
1856: IFFALSE 1987
// begin for j = 1 to r do
1858: LD_ADDR_VAR 0 6
1862: PUSH
1863: DOUBLE
1864: LD_INT 1
1866: DEC
1867: ST_TO_ADDR
1868: LD_VAR 0 7
1872: PUSH
1873: FOR_TO
1874: IFFALSE 1951
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
1876: LD_VAR 0 8
1880: PUSH
1881: LD_VAR 0 5
1885: ARRAY
1886: PUSH
1887: LD_INT 2
1889: ARRAY
1890: PUSH
1891: LD_VAR 0 7
1895: PUSH
1896: LD_VAR 0 6
1900: ARRAY
1901: PUSH
1902: LD_INT 2
1904: ARRAY
1905: GREATER
1906: IFFALSE 1949
// begin r := Insert ( r , j , tmp [ i ] ) ;
1908: LD_ADDR_VAR 0 7
1912: PUSH
1913: LD_VAR 0 7
1917: PPUSH
1918: LD_VAR 0 6
1922: PPUSH
1923: LD_VAR 0 8
1927: PUSH
1928: LD_VAR 0 5
1932: ARRAY
1933: PPUSH
1934: CALL_OW 2
1938: ST_TO_ADDR
// add := true ;
1939: LD_ADDR_VAR 0 9
1943: PUSH
1944: LD_INT 1
1946: ST_TO_ADDR
// break ;
1947: GO 1951
// end ; end ;
1949: GO 1873
1951: POP
1952: POP
// if not add then
1953: LD_VAR 0 9
1957: NOT
1958: IFFALSE 1985
// r := r ^ [ tmp [ i ] ] ;
1960: LD_ADDR_VAR 0 7
1964: PUSH
1965: LD_VAR 0 7
1969: PUSH
1970: LD_VAR 0 8
1974: PUSH
1975: LD_VAR 0 5
1979: ARRAY
1980: PUSH
1981: EMPTY
1982: LIST
1983: ADD
1984: ST_TO_ADDR
// end ;
1985: GO 1855
1987: POP
1988: POP
// end ; result := r ;
1989: LD_ADDR_VAR 0 4
1993: PUSH
1994: LD_VAR 0 7
1998: ST_TO_ADDR
// end ;
1999: LD_VAR 0 4
2003: RET
// export function MCF_Clear ( side ) ; var i ; begin
2004: LD_INT 0
2006: PPUSH
2007: PPUSH
// for i = 1 to 100 do
2008: LD_ADDR_VAR 0 3
2012: PUSH
2013: DOUBLE
2014: LD_INT 1
2016: DEC
2017: ST_TO_ADDR
2018: LD_INT 100
2020: PUSH
2021: FOR_TO
2022: IFFALSE 2058
// if MCF_Tag ( side , i , [ ] ) then
2024: LD_VAR 0 1
2028: PPUSH
2029: LD_VAR 0 3
2033: PPUSH
2034: EMPTY
2035: PPUSH
2036: CALL 627 0 3
2040: IFFALSE 2056
// MCF_ClearTag ( side , i ) ;
2042: LD_VAR 0 1
2046: PPUSH
2047: LD_VAR 0 3
2051: PPUSH
2052: CALL 868 0 2
2056: GO 2021
2058: POP
2059: POP
// result := true ;
2060: LD_ADDR_VAR 0 2
2064: PUSH
2065: LD_INT 1
2067: ST_TO_ADDR
// end ;
2068: LD_VAR 0 2
2072: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
2073: LD_INT 0
2075: PPUSH
2076: PPUSH
2077: PPUSH
// for i = 1 to plist do
2078: LD_ADDR_VAR 0 4
2082: PUSH
2083: DOUBLE
2084: LD_INT 1
2086: DEC
2087: ST_TO_ADDR
2088: LD_VAR 0 1
2092: PUSH
2093: FOR_TO
2094: IFFALSE 2143
// if MCF_HasClass ( plist [ i ] ) = n then
2096: LD_VAR 0 1
2100: PUSH
2101: LD_VAR 0 4
2105: ARRAY
2106: PPUSH
2107: CALL 2478 0 1
2111: PUSH
2112: LD_VAR 0 2
2116: EQUAL
2117: IFFALSE 2141
// tmp := tmp ^ plist [ i ] ;
2119: LD_ADDR_VAR 0 5
2123: PUSH
2124: LD_VAR 0 5
2128: PUSH
2129: LD_VAR 0 1
2133: PUSH
2134: LD_VAR 0 4
2138: ARRAY
2139: ADD
2140: ST_TO_ADDR
2141: GO 2093
2143: POP
2144: POP
// result := tmp ;
2145: LD_ADDR_VAR 0 3
2149: PUSH
2150: LD_VAR 0 5
2154: ST_TO_ADDR
// end ;
2155: LD_VAR 0 3
2159: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
2160: LD_INT 0
2162: PPUSH
2163: PPUSH
2164: PPUSH
// if mreg = ToArm then
2165: LD_VAR 0 2
2169: PUSH
2170: LD_STRING ToArm
2172: EQUAL
2173: IFFALSE 2240
// for i = MREG_ToArm [ side ] downto n do
2175: LD_ADDR_VAR 0 5
2179: PUSH
2180: DOUBLE
2181: LD_EXP 25
2185: PUSH
2186: LD_VAR 0 1
2190: ARRAY
2191: INC
2192: ST_TO_ADDR
2193: LD_VAR 0 3
2197: PUSH
2198: FOR_DOWNTO
2199: IFFALSE 2238
// MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
2201: LD_ADDR_EXP 25
2205: PUSH
2206: LD_EXP 25
2210: PPUSH
2211: LD_EXP 25
2215: PUSH
2216: LD_VAR 0 1
2220: ARRAY
2221: PUSH
2222: LD_VAR 0 5
2226: ARRAY
2227: PPUSH
2228: LD_INT 1
2230: PPUSH
2231: CALL 23535 0 3
2235: ST_TO_ADDR
2236: GO 2198
2238: POP
2239: POP
// if mreg = ToDep then
2240: LD_VAR 0 2
2244: PUSH
2245: LD_STRING ToDep
2247: EQUAL
2248: IFFALSE 2315
// for i = MREG_ToDep [ side ] downto n do
2250: LD_ADDR_VAR 0 5
2254: PUSH
2255: DOUBLE
2256: LD_EXP 26
2260: PUSH
2261: LD_VAR 0 1
2265: ARRAY
2266: INC
2267: ST_TO_ADDR
2268: LD_VAR 0 3
2272: PUSH
2273: FOR_DOWNTO
2274: IFFALSE 2313
// MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
2276: LD_ADDR_EXP 26
2280: PUSH
2281: LD_EXP 26
2285: PPUSH
2286: LD_EXP 26
2290: PUSH
2291: LD_VAR 0 1
2295: ARRAY
2296: PUSH
2297: LD_VAR 0 5
2301: ARRAY
2302: PPUSH
2303: LD_INT 1
2305: PPUSH
2306: CALL 23535 0 3
2310: ST_TO_ADDR
2311: GO 2273
2313: POP
2314: POP
// if mreg = ToFac then
2315: LD_VAR 0 2
2319: PUSH
2320: LD_STRING ToFac
2322: EQUAL
2323: IFFALSE 2390
// for i = MREG_ToFac [ side ] downto n do
2325: LD_ADDR_VAR 0 5
2329: PUSH
2330: DOUBLE
2331: LD_EXP 24
2335: PUSH
2336: LD_VAR 0 1
2340: ARRAY
2341: INC
2342: ST_TO_ADDR
2343: LD_VAR 0 3
2347: PUSH
2348: FOR_DOWNTO
2349: IFFALSE 2388
// MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
2351: LD_ADDR_EXP 24
2355: PUSH
2356: LD_EXP 24
2360: PPUSH
2361: LD_EXP 24
2365: PUSH
2366: LD_VAR 0 1
2370: ARRAY
2371: PUSH
2372: LD_VAR 0 5
2376: ARRAY
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL 23535 0 3
2385: ST_TO_ADDR
2386: GO 2348
2388: POP
2389: POP
// if mreg = ToLab then
2390: LD_VAR 0 2
2394: PUSH
2395: LD_STRING ToLab
2397: EQUAL
2398: IFFALSE 2465
// for i = MREG_ToLab [ side ] downto n do
2400: LD_ADDR_VAR 0 5
2404: PUSH
2405: DOUBLE
2406: LD_EXP 23
2410: PUSH
2411: LD_VAR 0 1
2415: ARRAY
2416: INC
2417: ST_TO_ADDR
2418: LD_VAR 0 3
2422: PUSH
2423: FOR_DOWNTO
2424: IFFALSE 2463
// MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
2426: LD_ADDR_EXP 23
2430: PUSH
2431: LD_EXP 23
2435: PPUSH
2436: LD_EXP 23
2440: PUSH
2441: LD_VAR 0 1
2445: ARRAY
2446: PUSH
2447: LD_VAR 0 5
2451: ARRAY
2452: PPUSH
2453: LD_INT 1
2455: PPUSH
2456: CALL 23535 0 3
2460: ST_TO_ADDR
2461: GO 2423
2463: POP
2464: POP
// result := true ;
2465: LD_ADDR_VAR 0 4
2469: PUSH
2470: LD_INT 1
2472: ST_TO_ADDR
// end ;
2473: LD_VAR 0 4
2477: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
2478: LD_INT 0
2480: PPUSH
2481: PPUSH
2482: PPUSH
// side := GetSide ( unit ) ;
2483: LD_ADDR_VAR 0 4
2487: PUSH
2488: LD_VAR 0 1
2492: PPUSH
2493: CALL_OW 255
2497: ST_TO_ADDR
// tmp := 0 ;
2498: LD_ADDR_VAR 0 3
2502: PUSH
2503: LD_INT 0
2505: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
2506: LD_VAR 0 1
2510: PUSH
2511: LD_EXP 25
2515: PUSH
2516: LD_VAR 0 4
2520: ARRAY
2521: IN
2522: IFFALSE 2532
// tmp := 1 ;
2524: LD_ADDR_VAR 0 3
2528: PUSH
2529: LD_INT 1
2531: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
2532: LD_VAR 0 1
2536: PUSH
2537: LD_EXP 26
2541: PUSH
2542: LD_VAR 0 4
2546: ARRAY
2547: IN
2548: IFFALSE 2558
// tmp := 2 ;
2550: LD_ADDR_VAR 0 3
2554: PUSH
2555: LD_INT 2
2557: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
2558: LD_VAR 0 1
2562: PUSH
2563: LD_EXP 24
2567: PUSH
2568: LD_VAR 0 4
2572: ARRAY
2573: IN
2574: IFFALSE 2584
// tmp := 3 ;
2576: LD_ADDR_VAR 0 3
2580: PUSH
2581: LD_INT 3
2583: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
2584: LD_VAR 0 1
2588: PUSH
2589: LD_EXP 23
2593: PUSH
2594: LD_VAR 0 4
2598: ARRAY
2599: IN
2600: IFFALSE 2610
// tmp := 4 ;
2602: LD_ADDR_VAR 0 3
2606: PUSH
2607: LD_INT 4
2609: ST_TO_ADDR
// result := tmp ;
2610: LD_ADDR_VAR 0 2
2614: PUSH
2615: LD_VAR 0 3
2619: ST_TO_ADDR
// end ;
2620: LD_VAR 0 2
2624: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
2625: LD_INT 0
2627: PPUSH
2628: PPUSH
// if mreg = ToArm then
2629: LD_VAR 0 2
2633: PUSH
2634: LD_STRING ToArm
2636: EQUAL
2637: IFFALSE 2726
// for i = MREG_ToArm [ side ] downto 1 do
2639: LD_ADDR_VAR 0 5
2643: PUSH
2644: DOUBLE
2645: LD_EXP 25
2649: PUSH
2650: LD_VAR 0 1
2654: ARRAY
2655: INC
2656: ST_TO_ADDR
2657: LD_INT 1
2659: PUSH
2660: FOR_DOWNTO
2661: IFFALSE 2724
// if MREG_ToArm [ side ] [ i ] = unit then
2663: LD_EXP 25
2667: PUSH
2668: LD_VAR 0 1
2672: ARRAY
2673: PUSH
2674: LD_VAR 0 5
2678: ARRAY
2679: PUSH
2680: LD_VAR 0 3
2684: EQUAL
2685: IFFALSE 2722
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
2687: LD_ADDR_EXP 25
2691: PUSH
2692: LD_EXP 25
2696: PPUSH
2697: LD_EXP 25
2701: PUSH
2702: LD_VAR 0 1
2706: ARRAY
2707: PUSH
2708: LD_VAR 0 5
2712: ARRAY
2713: PPUSH
2714: LD_INT 1
2716: PPUSH
2717: CALL 23535 0 3
2721: ST_TO_ADDR
// end ;
2722: GO 2660
2724: POP
2725: POP
// if mreg = ToDep then
2726: LD_VAR 0 2
2730: PUSH
2731: LD_STRING ToDep
2733: EQUAL
2734: IFFALSE 2823
// for i = MREG_ToDep [ side ] downto 1 do
2736: LD_ADDR_VAR 0 5
2740: PUSH
2741: DOUBLE
2742: LD_EXP 26
2746: PUSH
2747: LD_VAR 0 1
2751: ARRAY
2752: INC
2753: ST_TO_ADDR
2754: LD_INT 1
2756: PUSH
2757: FOR_DOWNTO
2758: IFFALSE 2821
// if MREG_ToDep [ side ] [ i ] = unit then
2760: LD_EXP 26
2764: PUSH
2765: LD_VAR 0 1
2769: ARRAY
2770: PUSH
2771: LD_VAR 0 5
2775: ARRAY
2776: PUSH
2777: LD_VAR 0 3
2781: EQUAL
2782: IFFALSE 2819
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
2784: LD_ADDR_EXP 26
2788: PUSH
2789: LD_EXP 26
2793: PPUSH
2794: LD_EXP 26
2798: PUSH
2799: LD_VAR 0 1
2803: ARRAY
2804: PUSH
2805: LD_VAR 0 5
2809: ARRAY
2810: PPUSH
2811: LD_INT 1
2813: PPUSH
2814: CALL 23535 0 3
2818: ST_TO_ADDR
// end ;
2819: GO 2757
2821: POP
2822: POP
// if mreg = ToFac then
2823: LD_VAR 0 2
2827: PUSH
2828: LD_STRING ToFac
2830: EQUAL
2831: IFFALSE 2920
// for i = MREG_ToFac [ side ] downto 1 do
2833: LD_ADDR_VAR 0 5
2837: PUSH
2838: DOUBLE
2839: LD_EXP 24
2843: PUSH
2844: LD_VAR 0 1
2848: ARRAY
2849: INC
2850: ST_TO_ADDR
2851: LD_INT 1
2853: PUSH
2854: FOR_DOWNTO
2855: IFFALSE 2918
// if MREG_ToFac [ side ] [ i ] = unit then
2857: LD_EXP 24
2861: PUSH
2862: LD_VAR 0 1
2866: ARRAY
2867: PUSH
2868: LD_VAR 0 5
2872: ARRAY
2873: PUSH
2874: LD_VAR 0 3
2878: EQUAL
2879: IFFALSE 2916
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
2881: LD_ADDR_EXP 24
2885: PUSH
2886: LD_EXP 24
2890: PPUSH
2891: LD_EXP 24
2895: PUSH
2896: LD_VAR 0 1
2900: ARRAY
2901: PUSH
2902: LD_VAR 0 5
2906: ARRAY
2907: PPUSH
2908: LD_INT 1
2910: PPUSH
2911: CALL 23535 0 3
2915: ST_TO_ADDR
// end ;
2916: GO 2854
2918: POP
2919: POP
// if mreg = ToLab then
2920: LD_VAR 0 2
2924: PUSH
2925: LD_STRING ToLab
2927: EQUAL
2928: IFFALSE 3017
// for i = MREG_ToLab [ side ] downto 1 do
2930: LD_ADDR_VAR 0 5
2934: PUSH
2935: DOUBLE
2936: LD_EXP 23
2940: PUSH
2941: LD_VAR 0 1
2945: ARRAY
2946: INC
2947: ST_TO_ADDR
2948: LD_INT 1
2950: PUSH
2951: FOR_DOWNTO
2952: IFFALSE 3015
// if MREG_ToLab [ side ] [ i ] = unit then
2954: LD_EXP 23
2958: PUSH
2959: LD_VAR 0 1
2963: ARRAY
2964: PUSH
2965: LD_VAR 0 5
2969: ARRAY
2970: PUSH
2971: LD_VAR 0 3
2975: EQUAL
2976: IFFALSE 3013
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
2978: LD_ADDR_EXP 23
2982: PUSH
2983: LD_EXP 23
2987: PPUSH
2988: LD_EXP 23
2992: PUSH
2993: LD_VAR 0 1
2997: ARRAY
2998: PUSH
2999: LD_VAR 0 5
3003: ARRAY
3004: PPUSH
3005: LD_INT 1
3007: PPUSH
3008: CALL 23535 0 3
3012: ST_TO_ADDR
// end ;
3013: GO 2951
3015: POP
3016: POP
// end ;
3017: LD_VAR 0 4
3021: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
3022: LD_INT 0
3024: PPUSH
3025: PPUSH
// result := false ;
3026: LD_ADDR_VAR 0 2
3030: PUSH
3031: LD_INT 0
3033: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
3034: LD_ADDR_VAR 0 3
3038: PUSH
3039: DOUBLE
3040: LD_INT 1
3042: DEC
3043: ST_TO_ADDR
3044: LD_EXP 15
3048: PUSH
3049: FOR_TO
3050: IFFALSE 3114
// if MREG_ToBuild [ i ] [ 1 ] = side then
3052: LD_EXP 15
3056: PUSH
3057: LD_VAR 0 3
3061: ARRAY
3062: PUSH
3063: LD_INT 1
3065: ARRAY
3066: PUSH
3067: LD_VAR 0 1
3071: EQUAL
3072: IFFALSE 3112
// begin if MREG_ToBuild [ i ] [ 1 ] then
3074: LD_EXP 15
3078: PUSH
3079: LD_VAR 0 3
3083: ARRAY
3084: PUSH
3085: LD_INT 1
3087: ARRAY
3088: IFFALSE 3112
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
3090: LD_ADDR_VAR 0 2
3094: PUSH
3095: LD_EXP 15
3099: PUSH
3100: LD_VAR 0 3
3104: ARRAY
3105: PUSH
3106: LD_INT 1
3108: ARRAY
3109: ST_TO_ADDR
// break ;
3110: GO 3114
// end ; end ;
3112: GO 3049
3114: POP
3115: POP
// for i = 1 to MREG_ToRepair do
3116: LD_ADDR_VAR 0 3
3120: PUSH
3121: DOUBLE
3122: LD_INT 1
3124: DEC
3125: ST_TO_ADDR
3126: LD_EXP 16
3130: PUSH
3131: FOR_TO
3132: IFFALSE 3196
// if MREG_ToRepair [ i ] [ 1 ] = side then
3134: LD_EXP 16
3138: PUSH
3139: LD_VAR 0 3
3143: ARRAY
3144: PUSH
3145: LD_INT 1
3147: ARRAY
3148: PUSH
3149: LD_VAR 0 1
3153: EQUAL
3154: IFFALSE 3194
// begin if MREG_ToRepair [ i ] [ 1 ] then
3156: LD_EXP 16
3160: PUSH
3161: LD_VAR 0 3
3165: ARRAY
3166: PUSH
3167: LD_INT 1
3169: ARRAY
3170: IFFALSE 3194
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
3172: LD_ADDR_VAR 0 2
3176: PUSH
3177: LD_EXP 16
3181: PUSH
3182: LD_VAR 0 3
3186: ARRAY
3187: PUSH
3188: LD_INT 1
3190: ARRAY
3191: ST_TO_ADDR
// break ;
3192: GO 3196
// end ; end ;
3194: GO 3131
3196: POP
3197: POP
// if MCF_Get ( side , [ f_constructed ] ) then
3198: LD_VAR 0 1
3202: PPUSH
3203: LD_INT 57
3205: PUSH
3206: EMPTY
3207: LIST
3208: PPUSH
3209: CALL 0 0 2
3213: IFFALSE 3240
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
3215: LD_ADDR_VAR 0 2
3219: PUSH
3220: LD_VAR 0 1
3224: PPUSH
3225: LD_INT 57
3227: PUSH
3228: EMPTY
3229: LIST
3230: PPUSH
3231: CALL 0 0 2
3235: PUSH
3236: LD_INT 1
3238: ARRAY
3239: ST_TO_ADDR
// end ;
3240: LD_VAR 0 2
3244: RET
// export function MCF_Info ( ) ; begin
3245: LD_INT 0
3247: PPUSH
// MC_Show ( MCF to zbiór funkcji s³u¿¹cych do operacji na listach i filtrach: ^ - MCF_Class -> Wyœwietla dan¹ klasê [mo¿liwe do³¹czenie dodatkowych filtrów] ^ - MCF_Tag -> Wyœwietla wszystkie jednostki z danymi tagiem [mo¿liwe do³¹czenie dodatkowych filtrów] ^ - MCF_SetTag -> Umo¿liwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortujê listê rosn¹co ^ - MCF_SortListDesc -> Sortujê listê malej¹co ^ - MCF_SortLevelAsc -> Sortujê dan¹ grupê jednnostek wg. danej umiejetnoœci wg. poziomu rosn¹co ^ - MCF_SortLevelDesc -> Sortujê dan¹ grupê jednostek wg. danej umiejetnoœci wg. poziomu malej¹co ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
3248: LD_STRING MCF to zbiór funkcji s³u¿¹cych do operacji na listach i filtrach:
3250: PUSH
3251: LD_STRING - MCF_Class -> Wyœwietla dan¹ klasê [mo¿liwe do³¹czenie dodatkowych filtrów]
3253: ADD
3254: PUSH
3255: LD_STRING - MCF_Tag -> Wyœwietla wszystkie jednostki z danymi tagiem [mo¿liwe do³¹czenie dodatkowych filtrów]
3257: ADD
3258: PUSH
3259: LD_STRING - MCF_SetTag -> Umo¿liwia nadanie tagu danej grupie jednostek
3261: ADD
3262: PUSH
3263: LD_STRING - MCF_ClearTag -> Kasuje dany tag
3265: ADD
3266: PUSH
3267: LD_STRING - MCF_SortListAsc -> Sortujê listê rosn¹co
3269: ADD
3270: PUSH
3271: LD_STRING - MCF_SortListDesc -> Sortujê listê malej¹co
3273: ADD
3274: PUSH
3275: LD_STRING - MCF_SortLevelAsc -> Sortujê dan¹ grupê jednnostek wg. danej umiejetnoœci wg. poziomu rosn¹co
3277: ADD
3278: PUSH
3279: LD_STRING - MCF_SortLevelDesc -> Sortujê dan¹ grupê jednostek wg. danej umiejetnoœci wg. poziomu malej¹co
3281: ADD
3282: PUSH
3283: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
3285: ADD
3286: PPUSH
3287: CALL 3814 0 1
// end ; end_of_file
3291: LD_VAR 0 1
3295: RET
// export function FakePep ( ) ; var i , un ; begin
3296: LD_INT 0
3298: PPUSH
3299: PPUSH
3300: PPUSH
// uc_side := 1 ;
3301: LD_ADDR_OWVAR 20
3305: PUSH
3306: LD_INT 1
3308: ST_TO_ADDR
// uc_nation := 1 ;
3309: LD_ADDR_OWVAR 21
3313: PUSH
3314: LD_INT 1
3316: ST_TO_ADDR
// for i = 1 to 15 do
3317: LD_ADDR_VAR 0 2
3321: PUSH
3322: DOUBLE
3323: LD_INT 1
3325: DEC
3326: ST_TO_ADDR
3327: LD_INT 15
3329: PUSH
3330: FOR_TO
3331: IFFALSE 3380
// begin PrepareHuman ( false , ( i div 4 ) + 1 , 8 ) ;
3333: LD_INT 0
3335: PPUSH
3336: LD_VAR 0 2
3340: PUSH
3341: LD_INT 4
3343: DIV
3344: PUSH
3345: LD_INT 1
3347: PLUS
3348: PPUSH
3349: LD_INT 8
3351: PPUSH
3352: CALL_OW 380
// un := CreateHuman ;
3356: LD_ADDR_VAR 0 3
3360: PUSH
3361: CALL_OW 44
3365: ST_TO_ADDR
// PlaceUnitAnywhere ( un , false ) ;
3366: LD_VAR 0 3
3370: PPUSH
3371: LD_INT 0
3373: PPUSH
3374: CALL_OW 51
// end ;
3378: GO 3330
3380: POP
3381: POP
// end ; end_of_file
3382: LD_VAR 0 1
3386: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
3387: LD_INT 0
3389: PPUSH
3390: PPUSH
3391: PPUSH
3392: PPUSH
3393: PPUSH
3394: PPUSH
3395: PPUSH
3396: PPUSH
// if unit then
3397: LD_VAR 0 1
3401: IFFALSE 3801
// begin if mode = 0 then
3403: LD_VAR 0 3
3407: PUSH
3408: LD_INT 0
3410: EQUAL
3411: IFFALSE 3559
// begin if coords then
3413: LD_VAR 0 2
3417: IFFALSE 3557
// while ( coords > 1 ) do
3419: LD_VAR 0 2
3423: PUSH
3424: LD_INT 1
3426: GREATER
3427: IFFALSE 3557
// if not HasTask ( unit ) then
3429: LD_VAR 0 1
3433: PPUSH
3434: CALL_OW 314
3438: NOT
3439: IFFALSE 3555
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
3441: LD_VAR 0 1
3445: PPUSH
3446: LD_VAR 0 2
3450: PUSH
3451: LD_INT 1
3453: ARRAY
3454: PPUSH
3455: LD_VAR 0 2
3459: PUSH
3460: LD_INT 2
3462: ARRAY
3463: PPUSH
3464: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
3468: LD_INT 35
3470: PPUSH
3471: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
3475: LD_VAR 0 1
3479: PPUSH
3480: CALL_OW 250
3484: PUSH
3485: LD_VAR 0 2
3489: PUSH
3490: LD_INT 1
3492: ARRAY
3493: EQUAL
3494: PUSH
3495: LD_VAR 0 1
3499: PPUSH
3500: CALL_OW 251
3504: PUSH
3505: LD_VAR 0 2
3509: PUSH
3510: LD_INT 2
3512: ARRAY
3513: EQUAL
3514: AND
3515: IFFALSE 3468
// for i = 1 to 2 do
3517: LD_ADDR_VAR 0 5
3521: PUSH
3522: DOUBLE
3523: LD_INT 1
3525: DEC
3526: ST_TO_ADDR
3527: LD_INT 2
3529: PUSH
3530: FOR_TO
3531: IFFALSE 3553
// coords := Delete ( coords , 1 ) ;
3533: LD_ADDR_VAR 0 2
3537: PUSH
3538: LD_VAR 0 2
3542: PPUSH
3543: LD_INT 1
3545: PPUSH
3546: CALL_OW 3
3550: ST_TO_ADDR
3551: GO 3530
3553: POP
3554: POP
// end ;
3555: GO 3419
// end else
3557: GO 3801
// begin if coords then
3559: LD_VAR 0 2
3563: IFFALSE 3801
// begin x := GetX ( unit ) ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 1
3574: PPUSH
3575: CALL_OW 250
3579: ST_TO_ADDR
// y := GetY ( unit ) ;
3580: LD_ADDR_VAR 0 7
3584: PUSH
3585: LD_VAR 0 1
3589: PPUSH
3590: CALL_OW 251
3594: ST_TO_ADDR
// while ( coords > 1 ) do
3595: LD_VAR 0 2
3599: PUSH
3600: LD_INT 1
3602: GREATER
3603: IFFALSE 3801
// begin Wait ( 0 0$0.3 ) ;
3605: LD_INT 10
3607: PPUSH
3608: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
3612: LD_VAR 0 1
3616: PPUSH
3617: CALL_OW 255
3621: PPUSH
3622: LD_VAR 0 1
3626: PPUSH
3627: CALL_OW 250
3631: PPUSH
3632: LD_VAR 0 1
3636: PPUSH
3637: CALL_OW 251
3641: PPUSH
3642: LD_INT 14
3644: PPUSH
3645: CALL 5825 0 4
3649: IFFALSE 3680
// begin ComMoveXY ( unit , x , y ) ;
3651: LD_VAR 0 1
3655: PPUSH
3656: LD_VAR 0 6
3660: PPUSH
3661: LD_VAR 0 7
3665: PPUSH
3666: CALL_OW 111
// result := false ;
3670: LD_ADDR_VAR 0 4
3674: PUSH
3675: LD_INT 0
3677: ST_TO_ADDR
// end else
3678: GO 3719
// if not HasTask ( unit ) then
3680: LD_VAR 0 1
3684: PPUSH
3685: CALL_OW 314
3689: NOT
3690: IFFALSE 3719
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
3692: LD_VAR 0 1
3696: PPUSH
3697: LD_VAR 0 2
3701: PUSH
3702: LD_INT 1
3704: ARRAY
3705: PPUSH
3706: LD_VAR 0 2
3710: PUSH
3711: LD_INT 2
3713: ARRAY
3714: PPUSH
3715: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
3719: LD_VAR 0 1
3723: PPUSH
3724: CALL_OW 250
3728: PUSH
3729: LD_VAR 0 2
3733: PUSH
3734: LD_INT 1
3736: ARRAY
3737: EQUAL
3738: PUSH
3739: LD_VAR 0 1
3743: PPUSH
3744: CALL_OW 251
3748: PUSH
3749: LD_VAR 0 2
3753: PUSH
3754: LD_INT 2
3756: ARRAY
3757: EQUAL
3758: AND
3759: IFFALSE 3799
// for i = 1 to 2 do
3761: LD_ADDR_VAR 0 5
3765: PUSH
3766: DOUBLE
3767: LD_INT 1
3769: DEC
3770: ST_TO_ADDR
3771: LD_INT 2
3773: PUSH
3774: FOR_TO
3775: IFFALSE 3797
// coords := Delete ( coords , 1 ) ;
3777: LD_ADDR_VAR 0 2
3781: PUSH
3782: LD_VAR 0 2
3786: PPUSH
3787: LD_INT 1
3789: PPUSH
3790: CALL_OW 3
3794: ST_TO_ADDR
3795: GO 3774
3797: POP
3798: POP
// end ;
3799: GO 3595
// end ; end ; end ; result := true ;
3801: LD_ADDR_VAR 0 4
3805: PUSH
3806: LD_INT 1
3808: ST_TO_ADDR
// end ;
3809: LD_VAR 0 4
3813: RET
// export function MC_Show ( string ) ; begin
3814: LD_INT 0
3816: PPUSH
// display_strings := string ;
3817: LD_ADDR_OWVAR 47
3821: PUSH
3822: LD_VAR 0 1
3826: ST_TO_ADDR
// end ; end_of_file
3827: LD_VAR 0 2
3831: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Crane , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
3832: LD_INT 0
3834: PPUSH
// MREG_Game := [ ] ;
3835: LD_ADDR_EXP 1
3839: PUSH
3840: EMPTY
3841: ST_TO_ADDR
// MREG_Crates := [ ] ;
3842: LD_ADDR_EXP 2
3846: PUSH
3847: EMPTY
3848: ST_TO_ADDR
// MREG_Heal := [ ] ;
3849: LD_ADDR_EXP 3
3853: PUSH
3854: EMPTY
3855: ST_TO_ADDR
// MREG_Tame := [ ] ;
3856: LD_ADDR_EXP 5
3860: PUSH
3861: EMPTY
3862: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
3863: LD_ADDR_EXP 6
3867: PUSH
3868: EMPTY
3869: ST_TO_ADDR
// MREG_SidesList := [ ] ;
3870: LD_ADDR_EXP 7
3874: PUSH
3875: EMPTY
3876: ST_TO_ADDR
// MREG_LabList := [ ] ;
3877: LD_ADDR_EXP 8
3881: PUSH
3882: EMPTY
3883: ST_TO_ADDR
// MREG_Cargo := [ ] ;
3884: LD_ADDR_EXP 9
3888: PUSH
3889: EMPTY
3890: ST_TO_ADDR
// MREG_Crane := [ ] ;
3891: LD_ADDR_EXP 10
3895: PUSH
3896: EMPTY
3897: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
3898: LD_ADDR_EXP 11
3902: PUSH
3903: EMPTY
3904: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
3905: LD_ADDR_EXP 12
3909: PUSH
3910: EMPTY
3911: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
3912: LD_ADDR_EXP 13
3916: PUSH
3917: EMPTY
3918: ST_TO_ADDR
// MREG_Status := [ ] ;
3919: LD_ADDR_EXP 14
3923: PUSH
3924: EMPTY
3925: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
3926: LD_ADDR_EXP 15
3930: PUSH
3931: EMPTY
3932: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
3933: LD_ADDR_EXP 16
3937: PUSH
3938: EMPTY
3939: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
3940: LD_ADDR_EXP 17
3944: PUSH
3945: EMPTY
3946: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
3947: LD_ADDR_EXP 18
3951: PUSH
3952: EMPTY
3953: ST_TO_ADDR
// MREG_ToRes := [ ] ;
3954: LD_ADDR_EXP 19
3958: PUSH
3959: EMPTY
3960: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
3961: LD_ADDR_EXP 20
3965: PUSH
3966: EMPTY
3967: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
3968: LD_ADDR_EXP 21
3972: PUSH
3973: EMPTY
3974: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
3975: LD_ADDR_EXP 22
3979: PUSH
3980: EMPTY
3981: ST_TO_ADDR
// MREG_ToLab := [ ] ;
3982: LD_ADDR_EXP 23
3986: PUSH
3987: EMPTY
3988: ST_TO_ADDR
// MREG_ToFac := [ ] ;
3989: LD_ADDR_EXP 24
3993: PUSH
3994: EMPTY
3995: ST_TO_ADDR
// MREG_ToArm := [ ] ;
3996: LD_ADDR_EXP 25
4000: PUSH
4001: EMPTY
4002: ST_TO_ADDR
// MREG_ToDep := [ ] ;
4003: LD_ADDR_EXP 26
4007: PUSH
4008: EMPTY
4009: ST_TO_ADDR
// MREG_Parking := [ ] ;
4010: LD_ADDR_EXP 27
4014: PUSH
4015: EMPTY
4016: ST_TO_ADDR
// MREG_VCombat := [ ] ;
4017: LD_ADDR_EXP 28
4021: PUSH
4022: EMPTY
4023: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
4024: LD_ADDR_EXP 31
4028: PUSH
4029: LD_INT 300
4031: PUSH
4032: LD_INT 100
4034: PUSH
4035: LD_INT 25
4037: PUSH
4038: EMPTY
4039: LIST
4040: LIST
4041: LIST
4042: ST_TO_ADDR
// end ;
4043: LD_VAR 0 1
4047: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
4048: LD_INT 0
4050: PPUSH
// if [ side , unit , mreg ] in mreg_list then
4051: LD_VAR 0 2
4055: PUSH
4056: LD_VAR 0 3
4060: PUSH
4061: LD_VAR 0 4
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: LIST
4070: PUSH
4071: LD_VAR 0 1
4075: IN
4076: IFFALSE 4090
// result := mreg_list else
4078: LD_ADDR_VAR 0 5
4082: PUSH
4083: LD_VAR 0 1
4087: ST_TO_ADDR
4088: GO 4124
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
4090: LD_ADDR_VAR 0 1
4094: PUSH
4095: LD_VAR 0 1
4099: PUSH
4100: LD_VAR 0 2
4104: PUSH
4105: LD_VAR 0 3
4109: PUSH
4110: LD_VAR 0 4
4114: PUSH
4115: EMPTY
4116: LIST
4117: LIST
4118: LIST
4119: PUSH
4120: EMPTY
4121: LIST
4122: ADD
4123: ST_TO_ADDR
// result := mreg_list ;
4124: LD_ADDR_VAR 0 5
4128: PUSH
4129: LD_VAR 0 1
4133: ST_TO_ADDR
// end ;
4134: LD_VAR 0 5
4138: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
4139: LD_INT 0
4141: PPUSH
// if [ side , unit , mreg ] in mreg_list then
4142: LD_VAR 0 2
4146: PUSH
4147: LD_VAR 0 3
4151: PUSH
4152: LD_VAR 0 4
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: LIST
4161: PUSH
4162: LD_VAR 0 1
4166: IN
4167: IFFALSE 4205
// result := mreg_list diff [ [ side , unit , mreg ] ] else
4169: LD_ADDR_VAR 0 5
4173: PUSH
4174: LD_VAR 0 1
4178: PUSH
4179: LD_VAR 0 2
4183: PUSH
4184: LD_VAR 0 3
4188: PUSH
4189: LD_VAR 0 4
4193: PUSH
4194: EMPTY
4195: LIST
4196: LIST
4197: LIST
4198: PUSH
4199: EMPTY
4200: LIST
4201: DIFF
4202: ST_TO_ADDR
4203: GO 4215
// result := mreg_list ;
4205: LD_ADDR_VAR 0 5
4209: PUSH
4210: LD_VAR 0 1
4214: ST_TO_ADDR
// end ;
4215: LD_VAR 0 5
4219: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
4220: LD_INT 0
4222: PPUSH
4223: PPUSH
4224: PPUSH
// for j = 1 to 8 do
4225: LD_ADDR_VAR 0 3
4229: PUSH
4230: DOUBLE
4231: LD_INT 1
4233: DEC
4234: ST_TO_ADDR
4235: LD_INT 8
4237: PUSH
4238: FOR_TO
4239: IFFALSE 5135
// begin if MCF_Get ( j , [ f_alive ] ) then
4241: LD_VAR 0 3
4245: PPUSH
4246: LD_INT 51
4248: PUSH
4249: EMPTY
4250: LIST
4251: PPUSH
4252: CALL 0 0 2
4256: IFFALSE 4274
// MREG_SidesList := MREG_SidesList ^ 1 else
4258: LD_ADDR_EXP 7
4262: PUSH
4263: LD_EXP 7
4267: PUSH
4268: LD_INT 1
4270: ADD
4271: ST_TO_ADDR
4272: GO 4288
// MREG_SidesList := MREG_SidesList ^ 0 ;
4274: LD_ADDR_EXP 7
4278: PUSH
4279: LD_EXP 7
4283: PUSH
4284: LD_INT 0
4286: ADD
4287: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
4288: LD_VAR 0 3
4292: PPUSH
4293: LD_INT 2
4295: PUSH
4296: LD_INT 34
4298: PUSH
4299: LD_INT 12
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: LD_INT 34
4308: PUSH
4309: LD_INT 32
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 34
4318: PUSH
4319: LD_INT 51
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: PPUSH
4335: CALL 225 0 2
4339: IFFALSE 4440
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
4341: LD_ADDR_VAR 0 2
4345: PUSH
4346: LD_VAR 0 3
4350: PPUSH
4351: LD_INT 2
4353: PUSH
4354: LD_INT 34
4356: PUSH
4357: LD_INT 12
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: PUSH
4364: LD_INT 34
4366: PUSH
4367: LD_INT 32
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 34
4376: PUSH
4377: LD_INT 51
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: LIST
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: PPUSH
4393: CALL 225 0 2
4397: PUSH
4398: FOR_IN
4399: IFFALSE 4438
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
4401: LD_ADDR_EXP 9
4405: PUSH
4406: LD_EXP 9
4410: PPUSH
4411: LD_VAR 0 3
4415: PPUSH
4416: LD_VAR 0 2
4420: PPUSH
4421: LD_VAR 0 2
4425: PPUSH
4426: CALL_OW 264
4430: PPUSH
4431: CALL 4048 0 4
4435: ST_TO_ADDR
4436: GO 4398
4438: POP
4439: POP
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) then
4440: LD_VAR 0 3
4444: PPUSH
4445: LD_INT 2
4447: PUSH
4448: LD_INT 34
4450: PUSH
4451: LD_INT 13
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: PUSH
4458: LD_INT 34
4460: PUSH
4461: LD_INT 52
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: LIST
4472: PUSH
4473: EMPTY
4474: LIST
4475: PPUSH
4476: CALL 225 0 2
4480: IFFALSE 4570
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) do
4482: LD_ADDR_VAR 0 2
4486: PUSH
4487: LD_VAR 0 3
4491: PPUSH
4492: LD_INT 2
4494: PUSH
4495: LD_INT 34
4497: PUSH
4498: LD_INT 13
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 34
4507: PUSH
4508: LD_INT 52
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: EMPTY
4516: LIST
4517: LIST
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PPUSH
4523: CALL 225 0 2
4527: PUSH
4528: FOR_IN
4529: IFFALSE 4568
// MREG_Crane := MC_RegistryUpdate ( MREG_Crane , j , i , GetWeapon ( i ) ) ;
4531: LD_ADDR_EXP 10
4535: PUSH
4536: LD_EXP 10
4540: PPUSH
4541: LD_VAR 0 3
4545: PPUSH
4546: LD_VAR 0 2
4550: PPUSH
4551: LD_VAR 0 2
4555: PPUSH
4556: CALL_OW 264
4560: PPUSH
4561: CALL 4048 0 4
4565: ST_TO_ADDR
4566: GO 4528
4568: POP
4569: POP
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] ] ] ) then
4570: LD_VAR 0 3
4574: PPUSH
4575: LD_INT 2
4577: PUSH
4578: LD_INT 34
4580: PUSH
4581: LD_INT 14
4583: PUSH
4584: EMPTY
4585: LIST
4586: LIST
4587: PUSH
4588: LD_INT 34
4590: PUSH
4591: LD_INT 53
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: PUSH
4598: EMPTY
4599: LIST
4600: LIST
4601: LIST
4602: PUSH
4603: EMPTY
4604: LIST
4605: PPUSH
4606: CALL 225 0 2
4610: IFFALSE 4700
// for i in MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] ] ] ) do
4612: LD_ADDR_VAR 0 2
4616: PUSH
4617: LD_VAR 0 3
4621: PPUSH
4622: LD_INT 2
4624: PUSH
4625: LD_INT 34
4627: PUSH
4628: LD_INT 14
4630: PUSH
4631: EMPTY
4632: LIST
4633: LIST
4634: PUSH
4635: LD_INT 34
4637: PUSH
4638: LD_INT 53
4640: PUSH
4641: EMPTY
4642: LIST
4643: LIST
4644: PUSH
4645: EMPTY
4646: LIST
4647: LIST
4648: LIST
4649: PUSH
4650: EMPTY
4651: LIST
4652: PPUSH
4653: CALL 225 0 2
4657: PUSH
4658: FOR_IN
4659: IFFALSE 4698
// MREG_Bulldozer := MC_RegistryUpdate ( MREG_Bulldozer , j , i , GetWeapon ( i ) ) ;
4661: LD_ADDR_EXP 11
4665: PUSH
4666: LD_EXP 11
4670: PPUSH
4671: LD_VAR 0 3
4675: PPUSH
4676: LD_VAR 0 2
4680: PPUSH
4681: LD_VAR 0 2
4685: PPUSH
4686: CALL_OW 264
4690: PPUSH
4691: CALL 4048 0 4
4695: ST_TO_ADDR
4696: GO 4658
4698: POP
4699: POP
// if MCF_Class ( j , 4 , [ ] ) then
4700: LD_VAR 0 3
4704: PPUSH
4705: LD_INT 4
4707: PPUSH
4708: EMPTY
4709: PPUSH
4710: CALL 83 0 3
4714: IFFALSE 4747
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
4716: LD_ADDR_EXP 23
4720: PUSH
4721: LD_EXP 23
4725: PUSH
4726: LD_VAR 0 3
4730: PPUSH
4731: LD_INT 4
4733: PPUSH
4734: EMPTY
4735: PPUSH
4736: CALL 83 0 3
4740: PUSH
4741: EMPTY
4742: LIST
4743: ADD
4744: ST_TO_ADDR
4745: GO 4764
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
4747: LD_ADDR_EXP 23
4751: PUSH
4752: LD_EXP 23
4756: PUSH
4757: LD_INT 0
4759: PUSH
4760: EMPTY
4761: LIST
4762: ADD
4763: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
4764: LD_VAR 0 3
4768: PPUSH
4769: LD_INT 3
4771: PPUSH
4772: EMPTY
4773: PPUSH
4774: CALL 83 0 3
4778: IFFALSE 4811
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
4780: LD_ADDR_EXP 24
4784: PUSH
4785: LD_EXP 24
4789: PUSH
4790: LD_VAR 0 3
4794: PPUSH
4795: LD_INT 3
4797: PPUSH
4798: EMPTY
4799: PPUSH
4800: CALL 83 0 3
4804: PUSH
4805: EMPTY
4806: LIST
4807: ADD
4808: ST_TO_ADDR
4809: GO 4828
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
4811: LD_ADDR_EXP 24
4815: PUSH
4816: LD_EXP 24
4820: PUSH
4821: LD_INT 0
4823: PUSH
4824: EMPTY
4825: LIST
4826: ADD
4827: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
4828: LD_VAR 0 3
4832: PPUSH
4833: LD_INT 1
4835: PPUSH
4836: EMPTY
4837: PPUSH
4838: CALL 83 0 3
4842: IFFALSE 4875
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
4844: LD_ADDR_EXP 25
4848: PUSH
4849: LD_EXP 25
4853: PUSH
4854: LD_VAR 0 3
4858: PPUSH
4859: LD_INT 1
4861: PPUSH
4862: EMPTY
4863: PPUSH
4864: CALL 83 0 3
4868: PUSH
4869: EMPTY
4870: LIST
4871: ADD
4872: ST_TO_ADDR
4873: GO 4892
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
4875: LD_ADDR_EXP 25
4879: PUSH
4880: LD_EXP 25
4884: PUSH
4885: LD_INT 0
4887: PUSH
4888: EMPTY
4889: LIST
4890: ADD
4891: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
4892: LD_VAR 0 3
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: EMPTY
4901: PPUSH
4902: CALL 83 0 3
4906: IFFALSE 4939
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
4908: LD_ADDR_EXP 26
4912: PUSH
4913: LD_EXP 26
4917: PUSH
4918: LD_VAR 0 3
4922: PPUSH
4923: LD_INT 2
4925: PPUSH
4926: EMPTY
4927: PPUSH
4928: CALL 83 0 3
4932: PUSH
4933: EMPTY
4934: LIST
4935: ADD
4936: ST_TO_ADDR
4937: GO 4956
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
4939: LD_ADDR_EXP 26
4943: PUSH
4944: LD_EXP 26
4948: PUSH
4949: LD_INT 0
4951: PUSH
4952: EMPTY
4953: LIST
4954: ADD
4955: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
4956: LD_ADDR_EXP 16
4960: PUSH
4961: LD_EXP 16
4965: PUSH
4966: LD_INT 0
4968: PUSH
4969: EMPTY
4970: LIST
4971: ADD
4972: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
4973: LD_ADDR_EXP 3
4977: PUSH
4978: LD_EXP 3
4982: PUSH
4983: LD_INT 0
4985: PUSH
4986: EMPTY
4987: LIST
4988: ADD
4989: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
4990: LD_ADDR_EXP 5
4994: PUSH
4995: LD_EXP 5
4999: PUSH
5000: LD_INT 0
5002: PUSH
5003: EMPTY
5004: LIST
5005: ADD
5006: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
5007: LD_ADDR_EXP 27
5011: PUSH
5012: LD_EXP 27
5016: PUSH
5017: LD_INT 0
5019: PUSH
5020: EMPTY
5021: LIST
5022: ADD
5023: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
5024: LD_ADDR_EXP 28
5028: PUSH
5029: LD_EXP 28
5033: PUSH
5034: LD_INT 0
5036: PUSH
5037: EMPTY
5038: LIST
5039: ADD
5040: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
5041: LD_ADDR_EXP 20
5045: PUSH
5046: LD_EXP 20
5050: PUSH
5051: LD_INT 0
5053: PUSH
5054: EMPTY
5055: LIST
5056: ADD
5057: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
5058: LD_ADDR_EXP 6
5062: PUSH
5063: LD_EXP 6
5067: PUSH
5068: LD_INT 0
5070: PUSH
5071: LD_INT 0
5073: PUSH
5074: LD_INT 0
5076: PUSH
5077: LD_INT 0
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: LIST
5084: LIST
5085: PUSH
5086: EMPTY
5087: LIST
5088: ADD
5089: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
5090: LD_ADDR_EXP 29
5094: PUSH
5095: LD_EXP 29
5099: PUSH
5100: LD_INT 0
5102: PUSH
5103: EMPTY
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: EMPTY
5110: LIST
5111: ADD
5112: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
5113: LD_ADDR_EXP 30
5117: PUSH
5118: LD_EXP 30
5122: PUSH
5123: LD_INT 0
5125: PUSH
5126: EMPTY
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: ADD
5132: ST_TO_ADDR
// end ;
5133: GO 4238
5135: POP
5136: POP
// end ;
5137: LD_VAR 0 1
5141: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
5142: LD_INT 0
5144: PPUSH
5145: PPUSH
5146: PPUSH
// m := false ;
5147: LD_ADDR_VAR 0 5
5151: PUSH
5152: LD_INT 0
5154: ST_TO_ADDR
// for i = 1 to mreg do
5155: LD_ADDR_VAR 0 4
5159: PUSH
5160: DOUBLE
5161: LD_INT 1
5163: DEC
5164: ST_TO_ADDR
5165: LD_VAR 0 2
5169: PUSH
5170: FOR_TO
5171: IFFALSE 5207
// if mreg [ i ] [ 1 ] = side then
5173: LD_VAR 0 2
5177: PUSH
5178: LD_VAR 0 4
5182: ARRAY
5183: PUSH
5184: LD_INT 1
5186: ARRAY
5187: PUSH
5188: LD_VAR 0 1
5192: EQUAL
5193: IFFALSE 5205
// begin m := true ;
5195: LD_ADDR_VAR 0 5
5199: PUSH
5200: LD_INT 1
5202: ST_TO_ADDR
// break ;
5203: GO 5207
// end ;
5205: GO 5170
5207: POP
5208: POP
// result := m ;
5209: LD_ADDR_VAR 0 3
5213: PUSH
5214: LD_VAR 0 5
5218: ST_TO_ADDR
// end ;
5219: LD_VAR 0 3
5223: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
5224: LD_INT 0
5226: PPUSH
5227: PPUSH
5228: PPUSH
// m := 0 ;
5229: LD_ADDR_VAR 0 5
5233: PUSH
5234: LD_INT 0
5236: ST_TO_ADDR
// for i = 1 to mreg do
5237: LD_ADDR_VAR 0 4
5241: PUSH
5242: DOUBLE
5243: LD_INT 1
5245: DEC
5246: ST_TO_ADDR
5247: LD_VAR 0 2
5251: PUSH
5252: FOR_TO
5253: IFFALSE 5293
// if mreg [ i ] [ 1 ] = side then
5255: LD_VAR 0 2
5259: PUSH
5260: LD_VAR 0 4
5264: ARRAY
5265: PUSH
5266: LD_INT 1
5268: ARRAY
5269: PUSH
5270: LD_VAR 0 1
5274: EQUAL
5275: IFFALSE 5291
// begin m := m + 1 ;
5277: LD_ADDR_VAR 0 5
5281: PUSH
5282: LD_VAR 0 5
5286: PUSH
5287: LD_INT 1
5289: PLUS
5290: ST_TO_ADDR
// end ;
5291: GO 5252
5293: POP
5294: POP
// result := m ;
5295: LD_ADDR_VAR 0 3
5299: PUSH
5300: LD_VAR 0 5
5304: ST_TO_ADDR
// end ;
5305: LD_VAR 0 3
5309: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
5310: LD_INT 0
5312: PPUSH
5313: PPUSH
// result := 0 ;
5314: LD_ADDR_VAR 0 3
5318: PUSH
5319: LD_INT 0
5321: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
5322: LD_ADDR_VAR 0 4
5326: PUSH
5327: DOUBLE
5328: LD_INT 1
5330: DEC
5331: ST_TO_ADDR
5332: LD_EXP 22
5336: PUSH
5337: FOR_TO
5338: IFFALSE 5400
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
5340: LD_EXP 22
5344: PUSH
5345: LD_VAR 0 4
5349: ARRAY
5350: PUSH
5351: LD_INT 1
5353: ARRAY
5354: PUSH
5355: LD_VAR 0 1
5359: EQUAL
5360: PUSH
5361: LD_EXP 22
5365: PUSH
5366: LD_VAR 0 4
5370: ARRAY
5371: PUSH
5372: LD_INT 2
5374: ARRAY
5375: PUSH
5376: LD_VAR 0 2
5380: EQUAL
5381: AND
5382: IFFALSE 5398
// begin result := result + 1 ;
5384: LD_ADDR_VAR 0 3
5388: PUSH
5389: LD_VAR 0 3
5393: PUSH
5394: LD_INT 1
5396: PLUS
5397: ST_TO_ADDR
// end ;
5398: GO 5337
5400: POP
5401: POP
// end ; end_of_file
5402: LD_VAR 0 3
5406: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
5407: LD_INT 0
5409: PPUSH
// CreateDepositXY ( x , y , t ) ;
5410: LD_VAR 0 1
5414: PPUSH
5415: LD_VAR 0 2
5419: PPUSH
5420: LD_VAR 0 3
5424: PPUSH
5425: CALL_OW 62
// end ;
5429: LD_VAR 0 4
5433: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
5434: LD_INT 0
5436: PPUSH
5437: PPUSH
// c := 1 ;
5438: LD_ADDR_VAR 0 5
5442: PUSH
5443: LD_INT 1
5445: ST_TO_ADDR
// case color of red :
5446: LD_VAR 0 3
5450: PUSH
5451: LD_STRING red
5453: DOUBLE
5454: EQUAL
5455: IFTRUE 5459
5457: GO 5470
5459: POP
// c = 1 ; dark-green :
5460: LD_ADDR_VAR 0 5
5464: PUSH
5465: LD_INT 1
5467: ST_TO_ADDR
5468: GO 5756
5470: LD_STRING dark-green
5472: DOUBLE
5473: EQUAL
5474: IFTRUE 5478
5476: GO 5489
5478: POP
// c = 2 ; purple :
5479: LD_ADDR_VAR 0 5
5483: PUSH
5484: LD_INT 2
5486: ST_TO_ADDR
5487: GO 5756
5489: LD_STRING purple
5491: DOUBLE
5492: EQUAL
5493: IFTRUE 5497
5495: GO 5508
5497: POP
// c = 3 ; aqua :
5498: LD_ADDR_VAR 0 5
5502: PUSH
5503: LD_INT 3
5505: ST_TO_ADDR
5506: GO 5756
5508: LD_STRING aqua
5510: DOUBLE
5511: EQUAL
5512: IFTRUE 5516
5514: GO 5527
5516: POP
// c = 4 ; grey :
5517: LD_ADDR_VAR 0 5
5521: PUSH
5522: LD_INT 4
5524: ST_TO_ADDR
5525: GO 5756
5527: LD_STRING grey
5529: DOUBLE
5530: EQUAL
5531: IFTRUE 5535
5533: GO 5546
5535: POP
// c = 5 ; lime :
5536: LD_ADDR_VAR 0 5
5540: PUSH
5541: LD_INT 5
5543: ST_TO_ADDR
5544: GO 5756
5546: LD_STRING lime
5548: DOUBLE
5549: EQUAL
5550: IFTRUE 5554
5552: GO 5565
5554: POP
// c = 6 ; tan :
5555: LD_ADDR_VAR 0 5
5559: PUSH
5560: LD_INT 6
5562: ST_TO_ADDR
5563: GO 5756
5565: LD_STRING tan
5567: DOUBLE
5568: EQUAL
5569: IFTRUE 5573
5571: GO 5584
5573: POP
// c = 7 ; pink :
5574: LD_ADDR_VAR 0 5
5578: PUSH
5579: LD_INT 7
5581: ST_TO_ADDR
5582: GO 5756
5584: LD_STRING pink
5586: DOUBLE
5587: EQUAL
5588: IFTRUE 5592
5590: GO 5603
5592: POP
// c = 8 ; green :
5593: LD_ADDR_VAR 0 5
5597: PUSH
5598: LD_INT 8
5600: ST_TO_ADDR
5601: GO 5756
5603: LD_STRING green
5605: DOUBLE
5606: EQUAL
5607: IFTRUE 5611
5609: GO 5622
5611: POP
// c = 9 ; blue :
5612: LD_ADDR_VAR 0 5
5616: PUSH
5617: LD_INT 9
5619: ST_TO_ADDR
5620: GO 5756
5622: LD_STRING blue
5624: DOUBLE
5625: EQUAL
5626: IFTRUE 5630
5628: GO 5641
5630: POP
// c = 10 ; yellow :
5631: LD_ADDR_VAR 0 5
5635: PUSH
5636: LD_INT 10
5638: ST_TO_ADDR
5639: GO 5756
5641: LD_STRING yellow
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5660
5649: POP
// c = 11 ; brown :
5650: LD_ADDR_VAR 0 5
5654: PUSH
5655: LD_INT 11
5657: ST_TO_ADDR
5658: GO 5756
5660: LD_STRING brown
5662: DOUBLE
5663: EQUAL
5664: IFTRUE 5668
5666: GO 5679
5668: POP
// c = 12 ; black :
5669: LD_ADDR_VAR 0 5
5673: PUSH
5674: LD_INT 12
5676: ST_TO_ADDR
5677: GO 5756
5679: LD_STRING black
5681: DOUBLE
5682: EQUAL
5683: IFTRUE 5687
5685: GO 5698
5687: POP
// c = 13 ; aqua2 :
5688: LD_ADDR_VAR 0 5
5692: PUSH
5693: LD_INT 13
5695: ST_TO_ADDR
5696: GO 5756
5698: LD_STRING aqua2
5700: DOUBLE
5701: EQUAL
5702: IFTRUE 5706
5704: GO 5717
5706: POP
// c = 14 ; orange :
5707: LD_ADDR_VAR 0 5
5711: PUSH
5712: LD_INT 14
5714: ST_TO_ADDR
5715: GO 5756
5717: LD_STRING orange
5719: DOUBLE
5720: EQUAL
5721: IFTRUE 5725
5723: GO 5736
5725: POP
// c = 15 ; white :
5726: LD_ADDR_VAR 0 5
5730: PUSH
5731: LD_INT 15
5733: ST_TO_ADDR
5734: GO 5756
5736: LD_STRING white
5738: DOUBLE
5739: EQUAL
5740: IFTRUE 5744
5742: GO 5755
5744: POP
// c = 16 ; end ;
5745: LD_ADDR_VAR 0 5
5749: PUSH
5750: LD_INT 16
5752: ST_TO_ADDR
5753: GO 5756
5755: POP
// if HexInfo ( x , y ) = 0 then
5756: LD_VAR 0 1
5760: PPUSH
5761: LD_VAR 0 2
5765: PPUSH
5766: CALL_OW 428
5770: PUSH
5771: LD_INT 0
5773: EQUAL
5774: IFFALSE 5798
// PlaceEnvironment ( x , y , 58 , c ) ;
5776: LD_VAR 0 1
5780: PPUSH
5781: LD_VAR 0 2
5785: PPUSH
5786: LD_INT 58
5788: PPUSH
5789: LD_VAR 0 5
5793: PPUSH
5794: CALL_OW 349
// end ;
5798: LD_VAR 0 4
5802: RET
// export function MCT_RemovePlace ( x , y ) ; begin
5803: LD_INT 0
5805: PPUSH
// RemoveEnvironment ( x , y ) ;
5806: LD_VAR 0 1
5810: PPUSH
5811: LD_VAR 0 2
5815: PPUSH
5816: CALL_OW 347
// end ;
5820: LD_VAR 0 3
5824: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
5825: LD_INT 0
5827: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
5828: LD_INT 81
5830: PUSH
5831: LD_VAR 0 1
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: PPUSH
5840: CALL_OW 69
5844: PUSH
5845: LD_INT 0
5847: EQUAL
5848: IFFALSE 5860
// result := false else
5850: LD_ADDR_VAR 0 5
5854: PUSH
5855: LD_INT 0
5857: ST_TO_ADDR
5858: GO 5924
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
5860: LD_INT 81
5862: PUSH
5863: LD_VAR 0 1
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: PUSH
5872: LD_INT 92
5874: PUSH
5875: LD_VAR 0 2
5879: PUSH
5880: LD_VAR 0 3
5884: PUSH
5885: LD_VAR 0 4
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: LIST
5894: LIST
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: PPUSH
5900: CALL_OW 69
5904: IFFALSE 5916
// result := true else
5906: LD_ADDR_VAR 0 5
5910: PUSH
5911: LD_INT 1
5913: ST_TO_ADDR
5914: GO 5924
// result := false ;
5916: LD_ADDR_VAR 0 5
5920: PUSH
5921: LD_INT 0
5923: ST_TO_ADDR
// end ;
5924: LD_VAR 0 5
5928: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
5929: LD_INT 0
5931: PPUSH
5932: PPUSH
5933: PPUSH
5934: PPUSH
5935: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
5936: LD_VAR 0 1
5940: PPUSH
5941: LD_INT 81
5943: PUSH
5944: LD_VAR 0 1
5948: PPUSH
5949: CALL_OW 255
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: PPUSH
5958: CALL_OW 69
5962: PPUSH
5963: LD_VAR 0 1
5967: PPUSH
5968: CALL_OW 74
5972: PPUSH
5973: CALL_OW 119
// dir := GetDir ( un ) ;
5977: LD_ADDR_VAR 0 4
5981: PUSH
5982: LD_VAR 0 1
5986: PPUSH
5987: CALL_OW 254
5991: ST_TO_ADDR
// dir := dir - 3 ;
5992: LD_ADDR_VAR 0 4
5996: PUSH
5997: LD_VAR 0 4
6001: PUSH
6002: LD_INT 3
6004: MINUS
6005: ST_TO_ADDR
// if dir < 0 then
6006: LD_VAR 0 4
6010: PUSH
6011: LD_INT 0
6013: LESS
6014: IFFALSE 6030
// dir := dir + 6 ;
6016: LD_ADDR_VAR 0 4
6020: PUSH
6021: LD_VAR 0 4
6025: PUSH
6026: LD_INT 6
6028: PLUS
6029: ST_TO_ADDR
// while true do
6030: LD_INT 1
6032: IFFALSE 6529
// begin coord_dist := 3 ;
6034: LD_ADDR_VAR 0 3
6038: PUSH
6039: LD_INT 3
6041: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
6042: LD_ADDR_VAR 0 5
6046: PUSH
6047: LD_VAR 0 1
6051: PPUSH
6052: CALL_OW 250
6056: PPUSH
6057: LD_VAR 0 4
6061: PPUSH
6062: LD_VAR 0 3
6066: PPUSH
6067: CALL_OW 272
6071: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
6072: LD_ADDR_VAR 0 6
6076: PUSH
6077: LD_VAR 0 1
6081: PPUSH
6082: CALL_OW 251
6086: PPUSH
6087: LD_VAR 0 4
6091: PPUSH
6092: LD_VAR 0 3
6096: PPUSH
6097: CALL_OW 273
6101: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
6102: LD_VAR 0 1
6106: PPUSH
6107: CALL_OW 255
6111: PPUSH
6112: LD_VAR 0 1
6116: PPUSH
6117: CALL_OW 250
6121: PPUSH
6122: LD_VAR 0 1
6126: PPUSH
6127: CALL_OW 251
6131: PPUSH
6132: LD_INT 14
6134: PPUSH
6135: CALL 5825 0 4
6139: PUSH
6140: LD_VAR 0 5
6144: PPUSH
6145: LD_VAR 0 6
6149: PPUSH
6150: CALL_OW 351
6154: OR
6155: PUSH
6156: LD_VAR 0 5
6160: PPUSH
6161: LD_VAR 0 6
6165: PPUSH
6166: CALL_OW 488
6170: PUSH
6171: LD_INT 0
6173: EQUAL
6174: OR
6175: PUSH
6176: LD_VAR 0 5
6180: PPUSH
6181: LD_VAR 0 6
6185: PPUSH
6186: CALL_OW 546
6190: PUSH
6191: LD_INT 1
6193: EQUAL
6194: OR
6195: PUSH
6196: LD_VAR 0 5
6200: PPUSH
6201: LD_VAR 0 6
6205: PPUSH
6206: CALL_OW 428
6210: PUSH
6211: LD_INT 0
6213: NONEQUAL
6214: OR
6215: IFFALSE 6443
// begin repeat begin Wait ( 0 0$0.3 ) ;
6217: LD_INT 10
6219: PPUSH
6220: CALL_OW 67
// coord_dist := coord_dist + 1 ;
6224: LD_ADDR_VAR 0 3
6228: PUSH
6229: LD_VAR 0 3
6233: PUSH
6234: LD_INT 1
6236: PLUS
6237: ST_TO_ADDR
// dir := dir + 1 ;
6238: LD_ADDR_VAR 0 4
6242: PUSH
6243: LD_VAR 0 4
6247: PUSH
6248: LD_INT 1
6250: PLUS
6251: ST_TO_ADDR
// if dir > 5 then
6252: LD_VAR 0 4
6256: PUSH
6257: LD_INT 5
6259: GREATER
6260: IFFALSE 6270
// dir = 0 ;
6262: LD_ADDR_VAR 0 4
6266: PUSH
6267: LD_INT 0
6269: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
6270: LD_ADDR_VAR 0 5
6274: PUSH
6275: LD_VAR 0 1
6279: PPUSH
6280: CALL_OW 250
6284: PPUSH
6285: LD_VAR 0 4
6289: PPUSH
6290: LD_VAR 0 3
6294: PPUSH
6295: CALL_OW 272
6299: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
6300: LD_ADDR_VAR 0 6
6304: PUSH
6305: LD_VAR 0 1
6309: PPUSH
6310: CALL_OW 251
6314: PPUSH
6315: LD_VAR 0 4
6319: PPUSH
6320: LD_VAR 0 3
6324: PPUSH
6325: CALL_OW 273
6329: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
6330: LD_VAR 0 1
6334: PPUSH
6335: CALL_OW 255
6339: PPUSH
6340: LD_VAR 0 1
6344: PPUSH
6345: CALL_OW 250
6349: PPUSH
6350: LD_VAR 0 1
6354: PPUSH
6355: CALL_OW 251
6359: PPUSH
6360: LD_INT 14
6362: PPUSH
6363: CALL 5825 0 4
6367: NOT
6368: PUSH
6369: LD_VAR 0 5
6373: PPUSH
6374: LD_VAR 0 6
6378: PPUSH
6379: CALL_OW 351
6383: NOT
6384: AND
6385: PUSH
6386: LD_VAR 0 5
6390: PPUSH
6391: LD_VAR 0 6
6395: PPUSH
6396: CALL_OW 488
6400: AND
6401: PUSH
6402: LD_VAR 0 5
6406: PPUSH
6407: LD_VAR 0 6
6411: PPUSH
6412: CALL_OW 546
6416: PUSH
6417: LD_INT 0
6419: EQUAL
6420: AND
6421: PUSH
6422: LD_VAR 0 5
6426: PPUSH
6427: LD_VAR 0 6
6431: PPUSH
6432: CALL_OW 428
6436: PUSH
6437: LD_INT 0
6439: EQUAL
6440: AND
6441: IFFALSE 6217
// end ; ComMoveXY ( un , x , y ) ;
6443: LD_VAR 0 1
6447: PPUSH
6448: LD_VAR 0 5
6452: PPUSH
6453: LD_VAR 0 6
6457: PPUSH
6458: CALL_OW 111
// Wait ( 0 0$1 ) ;
6462: LD_INT 35
6464: PPUSH
6465: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
6469: LD_VAR 0 1
6473: PPUSH
6474: LD_INT 81
6476: PUSH
6477: LD_VAR 0 1
6481: PPUSH
6482: CALL_OW 255
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: PPUSH
6491: CALL_OW 69
6495: PPUSH
6496: LD_VAR 0 1
6500: PPUSH
6501: CALL_OW 74
6505: PPUSH
6506: CALL_OW 296
6510: PUSH
6511: LD_INT 14
6513: GREATEREQUAL
6514: IFFALSE 6527
// begin ComStop ( un ) ;
6516: LD_VAR 0 1
6520: PPUSH
6521: CALL_OW 141
// break ;
6525: GO 6529
// end ; end ;
6527: GO 6030
// end ;
6529: LD_VAR 0 2
6533: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
6534: LD_INT 0
6536: PPUSH
6537: PPUSH
6538: PPUSH
6539: PPUSH
6540: PPUSH
6541: PPUSH
6542: PPUSH
6543: PPUSH
// x := GetX ( unit ) ;
6544: LD_ADDR_VAR 0 3
6548: PUSH
6549: LD_VAR 0 1
6553: PPUSH
6554: CALL_OW 250
6558: ST_TO_ADDR
// y := GetY ( unit ) ;
6559: LD_ADDR_VAR 0 4
6563: PUSH
6564: LD_VAR 0 1
6568: PPUSH
6569: CALL_OW 251
6573: ST_TO_ADDR
// i := 0 ;
6574: LD_ADDR_VAR 0 8
6578: PUSH
6579: LD_INT 0
6581: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
6582: LD_VAR 0 1
6586: PPUSH
6587: LD_INT 81
6589: PUSH
6590: LD_VAR 0 1
6594: PPUSH
6595: CALL_OW 255
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: PPUSH
6604: CALL_OW 69
6608: PPUSH
6609: LD_VAR 0 1
6613: PPUSH
6614: CALL_OW 74
6618: PPUSH
6619: CALL_OW 119
// dir := GetDir ( unit ) ;
6623: LD_ADDR_VAR 0 7
6627: PUSH
6628: LD_VAR 0 1
6632: PPUSH
6633: CALL_OW 254
6637: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
6638: LD_ADDR_VAR 0 9
6642: PUSH
6643: LD_INT 0
6645: PPUSH
6646: LD_INT 1
6648: PPUSH
6649: CALL_OW 12
6653: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
6654: LD_INT 10
6656: PPUSH
6657: CALL_OW 67
// if mode then
6661: LD_VAR 0 9
6665: IFFALSE 6683
// dir := dir + 1 else
6667: LD_ADDR_VAR 0 7
6671: PUSH
6672: LD_VAR 0 7
6676: PUSH
6677: LD_INT 1
6679: PLUS
6680: ST_TO_ADDR
6681: GO 6697
// dir := dir - 1 ;
6683: LD_ADDR_VAR 0 7
6687: PUSH
6688: LD_VAR 0 7
6692: PUSH
6693: LD_INT 1
6695: MINUS
6696: ST_TO_ADDR
// if ( dir < 0 ) then
6697: LD_VAR 0 7
6701: PUSH
6702: LD_INT 0
6704: LESS
6705: IFFALSE 6715
// dir := 5 ;
6707: LD_ADDR_VAR 0 7
6711: PUSH
6712: LD_INT 5
6714: ST_TO_ADDR
// if ( dir > 5 ) then
6715: LD_VAR 0 7
6719: PUSH
6720: LD_INT 5
6722: GREATER
6723: IFFALSE 6733
// dir := 0 ;
6725: LD_ADDR_VAR 0 7
6729: PUSH
6730: LD_INT 0
6732: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
6733: LD_ADDR_VAR 0 5
6737: PUSH
6738: LD_VAR 0 3
6742: PPUSH
6743: LD_VAR 0 7
6747: PPUSH
6748: LD_INT 4
6750: PPUSH
6751: CALL_OW 272
6755: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
6756: LD_ADDR_VAR 0 6
6760: PUSH
6761: LD_VAR 0 4
6765: PPUSH
6766: LD_VAR 0 7
6770: PPUSH
6771: LD_INT 4
6773: PPUSH
6774: CALL_OW 273
6778: ST_TO_ADDR
// i := i + 1 ;
6779: LD_ADDR_VAR 0 8
6783: PUSH
6784: LD_VAR 0 8
6788: PUSH
6789: LD_INT 1
6791: PLUS
6792: ST_TO_ADDR
// MC_Show ( [ x , y , dir ] ^ [ x2 , y2 ] ) ;
6793: LD_VAR 0 3
6797: PUSH
6798: LD_VAR 0 4
6802: PUSH
6803: LD_VAR 0 7
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: LD_VAR 0 5
6817: PUSH
6818: LD_VAR 0 6
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: ADD
6827: PPUSH
6828: CALL 3814 0 1
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
6832: LD_VAR 0 1
6836: PPUSH
6837: CALL_OW 255
6841: PPUSH
6842: LD_VAR 0 5
6846: PPUSH
6847: LD_VAR 0 6
6851: PPUSH
6852: LD_INT 14
6854: PPUSH
6855: CALL 5825 0 4
6859: PUSH
6860: LD_INT 0
6862: EQUAL
6863: PUSH
6864: LD_VAR 0 5
6868: PPUSH
6869: LD_VAR 0 6
6873: PPUSH
6874: CALL_OW 546
6878: PUSH
6879: LD_INT 0
6881: EQUAL
6882: AND
6883: PUSH
6884: LD_VAR 0 5
6888: PPUSH
6889: LD_VAR 0 6
6893: PPUSH
6894: CALL_OW 428
6898: PUSH
6899: LD_INT 0
6901: EQUAL
6902: AND
6903: IFFALSE 6907
// break ;
6905: GO 6917
// end until i > 4 ;
6907: LD_VAR 0 8
6911: PUSH
6912: LD_INT 4
6914: GREATER
6915: IFFALSE 6654
// if x2 and y2 then
6917: LD_VAR 0 5
6921: PUSH
6922: LD_VAR 0 6
6926: AND
6927: IFFALSE 6950
// result := [ x2 , y2 ] else
6929: LD_ADDR_VAR 0 2
6933: PUSH
6934: LD_VAR 0 5
6938: PUSH
6939: LD_VAR 0 6
6943: PUSH
6944: EMPTY
6945: LIST
6946: LIST
6947: ST_TO_ADDR
6948: GO 6979
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
6950: LD_ADDR_VAR 0 2
6954: PUSH
6955: LD_VAR 0 1
6959: PPUSH
6960: CALL_OW 250
6964: PUSH
6965: LD_VAR 0 1
6969: PPUSH
6970: CALL_OW 251
6974: PUSH
6975: EMPTY
6976: LIST
6977: LIST
6978: ST_TO_ADDR
// end ;
6979: LD_VAR 0 2
6983: RET
// export function MCT_Hex ( x , y ) ; begin
6984: LD_INT 0
6986: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
6987: LD_ADDR_VAR 0 3
6991: PUSH
6992: LD_VAR 0 1
6996: PPUSH
6997: LD_VAR 0 2
7001: PPUSH
7002: CALL_OW 546
7006: PUSH
7007: LD_VAR 0 1
7011: PPUSH
7012: LD_VAR 0 2
7016: PPUSH
7017: CALL_OW 428
7021: PUSH
7022: EMPTY
7023: LIST
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: ST_TO_ADDR
// end ;
7029: LD_VAR 0 3
7033: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
7034: LD_INT 0
7036: PPUSH
7037: PPUSH
7038: PPUSH
7039: PPUSH
7040: PPUSH
7041: PPUSH
7042: PPUSH
7043: PPUSH
7044: PPUSH
7045: PPUSH
7046: PPUSH
7047: PPUSH
7048: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
7049: LD_ADDR_VAR 0 10
7053: PUSH
7054: LD_EXP 29
7058: PUSH
7059: LD_VAR 0 1
7063: ARRAY
7064: PUSH
7065: LD_INT 1
7067: ARRAY
7068: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
7069: LD_ADDR_VAR 0 11
7073: PUSH
7074: LD_EXP 29
7078: PUSH
7079: LD_VAR 0 1
7083: ARRAY
7084: PUSH
7085: LD_INT 2
7087: ARRAY
7088: ST_TO_ADDR
// collectors := [ ] ;
7089: LD_ADDR_VAR 0 12
7093: PUSH
7094: EMPTY
7095: ST_TO_ADDR
// is_cargo := false ;
7096: LD_ADDR_VAR 0 13
7100: PUSH
7101: LD_INT 0
7103: ST_TO_ADDR
// if isEditor then
7104: LD_INT 1
7106: IFFALSE 7112
// TimerStart ( ) ;
7108: CALL_OW 548
// if MCF_Cargo ( side ) then
7112: LD_VAR 0 1
7116: PPUSH
7117: CALL 275 0 1
7121: IFFALSE 7148
// begin collectors := MCF_Cargo ( side ) ;
7123: LD_ADDR_VAR 0 12
7127: PUSH
7128: LD_VAR 0 1
7132: PPUSH
7133: CALL 275 0 1
7137: ST_TO_ADDR
// is_cargo := true ;
7138: LD_ADDR_VAR 0 13
7142: PUSH
7143: LD_INT 1
7145: ST_TO_ADDR
// end else
7146: GO 7297
// begin if MCF_ApeSpec ( side , engineer ) then
7148: LD_VAR 0 1
7152: PPUSH
7153: LD_STRING engineer
7155: PPUSH
7156: CALL 421 0 2
7160: IFFALSE 7180
// collectors := MCF_ApeSpec ( side , engineer ) ;
7162: LD_ADDR_VAR 0 12
7166: PUSH
7167: LD_VAR 0 1
7171: PPUSH
7172: LD_STRING engineer
7174: PPUSH
7175: CALL 421 0 2
7179: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
7180: LD_VAR 0 1
7184: PPUSH
7185: LD_INT 2
7187: PPUSH
7188: EMPTY
7189: PPUSH
7190: CALL 83 0 3
7194: IFFALSE 7297
// begin z := MCF_Class ( side , 2 , [ ] ) ;
7196: LD_ADDR_VAR 0 7
7200: PUSH
7201: LD_VAR 0 1
7205: PPUSH
7206: LD_INT 2
7208: PPUSH
7209: EMPTY
7210: PPUSH
7211: CALL 83 0 3
7215: ST_TO_ADDR
// if z > 5 then
7216: LD_VAR 0 7
7220: PUSH
7221: LD_INT 5
7223: GREATER
7224: IFFALSE 7236
// t1 := 5 else
7226: LD_ADDR_VAR 0 8
7230: PUSH
7231: LD_INT 5
7233: ST_TO_ADDR
7234: GO 7246
// t1 := z ;
7236: LD_ADDR_VAR 0 8
7240: PUSH
7241: LD_VAR 0 7
7245: ST_TO_ADDR
// for t2 = 1 to t1 do
7246: LD_ADDR_VAR 0 9
7250: PUSH
7251: DOUBLE
7252: LD_INT 1
7254: DEC
7255: ST_TO_ADDR
7256: LD_VAR 0 8
7260: PUSH
7261: FOR_TO
7262: IFFALSE 7295
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
7264: LD_ADDR_VAR 0 12
7268: PUSH
7269: LD_VAR 0 12
7273: PPUSH
7274: LD_INT 1
7276: PPUSH
7277: LD_VAR 0 7
7281: PUSH
7282: LD_VAR 0 9
7286: ARRAY
7287: PPUSH
7288: CALL_OW 2
7292: ST_TO_ADDR
7293: GO 7261
7295: POP
7296: POP
// end ; end ; if not mode then
7297: LD_VAR 0 10
7301: NOT
7302: IFFALSE 7308
// exit else
7304: GO 7565
7306: GO 7565
// begin if collectors then
7308: LD_VAR 0 12
7312: IFFALSE 7565
// for i in areas do
7314: LD_ADDR_VAR 0 3
7318: PUSH
7319: LD_VAR 0 11
7323: PUSH
7324: FOR_IN
7325: IFFALSE 7563
// if GetListOfCratesInArea ( i ) then
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL_OW 435
7336: IFFALSE 7561
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
7338: LD_ADDR_VAR 0 5
7342: PUSH
7343: LD_VAR 0 3
7347: PPUSH
7348: CALL_OW 435
7352: PUSH
7353: LD_INT 1
7355: ARRAY
7356: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
7357: LD_ADDR_VAR 0 6
7361: PUSH
7362: LD_VAR 0 3
7366: PPUSH
7367: CALL_OW 435
7371: PUSH
7372: LD_INT 2
7374: ARRAY
7375: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
7376: LD_VAR 0 13
7380: PUSH
7381: LD_VAR 0 12
7385: PUSH
7386: LD_INT 1
7388: ARRAY
7389: PPUSH
7390: CALL_OW 110
7394: PUSH
7395: LD_INT 0
7397: EQUAL
7398: AND
7399: IFFALSE 7461
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
7401: LD_VAR 0 12
7405: PUSH
7406: LD_INT 1
7408: ARRAY
7409: PPUSH
7410: CALL_OW 314
7414: NOT
7415: PUSH
7416: LD_VAR 0 12
7420: PUSH
7421: LD_INT 1
7423: ARRAY
7424: PPUSH
7425: CALL_OW 110
7429: PUSH
7430: LD_INT 0
7432: EQUAL
7433: AND
7434: IFFALSE 7459
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
7436: LD_VAR 0 12
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: LD_VAR 0 5
7449: PPUSH
7450: LD_VAR 0 6
7454: PPUSH
7455: CALL_OW 117
// end ; end else
7459: GO 7547
// begin for j = 1 to collectors do
7461: LD_ADDR_VAR 0 4
7465: PUSH
7466: DOUBLE
7467: LD_INT 1
7469: DEC
7470: ST_TO_ADDR
7471: LD_VAR 0 12
7475: PUSH
7476: FOR_TO
7477: IFFALSE 7545
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
7479: LD_VAR 0 12
7483: PUSH
7484: LD_VAR 0 4
7488: ARRAY
7489: PPUSH
7490: CALL_OW 314
7494: NOT
7495: PUSH
7496: LD_VAR 0 12
7500: PUSH
7501: LD_VAR 0 4
7505: ARRAY
7506: PPUSH
7507: CALL_OW 110
7511: PUSH
7512: LD_INT 0
7514: EQUAL
7515: AND
7516: IFFALSE 7543
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
7518: LD_VAR 0 12
7522: PUSH
7523: LD_VAR 0 4
7527: ARRAY
7528: PPUSH
7529: LD_VAR 0 5
7533: PPUSH
7534: LD_VAR 0 6
7538: PPUSH
7539: CALL 7926 0 3
// end ;
7543: GO 7476
7545: POP
7546: POP
// end ; if isEditor then
7547: LD_INT 1
7549: IFFALSE 7561
// begin debug_time := TimerEnd ( ) ;
7551: LD_ADDR_VAR 0 14
7555: PUSH
7556: CALL_OW 549
7560: ST_TO_ADDR
// end ; end ;
7561: GO 7324
7563: POP
7564: POP
// end ; end ;
7565: LD_VAR 0 2
7569: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
7570: LD_INT 0
7572: PPUSH
7573: PPUSH
7574: PPUSH
7575: PPUSH
7576: PPUSH
7577: PPUSH
// if not area then
7578: LD_VAR 0 1
7582: NOT
7583: IFFALSE 7589
// exit else
7585: GO 7841
7587: GO 7841
// if tick mod interval = 0 and Prob ( percent ) then
7589: LD_OWVAR 1
7593: PUSH
7594: LD_VAR 0 4
7598: MOD
7599: PUSH
7600: LD_INT 0
7602: EQUAL
7603: PUSH
7604: LD_VAR 0 3
7608: PPUSH
7609: CALL_OW 13
7613: AND
7614: IFFALSE 7841
// begin if GetListOfCratesInArea ( area ) < limit then
7616: LD_VAR 0 1
7620: PPUSH
7621: CALL_OW 435
7625: PUSH
7626: LD_VAR 0 5
7630: LESS
7631: IFFALSE 7841
// begin Randomize ;
7633: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
7637: LD_ADDR_VAR 0 7
7641: PUSH
7642: LD_INT 1
7644: PPUSH
7645: LD_VAR 0 2
7649: PPUSH
7650: CALL_OW 12
7654: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
7655: LD_ADDR_VAR 0 9
7659: PUSH
7660: LD_VAR 0 1
7664: PPUSH
7665: LD_INT 0
7667: PPUSH
7668: CALL_OW 517
7672: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
7673: LD_ADDR_VAR 0 8
7677: PUSH
7678: LD_INT 1
7680: PPUSH
7681: LD_VAR 0 9
7685: PUSH
7686: LD_INT 1
7688: ARRAY
7689: PPUSH
7690: CALL_OW 12
7694: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
7695: LD_VAR 0 9
7699: PUSH
7700: LD_INT 1
7702: ARRAY
7703: PUSH
7704: LD_VAR 0 8
7708: ARRAY
7709: PPUSH
7710: LD_VAR 0 9
7714: PUSH
7715: LD_INT 2
7717: ARRAY
7718: PUSH
7719: LD_VAR 0 8
7723: ARRAY
7724: PPUSH
7725: CALL_OW 428
7729: PUSH
7730: LD_INT 0
7732: GREATER
7733: PUSH
7734: LD_VAR 0 9
7738: PUSH
7739: LD_INT 1
7741: ARRAY
7742: PUSH
7743: LD_VAR 0 8
7747: ARRAY
7748: PPUSH
7749: LD_VAR 0 9
7753: PUSH
7754: LD_INT 2
7756: ARRAY
7757: PUSH
7758: LD_VAR 0 8
7762: ARRAY
7763: PPUSH
7764: CALL_OW 284
7768: PUSH
7769: LD_INT 0
7771: GREATER
7772: AND
7773: IFFALSE 7799
// c := Rand ( 1 , tmp [ 1 ] ) ;
7775: LD_ADDR_VAR 0 8
7779: PUSH
7780: LD_INT 1
7782: PPUSH
7783: LD_VAR 0 9
7787: PUSH
7788: LD_INT 1
7790: ARRAY
7791: PPUSH
7792: CALL_OW 12
7796: ST_TO_ADDR
7797: GO 7695
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
7799: LD_VAR 0 7
7803: PPUSH
7804: LD_VAR 0 9
7808: PUSH
7809: LD_INT 1
7811: ARRAY
7812: PUSH
7813: LD_VAR 0 8
7817: ARRAY
7818: PPUSH
7819: LD_VAR 0 9
7823: PUSH
7824: LD_INT 2
7826: ARRAY
7827: PUSH
7828: LD_VAR 0 8
7832: ARRAY
7833: PPUSH
7834: LD_INT 1
7836: PPUSH
7837: CALL_OW 54
// end ; end ; end ;
7841: LD_VAR 0 6
7845: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
7846: LD_INT 0
7848: PPUSH
7849: PPUSH
// if not MREG_Crates then
7850: LD_EXP 2
7854: NOT
7855: IFFALSE 7859
// exit ;
7857: GO 7921
// for i = MREG_Crates downto 1 do
7859: LD_ADDR_VAR 0 2
7863: PUSH
7864: DOUBLE
7865: LD_EXP 2
7869: INC
7870: ST_TO_ADDR
7871: LD_INT 1
7873: PUSH
7874: FOR_DOWNTO
7875: IFFALSE 7919
// if MREG_Crates [ i ] [ 3 ] = 0 then
7877: LD_EXP 2
7881: PUSH
7882: LD_VAR 0 2
7886: ARRAY
7887: PUSH
7888: LD_INT 3
7890: ARRAY
7891: PUSH
7892: LD_INT 0
7894: EQUAL
7895: IFFALSE 7917
// MREG_Crates := Delete ( MREG_Crates , i ) ;
7897: LD_ADDR_EXP 2
7901: PUSH
7902: LD_EXP 2
7906: PPUSH
7907: LD_VAR 0 2
7911: PPUSH
7912: CALL_OW 3
7916: ST_TO_ADDR
7917: GO 7874
7919: POP
7920: POP
// end ;
7921: LD_VAR 0 1
7925: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
7926: LD_INT 0
7928: PPUSH
7929: PPUSH
7930: PPUSH
7931: PPUSH
// if not unit then
7932: LD_VAR 0 1
7936: NOT
7937: IFFALSE 7941
// exit ;
7939: GO 8076
// if HasTask ( unit ) or not CanCarry ( unit ) then
7941: LD_VAR 0 1
7945: PPUSH
7946: CALL_OW 314
7950: PUSH
7951: LD_VAR 0 1
7955: PPUSH
7956: CALL_OW 280
7960: NOT
7961: OR
7962: IFFALSE 7966
// exit ;
7964: GO 8076
// side := GetSide ( unit ) ;
7966: LD_ADDR_VAR 0 6
7970: PUSH
7971: LD_VAR 0 1
7975: PPUSH
7976: CALL_OW 255
7980: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
7981: LD_ADDR_VAR 0 7
7985: PUSH
7986: LD_VAR 0 6
7990: PPUSH
7991: LD_INT 30
7993: PUSH
7994: LD_INT 1
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PPUSH
8001: CALL 0 0 2
8005: ST_TO_ADDR
// if Carry ( unit ) or not dep then
8006: LD_VAR 0 1
8010: PPUSH
8011: CALL_OW 281
8015: PUSH
8016: LD_VAR 0 7
8020: NOT
8021: OR
8022: IFFALSE 8028
// exit else
8024: GO 8076
8026: GO 8076
// if GetResourceAmountXY ( x , y ) then
8028: LD_VAR 0 2
8032: PPUSH
8033: LD_VAR 0 3
8037: PPUSH
8038: CALL_OW 284
8042: IFFALSE 8074
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_VAR 0 2
8053: PPUSH
8054: LD_VAR 0 3
8058: PPUSH
8059: LD_VAR 0 7
8063: PUSH
8064: LD_INT 1
8066: ARRAY
8067: PPUSH
8068: CALL 24540 0 4
// end else
8072: GO 8076
// exit ;
8074: GO 8076
// end ; end_of_file
8076: LD_VAR 0 4
8080: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
8081: LD_INT 0
8083: PPUSH
8084: PPUSH
8085: PPUSH
// pom := GetBase ( bdepot ) ;
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: LD_VAR 0 1
8095: PPUSH
8096: CALL_OW 274
8100: ST_TO_ADDR
// sor := [ ] ;
8101: LD_ADDR_VAR 0 4
8105: PUSH
8106: EMPTY
8107: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
8108: LD_ADDR_VAR 0 4
8112: PUSH
8113: LD_VAR 0 4
8117: PUSH
8118: LD_VAR 0 3
8122: PPUSH
8123: LD_INT 1
8125: PPUSH
8126: CALL_OW 275
8130: ADD
8131: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
8132: LD_ADDR_VAR 0 4
8136: PUSH
8137: LD_VAR 0 4
8141: PUSH
8142: LD_VAR 0 3
8146: PPUSH
8147: LD_INT 2
8149: PPUSH
8150: CALL_OW 275
8154: ADD
8155: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
8156: LD_ADDR_VAR 0 4
8160: PUSH
8161: LD_VAR 0 4
8165: PUSH
8166: LD_VAR 0 3
8170: PPUSH
8171: LD_INT 3
8173: PPUSH
8174: CALL_OW 275
8178: ADD
8179: ST_TO_ADDR
// result := sor ;
8180: LD_ADDR_VAR 0 2
8184: PUSH
8185: LD_VAR 0 4
8189: ST_TO_ADDR
// end ;
8190: LD_VAR 0 2
8194: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
8195: LD_INT 0
8197: PPUSH
8198: PPUSH
// while ( coord_list ) do
8199: LD_VAR 0 3
8203: IFFALSE 8377
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
8205: LD_ADDR_EXP 15
8209: PUSH
8210: LD_EXP 15
8214: PPUSH
8215: LD_VAR 0 1
8219: PPUSH
8220: LD_VAR 0 2
8224: PPUSH
8225: LD_VAR 0 3
8229: PUSH
8230: LD_INT 1
8232: ARRAY
8233: PUSH
8234: LD_VAR 0 3
8238: PUSH
8239: LD_INT 2
8241: ARRAY
8242: PUSH
8243: LD_VAR 0 3
8247: PUSH
8248: LD_INT 3
8250: ARRAY
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: LIST
8256: PPUSH
8257: CALL 4048 0 4
8261: ST_TO_ADDR
// if weapon_list then
8262: LD_VAR 0 4
8266: IFFALSE 8337
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
8268: LD_ADDR_EXP 12
8272: PUSH
8273: LD_EXP 12
8277: PPUSH
8278: LD_VAR 0 1
8282: PPUSH
8283: LD_VAR 0 4
8287: PUSH
8288: LD_INT 1
8290: ARRAY
8291: PPUSH
8292: LD_VAR 0 3
8296: PUSH
8297: LD_INT 1
8299: ARRAY
8300: PUSH
8301: LD_VAR 0 3
8305: PUSH
8306: LD_INT 2
8308: ARRAY
8309: PUSH
8310: EMPTY
8311: LIST
8312: LIST
8313: PPUSH
8314: CALL 4048 0 4
8318: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
8319: LD_ADDR_VAR 0 4
8323: PUSH
8324: LD_VAR 0 4
8328: PPUSH
8329: LD_INT 1
8331: PPUSH
8332: CALL_OW 3
8336: ST_TO_ADDR
// end ; for i = 1 to 3 do
8337: LD_ADDR_VAR 0 6
8341: PUSH
8342: DOUBLE
8343: LD_INT 1
8345: DEC
8346: ST_TO_ADDR
8347: LD_INT 3
8349: PUSH
8350: FOR_TO
8351: IFFALSE 8373
// coord_list := Delete ( coord_list , 1 ) ;
8353: LD_ADDR_VAR 0 3
8357: PUSH
8358: LD_VAR 0 3
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: CALL_OW 3
8370: ST_TO_ADDR
8371: GO 8350
8373: POP
8374: POP
// end ;
8375: GO 8199
// result := true ;
8377: LD_ADDR_VAR 0 5
8381: PUSH
8382: LD_INT 1
8384: ST_TO_ADDR
// end ;
8385: LD_VAR 0 5
8389: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
8390: LD_INT 0
8392: PPUSH
8393: PPUSH
// if not weapon_list then
8394: LD_VAR 0 3
8398: NOT
8399: IFFALSE 8403
// exit ;
8401: GO 8518
// while ( coord_list ) do
8403: LD_VAR 0 2
8407: IFFALSE 8518
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
8409: LD_ADDR_EXP 12
8413: PUSH
8414: LD_EXP 12
8418: PPUSH
8419: LD_VAR 0 1
8423: PPUSH
8424: LD_VAR 0 3
8428: PUSH
8429: LD_INT 1
8431: ARRAY
8432: PPUSH
8433: LD_VAR 0 2
8437: PUSH
8438: LD_INT 1
8440: ARRAY
8441: PUSH
8442: LD_VAR 0 2
8446: PUSH
8447: LD_INT 2
8449: ARRAY
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PPUSH
8455: CALL 4048 0 4
8459: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
8460: LD_ADDR_VAR 0 3
8464: PUSH
8465: LD_VAR 0 3
8469: PPUSH
8470: LD_INT 1
8472: PPUSH
8473: CALL_OW 3
8477: ST_TO_ADDR
// for i = 1 to 2 do
8478: LD_ADDR_VAR 0 5
8482: PUSH
8483: DOUBLE
8484: LD_INT 1
8486: DEC
8487: ST_TO_ADDR
8488: LD_INT 2
8490: PUSH
8491: FOR_TO
8492: IFFALSE 8514
// coord_list := Delete ( coord_list , 1 ) ;
8494: LD_ADDR_VAR 0 2
8498: PUSH
8499: LD_VAR 0 2
8503: PPUSH
8504: LD_INT 1
8506: PPUSH
8507: CALL_OW 3
8511: ST_TO_ADDR
8512: GO 8491
8514: POP
8515: POP
// end ;
8516: GO 8403
// end ;
8518: LD_VAR 0 4
8522: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
8523: LD_INT 0
8525: PPUSH
8526: PPUSH
// while ( coord_list ) do
8527: LD_VAR 0 2
8531: IFFALSE 8686
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
8533: LD_VAR 0 2
8537: PUSH
8538: LD_INT 1
8540: ARRAY
8541: PPUSH
8542: LD_VAR 0 2
8546: PUSH
8547: LD_INT 2
8549: ARRAY
8550: PPUSH
8551: CALL_OW 428
8555: IFFALSE 8646
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
8557: LD_VAR 0 2
8561: PUSH
8562: LD_INT 1
8564: ARRAY
8565: PPUSH
8566: LD_VAR 0 2
8570: PUSH
8571: LD_INT 2
8573: ARRAY
8574: PPUSH
8575: CALL_OW 428
8579: PPUSH
8580: CALL_OW 266
8584: PUSH
8585: LD_INT 31
8587: PUSH
8588: LD_INT 32
8590: PUSH
8591: LD_INT 33
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: IN
8599: IFFALSE 8646
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
8601: LD_ADDR_EXP 21
8605: PUSH
8606: LD_EXP 21
8610: PPUSH
8611: LD_VAR 0 1
8615: PPUSH
8616: LD_VAR 0 2
8620: PUSH
8621: LD_INT 1
8623: ARRAY
8624: PPUSH
8625: LD_VAR 0 2
8629: PUSH
8630: LD_INT 2
8632: ARRAY
8633: PPUSH
8634: CALL_OW 428
8638: PPUSH
8639: EMPTY
8640: PPUSH
8641: CALL 4048 0 4
8645: ST_TO_ADDR
// for i = 1 to 3 do
8646: LD_ADDR_VAR 0 4
8650: PUSH
8651: DOUBLE
8652: LD_INT 1
8654: DEC
8655: ST_TO_ADDR
8656: LD_INT 3
8658: PUSH
8659: FOR_TO
8660: IFFALSE 8682
// coord_list := Delete ( coord_list , 1 ) ;
8662: LD_ADDR_VAR 0 2
8666: PUSH
8667: LD_VAR 0 2
8671: PPUSH
8672: LD_INT 1
8674: PPUSH
8675: CALL_OW 3
8679: ST_TO_ADDR
8680: GO 8659
8682: POP
8683: POP
// end ;
8684: GO 8527
// result := true ;
8686: LD_ADDR_VAR 0 3
8690: PUSH
8691: LD_INT 1
8693: ST_TO_ADDR
// end ;
8694: LD_VAR 0 3
8698: RET
// export function MCS_Depot ( side , coord_list ) ; begin
8699: LD_INT 0
8701: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
8702: LD_ADDR_EXP 15
8706: PUSH
8707: LD_EXP 15
8711: PPUSH
8712: LD_VAR 0 1
8716: PPUSH
8717: LD_INT 0
8719: PPUSH
8720: LD_VAR 0 2
8724: PPUSH
8725: CALL 4048 0 4
8729: ST_TO_ADDR
// end ;
8730: LD_VAR 0 3
8734: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
8735: LD_INT 0
8737: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
8738: LD_ADDR_EXP 15
8742: PUSH
8743: LD_EXP 15
8747: PPUSH
8748: LD_VAR 0 1
8752: PPUSH
8753: LD_INT 6
8755: PPUSH
8756: LD_VAR 0 2
8760: PPUSH
8761: CALL 4048 0 4
8765: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
8766: LD_ADDR_EXP 18
8770: PUSH
8771: LD_EXP 18
8775: PPUSH
8776: LD_VAR 0 1
8780: PPUSH
8781: LD_VAR 0 3
8785: PUSH
8786: LD_INT 1
8788: ARRAY
8789: PPUSH
8790: LD_VAR 0 3
8794: PUSH
8795: LD_INT 2
8797: ARRAY
8798: PPUSH
8799: CALL 4048 0 4
8803: ST_TO_ADDR
// end ;
8804: LD_VAR 0 4
8808: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
8809: LD_INT 0
8811: PPUSH
8812: PPUSH
// if ext_list > 5 then
8813: LD_VAR 0 3
8817: PUSH
8818: LD_INT 5
8820: GREATER
8821: IFFALSE 8865
// for i = 6 to ext_list do
8823: LD_ADDR_VAR 0 5
8827: PUSH
8828: DOUBLE
8829: LD_INT 6
8831: DEC
8832: ST_TO_ADDR
8833: LD_VAR 0 3
8837: PUSH
8838: FOR_TO
8839: IFFALSE 8863
// ext_list := Delete ( ext_list , ext_list ) ;
8841: LD_ADDR_VAR 0 3
8845: PUSH
8846: LD_VAR 0 3
8850: PPUSH
8851: LD_VAR 0 3
8855: PPUSH
8856: CALL_OW 3
8860: ST_TO_ADDR
8861: GO 8838
8863: POP
8864: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
8865: LD_VAR 0 1
8869: PPUSH
8870: LD_VAR 0 2
8874: PUSH
8875: LD_INT 1
8877: ARRAY
8878: PPUSH
8879: LD_VAR 0 2
8883: PUSH
8884: LD_INT 2
8886: ARRAY
8887: PPUSH
8888: LD_VAR 0 2
8892: PUSH
8893: LD_INT 3
8895: ARRAY
8896: PPUSH
8897: LD_VAR 0 3
8901: PPUSH
8902: CALL 10529 0 5
// end ;
8906: LD_VAR 0 4
8910: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
8911: LD_INT 0
8913: PPUSH
8914: PPUSH
8915: PPUSH
// p := 1 ;
8916: LD_ADDR_VAR 0 6
8920: PUSH
8921: LD_INT 1
8923: ST_TO_ADDR
// if type_list = [ ] then
8924: LD_VAR 0 3
8928: PUSH
8929: EMPTY
8930: EQUAL
8931: IFFALSE 8941
// type_list := b_oil_power ;
8933: LD_ADDR_VAR 0 3
8937: PUSH
8938: LD_INT 26
8940: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
8941: LD_ADDR_VAR 0 5
8945: PUSH
8946: DOUBLE
8947: LD_INT 1
8949: DEC
8950: ST_TO_ADDR
8951: LD_VAR 0 2
8955: PUSH
8956: LD_INT 3
8958: DIVREAL
8959: PUSH
8960: FOR_TO
8961: IFFALSE 9064
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
8963: LD_ADDR_EXP 15
8967: PUSH
8968: LD_EXP 15
8972: PPUSH
8973: LD_VAR 0 1
8977: PPUSH
8978: LD_VAR 0 3
8982: PUSH
8983: LD_INT 1
8985: PPUSH
8986: LD_VAR 0 3
8990: PPUSH
8991: CALL_OW 12
8995: ARRAY
8996: PPUSH
8997: LD_VAR 0 2
9001: PUSH
9002: LD_VAR 0 6
9006: ARRAY
9007: PUSH
9008: LD_VAR 0 2
9012: PUSH
9013: LD_VAR 0 6
9017: PUSH
9018: LD_INT 1
9020: PLUS
9021: ARRAY
9022: PUSH
9023: LD_VAR 0 2
9027: PUSH
9028: LD_VAR 0 6
9032: PUSH
9033: LD_INT 2
9035: PLUS
9036: ARRAY
9037: PUSH
9038: EMPTY
9039: LIST
9040: LIST
9041: LIST
9042: PPUSH
9043: CALL 4048 0 4
9047: ST_TO_ADDR
// p := p + 3 ;
9048: LD_ADDR_VAR 0 6
9052: PUSH
9053: LD_VAR 0 6
9057: PUSH
9058: LD_INT 3
9060: PLUS
9061: ST_TO_ADDR
// end ;
9062: GO 8960
9064: POP
9065: POP
// end ;
9066: LD_VAR 0 4
9070: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
9071: LD_INT 0
9073: PPUSH
9074: PPUSH
9075: PPUSH
9076: PPUSH
// if not MREG_Deposit [ side ] then
9077: LD_EXP 30
9081: PUSH
9082: LD_VAR 0 1
9086: ARRAY
9087: NOT
9088: IFFALSE 9092
// exit ;
9090: GO 9269
// p := 1 ;
9092: LD_ADDR_VAR 0 4
9096: PUSH
9097: LD_INT 1
9099: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
9100: LD_ADDR_VAR 0 3
9104: PUSH
9105: DOUBLE
9106: LD_INT 1
9108: DEC
9109: ST_TO_ADDR
9110: LD_EXP 30
9114: PUSH
9115: LD_VAR 0 1
9119: ARRAY
9120: PUSH
9121: LD_INT 3
9123: DIVREAL
9124: PUSH
9125: FOR_TO
9126: IFFALSE 9267
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
9128: LD_EXP 30
9132: PUSH
9133: LD_VAR 0 1
9137: ARRAY
9138: PUSH
9139: LD_VAR 0 4
9143: PUSH
9144: LD_INT 2
9146: PLUS
9147: ARRAY
9148: PUSH
9149: LD_INT 2
9151: EQUAL
9152: IFFALSE 9164
// b := b_oil_mine else
9154: LD_ADDR_VAR 0 5
9158: PUSH
9159: LD_INT 29
9161: ST_TO_ADDR
9162: GO 9172
// b := b_siberite_mine ;
9164: LD_ADDR_VAR 0 5
9168: PUSH
9169: LD_INT 30
9171: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
9172: LD_ADDR_EXP 15
9176: PUSH
9177: LD_EXP 15
9181: PPUSH
9182: LD_VAR 0 1
9186: PPUSH
9187: LD_VAR 0 5
9191: PPUSH
9192: LD_EXP 30
9196: PUSH
9197: LD_VAR 0 1
9201: ARRAY
9202: PUSH
9203: LD_VAR 0 4
9207: ARRAY
9208: PUSH
9209: LD_EXP 30
9213: PUSH
9214: LD_VAR 0 1
9218: ARRAY
9219: PUSH
9220: LD_VAR 0 4
9224: PUSH
9225: LD_INT 1
9227: PLUS
9228: ARRAY
9229: PUSH
9230: LD_INT 0
9232: PPUSH
9233: LD_INT 5
9235: PPUSH
9236: CALL_OW 12
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: LIST
9245: PPUSH
9246: CALL 4048 0 4
9250: ST_TO_ADDR
// p := p + 3 ;
9251: LD_ADDR_VAR 0 4
9255: PUSH
9256: LD_VAR 0 4
9260: PUSH
9261: LD_INT 3
9263: PLUS
9264: ST_TO_ADDR
// end ;
9265: GO 9125
9267: POP
9268: POP
// end ;
9269: LD_VAR 0 2
9273: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
9274: LD_INT 0
9276: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
9277: LD_ADDR_EXP 15
9281: PUSH
9282: LD_EXP 15
9286: PPUSH
9287: LD_VAR 0 1
9291: PPUSH
9292: LD_INT 4
9294: PPUSH
9295: LD_VAR 0 2
9299: PPUSH
9300: CALL 4048 0 4
9304: ST_TO_ADDR
// end ;
9305: LD_VAR 0 3
9309: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
9310: LD_INT 0
9312: PPUSH
// case nation of 1 , us :
9313: LD_VAR 0 2
9317: PUSH
9318: LD_INT 1
9320: DOUBLE
9321: EQUAL
9322: IFTRUE 9332
9324: LD_STRING us
9326: DOUBLE
9327: EQUAL
9328: IFTRUE 9332
9330: GO 9363
9332: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
9333: LD_ADDR_EXP 15
9337: PUSH
9338: LD_EXP 15
9342: PPUSH
9343: LD_VAR 0 1
9347: PPUSH
9348: LD_INT 36
9350: PPUSH
9351: LD_VAR 0 3
9355: PPUSH
9356: CALL 4048 0 4
9360: ST_TO_ADDR
9361: GO 9414
9363: LD_INT 2
9365: DOUBLE
9366: EQUAL
9367: IFTRUE 9377
9369: LD_STRING ar
9371: DOUBLE
9372: EQUAL
9373: IFTRUE 9377
9375: GO 9413
9377: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
9378: LD_ADDR_EXP 15
9382: PUSH
9383: LD_VAR 0 1
9387: PPUSH
9388: LD_INT 14
9390: PUSH
9391: LD_INT 2
9393: PUSH
9394: LD_INT 1
9396: PUSH
9397: LD_INT 31
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: PPUSH
9406: CALL 9419 0 2
9410: ST_TO_ADDR
9411: GO 9414
9413: POP
// end ;
9414: LD_VAR 0 4
9418: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
9419: LD_INT 0
9421: PPUSH
9422: PPUSH
// for i = 1 to list do
9423: LD_ADDR_VAR 0 4
9427: PUSH
9428: DOUBLE
9429: LD_INT 1
9431: DEC
9432: ST_TO_ADDR
9433: LD_VAR 0 2
9437: PUSH
9438: FOR_TO
9439: IFFALSE 9489
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
9441: LD_ADDR_EXP 20
9445: PUSH
9446: LD_EXP 20
9450: PPUSH
9451: LD_VAR 0 1
9455: PPUSH
9456: LD_EXP 20
9460: PUSH
9461: LD_VAR 0 1
9465: ARRAY
9466: PUSH
9467: LD_INT 1
9469: PLUS
9470: PPUSH
9471: LD_VAR 0 2
9475: PUSH
9476: LD_VAR 0 4
9480: ARRAY
9481: PPUSH
9482: CALL 23459 0 4
9486: ST_TO_ADDR
9487: GO 9438
9489: POP
9490: POP
// end ;
9491: LD_VAR 0 3
9495: RET
// export function MCS_GetVehicleList ( side ) ; begin
9496: LD_INT 0
9498: PPUSH
// result := MREG_ToConstruct [ side ] ;
9499: LD_ADDR_VAR 0 2
9503: PUSH
9504: LD_EXP 20
9508: PUSH
9509: LD_VAR 0 1
9513: ARRAY
9514: ST_TO_ADDR
// end ;
9515: LD_VAR 0 2
9519: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
9520: LD_INT 0
9522: PPUSH
9523: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
9524: LD_ADDR_EXP 27
9528: PUSH
9529: LD_EXP 27
9533: PPUSH
9534: LD_VAR 0 1
9538: PPUSH
9539: LD_VAR 0 2
9543: PPUSH
9544: CALL_OW 1
9548: ST_TO_ADDR
// end ;
9549: LD_VAR 0 3
9553: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
9554: LD_INT 0
9556: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
9557: LD_ADDR_EXP 5
9561: PUSH
9562: LD_EXP 5
9566: PPUSH
9567: LD_VAR 0 1
9571: PPUSH
9572: LD_VAR 0 2
9576: PPUSH
9577: CALL_OW 1
9581: ST_TO_ADDR
// end ;
9582: LD_VAR 0 3
9586: RET
// export function MCS_ApeOptions ( side , options ) ; begin
9587: LD_INT 0
9589: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
9590: LD_ADDR_EXP 6
9594: PUSH
9595: LD_EXP 6
9599: PPUSH
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_VAR 0 2
9609: PPUSH
9610: CALL_OW 1
9614: ST_TO_ADDR
// end ;
9615: LD_VAR 0 3
9619: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
9620: LD_INT 0
9622: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
9623: LD_ADDR_EXP 29
9627: PUSH
9628: LD_EXP 29
9632: PPUSH
9633: LD_VAR 0 1
9637: PPUSH
9638: LD_INT 1
9640: PPUSH
9641: LD_VAR 0 2
9645: PPUSH
9646: CALL 23459 0 4
9650: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
9651: LD_ADDR_EXP 29
9655: PUSH
9656: LD_EXP 29
9660: PPUSH
9661: LD_VAR 0 1
9665: PPUSH
9666: LD_INT 2
9668: PPUSH
9669: LD_VAR 0 3
9673: PPUSH
9674: CALL 23459 0 4
9678: ST_TO_ADDR
// end ;
9679: LD_VAR 0 4
9683: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
9684: LD_INT 0
9686: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
9687: LD_ADDR_EXP 31
9691: PUSH
9692: LD_EXP 31
9696: PPUSH
9697: LD_INT 1
9699: PPUSH
9700: LD_VAR 0 1
9704: PPUSH
9705: CALL_OW 1
9709: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
9710: LD_ADDR_EXP 31
9714: PUSH
9715: LD_EXP 31
9719: PPUSH
9720: LD_INT 2
9722: PPUSH
9723: LD_VAR 0 2
9727: PPUSH
9728: CALL_OW 1
9732: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
9733: LD_ADDR_EXP 31
9737: PUSH
9738: LD_EXP 31
9742: PPUSH
9743: LD_INT 3
9745: PPUSH
9746: LD_VAR 0 3
9750: PPUSH
9751: CALL_OW 1
9755: ST_TO_ADDR
// end ;
9756: LD_VAR 0 4
9760: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
9761: LD_INT 0
9763: PPUSH
9764: PPUSH
9765: PPUSH
// if not side or not list then
9766: LD_VAR 0 1
9770: NOT
9771: PUSH
9772: LD_VAR 0 2
9776: NOT
9777: OR
9778: IFFALSE 9782
// exit ;
9780: GO 9948
// SetTech ( 20 , side , state_researched ) ;
9782: LD_INT 20
9784: PPUSH
9785: LD_VAR 0 1
9789: PPUSH
9790: LD_INT 2
9792: PPUSH
9793: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
9797: LD_ADDR_EXP 30
9801: PUSH
9802: LD_EXP 30
9806: PPUSH
9807: LD_VAR 0 1
9811: PPUSH
9812: LD_VAR 0 2
9816: PPUSH
9817: CALL_OW 2
9821: ST_TO_ADDR
// p := 1 ;
9822: LD_ADDR_VAR 0 5
9826: PUSH
9827: LD_INT 1
9829: ST_TO_ADDR
// for i = 1 to list / 3 do
9830: LD_ADDR_VAR 0 4
9834: PUSH
9835: DOUBLE
9836: LD_INT 1
9838: DEC
9839: ST_TO_ADDR
9840: LD_VAR 0 2
9844: PUSH
9845: LD_INT 3
9847: DIVREAL
9848: PUSH
9849: FOR_TO
9850: IFFALSE 9946
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
9852: LD_VAR 0 2
9856: PUSH
9857: LD_VAR 0 5
9861: ARRAY
9862: PPUSH
9863: LD_VAR 0 2
9867: PUSH
9868: LD_VAR 0 5
9872: PUSH
9873: LD_INT 1
9875: PLUS
9876: ARRAY
9877: PPUSH
9878: LD_VAR 0 2
9882: PUSH
9883: LD_VAR 0 5
9887: PUSH
9888: LD_INT 2
9890: PLUS
9891: ARRAY
9892: PPUSH
9893: CALL 5407 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , true ) ;
9897: LD_VAR 0 2
9901: PUSH
9902: LD_VAR 0 5
9906: ARRAY
9907: PPUSH
9908: LD_VAR 0 2
9912: PUSH
9913: LD_VAR 0 5
9917: PUSH
9918: LD_INT 1
9920: PLUS
9921: ARRAY
9922: PPUSH
9923: LD_INT 1
9925: PPUSH
9926: CALL_OW 441
// p := p + 3 ;
9930: LD_ADDR_VAR 0 5
9934: PUSH
9935: LD_VAR 0 5
9939: PUSH
9940: LD_INT 3
9942: PLUS
9943: ST_TO_ADDR
// end ;
9944: GO 9849
9946: POP
9947: POP
// end ; end_of_file
9948: LD_VAR 0 3
9952: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
9953: LD_INT 0
9955: PPUSH
9956: PPUSH
9957: PPUSH
9958: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
9959: LD_ADDR_VAR 0 8
9963: PUSH
9964: LD_VAR 0 1
9968: PPUSH
9969: LD_INT 2
9971: PPUSH
9972: EMPTY
9973: PPUSH
9974: CALL 83 0 3
9978: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
9979: LD_VAR 0 8
9983: PUSH
9984: LD_VAR 0 2
9988: PPUSH
9989: LD_VAR 0 3
9993: PPUSH
9994: CALL_OW 428
9998: PUSH
9999: LD_INT 0
10001: EQUAL
10002: AND
10003: IFFALSE 10077
// for i = 1 to plist do
10005: LD_ADDR_VAR 0 6
10009: PUSH
10010: DOUBLE
10011: LD_INT 1
10013: DEC
10014: ST_TO_ADDR
10015: LD_VAR 0 8
10019: PUSH
10020: FOR_TO
10021: IFFALSE 10075
// if NotTask ( plist [ i ] ) then
10023: LD_VAR 0 8
10027: PUSH
10028: LD_VAR 0 6
10032: ARRAY
10033: PPUSH
10034: CALL 24715 0 1
10038: IFFALSE 10073
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
10040: LD_VAR 0 8
10044: PUSH
10045: LD_VAR 0 6
10049: ARRAY
10050: PPUSH
10051: LD_INT 0
10053: PPUSH
10054: LD_VAR 0 2
10058: PPUSH
10059: LD_VAR 0 3
10063: PPUSH
10064: LD_VAR 0 4
10068: PPUSH
10069: CALL_OW 145
// end ;
10073: GO 10020
10075: POP
10076: POP
// end ;
10077: LD_VAR 0 5
10081: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
10082: LD_INT 0
10084: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
10085: LD_VAR 0 1
10089: PPUSH
10090: LD_INT 6
10092: PPUSH
10093: LD_VAR 0 2
10097: PPUSH
10098: LD_VAR 0 3
10102: PPUSH
10103: LD_VAR 0 4
10107: PPUSH
10108: CALL 11586 0 5
// end ;
10112: LD_VAR 0 5
10116: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
10117: LD_INT 0
10119: PPUSH
10120: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
10121: LD_ADDR_VAR 0 4
10125: PUSH
10126: LD_INT 22
10128: PUSH
10129: LD_VAR 0 1
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 2
10140: PUSH
10141: LD_INT 30
10143: PUSH
10144: LD_INT 0
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: PUSH
10151: LD_INT 30
10153: PUSH
10154: LD_INT 1
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: PPUSH
10173: CALL_OW 69
10177: PPUSH
10178: LD_VAR 0 2
10182: PPUSH
10183: CALL_OW 250
10187: PPUSH
10188: LD_VAR 0 2
10192: PPUSH
10193: CALL_OW 251
10197: PPUSH
10198: CALL_OW 73
10202: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
10203: LD_VAR 0 4
10207: PPUSH
10208: LD_VAR 0 2
10212: PPUSH
10213: CALL 11875 0 2
10217: IFFALSE 10276
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
10219: LD_VAR 0 1
10223: PPUSH
10224: LD_INT 30
10226: PUSH
10227: LD_VAR 0 2
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PPUSH
10236: CALL 0 0 2
10240: PUSH
10241: LD_INT 1
10243: ARRAY
10244: PPUSH
10245: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
10249: LD_ADDR_EXP 17
10253: PUSH
10254: LD_EXP 17
10258: PPUSH
10259: LD_VAR 0 1
10263: PPUSH
10264: LD_VAR 0 2
10268: PPUSH
10269: EMPTY
10270: PPUSH
10271: CALL 4139 0 4
10275: ST_TO_ADDR
// end ; end ;
10276: LD_VAR 0 3
10280: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
10281: LD_INT 0
10283: PPUSH
10284: PPUSH
10285: PPUSH
10286: PPUSH
10287: PPUSH
10288: PPUSH
// result := false ;
10289: LD_ADDR_VAR 0 4
10293: PUSH
10294: LD_INT 0
10296: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
10297: LD_VAR 0 1
10301: PPUSH
10302: LD_EXP 8
10306: PPUSH
10307: CALL 5142 0 2
10311: IFFALSE 10524
// for i = 1 to MREG_LabList do
10313: LD_ADDR_VAR 0 5
10317: PUSH
10318: DOUBLE
10319: LD_INT 1
10321: DEC
10322: ST_TO_ADDR
10323: LD_EXP 8
10327: PUSH
10328: FOR_TO
10329: IFFALSE 10522
// begin if MREG_LabList [ i ] [ 1 ] = side then
10331: LD_EXP 8
10335: PUSH
10336: LD_VAR 0 5
10340: ARRAY
10341: PUSH
10342: LD_INT 1
10344: ARRAY
10345: PUSH
10346: LD_VAR 0 1
10350: EQUAL
10351: IFFALSE 10520
// begin lab := MREG_LabList [ i ] [ 2 ] ;
10353: LD_ADDR_VAR 0 7
10357: PUSH
10358: LD_EXP 8
10362: PUSH
10363: LD_VAR 0 5
10367: ARRAY
10368: PUSH
10369: LD_INT 2
10371: ARRAY
10372: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
10373: LD_ADDR_VAR 0 9
10377: PUSH
10378: LD_INT 22
10380: PUSH
10381: LD_VAR 0 1
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 2
10392: PUSH
10393: LD_INT 30
10395: PUSH
10396: LD_INT 0
10398: PUSH
10399: EMPTY
10400: LIST
10401: LIST
10402: PUSH
10403: LD_INT 30
10405: PUSH
10406: LD_INT 1
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: PUSH
10418: EMPTY
10419: LIST
10420: LIST
10421: PUSH
10422: EMPTY
10423: LIST
10424: PPUSH
10425: CALL_OW 69
10429: PPUSH
10430: LD_VAR 0 7
10434: PPUSH
10435: CALL_OW 250
10439: PPUSH
10440: LD_VAR 0 7
10444: PPUSH
10445: CALL_OW 251
10449: PPUSH
10450: CALL_OW 73
10454: ST_TO_ADDR
// if dep then
10455: LD_VAR 0 9
10459: IFFALSE 10518
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
10461: LD_VAR 0 9
10465: PPUSH
10466: LD_VAR 0 2
10470: PPUSH
10471: LD_VAR 0 3
10475: PPUSH
10476: CALL 11991 0 3
10480: IFFALSE 10518
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
10482: LD_VAR 0 7
10486: PPUSH
10487: LD_VAR 0 2
10491: PPUSH
10492: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
10496: LD_VAR 0 7
10500: PPUSH
10501: LD_VAR 0 3
10505: PPUSH
10506: CALL_OW 207
// result := true ;
10510: LD_ADDR_VAR 0 4
10514: PUSH
10515: LD_INT 1
10517: ST_TO_ADDR
// end ; end ; break ;
10518: GO 10522
// end ; end ;
10520: GO 10328
10522: POP
10523: POP
// end ;
10524: LD_VAR 0 4
10528: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
10529: LD_INT 0
10531: PPUSH
10532: PPUSH
10533: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
10534: LD_ADDR_VAR 0 7
10538: PUSH
10539: LD_VAR 0 2
10543: PPUSH
10544: LD_VAR 0 3
10548: PPUSH
10549: LD_VAR 0 4
10553: PPUSH
10554: CALL 10716 0 3
10558: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
10559: LD_ADDR_EXP 15
10563: PUSH
10564: LD_EXP 15
10568: PPUSH
10569: LD_VAR 0 1
10573: PPUSH
10574: LD_INT 2
10576: PPUSH
10577: LD_VAR 0 2
10581: PUSH
10582: LD_VAR 0 3
10586: PUSH
10587: LD_VAR 0 4
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: LIST
10596: PPUSH
10597: CALL 4048 0 4
10601: ST_TO_ADDR
// if ext_list then
10602: LD_VAR 0 5
10606: IFFALSE 10711
// for i = 1 to ext_list do
10608: LD_ADDR_VAR 0 8
10612: PUSH
10613: DOUBLE
10614: LD_INT 1
10616: DEC
10617: ST_TO_ADDR
10618: LD_VAR 0 5
10622: PUSH
10623: FOR_TO
10624: IFFALSE 10709
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
10626: LD_ADDR_EXP 15
10630: PUSH
10631: LD_EXP 15
10635: PPUSH
10636: LD_VAR 0 1
10640: PPUSH
10641: LD_VAR 0 5
10645: PUSH
10646: LD_VAR 0 8
10650: ARRAY
10651: PPUSH
10652: LD_VAR 0 7
10656: PUSH
10657: LD_VAR 0 8
10661: ARRAY
10662: PUSH
10663: LD_INT 1
10665: ARRAY
10666: PUSH
10667: LD_VAR 0 7
10671: PUSH
10672: LD_VAR 0 8
10676: ARRAY
10677: PUSH
10678: LD_INT 2
10680: ARRAY
10681: PUSH
10682: LD_VAR 0 7
10686: PUSH
10687: LD_VAR 0 8
10691: ARRAY
10692: PUSH
10693: LD_INT 3
10695: ARRAY
10696: PUSH
10697: EMPTY
10698: LIST
10699: LIST
10700: LIST
10701: PPUSH
10702: CALL 4048 0 4
10706: ST_TO_ADDR
10707: GO 10623
10709: POP
10710: POP
// end ;
10711: LD_VAR 0 6
10715: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
10716: LD_INT 0
10718: PPUSH
10719: PPUSH
// list := [ ] ;
10720: LD_ADDR_VAR 0 5
10724: PUSH
10725: EMPTY
10726: ST_TO_ADDR
// case d of 0 :
10727: LD_VAR 0 3
10731: PUSH
10732: LD_INT 0
10734: DOUBLE
10735: EQUAL
10736: IFTRUE 10740
10738: GO 10873
10740: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
10741: LD_ADDR_VAR 0 5
10745: PUSH
10746: LD_VAR 0 1
10750: PUSH
10751: LD_INT 4
10753: MINUS
10754: PUSH
10755: LD_VAR 0 2
10759: PUSH
10760: LD_INT 4
10762: MINUS
10763: PUSH
10764: LD_INT 2
10766: PUSH
10767: EMPTY
10768: LIST
10769: LIST
10770: LIST
10771: PUSH
10772: LD_VAR 0 1
10776: PUSH
10777: LD_INT 3
10779: MINUS
10780: PUSH
10781: LD_VAR 0 2
10785: PUSH
10786: LD_INT 1
10788: PUSH
10789: EMPTY
10790: LIST
10791: LIST
10792: LIST
10793: PUSH
10794: LD_VAR 0 1
10798: PUSH
10799: LD_INT 4
10801: PLUS
10802: PUSH
10803: LD_VAR 0 2
10807: PUSH
10808: LD_INT 4
10810: PUSH
10811: EMPTY
10812: LIST
10813: LIST
10814: LIST
10815: PUSH
10816: LD_VAR 0 1
10820: PUSH
10821: LD_INT 3
10823: PLUS
10824: PUSH
10825: LD_VAR 0 2
10829: PUSH
10830: LD_INT 3
10832: PLUS
10833: PUSH
10834: LD_INT 5
10836: PUSH
10837: EMPTY
10838: LIST
10839: LIST
10840: LIST
10841: PUSH
10842: LD_VAR 0 1
10846: PUSH
10847: LD_VAR 0 2
10851: PUSH
10852: LD_INT 4
10854: PLUS
10855: PUSH
10856: LD_INT 0
10858: PUSH
10859: EMPTY
10860: LIST
10861: LIST
10862: LIST
10863: PUSH
10864: EMPTY
10865: LIST
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: ST_TO_ADDR
// end ; 1 :
10871: GO 11571
10873: LD_INT 1
10875: DOUBLE
10876: EQUAL
10877: IFTRUE 10881
10879: GO 11014
10881: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 3 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
10882: LD_ADDR_VAR 0 5
10886: PUSH
10887: LD_VAR 0 1
10891: PUSH
10892: LD_VAR 0 2
10896: PUSH
10897: LD_INT 4
10899: MINUS
10900: PUSH
10901: LD_INT 3
10903: PUSH
10904: EMPTY
10905: LIST
10906: LIST
10907: LIST
10908: PUSH
10909: LD_VAR 0 1
10913: PUSH
10914: LD_INT 3
10916: MINUS
10917: PUSH
10918: LD_VAR 0 2
10922: PUSH
10923: LD_INT 3
10925: MINUS
10926: PUSH
10927: LD_INT 2
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: LIST
10934: PUSH
10935: LD_VAR 0 1
10939: PUSH
10940: LD_INT 3
10942: MINUS
10943: PUSH
10944: LD_VAR 0 2
10948: PUSH
10949: LD_INT 1
10951: PUSH
10952: EMPTY
10953: LIST
10954: LIST
10955: LIST
10956: PUSH
10957: LD_VAR 0 1
10961: PUSH
10962: LD_VAR 0 2
10966: PUSH
10967: LD_INT 3
10969: PLUS
10970: PUSH
10971: LD_INT 0
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: LIST
10978: PUSH
10979: LD_VAR 0 1
10983: PUSH
10984: LD_INT 4
10986: PLUS
10987: PUSH
10988: LD_VAR 0 2
10992: PUSH
10993: LD_INT 4
10995: PLUS
10996: PUSH
10997: LD_INT 5
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: LIST
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: LIST
11009: LIST
11010: LIST
11011: ST_TO_ADDR
// end ; 2 :
11012: GO 11571
11014: LD_INT 2
11016: DOUBLE
11017: EQUAL
11018: IFTRUE 11022
11020: GO 11151
11022: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 3 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
11023: LD_ADDR_VAR 0 5
11027: PUSH
11028: LD_VAR 0 1
11032: PUSH
11033: LD_VAR 0 2
11037: PUSH
11038: LD_INT 3
11040: MINUS
11041: PUSH
11042: LD_INT 3
11044: PUSH
11045: EMPTY
11046: LIST
11047: LIST
11048: LIST
11049: PUSH
11050: LD_VAR 0 1
11054: PUSH
11055: LD_INT 3
11057: PLUS
11058: PUSH
11059: LD_VAR 0 2
11063: PUSH
11064: LD_INT 4
11066: PUSH
11067: EMPTY
11068: LIST
11069: LIST
11070: LIST
11071: PUSH
11072: LD_VAR 0 1
11076: PUSH
11077: LD_VAR 0 2
11081: PUSH
11082: LD_INT 4
11084: PLUS
11085: PUSH
11086: LD_INT 0
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: LIST
11093: PUSH
11094: LD_VAR 0 1
11098: PUSH
11099: LD_INT 3
11101: MINUS
11102: PUSH
11103: LD_VAR 0 2
11107: PUSH
11108: LD_INT 1
11110: PUSH
11111: EMPTY
11112: LIST
11113: LIST
11114: LIST
11115: PUSH
11116: LD_VAR 0 1
11120: PUSH
11121: LD_INT 4
11123: MINUS
11124: PUSH
11125: LD_VAR 0 2
11129: PUSH
11130: LD_INT 4
11132: MINUS
11133: PUSH
11134: LD_INT 2
11136: PUSH
11137: EMPTY
11138: LIST
11139: LIST
11140: LIST
11141: PUSH
11142: EMPTY
11143: LIST
11144: LIST
11145: LIST
11146: LIST
11147: LIST
11148: ST_TO_ADDR
// end ; 3 :
11149: GO 11571
11151: LD_INT 3
11153: DOUBLE
11154: EQUAL
11155: IFTRUE 11159
11157: GO 11292
11159: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
11160: LD_ADDR_VAR 0 5
11164: PUSH
11165: LD_VAR 0 1
11169: PUSH
11170: LD_INT 3
11172: PLUS
11173: PUSH
11174: LD_VAR 0 2
11178: PUSH
11179: LD_INT 4
11181: PUSH
11182: EMPTY
11183: LIST
11184: LIST
11185: LIST
11186: PUSH
11187: LD_VAR 0 1
11191: PUSH
11192: LD_INT 4
11194: PLUS
11195: PUSH
11196: LD_VAR 0 2
11200: PUSH
11201: LD_INT 4
11203: PLUS
11204: PUSH
11205: LD_INT 5
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: LIST
11212: PUSH
11213: LD_VAR 0 1
11217: PUSH
11218: LD_INT 4
11220: MINUS
11221: PUSH
11222: LD_VAR 0 2
11226: PUSH
11227: LD_INT 1
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: LIST
11234: PUSH
11235: LD_VAR 0 1
11239: PUSH
11240: LD_VAR 0 2
11244: PUSH
11245: LD_INT 4
11247: MINUS
11248: PUSH
11249: LD_INT 3
11251: PUSH
11252: EMPTY
11253: LIST
11254: LIST
11255: LIST
11256: PUSH
11257: LD_VAR 0 1
11261: PUSH
11262: LD_INT 3
11264: MINUS
11265: PUSH
11266: LD_VAR 0 2
11270: PUSH
11271: LD_INT 3
11273: MINUS
11274: PUSH
11275: LD_INT 2
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: LIST
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: ST_TO_ADDR
// end ; 4 :
11290: GO 11571
11292: LD_INT 4
11294: DOUBLE
11295: EQUAL
11296: IFTRUE 11300
11298: GO 11433
11300: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
11301: LD_ADDR_VAR 0 5
11305: PUSH
11306: LD_VAR 0 1
11310: PUSH
11311: LD_VAR 0 2
11315: PUSH
11316: LD_INT 4
11318: PLUS
11319: PUSH
11320: LD_INT 0
11322: PUSH
11323: EMPTY
11324: LIST
11325: LIST
11326: LIST
11327: PUSH
11328: LD_VAR 0 1
11332: PUSH
11333: LD_INT 3
11335: PLUS
11336: PUSH
11337: LD_VAR 0 2
11341: PUSH
11342: LD_INT 3
11344: PLUS
11345: PUSH
11346: LD_INT 5
11348: PUSH
11349: EMPTY
11350: LIST
11351: LIST
11352: LIST
11353: PUSH
11354: LD_VAR 0 1
11358: PUSH
11359: LD_INT 3
11361: PLUS
11362: PUSH
11363: LD_VAR 0 2
11367: PUSH
11368: LD_INT 4
11370: PUSH
11371: EMPTY
11372: LIST
11373: LIST
11374: LIST
11375: PUSH
11376: LD_VAR 0 1
11380: PUSH
11381: LD_VAR 0 2
11385: PUSH
11386: LD_INT 3
11388: MINUS
11389: PUSH
11390: LD_INT 3
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: LIST
11397: PUSH
11398: LD_VAR 0 1
11402: PUSH
11403: LD_INT 4
11405: MINUS
11406: PUSH
11407: LD_VAR 0 2
11411: PUSH
11412: LD_INT 4
11414: MINUS
11415: PUSH
11416: LD_INT 2
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: ST_TO_ADDR
// end ; 5 :
11431: GO 11571
11433: LD_INT 5
11435: DOUBLE
11436: EQUAL
11437: IFTRUE 11441
11439: GO 11570
11441: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
11442: LD_ADDR_VAR 0 5
11446: PUSH
11447: LD_VAR 0 1
11451: PUSH
11452: LD_INT 4
11454: MINUS
11455: PUSH
11456: LD_VAR 0 2
11460: PUSH
11461: LD_INT 1
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: LIST
11468: PUSH
11469: LD_VAR 0 1
11473: PUSH
11474: LD_VAR 0 2
11478: PUSH
11479: LD_INT 4
11481: MINUS
11482: PUSH
11483: LD_INT 3
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: LIST
11490: PUSH
11491: LD_VAR 0 1
11495: PUSH
11496: LD_INT 4
11498: PLUS
11499: PUSH
11500: LD_VAR 0 2
11504: PUSH
11505: LD_INT 4
11507: PLUS
11508: PUSH
11509: LD_INT 5
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: LIST
11516: PUSH
11517: LD_VAR 0 1
11521: PUSH
11522: LD_INT 3
11524: PLUS
11525: PUSH
11526: LD_VAR 0 2
11530: PUSH
11531: LD_INT 4
11533: PUSH
11534: EMPTY
11535: LIST
11536: LIST
11537: LIST
11538: PUSH
11539: LD_VAR 0 1
11543: PUSH
11544: LD_VAR 0 2
11548: PUSH
11549: LD_INT 3
11551: PLUS
11552: PUSH
11553: LD_INT 0
11555: PUSH
11556: EMPTY
11557: LIST
11558: LIST
11559: LIST
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: LIST
11565: LIST
11566: LIST
11567: ST_TO_ADDR
// end ; end ;
11568: GO 11571
11570: POP
// result := list ;
11571: LD_ADDR_VAR 0 4
11575: PUSH
11576: LD_VAR 0 5
11580: ST_TO_ADDR
// end ;
11581: LD_VAR 0 4
11585: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
11586: LD_INT 0
11588: PPUSH
11589: PPUSH
11590: PPUSH
11591: PPUSH
11592: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11593: LD_ADDR_VAR 0 10
11597: PUSH
11598: LD_VAR 0 1
11602: PPUSH
11603: LD_INT 2
11605: PPUSH
11606: EMPTY
11607: PPUSH
11608: CALL 83 0 3
11612: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
11613: LD_ADDR_VAR 0 9
11617: PUSH
11618: LD_INT 22
11620: PUSH
11621: LD_VAR 0 1
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: PUSH
11630: LD_INT 2
11632: PUSH
11633: LD_INT 30
11635: PUSH
11636: LD_INT 0
11638: PUSH
11639: EMPTY
11640: LIST
11641: LIST
11642: PUSH
11643: LD_INT 30
11645: PUSH
11646: LD_INT 1
11648: PUSH
11649: EMPTY
11650: LIST
11651: LIST
11652: PUSH
11653: EMPTY
11654: LIST
11655: LIST
11656: LIST
11657: PUSH
11658: EMPTY
11659: LIST
11660: LIST
11661: PUSH
11662: EMPTY
11663: LIST
11664: PPUSH
11665: CALL_OW 69
11669: PPUSH
11670: LD_VAR 0 3
11674: PPUSH
11675: LD_VAR 0 4
11679: PPUSH
11680: CALL_OW 73
11684: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
11685: LD_ADDR_VAR 0 8
11689: PUSH
11690: LD_VAR 0 9
11694: PPUSH
11695: LD_VAR 0 2
11699: PPUSH
11700: CALL 11875 0 2
11704: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
11705: LD_VAR 0 10
11709: PUSH
11710: LD_VAR 0 8
11714: AND
11715: PUSH
11716: LD_VAR 0 9
11720: PPUSH
11721: LD_VAR 0 3
11725: PPUSH
11726: LD_VAR 0 4
11730: PPUSH
11731: CALL_OW 297
11735: PUSH
11736: LD_INT 26
11738: LESSEQUAL
11739: AND
11740: PUSH
11741: LD_VAR 0 3
11745: PPUSH
11746: LD_VAR 0 4
11750: PPUSH
11751: CALL_OW 428
11755: PUSH
11756: LD_INT 0
11758: EQUAL
11759: AND
11760: IFFALSE 11870
// for i = 1 to plist do
11762: LD_ADDR_VAR 0 7
11766: PUSH
11767: DOUBLE
11768: LD_INT 1
11770: DEC
11771: ST_TO_ADDR
11772: LD_VAR 0 10
11776: PUSH
11777: FOR_TO
11778: IFFALSE 11868
// if IsInUnit ( plist [ i ] ) then
11780: LD_VAR 0 10
11784: PUSH
11785: LD_VAR 0 7
11789: ARRAY
11790: PPUSH
11791: CALL_OW 310
11795: IFFALSE 11814
// ComExitBuilding ( plist [ i ] ) else
11797: LD_VAR 0 10
11801: PUSH
11802: LD_VAR 0 7
11806: ARRAY
11807: PPUSH
11808: CALL_OW 122
11812: GO 11866
// if NotTask ( plist [ i ] ) then
11814: LD_VAR 0 10
11818: PUSH
11819: LD_VAR 0 7
11823: ARRAY
11824: PPUSH
11825: CALL 24715 0 1
11829: IFFALSE 11866
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
11831: LD_VAR 0 10
11835: PUSH
11836: LD_VAR 0 7
11840: ARRAY
11841: PPUSH
11842: LD_VAR 0 2
11846: PPUSH
11847: LD_VAR 0 3
11851: PPUSH
11852: LD_VAR 0 4
11856: PPUSH
11857: LD_VAR 0 5
11861: PPUSH
11862: CALL_OW 145
// end ;
11866: GO 11777
11868: POP
11869: POP
// end ;
11870: LD_VAR 0 6
11874: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
11875: LD_INT 0
11877: PPUSH
11878: PPUSH
11879: PPUSH
// pom := GetBase ( bdepot ) ;
11880: LD_ADDR_VAR 0 4
11884: PUSH
11885: LD_VAR 0 1
11889: PPUSH
11890: CALL_OW 274
11894: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
11895: LD_ADDR_VAR 0 5
11899: PUSH
11900: LD_VAR 0 2
11904: PPUSH
11905: LD_VAR 0 1
11909: PPUSH
11910: CALL_OW 248
11914: PPUSH
11915: CALL_OW 450
11919: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
11920: LD_VAR 0 4
11924: PPUSH
11925: LD_INT 1
11927: PPUSH
11928: CALL_OW 275
11932: PUSH
11933: LD_VAR 0 5
11937: PUSH
11938: LD_INT 1
11940: ARRAY
11941: GREATEREQUAL
11942: PUSH
11943: LD_VAR 0 4
11947: PPUSH
11948: LD_INT 3
11950: PPUSH
11951: CALL_OW 275
11955: PUSH
11956: LD_VAR 0 5
11960: PUSH
11961: LD_INT 3
11963: ARRAY
11964: GREATEREQUAL
11965: AND
11966: IFFALSE 11978
// result := true else
11968: LD_ADDR_VAR 0 3
11972: PUSH
11973: LD_INT 1
11975: ST_TO_ADDR
11976: GO 11986
// result := false ;
11978: LD_ADDR_VAR 0 3
11982: PUSH
11983: LD_INT 0
11985: ST_TO_ADDR
// end ;
11986: LD_VAR 0 3
11990: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
11991: LD_INT 0
11993: PPUSH
11994: PPUSH
11995: PPUSH
11996: PPUSH
11997: PPUSH
// pom := GetBase ( bdepot ) ;
11998: LD_ADDR_VAR 0 5
12002: PUSH
12003: LD_VAR 0 1
12007: PPUSH
12008: CALL_OW 274
12012: ST_TO_ADDR
// cost := [ ] ;
12013: LD_ADDR_VAR 0 8
12017: PUSH
12018: EMPTY
12019: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
12020: LD_ADDR_VAR 0 6
12024: PUSH
12025: LD_VAR 0 2
12029: PPUSH
12030: LD_VAR 0 1
12034: PPUSH
12035: CALL_OW 248
12039: PPUSH
12040: CALL_OW 450
12044: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
12045: LD_ADDR_VAR 0 7
12049: PUSH
12050: LD_VAR 0 3
12054: PPUSH
12055: LD_VAR 0 1
12059: PPUSH
12060: CALL_OW 248
12064: PPUSH
12065: CALL_OW 450
12069: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
12070: LD_ADDR_VAR 0 8
12074: PUSH
12075: LD_VAR 0 8
12079: PPUSH
12080: LD_INT 1
12082: PPUSH
12083: LD_VAR 0 6
12087: PUSH
12088: LD_INT 1
12090: ARRAY
12091: PUSH
12092: LD_VAR 0 7
12096: PUSH
12097: LD_INT 1
12099: ARRAY
12100: PLUS
12101: PPUSH
12102: CALL_OW 1
12106: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
12107: LD_ADDR_VAR 0 8
12111: PUSH
12112: LD_VAR 0 8
12116: PPUSH
12117: LD_INT 2
12119: PPUSH
12120: LD_VAR 0 6
12124: PUSH
12125: LD_INT 2
12127: ARRAY
12128: PUSH
12129: LD_VAR 0 7
12133: PUSH
12134: LD_INT 2
12136: ARRAY
12137: PLUS
12138: PPUSH
12139: CALL_OW 1
12143: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
12144: LD_ADDR_VAR 0 8
12148: PUSH
12149: LD_VAR 0 8
12153: PPUSH
12154: LD_INT 3
12156: PPUSH
12157: LD_VAR 0 6
12161: PUSH
12162: LD_INT 3
12164: ARRAY
12165: PUSH
12166: LD_VAR 0 7
12170: PUSH
12171: LD_INT 3
12173: ARRAY
12174: PLUS
12175: PPUSH
12176: CALL_OW 1
12180: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
12181: LD_VAR 0 5
12185: PPUSH
12186: LD_INT 1
12188: PPUSH
12189: CALL_OW 275
12193: PUSH
12194: LD_VAR 0 8
12198: PUSH
12199: LD_INT 1
12201: ARRAY
12202: GREATEREQUAL
12203: PUSH
12204: LD_VAR 0 5
12208: PPUSH
12209: LD_INT 3
12211: PPUSH
12212: CALL_OW 275
12216: PUSH
12217: LD_VAR 0 8
12221: PUSH
12222: LD_INT 3
12224: ARRAY
12225: GREATEREQUAL
12226: AND
12227: IFFALSE 12239
// result := true else
12229: LD_ADDR_VAR 0 4
12233: PUSH
12234: LD_INT 1
12236: ST_TO_ADDR
12237: GO 12247
// result := false ;
12239: LD_ADDR_VAR 0 4
12243: PUSH
12244: LD_INT 0
12246: ST_TO_ADDR
// end ;
12247: LD_VAR 0 4
12251: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
12252: LD_INT 0
12254: PPUSH
12255: PPUSH
12256: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
12257: LD_ADDR_VAR 0 5
12261: PUSH
12262: LD_VAR 0 1
12266: PPUSH
12267: LD_INT 2
12269: PPUSH
12270: EMPTY
12271: PPUSH
12272: CALL 83 0 3
12276: ST_TO_ADDR
// if unit and plist then
12277: LD_VAR 0 2
12281: PUSH
12282: LD_VAR 0 5
12286: AND
12287: IFFALSE 12348
// for i = 1 to plist do
12289: LD_ADDR_VAR 0 4
12293: PUSH
12294: DOUBLE
12295: LD_INT 1
12297: DEC
12298: ST_TO_ADDR
12299: LD_VAR 0 5
12303: PUSH
12304: FOR_TO
12305: IFFALSE 12346
// if NotTask ( plist [ i ] ) then
12307: LD_VAR 0 5
12311: PUSH
12312: LD_VAR 0 4
12316: ARRAY
12317: PPUSH
12318: CALL 24715 0 1
12322: IFFALSE 12344
// ComDismantle ( plist [ i ] , unit ) ;
12324: LD_VAR 0 5
12328: PUSH
12329: LD_VAR 0 4
12333: ARRAY
12334: PPUSH
12335: LD_VAR 0 2
12339: PPUSH
12340: CALL_OW 167
12344: GO 12304
12346: POP
12347: POP
// result := true ;
12348: LD_ADDR_VAR 0 3
12352: PUSH
12353: LD_INT 1
12355: ST_TO_ADDR
// end ;
12356: LD_VAR 0 3
12360: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
12361: LD_INT 0
12363: PPUSH
12364: PPUSH
12365: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
12366: LD_ADDR_VAR 0 5
12370: PUSH
12371: LD_VAR 0 1
12375: PPUSH
12376: LD_INT 2
12378: PPUSH
12379: EMPTY
12380: PPUSH
12381: CALL 83 0 3
12385: ST_TO_ADDR
// if unit and plist then
12386: LD_VAR 0 2
12390: PUSH
12391: LD_VAR 0 5
12395: AND
12396: IFFALSE 12457
// for i = 1 to plist do
12398: LD_ADDR_VAR 0 4
12402: PUSH
12403: DOUBLE
12404: LD_INT 1
12406: DEC
12407: ST_TO_ADDR
12408: LD_VAR 0 5
12412: PUSH
12413: FOR_TO
12414: IFFALSE 12455
// if NotTask ( plist [ i ] ) then
12416: LD_VAR 0 5
12420: PUSH
12421: LD_VAR 0 4
12425: ARRAY
12426: PPUSH
12427: CALL 24715 0 1
12431: IFFALSE 12453
// ComComplete ( plist [ i ] , unit ) ;
12433: LD_VAR 0 5
12437: PUSH
12438: LD_VAR 0 4
12442: ARRAY
12443: PPUSH
12444: LD_VAR 0 2
12448: PPUSH
12449: CALL 24251 0 2
12453: GO 12413
12455: POP
12456: POP
// result := true ;
12457: LD_ADDR_VAR 0 3
12461: PUSH
12462: LD_INT 1
12464: ST_TO_ADDR
// end ;
12465: LD_VAR 0 3
12469: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
12470: LD_INT 0
12472: PPUSH
12473: PPUSH
12474: PPUSH
12475: PPUSH
12476: PPUSH
12477: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12478: LD_ADDR_VAR 0 5
12482: PUSH
12483: LD_INT 22
12485: PUSH
12486: LD_VAR 0 1
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: PUSH
12495: LD_INT 21
12497: PUSH
12498: LD_INT 3
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: PUSH
12505: LD_INT 3
12507: PUSH
12508: LD_INT 57
12510: PUSH
12511: EMPTY
12512: LIST
12513: PUSH
12514: EMPTY
12515: LIST
12516: LIST
12517: PUSH
12518: LD_INT 3
12520: PUSH
12521: LD_INT 24
12523: PUSH
12524: LD_INT 1000
12526: PUSH
12527: EMPTY
12528: LIST
12529: LIST
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: LIST
12539: LIST
12540: PPUSH
12541: CALL_OW 69
12545: ST_TO_ADDR
// r := [ ] ;
12546: LD_ADDR_VAR 0 6
12550: PUSH
12551: EMPTY
12552: ST_TO_ADDR
// if not tmp then
12553: LD_VAR 0 5
12557: NOT
12558: IFFALSE 12564
// exit else
12560: GO 12752
12562: GO 12732
// begin r := [ tmp [ 1 ] ] ;
12564: LD_ADDR_VAR 0 6
12568: PUSH
12569: LD_VAR 0 5
12573: PUSH
12574: LD_INT 1
12576: ARRAY
12577: PUSH
12578: EMPTY
12579: LIST
12580: ST_TO_ADDR
// for i = 2 to tmp do
12581: LD_ADDR_VAR 0 3
12585: PUSH
12586: DOUBLE
12587: LD_INT 2
12589: DEC
12590: ST_TO_ADDR
12591: LD_VAR 0 5
12595: PUSH
12596: FOR_TO
12597: IFFALSE 12730
// begin m := false ;
12599: LD_ADDR_VAR 0 7
12603: PUSH
12604: LD_INT 0
12606: ST_TO_ADDR
// for j = 1 to r do
12607: LD_ADDR_VAR 0 4
12611: PUSH
12612: DOUBLE
12613: LD_INT 1
12615: DEC
12616: ST_TO_ADDR
12617: LD_VAR 0 6
12621: PUSH
12622: FOR_TO
12623: IFFALSE 12697
// if GetLives ( tmp [ i ] ) < r [ j ] then
12625: LD_VAR 0 5
12629: PUSH
12630: LD_VAR 0 3
12634: ARRAY
12635: PPUSH
12636: CALL_OW 256
12640: PUSH
12641: LD_VAR 0 6
12645: PUSH
12646: LD_VAR 0 4
12650: ARRAY
12651: LESS
12652: IFFALSE 12695
// begin r := Insert ( r , j , tmp [ i ] ) ;
12654: LD_ADDR_VAR 0 6
12658: PUSH
12659: LD_VAR 0 6
12663: PPUSH
12664: LD_VAR 0 4
12668: PPUSH
12669: LD_VAR 0 5
12673: PUSH
12674: LD_VAR 0 3
12678: ARRAY
12679: PPUSH
12680: CALL_OW 2
12684: ST_TO_ADDR
// m := true ;
12685: LD_ADDR_VAR 0 7
12689: PUSH
12690: LD_INT 1
12692: ST_TO_ADDR
// break ;
12693: GO 12697
// end ;
12695: GO 12622
12697: POP
12698: POP
// if not m then
12699: LD_VAR 0 7
12703: NOT
12704: IFFALSE 12728
// r := r ^ tmp [ i ] ;
12706: LD_ADDR_VAR 0 6
12710: PUSH
12711: LD_VAR 0 6
12715: PUSH
12716: LD_VAR 0 5
12720: PUSH
12721: LD_VAR 0 3
12725: ARRAY
12726: ADD
12727: ST_TO_ADDR
// end ;
12728: GO 12596
12730: POP
12731: POP
// end ; if r then
12732: LD_VAR 0 6
12736: IFFALSE 12750
// result := r else
12738: LD_ADDR_VAR 0 2
12742: PUSH
12743: LD_VAR 0 6
12747: ST_TO_ADDR
12748: GO 12752
// exit ;
12750: GO 12752
// end ;
12752: LD_VAR 0 2
12756: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
12757: LD_INT 0
12759: PPUSH
12760: PPUSH
12761: PPUSH
12762: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
12763: LD_ADDR_VAR 0 5
12767: PUSH
12768: LD_INT 22
12770: PUSH
12771: LD_VAR 0 1
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: LD_INT 2
12782: PUSH
12783: LD_INT 25
12785: PUSH
12786: LD_INT 2
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: PUSH
12793: LD_INT 25
12795: PUSH
12796: LD_INT 16
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 34
12805: PUSH
12806: LD_INT 13
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: LD_INT 34
12815: PUSH
12816: LD_INT 52
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PUSH
12830: LD_INT 24
12832: PUSH
12833: LD_INT 650
12835: PUSH
12836: EMPTY
12837: LIST
12838: LIST
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: LIST
12844: PPUSH
12845: CALL_OW 69
12849: ST_TO_ADDR
// p := 1 ;
12850: LD_ADDR_VAR 0 4
12854: PUSH
12855: LD_INT 1
12857: ST_TO_ADDR
// for i = 1 to repairs do
12858: LD_ADDR_VAR 0 3
12862: PUSH
12863: DOUBLE
12864: LD_INT 1
12866: DEC
12867: ST_TO_ADDR
12868: LD_VAR 0 5
12872: PUSH
12873: FOR_TO
12874: IFFALSE 13010
// begin if IsInUnit ( repairs [ i ] ) then
12876: LD_VAR 0 5
12880: PUSH
12881: LD_VAR 0 3
12885: ARRAY
12886: PPUSH
12887: CALL_OW 310
12891: IFFALSE 12910
// ComExitBuilding ( repairs [ i ] ) else
12893: LD_VAR 0 5
12897: PUSH
12898: LD_VAR 0 3
12902: ARRAY
12903: PPUSH
12904: CALL_OW 122
12908: GO 13008
// if not HasTask ( repairs [ i ] ) then
12910: LD_VAR 0 5
12914: PUSH
12915: LD_VAR 0 3
12919: ARRAY
12920: PPUSH
12921: CALL_OW 314
12925: NOT
12926: IFFALSE 13008
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
12928: LD_VAR 0 5
12932: PUSH
12933: LD_VAR 0 3
12937: ARRAY
12938: PPUSH
12939: LD_EXP 16
12943: PUSH
12944: LD_VAR 0 1
12948: ARRAY
12949: PUSH
12950: LD_VAR 0 4
12954: ARRAY
12955: PPUSH
12956: CALL_OW 130
// if i mod 3 = 0 then
12960: LD_VAR 0 3
12964: PUSH
12965: LD_INT 3
12967: MOD
12968: PUSH
12969: LD_INT 0
12971: EQUAL
12972: IFFALSE 12988
// p := p + 1 ;
12974: LD_ADDR_VAR 0 4
12978: PUSH
12979: LD_VAR 0 4
12983: PUSH
12984: LD_INT 1
12986: PLUS
12987: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
12988: LD_EXP 16
12992: PUSH
12993: LD_VAR 0 1
12997: ARRAY
12998: PUSH
12999: LD_VAR 0 4
13003: LESS
13004: IFFALSE 13008
// break ;
13006: GO 13010
// end ; end ;
13008: GO 12873
13010: POP
13011: POP
// end ; end_of_file
13012: LD_VAR 0 2
13016: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
13017: LD_INT 0
13019: PPUSH
13020: PPUSH
13021: PPUSH
13022: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
13023: LD_ADDR_VAR 0 5
13027: PUSH
13028: LD_INT 35
13030: PUSH
13031: LD_INT 45
13033: PUSH
13034: LD_INT 46
13036: PUSH
13037: LD_INT 47
13039: PUSH
13040: LD_INT 1
13042: PUSH
13043: LD_INT 2
13045: PUSH
13046: LD_INT 48
13048: PUSH
13049: LD_INT 49
13051: PUSH
13052: LD_INT 50
13054: PUSH
13055: LD_INT 20
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: LIST
13062: LIST
13063: LIST
13064: LIST
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: ST_TO_ADDR
// if MCF_Lab ( side ) then
13070: LD_VAR 0 1
13074: PPUSH
13075: CALL 39 0 1
13079: IFFALSE 13318
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
13081: LD_VAR 0 1
13085: PPUSH
13086: CALL 39 0 1
13090: PUSH
13091: LD_INT 1
13093: ARRAY
13094: PPUSH
13095: CALL_OW 461
13099: PUSH
13100: LD_INT 2
13102: EQUAL
13103: IFFALSE 13242
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
13105: LD_VAR 0 1
13109: PPUSH
13110: CALL 39 0 1
13114: PUSH
13115: LD_INT 1
13117: ARRAY
13118: PPUSH
13119: LD_VAR 0 2
13123: PPUSH
13124: CALL 13414 0 2
13128: IFFALSE 13155
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
13130: LD_VAR 0 1
13134: PPUSH
13135: CALL 39 0 1
13139: PUSH
13140: LD_INT 1
13142: ARRAY
13143: PPUSH
13144: LD_VAR 0 2
13148: PPUSH
13149: CALL_OW 124
13153: GO 13242
// if MCF_Lab ( side ) > 1 then
13155: LD_VAR 0 1
13159: PPUSH
13160: CALL 39 0 1
13164: PUSH
13165: LD_INT 1
13167: GREATER
13168: IFFALSE 13242
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
13170: LD_VAR 0 1
13174: PPUSH
13175: CALL 39 0 1
13179: PUSH
13180: LD_INT 2
13182: ARRAY
13183: PPUSH
13184: CALL_OW 461
13188: PUSH
13189: LD_INT 2
13191: EQUAL
13192: IFFALSE 13242
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
13194: LD_VAR 0 1
13198: PPUSH
13199: CALL 39 0 1
13203: PUSH
13204: LD_INT 2
13206: ARRAY
13207: PPUSH
13208: LD_VAR 0 2
13212: PPUSH
13213: CALL 13414 0 2
13217: IFFALSE 13242
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
13219: LD_VAR 0 1
13223: PPUSH
13224: CALL 39 0 1
13228: PUSH
13229: LD_INT 2
13231: ARRAY
13232: PPUSH
13233: LD_VAR 0 2
13237: PPUSH
13238: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
13242: LD_VAR 0 2
13246: PUSH
13247: LD_INT 2
13249: PUSH
13250: LD_INT 11
13252: PUSH
13253: LD_INT 4
13255: PUSH
13256: LD_INT 3
13258: PUSH
13259: EMPTY
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: IN
13265: IFFALSE 13318
// begin for lab in MCF_Lab ( side ) do
13267: LD_ADDR_VAR 0 6
13271: PUSH
13272: LD_VAR 0 1
13276: PPUSH
13277: CALL 39 0 1
13281: PUSH
13282: FOR_IN
13283: IFFALSE 13316
// if BuildingStatus ( lab ) = bs_need_ape then
13285: LD_VAR 0 6
13289: PPUSH
13290: CALL_OW 461
13294: PUSH
13295: LD_INT 10
13297: EQUAL
13298: IFFALSE 13314
// MCL_ResTame ( side , lab ) ;
13300: LD_VAR 0 1
13304: PPUSH
13305: LD_VAR 0 6
13309: PPUSH
13310: CALL 13539 0 2
13314: GO 13282
13316: POP
13317: POP
// end ; end ; end ;
13318: LD_VAR 0 3
13322: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
13323: LD_INT 0
13325: PPUSH
13326: PPUSH
// tmp := [ ] ;
13327: LD_ADDR_VAR 0 3
13331: PUSH
13332: EMPTY
13333: ST_TO_ADDR
// if not lab then
13334: LD_VAR 0 1
13338: NOT
13339: IFFALSE 13351
// result := false else
13341: LD_ADDR_VAR 0 2
13345: PUSH
13346: LD_INT 0
13348: ST_TO_ADDR
13349: GO 13409
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
13351: LD_ADDR_VAR 0 3
13355: PUSH
13356: LD_VAR 0 3
13360: PUSH
13361: LD_VAR 0 1
13365: PPUSH
13366: LD_INT 1
13368: PPUSH
13369: CALL_OW 268
13373: ADD
13374: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
13375: LD_ADDR_VAR 0 3
13379: PUSH
13380: LD_VAR 0 3
13384: PUSH
13385: LD_VAR 0 1
13389: PPUSH
13390: LD_INT 2
13392: PPUSH
13393: CALL_OW 268
13397: ADD
13398: ST_TO_ADDR
// result := tmp ;
13399: LD_ADDR_VAR 0 2
13403: PUSH
13404: LD_VAR 0 3
13408: ST_TO_ADDR
// end ; end ;
13409: LD_VAR 0 2
13413: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
13414: LD_INT 0
13416: PPUSH
13417: PPUSH
13418: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
13419: LD_ADDR_VAR 0 5
13423: PUSH
13424: LD_INT 35
13426: PUSH
13427: LD_INT 45
13429: PUSH
13430: LD_INT 46
13432: PUSH
13433: LD_INT 47
13435: PUSH
13436: LD_INT 1
13438: PUSH
13439: LD_INT 2
13441: PUSH
13442: LD_INT 48
13444: PUSH
13445: LD_INT 49
13447: PUSH
13448: LD_INT 50
13450: PUSH
13451: LD_INT 20
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: LIST
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: LIST
13463: LIST
13464: LIST
13465: ST_TO_ADDR
// if lab then
13466: LD_VAR 0 1
13470: IFFALSE 13526
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
13472: LD_VAR 0 2
13476: PUSH
13477: LD_VAR 0 5
13481: IN
13482: PUSH
13483: LD_VAR 0 2
13487: PPUSH
13488: CALL_OW 481
13492: PUSH
13493: LD_VAR 0 1
13497: PPUSH
13498: CALL 13323 0 1
13502: IN
13503: OR
13504: IFFALSE 13516
// result := true else
13506: LD_ADDR_VAR 0 3
13510: PUSH
13511: LD_INT 1
13513: ST_TO_ADDR
13514: GO 13524
// result := false ;
13516: LD_ADDR_VAR 0 3
13520: PUSH
13521: LD_INT 0
13523: ST_TO_ADDR
// end else
13524: GO 13534
// result := false ;
13526: LD_ADDR_VAR 0 3
13530: PUSH
13531: LD_INT 0
13533: ST_TO_ADDR
// end ;
13534: LD_VAR 0 3
13538: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
13539: LD_INT 0
13541: PPUSH
13542: PPUSH
13543: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
13544: LD_ADDR_VAR 0 4
13548: PUSH
13549: LD_VAR 0 1
13553: PPUSH
13554: LD_INT 171
13556: PPUSH
13557: EMPTY
13558: PPUSH
13559: CALL 627 0 3
13563: ST_TO_ADDR
// if not ape then
13564: LD_VAR 0 4
13568: NOT
13569: IFFALSE 13601
// if MCF_Ape ( side ) then
13571: LD_VAR 0 1
13575: PPUSH
13576: CALL 337 0 1
13580: IFFALSE 13601
// ape := MCF_Ape ( side ) [ 1 ] ;
13582: LD_ADDR_VAR 0 4
13586: PUSH
13587: LD_VAR 0 1
13591: PPUSH
13592: CALL 337 0 1
13596: PUSH
13597: LD_INT 1
13599: ARRAY
13600: ST_TO_ADDR
// if ape then
13601: LD_VAR 0 4
13605: IFFALSE 13656
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
13607: LD_VAR 0 4
13611: PUSH
13612: LD_INT 1
13614: ARRAY
13615: PPUSH
13616: CALL_OW 310
13620: PUSH
13621: LD_VAR 0 4
13625: PUSH
13626: LD_INT 1
13628: ARRAY
13629: PPUSH
13630: CALL_OW 310
13634: PUSH
13635: LD_VAR 0 2
13639: NONEQUAL
13640: AND
13641: IFFALSE 13656
// ComExitBuilding ( ape [ 1 ] ) ;
13643: LD_VAR 0 4
13647: PUSH
13648: LD_INT 1
13650: ARRAY
13651: PPUSH
13652: CALL_OW 122
// if not lab then
13656: LD_VAR 0 2
13660: NOT
13661: IFFALSE 13667
// exit else
13663: GO 13815
13665: GO 13775
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_INT 16
13674: PPUSH
13675: LD_INT 25
13677: PUSH
13678: LD_INT 4
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: PPUSH
13685: CALL 627 0 3
13689: PUSH
13690: LD_INT 0
13692: EQUAL
13693: PUSH
13694: LD_VAR 0 2
13698: PPUSH
13699: CALL_OW 313
13703: PUSH
13704: LD_INT 6
13706: EQUAL
13707: AND
13708: IFFALSE 13775
// begin tmp := UnitsInside ( lab ) ;
13710: LD_ADDR_VAR 0 5
13714: PUSH
13715: LD_VAR 0 2
13719: PPUSH
13720: CALL_OW 313
13724: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
13725: LD_VAR 0 5
13729: PUSH
13730: LD_VAR 0 5
13734: ARRAY
13735: PPUSH
13736: LD_INT 16
13738: PPUSH
13739: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
13743: LD_VAR 0 5
13747: PUSH
13748: LD_VAR 0 5
13752: ARRAY
13753: PPUSH
13754: CALL_OW 310
13758: IFFALSE 13775
// ComExitBuilding ( tmp [ tmp ] ) ;
13760: LD_VAR 0 5
13764: PUSH
13765: LD_VAR 0 5
13769: ARRAY
13770: PPUSH
13771: CALL_OW 122
// end ; if ape then
13775: LD_VAR 0 4
13779: IFFALSE 13815
// if not IsInUnit ( ape [ 1 ] ) then
13781: LD_VAR 0 4
13785: PUSH
13786: LD_INT 1
13788: ARRAY
13789: PPUSH
13790: CALL_OW 310
13794: NOT
13795: IFFALSE 13815
// ComEnterUnit ( ape [ 1 ] , lab ) ;
13797: LD_VAR 0 4
13801: PUSH
13802: LD_INT 1
13804: ARRAY
13805: PPUSH
13806: LD_VAR 0 2
13810: PPUSH
13811: CALL_OW 120
// end ;
13815: LD_VAR 0 3
13819: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
13820: LD_INT 0
13822: PPUSH
13823: PPUSH
13824: PPUSH
// result := false ;
13825: LD_ADDR_VAR 0 2
13829: PUSH
13830: LD_INT 0
13832: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
13833: LD_ADDR_VAR 0 3
13837: PUSH
13838: LD_VAR 0 1
13842: PPUSH
13843: CALL 13982 0 1
13847: ST_TO_ADDR
// if techs then
13848: LD_VAR 0 3
13852: IFFALSE 13882
// if techs [ 2 ] then
13854: LD_VAR 0 3
13858: PUSH
13859: LD_INT 2
13861: ARRAY
13862: IFFALSE 13874
// result := true else
13864: LD_ADDR_VAR 0 2
13868: PUSH
13869: LD_INT 1
13871: ST_TO_ADDR
13872: GO 13882
// result := false ;
13874: LD_ADDR_VAR 0 2
13878: PUSH
13879: LD_INT 0
13881: ST_TO_ADDR
// end ;
13882: LD_VAR 0 2
13886: RET
// export function MCL_Start ( side ) ; var i ; begin
13887: LD_INT 0
13889: PPUSH
13890: PPUSH
// if MREG_ForSide ( side , MREG_ToRes ) then
13891: LD_VAR 0 1
13895: PPUSH
13896: LD_EXP 19
13900: PPUSH
13901: CALL 5142 0 2
13905: IFFALSE 13977
// for i = 1 to MREG_ToRes do
13907: LD_ADDR_VAR 0 3
13911: PUSH
13912: DOUBLE
13913: LD_INT 1
13915: DEC
13916: ST_TO_ADDR
13917: LD_EXP 19
13921: PUSH
13922: FOR_TO
13923: IFFALSE 13975
// if MREG_ToRes [ i ] [ 1 ] = side then
13925: LD_EXP 19
13929: PUSH
13930: LD_VAR 0 3
13934: ARRAY
13935: PUSH
13936: LD_INT 1
13938: ARRAY
13939: PUSH
13940: LD_VAR 0 1
13944: EQUAL
13945: IFFALSE 13973
// begin MCL_Research ( side , MREG_ToRes [ i ] [ 2 ] ) ;
13947: LD_VAR 0 1
13951: PPUSH
13952: LD_EXP 19
13956: PUSH
13957: LD_VAR 0 3
13961: ARRAY
13962: PUSH
13963: LD_INT 2
13965: ARRAY
13966: PPUSH
13967: CALL 13017 0 2
// break ;
13971: GO 13975
// end ;
13973: GO 13922
13975: POP
13976: POP
// end ;
13977: LD_VAR 0 2
13981: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
13982: LD_INT 0
13984: PPUSH
13985: PPUSH
13986: PPUSH
// if MREG_ToRes then
13987: LD_EXP 19
13991: IFFALSE 14065
// for i = 1 to MREG_ToRes do
13993: LD_ADDR_VAR 0 3
13997: PUSH
13998: DOUBLE
13999: LD_INT 1
14001: DEC
14002: ST_TO_ADDR
14003: LD_EXP 19
14007: PUSH
14008: FOR_TO
14009: IFFALSE 14063
// if MREG_ToRes [ i ] [ 1 ] = side then
14011: LD_EXP 19
14015: PUSH
14016: LD_VAR 0 3
14020: ARRAY
14021: PUSH
14022: LD_INT 1
14024: ARRAY
14025: PUSH
14026: LD_VAR 0 1
14030: EQUAL
14031: IFFALSE 14061
// begin techs := techs ^ MREG_ToRes [ i ] [ 2 ] ;
14033: LD_ADDR_VAR 0 4
14037: PUSH
14038: LD_VAR 0 4
14042: PUSH
14043: LD_EXP 19
14047: PUSH
14048: LD_VAR 0 3
14052: ARRAY
14053: PUSH
14054: LD_INT 2
14056: ARRAY
14057: ADD
14058: ST_TO_ADDR
// break ;
14059: GO 14063
// end ;
14061: GO 14008
14063: POP
14064: POP
// result := techs ;
14065: LD_ADDR_VAR 0 2
14069: PUSH
14070: LD_VAR 0 4
14074: ST_TO_ADDR
// end ;
14075: LD_VAR 0 2
14079: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
14080: LD_INT 0
14082: PPUSH
14083: PPUSH
// for i = 1 to tech_list do
14084: LD_ADDR_VAR 0 4
14088: PUSH
14089: DOUBLE
14090: LD_INT 1
14092: DEC
14093: ST_TO_ADDR
14094: LD_VAR 0 2
14098: PUSH
14099: FOR_TO
14100: IFFALSE 14148
// if not tech_list = 20 then
14102: LD_VAR 0 2
14106: PUSH
14107: LD_INT 20
14109: EQUAL
14110: NOT
14111: IFFALSE 14146
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
14113: LD_ADDR_EXP 19
14117: PUSH
14118: LD_EXP 19
14122: PPUSH
14123: LD_VAR 0 1
14127: PPUSH
14128: LD_VAR 0 2
14132: PUSH
14133: LD_VAR 0 4
14137: ARRAY
14138: PPUSH
14139: EMPTY
14140: PPUSH
14141: CALL 4048 0 4
14145: ST_TO_ADDR
14146: GO 14099
14148: POP
14149: POP
// result := true ;
14150: LD_ADDR_VAR 0 3
14154: PUSH
14155: LD_INT 1
14157: ST_TO_ADDR
// end ;
14158: LD_VAR 0 3
14162: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
14163: LD_INT 0
14165: PPUSH
14166: PPUSH
// for i = MREG_ToRes downto 1 do
14167: LD_ADDR_VAR 0 3
14171: PUSH
14172: DOUBLE
14173: LD_EXP 19
14177: INC
14178: ST_TO_ADDR
14179: LD_INT 1
14181: PUSH
14182: FOR_DOWNTO
14183: IFFALSE 14229
// if MREG_ToRes [ i ] [ 1 ] = side then
14185: LD_EXP 19
14189: PUSH
14190: LD_VAR 0 3
14194: ARRAY
14195: PUSH
14196: LD_INT 1
14198: ARRAY
14199: PUSH
14200: LD_VAR 0 1
14204: EQUAL
14205: IFFALSE 14227
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
14207: LD_ADDR_EXP 19
14211: PUSH
14212: LD_EXP 19
14216: PPUSH
14217: LD_VAR 0 3
14221: PPUSH
14222: CALL_OW 3
14226: ST_TO_ADDR
14227: GO 14182
14229: POP
14230: POP
// result := true ;
14231: LD_ADDR_VAR 0 2
14235: PUSH
14236: LD_INT 1
14238: ST_TO_ADDR
// end ;
14239: LD_VAR 0 2
14243: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
14244: LD_INT 0
14246: PPUSH
// result := GetTechProgress ( side , tech ) ;
14247: LD_ADDR_VAR 0 3
14251: PUSH
14252: LD_VAR 0 1
14256: PPUSH
14257: LD_VAR 0 2
14261: PPUSH
14262: CALL_OW 326
14266: ST_TO_ADDR
// end ;
14267: LD_VAR 0 3
14271: RET
// export function MCL_Require ( tech ) ; begin
14272: LD_INT 0
14274: PPUSH
// result := GetTechTechsReq ( tech ) ;
14275: LD_ADDR_VAR 0 2
14279: PUSH
14280: LD_VAR 0 1
14284: PPUSH
14285: CALL_OW 480
14289: ST_TO_ADDR
// end ; end_of_file
14290: LD_VAR 0 2
14294: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
14295: LD_INT 0
14297: PPUSH
14298: PPUSH
14299: PPUSH
// pom := GetBase ( fac ) ;
14300: LD_ADDR_VAR 0 5
14304: PUSH
14305: LD_VAR 0 1
14309: PPUSH
14310: CALL_OW 274
14314: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
14315: LD_ADDR_VAR 0 4
14319: PUSH
14320: LD_VAR 0 2
14324: PUSH
14325: LD_INT 1
14327: ARRAY
14328: PPUSH
14329: LD_VAR 0 2
14333: PUSH
14334: LD_INT 2
14336: ARRAY
14337: PPUSH
14338: LD_VAR 0 2
14342: PUSH
14343: LD_INT 3
14345: ARRAY
14346: PPUSH
14347: LD_VAR 0 2
14351: PUSH
14352: LD_INT 4
14354: ARRAY
14355: PPUSH
14356: CALL_OW 449
14360: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
14361: LD_VAR 0 5
14365: PPUSH
14366: LD_INT 1
14368: PPUSH
14369: CALL_OW 275
14373: PUSH
14374: LD_VAR 0 4
14378: PUSH
14379: LD_INT 1
14381: ARRAY
14382: GREATEREQUAL
14383: PUSH
14384: LD_VAR 0 5
14388: PPUSH
14389: LD_INT 2
14391: PPUSH
14392: CALL_OW 275
14396: PUSH
14397: LD_VAR 0 4
14401: PUSH
14402: LD_INT 2
14404: ARRAY
14405: GREATEREQUAL
14406: AND
14407: PUSH
14408: LD_VAR 0 5
14412: PPUSH
14413: LD_INT 3
14415: PPUSH
14416: CALL_OW 275
14420: PUSH
14421: LD_VAR 0 4
14425: PUSH
14426: LD_INT 3
14428: ARRAY
14429: GREATEREQUAL
14430: AND
14431: IFFALSE 14443
// result := true else
14433: LD_ADDR_VAR 0 3
14437: PUSH
14438: LD_INT 1
14440: ST_TO_ADDR
14441: GO 14451
// result := false ;
14443: LD_ADDR_VAR 0 3
14447: PUSH
14448: LD_INT 0
14450: ST_TO_ADDR
// end ;
14451: LD_VAR 0 3
14455: RET
// export function MCV_Produce ( side , fac , list ) ; var i ; begin
14456: LD_INT 0
14458: PPUSH
14459: PPUSH
// if fac then
14460: LD_VAR 0 2
14464: IFFALSE 14658
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
14466: LD_VAR 0 2
14470: PPUSH
14471: LD_VAR 0 3
14475: PPUSH
14476: CALL 14295 0 2
14480: PUSH
14481: LD_VAR 0 2
14485: PPUSH
14486: CALL_OW 461
14490: PUSH
14491: LD_INT 2
14493: EQUAL
14494: AND
14495: PUSH
14496: LD_VAR 0 2
14500: PPUSH
14501: LD_VAR 0 3
14505: PUSH
14506: LD_INT 1
14508: ARRAY
14509: PPUSH
14510: LD_VAR 0 3
14514: PUSH
14515: LD_INT 2
14517: ARRAY
14518: PPUSH
14519: LD_VAR 0 3
14523: PUSH
14524: LD_INT 3
14526: ARRAY
14527: PPUSH
14528: LD_VAR 0 3
14532: PUSH
14533: LD_INT 4
14535: ARRAY
14536: PPUSH
14537: CALL_OW 448
14541: AND
14542: IFFALSE 14648
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
14544: LD_VAR 0 2
14548: PPUSH
14549: LD_VAR 0 3
14553: PUSH
14554: LD_INT 1
14556: ARRAY
14557: PPUSH
14558: LD_VAR 0 3
14562: PUSH
14563: LD_INT 2
14565: ARRAY
14566: PPUSH
14567: LD_VAR 0 3
14571: PUSH
14572: LD_INT 3
14574: ARRAY
14575: PPUSH
14576: LD_VAR 0 3
14580: PUSH
14581: LD_INT 4
14583: ARRAY
14584: PPUSH
14585: CALL_OW 125
// for i = 1 to 4 do
14589: LD_ADDR_VAR 0 5
14593: PUSH
14594: DOUBLE
14595: LD_INT 1
14597: DEC
14598: ST_TO_ADDR
14599: LD_INT 4
14601: PUSH
14602: FOR_TO
14603: IFFALSE 14636
// MREG_ToConstruct := Remove ( MREG_ToConstruct , list [ i ] , true ) ;
14605: LD_ADDR_EXP 20
14609: PUSH
14610: LD_EXP 20
14614: PPUSH
14615: LD_VAR 0 3
14619: PUSH
14620: LD_VAR 0 5
14624: ARRAY
14625: PPUSH
14626: LD_INT 1
14628: PPUSH
14629: CALL 23535 0 3
14633: ST_TO_ADDR
14634: GO 14602
14636: POP
14637: POP
// result := true ;
14638: LD_ADDR_VAR 0 4
14642: PUSH
14643: LD_INT 1
14645: ST_TO_ADDR
// end else
14646: GO 14656
// result := false ;
14648: LD_ADDR_VAR 0 4
14652: PUSH
14653: LD_INT 0
14655: ST_TO_ADDR
// end else
14656: GO 14666
// result := false ;
14658: LD_ADDR_VAR 0 4
14662: PUSH
14663: LD_INT 0
14665: ST_TO_ADDR
// end ;
14666: LD_VAR 0 4
14670: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
14671: LD_INT 0
14673: PPUSH
14674: PPUSH
// if MREG_Parking [ side ] then
14675: LD_EXP 27
14679: PUSH
14680: LD_VAR 0 1
14684: ARRAY
14685: IFFALSE 14838
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
14687: LD_VAR 0 2
14691: PPUSH
14692: LD_EXP 27
14696: PUSH
14697: LD_VAR 0 1
14701: ARRAY
14702: PPUSH
14703: CALL_OW 308
14707: NOT
14708: IFFALSE 14838
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
14710: LD_VAR 0 2
14714: PPUSH
14715: LD_EXP 27
14719: PUSH
14720: LD_VAR 0 1
14724: ARRAY
14725: PPUSH
14726: CALL_OW 113
// if GetControl ( veh ) = control_manual then
14730: LD_VAR 0 2
14734: PPUSH
14735: CALL_OW 263
14739: PUSH
14740: LD_INT 1
14742: EQUAL
14743: IFFALSE 14838
// begin i := GetDriver ( veh ) ;
14745: LD_ADDR_VAR 0 4
14749: PUSH
14750: LD_VAR 0 2
14754: PPUSH
14755: CALL 24070 0 1
14759: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
14760: LD_INT 35
14762: PPUSH
14763: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) ;
14767: LD_VAR 0 2
14771: PPUSH
14772: LD_EXP 27
14776: PUSH
14777: LD_VAR 0 1
14781: ARRAY
14782: PPUSH
14783: CALL_OW 308
14787: IFFALSE 14760
// ComExitVehicle ( i ) ;
14789: LD_VAR 0 4
14793: PPUSH
14794: CALL_OW 121
// Wait ( 1 ) ;
14798: LD_INT 1
14800: PPUSH
14801: CALL_OW 67
// ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
14805: LD_VAR 0 4
14809: PPUSH
14810: LD_VAR 0 1
14814: PPUSH
14815: LD_INT 30
14817: PUSH
14818: LD_INT 3
14820: PUSH
14821: EMPTY
14822: LIST
14823: LIST
14824: PPUSH
14825: CALL 0 0 2
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: PPUSH
14834: CALL_OW 120
// end ; end ; end ;
14838: LD_VAR 0 3
14842: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
14843: LD_INT 0
14845: PPUSH
14846: PPUSH
14847: PPUSH
14848: PPUSH
14849: PPUSH
14850: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
14851: LD_VAR 0 1
14855: PPUSH
14856: LD_INT 30
14858: PUSH
14859: LD_INT 3
14861: PUSH
14862: EMPTY
14863: LIST
14864: LIST
14865: PPUSH
14866: CALL 0 0 2
14870: IFFALSE 15109
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
14872: LD_VAR 0 1
14876: PPUSH
14877: LD_INT 30
14879: PUSH
14880: LD_INT 3
14882: PUSH
14883: EMPTY
14884: LIST
14885: LIST
14886: PPUSH
14887: CALL 0 0 2
14891: PUSH
14892: LD_INT 1
14894: ARRAY
14895: PPUSH
14896: CALL_OW 461
14900: PUSH
14901: LD_INT 2
14903: EQUAL
14904: IFFALSE 15109
// begin if MREG_ForSide ( side , MREG_TurretWeapon ) then
14906: LD_VAR 0 1
14910: PPUSH
14911: LD_EXP 12
14915: PPUSH
14916: CALL 5142 0 2
14920: IFFALSE 15109
// for i = 1 to MREG_TurretWeapon do
14922: LD_ADDR_VAR 0 3
14926: PUSH
14927: DOUBLE
14928: LD_INT 1
14930: DEC
14931: ST_TO_ADDR
14932: LD_EXP 12
14936: PUSH
14937: FOR_TO
14938: IFFALSE 15107
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
14940: LD_EXP 12
14944: PUSH
14945: LD_VAR 0 3
14949: ARRAY
14950: PUSH
14951: LD_INT 1
14953: ARRAY
14954: PUSH
14955: LD_VAR 0 1
14959: EQUAL
14960: IFFALSE 15105
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
14962: LD_ADDR_VAR 0 5
14966: PUSH
14967: LD_EXP 12
14971: PUSH
14972: LD_VAR 0 3
14976: ARRAY
14977: PUSH
14978: LD_INT 2
14980: ARRAY
14981: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
14982: LD_ADDR_VAR 0 6
14986: PUSH
14987: LD_EXP 12
14991: PUSH
14992: LD_VAR 0 3
14996: ARRAY
14997: PUSH
14998: LD_INT 3
15000: ARRAY
15001: PUSH
15002: LD_INT 1
15004: ARRAY
15005: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
15006: LD_ADDR_VAR 0 7
15010: PUSH
15011: LD_EXP 12
15015: PUSH
15016: LD_VAR 0 3
15020: ARRAY
15021: PUSH
15022: LD_INT 3
15024: ARRAY
15025: PUSH
15026: LD_INT 2
15028: ARRAY
15029: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
15030: LD_ADDR_VAR 0 4
15034: PUSH
15035: LD_VAR 0 6
15039: PPUSH
15040: LD_VAR 0 7
15044: PPUSH
15045: CALL_OW 428
15049: ST_TO_ADDR
// AddComPlaceWeapon ( turret , weapon ) ;
15050: LD_VAR 0 4
15054: PPUSH
15055: LD_VAR 0 5
15059: PPUSH
15060: CALL_OW 208
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , side , weapon , [ x , y ] ) ;
15064: LD_ADDR_EXP 12
15068: PUSH
15069: LD_EXP 12
15073: PPUSH
15074: LD_VAR 0 1
15078: PPUSH
15079: LD_VAR 0 5
15083: PPUSH
15084: LD_VAR 0 6
15088: PUSH
15089: LD_VAR 0 7
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: PPUSH
15098: CALL 4139 0 4
15102: ST_TO_ADDR
// break ;
15103: GO 15107
// end ;
15105: GO 14937
15107: POP
15108: POP
// end ; end ;
15109: LD_VAR 0 2
15113: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
15114: LD_INT 0
15116: PPUSH
15117: PPUSH
15118: PPUSH
15119: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
15120: LD_ADDR_VAR 0 4
15124: PUSH
15125: LD_VAR 0 1
15129: PPUSH
15130: LD_INT 32
15132: PUSH
15133: LD_INT 1
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: PPUSH
15140: CALL 0 0 2
15144: ST_TO_ADDR
// if not tmp then
15145: LD_VAR 0 4
15149: NOT
15150: IFFALSE 15156
// exit else
15152: GO 15238
15154: GO 15238
// begin for i = 1 to tmp do
15156: LD_ADDR_VAR 0 3
15160: PUSH
15161: DOUBLE
15162: LD_INT 1
15164: DEC
15165: ST_TO_ADDR
15166: LD_VAR 0 4
15170: PUSH
15171: FOR_TO
15172: IFFALSE 15236
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
15174: LD_VAR 0 4
15178: PUSH
15179: LD_VAR 0 3
15183: ARRAY
15184: PPUSH
15185: CALL_OW 261
15189: PUSH
15190: LD_INT 20
15192: LESS
15193: PUSH
15194: LD_VAR 0 4
15198: PUSH
15199: LD_VAR 0 3
15203: ARRAY
15204: PPUSH
15205: CALL_OW 110
15209: PUSH
15210: LD_INT 0
15212: EQUAL
15213: AND
15214: IFFALSE 15234
// begin SetTag ( tmp [ i ] , 21 ) ;
15216: LD_VAR 0 4
15220: PUSH
15221: LD_VAR 0 3
15225: ARRAY
15226: PPUSH
15227: LD_INT 21
15229: PPUSH
15230: CALL_OW 109
// end ;
15234: GO 15171
15236: POP
15237: POP
// end ; end ;
15238: LD_VAR 0 2
15242: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
15243: LD_INT 0
15245: PPUSH
15246: PPUSH
15247: PPUSH
15248: PPUSH
15249: PPUSH
// if not unit then
15250: LD_VAR 0 1
15254: NOT
15255: IFFALSE 15259
// exit ;
15257: GO 15464
// side := GetSide ( unit ) ;
15259: LD_ADDR_VAR 0 3
15263: PUSH
15264: LD_VAR 0 1
15268: PPUSH
15269: CALL_OW 255
15273: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
15274: LD_ADDR_VAR 0 5
15278: PUSH
15279: LD_VAR 0 3
15283: PPUSH
15284: LD_INT 2
15286: PUSH
15287: LD_INT 30
15289: PUSH
15290: LD_INT 1
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PUSH
15297: LD_INT 30
15299: PUSH
15300: LD_INT 3
15302: PUSH
15303: EMPTY
15304: LIST
15305: LIST
15306: PUSH
15307: LD_INT 30
15309: PUSH
15310: LD_INT 29
15312: PUSH
15313: EMPTY
15314: LIST
15315: LIST
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: LIST
15321: LIST
15322: PPUSH
15323: CALL 0 0 2
15327: ST_TO_ADDR
// if not b then
15328: LD_VAR 0 5
15332: NOT
15333: IFFALSE 15339
// exit else
15335: GO 15464
15337: GO 15464
// if GetTag ( unit ) = 21 then
15339: LD_VAR 0 1
15343: PPUSH
15344: CALL_OW 110
15348: PUSH
15349: LD_INT 21
15351: EQUAL
15352: IFFALSE 15464
// begin c := NearestUnitToUnit ( b , unit ) ;
15354: LD_ADDR_VAR 0 6
15358: PUSH
15359: LD_VAR 0 5
15363: PPUSH
15364: LD_VAR 0 1
15368: PPUSH
15369: CALL_OW 74
15373: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
15374: LD_VAR 0 1
15378: PPUSH
15379: LD_VAR 0 6
15383: PPUSH
15384: CALL_OW 250
15388: PPUSH
15389: LD_VAR 0 6
15393: PPUSH
15394: CALL_OW 251
15398: PPUSH
15399: CALL_OW 297
15403: PUSH
15404: LD_INT 6
15406: GREATER
15407: IFFALSE 15440
// ComMoveXY ( unit , GetX ( c ) , GetY ( c ) ) else
15409: LD_VAR 0 1
15413: PPUSH
15414: LD_VAR 0 6
15418: PPUSH
15419: CALL_OW 250
15423: PPUSH
15424: LD_VAR 0 6
15428: PPUSH
15429: CALL_OW 251
15433: PPUSH
15434: CALL_OW 111
15438: GO 15464
// begin SetFuel ( unit , 100 ) ;
15440: LD_VAR 0 1
15444: PPUSH
15445: LD_INT 100
15447: PPUSH
15448: CALL_OW 240
// SetTag ( unit , 0 ) ;
15452: LD_VAR 0 1
15456: PPUSH
15457: LD_INT 0
15459: PPUSH
15460: CALL_OW 109
// end ; end ; end ;
15464: LD_VAR 0 2
15468: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
15469: LD_INT 0
15471: PPUSH
15472: PPUSH
15473: PPUSH
15474: PPUSH
15475: PPUSH
15476: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
15477: LD_ADDR_VAR 0 7
15481: PUSH
15482: LD_VAR 0 1
15486: PPUSH
15487: LD_INT 33
15489: PUSH
15490: LD_INT 2
15492: PUSH
15493: EMPTY
15494: LIST
15495: LIST
15496: PUSH
15497: LD_INT 3
15499: PUSH
15500: LD_INT 61
15502: PUSH
15503: EMPTY
15504: LIST
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL 0 0 2
15518: ST_TO_ADDR
// if not vehs then
15519: LD_VAR 0 7
15523: NOT
15524: IFFALSE 15528
// exit ;
15526: GO 15822
// if nation = 1 then
15528: LD_VAR 0 2
15532: PUSH
15533: LD_INT 1
15535: EQUAL
15536: IFFALSE 15715
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
15538: LD_VAR 0 1
15542: PPUSH
15543: LD_INT 30
15545: PUSH
15546: LD_INT 36
15548: PUSH
15549: EMPTY
15550: LIST
15551: LIST
15552: PPUSH
15553: CALL 0 0 2
15557: NOT
15558: IFFALSE 15564
// exit else
15560: GO 15822
15562: GO 15713
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
15564: LD_ADDR_VAR 0 5
15568: PUSH
15569: LD_VAR 0 1
15573: PPUSH
15574: LD_INT 30
15576: PUSH
15577: LD_INT 36
15579: PUSH
15580: EMPTY
15581: LIST
15582: LIST
15583: PPUSH
15584: CALL 0 0 2
15588: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
15589: LD_ADDR_VAR 0 6
15593: PUSH
15594: LD_VAR 0 5
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PPUSH
15603: CALL_OW 313
15607: ST_TO_ADDR
// for i = vehs downto 1 do
15608: LD_ADDR_VAR 0 4
15612: PUSH
15613: DOUBLE
15614: LD_VAR 0 7
15618: INC
15619: ST_TO_ADDR
15620: LD_INT 1
15622: PUSH
15623: FOR_DOWNTO
15624: IFFALSE 15711
// begin if not IsControledBy ( vehs [ i ] ) then
15626: LD_VAR 0 7
15630: PUSH
15631: LD_VAR 0 4
15635: ARRAY
15636: PPUSH
15637: CALL_OW 312
15641: NOT
15642: IFFALSE 15709
// begin tmp := MCV_RemoteDriver ( oper ) ;
15644: LD_ADDR_VAR 0 8
15648: PUSH
15649: LD_VAR 0 6
15653: PPUSH
15654: CALL 15827 0 1
15658: ST_TO_ADDR
// MC_Show ( tmp ) ;
15659: LD_VAR 0 8
15663: PPUSH
15664: CALL 3814 0 1
// if not tmp then
15668: LD_VAR 0 8
15672: NOT
15673: IFFALSE 15681
// exit else
15675: POP
15676: POP
15677: GO 15822
15679: GO 15709
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
15681: LD_VAR 0 7
15685: PUSH
15686: LD_VAR 0 4
15690: ARRAY
15691: PPUSH
15692: LD_VAR 0 8
15696: PUSH
15697: LD_INT 1
15699: ARRAY
15700: PUSH
15701: LD_INT 1
15703: ARRAY
15704: PPUSH
15705: CALL_OW 135
// end ; end ;
15709: GO 15623
15711: POP
15712: POP
// end ; end else
15713: GO 15822
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
15715: LD_VAR 0 1
15719: PPUSH
15720: LD_INT 34
15722: PUSH
15723: LD_INT 31
15725: PUSH
15726: EMPTY
15727: LIST
15728: LIST
15729: PPUSH
15730: CALL 0 0 2
15734: NOT
15735: IFFALSE 15741
// exit else
15737: GO 15822
15739: GO 15822
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
15741: LD_ADDR_VAR 0 5
15745: PUSH
15746: LD_VAR 0 1
15750: PPUSH
15751: LD_INT 34
15753: PUSH
15754: LD_INT 31
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: PPUSH
15761: CALL 0 0 2
15765: ST_TO_ADDR
// oper := [ ] ;
15766: LD_ADDR_VAR 0 6
15770: PUSH
15771: EMPTY
15772: ST_TO_ADDR
// for i = 1 to ct do
15773: LD_ADDR_VAR 0 4
15777: PUSH
15778: DOUBLE
15779: LD_INT 1
15781: DEC
15782: ST_TO_ADDR
15783: LD_VAR 0 5
15787: PUSH
15788: FOR_TO
15789: IFFALSE 15820
// oper := oper ^ GetDriver ( ct [ i ] ) ;
15791: LD_ADDR_VAR 0 6
15795: PUSH
15796: LD_VAR 0 6
15800: PUSH
15801: LD_VAR 0 5
15805: PUSH
15806: LD_VAR 0 4
15810: ARRAY
15811: PPUSH
15812: CALL 24070 0 1
15816: ADD
15817: ST_TO_ADDR
15818: GO 15788
15820: POP
15821: POP
// end ; end ; end ;
15822: LD_VAR 0 3
15826: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
15827: LD_INT 0
15829: PPUSH
15830: PPUSH
15831: PPUSH
15832: PPUSH
15833: PPUSH
15834: PPUSH
// if not drivers then
15835: LD_VAR 0 1
15839: NOT
15840: IFFALSE 15846
// exit else
15842: GO 16126
15844: GO 16126
// begin linked := [ ] ;
15846: LD_ADDR_VAR 0 5
15850: PUSH
15851: EMPTY
15852: ST_TO_ADDR
// for i = 1 to drivers do
15853: LD_ADDR_VAR 0 3
15857: PUSH
15858: DOUBLE
15859: LD_INT 1
15861: DEC
15862: ST_TO_ADDR
15863: LD_VAR 0 1
15867: PUSH
15868: FOR_TO
15869: IFFALSE 16114
// begin if CanControl ( drivers [ i ] ) then
15871: LD_VAR 0 1
15875: PUSH
15876: LD_VAR 0 3
15880: ARRAY
15881: PPUSH
15882: CALL 24642 0 1
15886: IFFALSE 16112
// if i > 1 then
15888: LD_VAR 0 3
15892: PUSH
15893: LD_INT 1
15895: GREATER
15896: IFFALSE 16073
// begin m := false ;
15898: LD_ADDR_VAR 0 6
15902: PUSH
15903: LD_INT 0
15905: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
15906: LD_ADDR_VAR 0 7
15910: PUSH
15911: LD_VAR 0 1
15915: PUSH
15916: LD_VAR 0 3
15920: ARRAY
15921: PPUSH
15922: CALL_OW 432
15926: ST_TO_ADDR
// for j = 1 to linked do
15927: LD_ADDR_VAR 0 4
15931: PUSH
15932: DOUBLE
15933: LD_INT 1
15935: DEC
15936: ST_TO_ADDR
15937: LD_VAR 0 5
15941: PUSH
15942: FOR_TO
15943: IFFALSE 16017
// begin if l < linked [ j ] [ 2 ] then
15945: LD_VAR 0 7
15949: PUSH
15950: LD_VAR 0 5
15954: PUSH
15955: LD_VAR 0 4
15959: ARRAY
15960: PUSH
15961: LD_INT 2
15963: ARRAY
15964: LESS
15965: IFFALSE 16015
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
15967: LD_ADDR_VAR 0 5
15971: PUSH
15972: LD_VAR 0 5
15976: PPUSH
15977: LD_INT 1
15979: PPUSH
15980: LD_VAR 0 1
15984: PUSH
15985: LD_VAR 0 3
15989: ARRAY
15990: PUSH
15991: LD_VAR 0 7
15995: PUSH
15996: EMPTY
15997: LIST
15998: LIST
15999: PPUSH
16000: CALL_OW 2
16004: ST_TO_ADDR
// m := true ;
16005: LD_ADDR_VAR 0 6
16009: PUSH
16010: LD_INT 1
16012: ST_TO_ADDR
// break ;
16013: GO 16017
// end ; end ;
16015: GO 15942
16017: POP
16018: POP
// if not m then
16019: LD_VAR 0 6
16023: NOT
16024: IFFALSE 16071
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
16026: LD_ADDR_VAR 0 5
16030: PUSH
16031: LD_VAR 0 5
16035: PUSH
16036: LD_VAR 0 1
16040: PUSH
16041: LD_VAR 0 3
16045: ARRAY
16046: PUSH
16047: LD_VAR 0 1
16051: PUSH
16052: LD_VAR 0 3
16056: ARRAY
16057: PPUSH
16058: CALL_OW 432
16062: PUSH
16063: EMPTY
16064: LIST
16065: LIST
16066: PUSH
16067: EMPTY
16068: LIST
16069: ADD
16070: ST_TO_ADDR
// end else
16071: GO 16112
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
16073: LD_ADDR_VAR 0 5
16077: PUSH
16078: LD_VAR 0 1
16082: PUSH
16083: LD_VAR 0 3
16087: ARRAY
16088: PUSH
16089: LD_VAR 0 1
16093: PUSH
16094: LD_VAR 0 3
16098: ARRAY
16099: PPUSH
16100: CALL_OW 432
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: PUSH
16109: EMPTY
16110: LIST
16111: ST_TO_ADDR
// end ;
16112: GO 15868
16114: POP
16115: POP
// result := linked ;
16116: LD_ADDR_VAR 0 2
16120: PUSH
16121: LD_VAR 0 5
16125: ST_TO_ADDR
// end ; end ; end_of_file
16126: LD_VAR 0 2
16130: RET
// export mc_game_live ; starting begin ResetFog ( ) ;
16131: CALL_OW 335
// RandomizeAll ;
16135: CALL_OW 11
// FakePep ( ) ;
16139: CALL 3296 0 0
// mc_game_live := 1 ;
16143: LD_ADDR_EXP 32
16147: PUSH
16148: LD_INT 1
16150: ST_TO_ADDR
// MC_Registry ( ) ;
16151: CALL 3832 0 0
// MC_RegistryInit ( ) ;
16155: CALL 4220 0 0
// MCT_MarkPlace ( 10 , 7 , aqua ) ;
16159: LD_INT 10
16161: PPUSH
16162: LD_INT 7
16164: PPUSH
16165: LD_STRING aqua
16167: PPUSH
16168: CALL 5434 0 3
// MCN_AddApes ( Area43 , 5 , 10 ) ;
16172: LD_INT 5
16174: PPUSH
16175: LD_INT 5
16177: PPUSH
16178: LD_INT 10
16180: PPUSH
16181: CALL 24860 0 3
// MCS_SetResourcesBonus ( 20 , 16000 , 30 ) ;
16185: LD_INT 20
16187: PPUSH
16188: LD_INT 16000
16190: PPUSH
16191: LD_INT 30
16193: PPUSH
16194: CALL 9684 0 3
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , 20 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_weap3 , tech_rocket , tech_advMet , tech_sib1 , tech_comp1 , tech_ai , tech_advai , tech_comp2 , tech_opto1 , tech_opto2 , tech_radar , tech_remcont ] ) ;
16198: LD_INT 1
16200: PPUSH
16201: LD_INT 48
16203: PUSH
16204: LD_INT 49
16206: PUSH
16207: LD_INT 20
16209: PUSH
16210: LD_INT 46
16212: PUSH
16213: LD_INT 47
16215: PUSH
16216: LD_INT 35
16218: PUSH
16219: LD_INT 45
16221: PUSH
16222: LD_INT 1
16224: PUSH
16225: LD_INT 50
16227: PUSH
16228: LD_INT 2
16230: PUSH
16231: LD_INT 51
16233: PUSH
16234: LD_INT 52
16236: PUSH
16237: LD_INT 69
16239: PUSH
16240: LD_INT 39
16242: PUSH
16243: LD_INT 53
16245: PUSH
16246: LD_INT 40
16248: PUSH
16249: LD_INT 34
16251: PUSH
16252: LD_INT 54
16254: PUSH
16255: LD_INT 57
16257: PUSH
16258: LD_INT 32
16260: PUSH
16261: LD_INT 27
16263: PUSH
16264: LD_INT 58
16266: PUSH
16267: LD_INT 60
16269: PUSH
16270: LD_INT 61
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: LD_INT 15
16278: PUSH
16279: EMPTY
16280: LIST
16281: LIST
16282: LIST
16283: LIST
16284: LIST
16285: LIST
16286: LIST
16287: LIST
16288: LIST
16289: LIST
16290: LIST
16291: LIST
16292: LIST
16293: LIST
16294: LIST
16295: LIST
16296: LIST
16297: LIST
16298: LIST
16299: LIST
16300: LIST
16301: LIST
16302: LIST
16303: LIST
16304: LIST
16305: LIST
16306: PPUSH
16307: CALL 14080 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
16311: LD_INT 1
16313: PPUSH
16314: LD_INT 3
16316: PPUSH
16317: CALL 9554 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
16321: LD_INT 1
16323: PPUSH
16324: LD_INT 0
16326: PUSH
16327: LD_INT 1
16329: PUSH
16330: LD_INT 0
16332: PUSH
16333: LD_INT 0
16335: PUSH
16336: EMPTY
16337: LIST
16338: LIST
16339: LIST
16340: LIST
16341: PPUSH
16342: CALL 9587 0 2
// MCS_CreateDeposits ( 1 , [ 9 , 13 , 2 , 29 , 10 , 3 ] ) ;
16346: LD_INT 1
16348: PPUSH
16349: LD_INT 9
16351: PUSH
16352: LD_INT 13
16354: PUSH
16355: LD_INT 2
16357: PUSH
16358: LD_INT 29
16360: PUSH
16361: LD_INT 10
16363: PUSH
16364: LD_INT 3
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: LIST
16371: LIST
16372: LIST
16373: LIST
16374: PPUSH
16375: CALL 9761 0 2
// MCS_Collector ( 1 , 1 , [ Area44 ] ) ;
16379: LD_INT 1
16381: PPUSH
16382: LD_INT 1
16384: PPUSH
16385: LD_INT 6
16387: PUSH
16388: EMPTY
16389: LIST
16390: PPUSH
16391: CALL 9620 0 3
// MCS_SetParking ( 1 , area42 ) ;
16395: LD_INT 1
16397: PPUSH
16398: LD_INT 4
16400: PPUSH
16401: CALL 9520 0 2
// MCS_Depot ( 1 , [ 33 , 27 , 1 ] ) ;
16405: LD_INT 1
16407: PPUSH
16408: LD_INT 33
16410: PUSH
16411: LD_INT 27
16413: PUSH
16414: LD_INT 1
16416: PUSH
16417: EMPTY
16418: LIST
16419: LIST
16420: LIST
16421: PPUSH
16422: CALL 8699 0 2
// MCS_Mine ( 1 ) ;
16426: LD_INT 1
16428: PPUSH
16429: CALL 9071 0 1
// MCS_Lab ( 1 , [ 20 , 20 , 3 ] , [ b_lab_weapon , b_lab_opto ] ) ;
16433: LD_INT 1
16435: PPUSH
16436: LD_INT 20
16438: PUSH
16439: LD_INT 20
16441: PUSH
16442: LD_INT 3
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: LIST
16449: PPUSH
16450: LD_INT 10
16452: PUSH
16453: LD_INT 15
16455: PUSH
16456: EMPTY
16457: LIST
16458: LIST
16459: PPUSH
16460: CALL 8735 0 3
// MCS_Lab ( 1 , [ 40 , 17 , 1 ] , [ b_lab_computer , b_lab_siberium ] ) ;
16464: LD_INT 1
16466: PPUSH
16467: LD_INT 40
16469: PUSH
16470: LD_INT 17
16472: PUSH
16473: LD_INT 1
16475: PUSH
16476: EMPTY
16477: LIST
16478: LIST
16479: LIST
16480: PPUSH
16481: LD_INT 12
16483: PUSH
16484: LD_INT 11
16486: PUSH
16487: EMPTY
16488: LIST
16489: LIST
16490: PPUSH
16491: CALL 8735 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 10 , 7 , 2 , 37 , 41 , 3 ] , [ us_machine_gun , us_machine_gun ] ) ;
16495: LD_INT 1
16497: PPUSH
16498: LD_INT 32
16500: PPUSH
16501: LD_INT 10
16503: PUSH
16504: LD_INT 7
16506: PUSH
16507: LD_INT 2
16509: PUSH
16510: LD_INT 37
16512: PUSH
16513: LD_INT 41
16515: PUSH
16516: LD_INT 3
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: LIST
16523: LIST
16524: LIST
16525: LIST
16526: PPUSH
16527: LD_INT 2
16529: PUSH
16530: LD_INT 2
16532: PUSH
16533: EMPTY
16534: LIST
16535: LIST
16536: PPUSH
16537: CALL 8195 0 4
// MCS_ChangeFortification ( 1 , [ 10 , 7 ] , [ us_gatling_gun ] ) ;
16541: LD_INT 1
16543: PPUSH
16544: LD_INT 10
16546: PUSH
16547: LD_INT 7
16549: PUSH
16550: EMPTY
16551: LIST
16552: LIST
16553: PPUSH
16554: LD_INT 4
16556: PUSH
16557: EMPTY
16558: LIST
16559: PPUSH
16560: CALL 8390 0 3
// MCS_PowerPlants ( 1 , [ 29 , 13 , 0 , 17 , 10 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
16564: LD_INT 1
16566: PPUSH
16567: LD_INT 29
16569: PUSH
16570: LD_INT 13
16572: PUSH
16573: LD_INT 0
16575: PUSH
16576: LD_INT 17
16578: PUSH
16579: LD_INT 10
16581: PUSH
16582: LD_INT 2
16584: PUSH
16585: EMPTY
16586: LIST
16587: LIST
16588: LIST
16589: LIST
16590: LIST
16591: LIST
16592: PPUSH
16593: LD_INT 27
16595: PUSH
16596: LD_INT 26
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PPUSH
16603: CALL 8911 0 3
// MCS_Barracks ( 1 , [ 46 , 27 , 5 ] ) ;
16607: LD_INT 1
16609: PPUSH
16610: LD_INT 46
16612: PUSH
16613: LD_INT 27
16615: PUSH
16616: LD_INT 5
16618: PUSH
16619: EMPTY
16620: LIST
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL 9274 0 2
// MCS_Factory ( 1 , [ 48 , 40 , 0 ] , [ b_ext_gun , b_ext_noncombat , b_ext_computer , b_ext_radar , b_ext_track , b_ext_gun ] ) ;
16628: LD_INT 1
16630: PPUSH
16631: LD_INT 48
16633: PUSH
16634: LD_INT 40
16636: PUSH
16637: LD_INT 0
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: LD_INT 17
16647: PUSH
16648: LD_INT 19
16650: PUSH
16651: LD_INT 24
16653: PUSH
16654: LD_INT 20
16656: PUSH
16657: LD_INT 16
16659: PUSH
16660: LD_INT 17
16662: PUSH
16663: EMPTY
16664: LIST
16665: LIST
16666: LIST
16667: LIST
16668: LIST
16669: LIST
16670: PPUSH
16671: CALL 8809 0 3
// MCS_ControlTower ( 1 , 1 , [ 33 , 49 , 2 ] ) ;
16675: LD_INT 1
16677: PPUSH
16678: LD_INT 1
16680: PPUSH
16681: LD_INT 33
16683: PUSH
16684: LD_INT 49
16686: PUSH
16687: LD_INT 2
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: LIST
16694: PPUSH
16695: CALL 9310 0 3
// MCS_AddVehicle ( 1 , [ us_medium_wheeled , engine_combustion , control_computer , us_cargo_bay ] ) ;
16699: LD_INT 1
16701: PPUSH
16702: LD_INT 2
16704: PUSH
16705: LD_INT 1
16707: PUSH
16708: LD_INT 3
16710: PUSH
16711: LD_INT 12
16713: PUSH
16714: EMPTY
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: PPUSH
16720: CALL 9419 0 2
// MCS_AddVehicle ( 1 , [ us_medium_wheeled , engine_combustion , control_remote , us_gatling_gun ] ) ;
16724: LD_INT 1
16726: PPUSH
16727: LD_INT 2
16729: PUSH
16730: LD_INT 1
16732: PUSH
16733: LD_INT 2
16735: PUSH
16736: LD_INT 4
16738: PUSH
16739: EMPTY
16740: LIST
16741: LIST
16742: LIST
16743: LIST
16744: PPUSH
16745: CALL 9419 0 2
// MC_Game ( 0 0$01 ) ;
16749: LD_INT 35
16751: PPUSH
16752: CALL 16757 0 1
// end ;
16756: END
// function MC_Game ( int ) ; var i , side , un ; begin
16757: LD_INT 0
16759: PPUSH
16760: PPUSH
16761: PPUSH
16762: PPUSH
// while ( mc_game_live ) do
16763: LD_EXP 32
16767: IFFALSE 18294
// begin Wait ( int ) ;
16769: LD_VAR 0 1
16773: PPUSH
16774: CALL_OW 67
// if isEditor then
16778: LD_INT 1
16780: IFFALSE 16791
// MC_Show ( MREG_Deposit ) ;
16782: LD_EXP 30
16786: PPUSH
16787: CALL 3814 0 1
// MCT_Crates ( area44 , 4 , 66 , 0 0$20 , 20 ) ;
16791: LD_INT 6
16793: PPUSH
16794: LD_INT 4
16796: PPUSH
16797: LD_INT 66
16799: PPUSH
16800: LD_INT 700
16802: PPUSH
16803: LD_INT 20
16805: PPUSH
16806: CALL 7570 0 5
// for side = 1 to 8 do
16810: LD_ADDR_VAR 0 4
16814: PUSH
16815: DOUBLE
16816: LD_INT 1
16818: DEC
16819: ST_TO_ADDR
16820: LD_INT 8
16822: PUSH
16823: FOR_TO
16824: IFFALSE 18290
// begin if MREG_SidesList [ side ] = 0 then
16826: LD_EXP 7
16830: PUSH
16831: LD_VAR 0 4
16835: ARRAY
16836: PUSH
16837: LD_INT 0
16839: EQUAL
16840: IFFALSE 16844
// continue ;
16842: GO 16823
// if MCL_GetTechList ( side ) then
16844: LD_VAR 0 4
16848: PPUSH
16849: CALL 13982 0 1
16853: IFFALSE 16864
// MCL_Start ( side ) ;
16855: LD_VAR 0 4
16859: PPUSH
16860: CALL 13887 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
16864: LD_ADDR_EXP 3
16868: PUSH
16869: LD_EXP 3
16873: PPUSH
16874: LD_VAR 0 4
16878: PPUSH
16879: LD_VAR 0 4
16883: PPUSH
16884: CALL 25787 0 1
16888: PPUSH
16889: CALL_OW 1
16893: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
16894: LD_ADDR_EXP 16
16898: PUSH
16899: LD_EXP 16
16903: PPUSH
16904: LD_VAR 0 4
16908: PPUSH
16909: LD_VAR 0 4
16913: PPUSH
16914: CALL 12470 0 1
16918: PPUSH
16919: CALL_OW 1
16923: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
16924: LD_VAR 0 4
16928: PPUSH
16929: LD_EXP 22
16933: PPUSH
16934: CALL 5142 0 2
16938: IFFALSE 17023
// begin for i = MREG_ToChangeClass downto 1 do
16940: LD_ADDR_VAR 0 3
16944: PUSH
16945: DOUBLE
16946: LD_EXP 22
16950: INC
16951: ST_TO_ADDR
16952: LD_INT 1
16954: PUSH
16955: FOR_DOWNTO
16956: IFFALSE 17021
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
16958: LD_EXP 22
16962: PUSH
16963: LD_VAR 0 3
16967: ARRAY
16968: PUSH
16969: LD_INT 1
16971: ARRAY
16972: PUSH
16973: LD_VAR 0 4
16977: EQUAL
16978: IFFALSE 17019
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
16980: LD_VAR 0 4
16984: PPUSH
16985: LD_EXP 22
16989: PUSH
16990: LD_VAR 0 3
16994: ARRAY
16995: PUSH
16996: LD_INT 2
16998: ARRAY
16999: PPUSH
17000: LD_EXP 22
17004: PUSH
17005: LD_VAR 0 3
17009: ARRAY
17010: PUSH
17011: LD_INT 3
17013: ARRAY
17014: PPUSH
17015: CALL 22895 0 3
// end ; end ;
17019: GO 16955
17021: POP
17022: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
17023: LD_INT 1
17025: PUSH
17026: LD_EXP 6
17030: PUSH
17031: LD_VAR 0 4
17035: ARRAY
17036: IN
17037: IFFALSE 17048
// begin MCN_TrainApe ( side ) ;
17039: LD_VAR 0 4
17043: PPUSH
17044: CALL 25440 0 1
// end ; if MREG_ToConstruct [ side ] then
17048: LD_EXP 20
17052: PUSH
17053: LD_VAR 0 4
17057: ARRAY
17058: IFFALSE 17180
// begin if MCF_Get ( side , [ f_btype , b_factory ] ) then
17060: LD_VAR 0 4
17064: PPUSH
17065: LD_INT 30
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: PPUSH
17075: CALL 0 0 2
17079: IFFALSE 17180
// MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
17081: LD_VAR 0 4
17085: PPUSH
17086: LD_VAR 0 4
17090: PPUSH
17091: LD_INT 30
17093: PUSH
17094: LD_INT 3
17096: PUSH
17097: EMPTY
17098: LIST
17099: LIST
17100: PPUSH
17101: CALL 0 0 2
17105: PUSH
17106: LD_INT 1
17108: ARRAY
17109: PPUSH
17110: LD_EXP 20
17114: PUSH
17115: LD_VAR 0 4
17119: ARRAY
17120: PUSH
17121: LD_INT 1
17123: ARRAY
17124: PUSH
17125: LD_EXP 20
17129: PUSH
17130: LD_VAR 0 4
17134: ARRAY
17135: PUSH
17136: LD_INT 2
17138: ARRAY
17139: PUSH
17140: LD_EXP 20
17144: PUSH
17145: LD_VAR 0 4
17149: ARRAY
17150: PUSH
17151: LD_INT 3
17153: ARRAY
17154: PUSH
17155: LD_EXP 20
17159: PUSH
17160: LD_VAR 0 4
17164: ARRAY
17165: PUSH
17166: LD_INT 4
17168: ARRAY
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: PPUSH
17176: CALL 14456 0 3
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) then
17180: LD_VAR 0 4
17184: PPUSH
17185: LD_INT 30
17187: PUSH
17188: LD_INT 3
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: PPUSH
17195: CALL 0 0 2
17199: PUSH
17200: LD_VAR 0 4
17204: PPUSH
17205: LD_EXP 12
17209: PPUSH
17210: CALL 5142 0 2
17214: AND
17215: IFFALSE 17226
// MCV_Turret ( side ) ;
17217: LD_VAR 0 4
17221: PPUSH
17222: CALL 14843 0 1
// if MCF_Get ( side , [ f_engine , engine_combustion ] ) then
17226: LD_VAR 0 4
17230: PPUSH
17231: LD_INT 32
17233: PUSH
17234: LD_INT 1
17236: PUSH
17237: EMPTY
17238: LIST
17239: LIST
17240: PPUSH
17241: CALL 0 0 2
17245: IFFALSE 17295
// begin MCV_CheckFuel ( side ) ;
17247: LD_VAR 0 4
17251: PPUSH
17252: CALL 15114 0 1
// if MCF_Tag ( side , 21 , [ ] ) then
17256: LD_VAR 0 4
17260: PPUSH
17261: LD_INT 21
17263: PPUSH
17264: EMPTY
17265: PPUSH
17266: CALL 627 0 3
17270: IFFALSE 17295
// MCV_Refuel ( MCF_Tag ( side , 21 , [ ] ) [ 1 ] ) ;
17272: LD_VAR 0 4
17276: PPUSH
17277: LD_INT 21
17279: PPUSH
17280: EMPTY
17281: PPUSH
17282: CALL 627 0 3
17286: PUSH
17287: LD_INT 1
17289: ARRAY
17290: PPUSH
17291: CALL 15243 0 1
// end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
17295: LD_VAR 0 4
17299: PPUSH
17300: LD_INT 33
17302: PUSH
17303: LD_INT 2
17305: PUSH
17306: EMPTY
17307: LIST
17308: LIST
17309: PPUSH
17310: CALL 0 0 2
17314: IFFALSE 17354
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
17316: LD_VAR 0 4
17320: PPUSH
17321: LD_VAR 0 4
17325: PPUSH
17326: LD_INT 33
17328: PUSH
17329: LD_INT 2
17331: PUSH
17332: EMPTY
17333: LIST
17334: LIST
17335: PPUSH
17336: CALL 0 0 2
17340: PUSH
17341: LD_INT 1
17343: ARRAY
17344: PPUSH
17345: CALL_OW 248
17349: PPUSH
17350: CALL 15469 0 2
// if MREG_ToRepair [ side ] then
17354: LD_EXP 16
17358: PUSH
17359: LD_VAR 0 4
17363: ARRAY
17364: IFFALSE 17377
// begin MCB_Repair ( side ) ;
17366: LD_VAR 0 4
17370: PPUSH
17371: CALL 12757 0 1
// end else
17375: GO 18258
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
17377: LD_VAR 0 4
17381: PPUSH
17382: LD_EXP 18
17386: PPUSH
17387: CALL 5142 0 2
17391: PUSH
17392: LD_VAR 0 4
17396: PPUSH
17397: LD_EXP 8
17401: PPUSH
17402: CALL 5142 0 2
17406: AND
17407: IFFALSE 17615
// begin for i = 1 to MREG_ToUpLab do
17409: LD_ADDR_VAR 0 3
17413: PUSH
17414: DOUBLE
17415: LD_INT 1
17417: DEC
17418: ST_TO_ADDR
17419: LD_EXP 18
17423: PUSH
17424: FOR_TO
17425: IFFALSE 17611
// if MREG_ToUpLab [ i ] [ 1 ] = side then
17427: LD_EXP 18
17431: PUSH
17432: LD_VAR 0 3
17436: ARRAY
17437: PUSH
17438: LD_INT 1
17440: ARRAY
17441: PUSH
17442: LD_VAR 0 4
17446: EQUAL
17447: IFFALSE 17609
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
17449: LD_EXP 18
17453: PUSH
17454: LD_VAR 0 3
17458: ARRAY
17459: PUSH
17460: LD_INT 2
17462: ARRAY
17463: PUSH
17464: LD_EXP 18
17468: PUSH
17469: LD_VAR 0 3
17473: ARRAY
17474: PUSH
17475: LD_INT 3
17477: ARRAY
17478: AND
17479: IFFALSE 17607
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
17481: LD_VAR 0 4
17485: PPUSH
17486: LD_EXP 18
17490: PUSH
17491: LD_VAR 0 3
17495: ARRAY
17496: PUSH
17497: LD_INT 2
17499: ARRAY
17500: PPUSH
17501: LD_EXP 18
17505: PUSH
17506: LD_VAR 0 3
17510: ARRAY
17511: PUSH
17512: LD_INT 3
17514: ARRAY
17515: PPUSH
17516: CALL 10281 0 3
17520: IFFALSE 17607
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
17522: LD_ADDR_EXP 18
17526: PUSH
17527: LD_EXP 18
17531: PPUSH
17532: LD_VAR 0 4
17536: PPUSH
17537: LD_EXP 18
17541: PUSH
17542: LD_VAR 0 3
17546: ARRAY
17547: PUSH
17548: LD_INT 2
17550: ARRAY
17551: PPUSH
17552: LD_EXP 18
17556: PUSH
17557: LD_VAR 0 3
17561: ARRAY
17562: PUSH
17563: LD_INT 3
17565: ARRAY
17566: PPUSH
17567: CALL 4139 0 4
17571: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
17572: LD_ADDR_EXP 8
17576: PUSH
17577: LD_EXP 8
17581: PPUSH
17582: LD_VAR 0 4
17586: PPUSH
17587: LD_EXP 8
17591: PUSH
17592: LD_INT 1
17594: ARRAY
17595: PUSH
17596: LD_INT 2
17598: ARRAY
17599: PPUSH
17600: EMPTY
17601: PPUSH
17602: CALL 4139 0 4
17606: ST_TO_ADDR
// end ; break ;
17607: GO 17611
// end ;
17609: GO 17424
17611: POP
17612: POP
// end else
17613: GO 18258
// if MREG_ForSide ( side , MREG_ToUpdate ) then
17615: LD_VAR 0 4
17619: PPUSH
17620: LD_EXP 17
17624: PPUSH
17625: CALL 5142 0 2
17629: IFFALSE 17703
// begin for i = 1 to MREG_ToUpdate do
17631: LD_ADDR_VAR 0 3
17635: PUSH
17636: DOUBLE
17637: LD_INT 1
17639: DEC
17640: ST_TO_ADDR
17641: LD_EXP 17
17645: PUSH
17646: FOR_TO
17647: IFFALSE 17699
// if MREG_ToUpdate [ i ] [ 1 ] = side then
17649: LD_EXP 17
17653: PUSH
17654: LD_VAR 0 3
17658: ARRAY
17659: PUSH
17660: LD_INT 1
17662: ARRAY
17663: PUSH
17664: LD_VAR 0 4
17668: EQUAL
17669: IFFALSE 17697
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
17671: LD_VAR 0 4
17675: PPUSH
17676: LD_EXP 17
17680: PUSH
17681: LD_VAR 0 3
17685: ARRAY
17686: PUSH
17687: LD_INT 2
17689: ARRAY
17690: PPUSH
17691: CALL 10117 0 2
// break ;
17695: GO 17699
// end ;
17697: GO 17646
17699: POP
17700: POP
// end else
17701: GO 18258
// if MCF_Get ( side , [ f_constructed ] ) then
17703: LD_VAR 0 4
17707: PPUSH
17708: LD_INT 57
17710: PUSH
17711: EMPTY
17712: LIST
17713: PPUSH
17714: CALL 0 0 2
17718: IFFALSE 17751
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
17720: LD_VAR 0 4
17724: PPUSH
17725: LD_VAR 0 4
17729: PPUSH
17730: LD_INT 57
17732: PUSH
17733: EMPTY
17734: LIST
17735: PPUSH
17736: CALL 0 0 2
17740: PUSH
17741: LD_INT 1
17743: ARRAY
17744: PPUSH
17745: CALL 12361 0 2
17749: GO 18258
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) then
17751: LD_VAR 0 4
17755: PPUSH
17756: LD_EXP 15
17760: PPUSH
17761: CALL 5142 0 2
17765: PUSH
17766: LD_VAR 0 4
17770: PPUSH
17771: CALL_OW 345
17775: NOT
17776: AND
17777: IFFALSE 18174
// begin for i = 1 to MREG_ToBuild do
17779: LD_ADDR_VAR 0 3
17783: PUSH
17784: DOUBLE
17785: LD_INT 1
17787: DEC
17788: ST_TO_ADDR
17789: LD_EXP 15
17793: PUSH
17794: FOR_TO
17795: IFFALSE 18170
// if MREG_ToBuild [ i ] [ 1 ] = side then
17797: LD_EXP 15
17801: PUSH
17802: LD_VAR 0 3
17806: ARRAY
17807: PUSH
17808: LD_INT 1
17810: ARRAY
17811: PUSH
17812: LD_VAR 0 4
17816: EQUAL
17817: IFFALSE 18168
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
17819: LD_INT 1
17821: PUSH
17822: LD_EXP 15
17826: PUSH
17827: LD_VAR 0 3
17831: ARRAY
17832: PUSH
17833: LD_INT 3
17835: ARRAY
17836: PUSH
17837: LD_INT 1
17839: ARRAY
17840: PPUSH
17841: LD_EXP 15
17845: PUSH
17846: LD_VAR 0 3
17850: ARRAY
17851: PUSH
17852: LD_INT 3
17854: ARRAY
17855: PUSH
17856: LD_INT 2
17858: ARRAY
17859: PPUSH
17860: CALL_OW 351
17864: AND
17865: IFFALSE 17909
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
17867: LD_EXP 15
17871: PUSH
17872: LD_VAR 0 3
17876: ARRAY
17877: PUSH
17878: LD_INT 3
17880: ARRAY
17881: PUSH
17882: LD_INT 1
17884: ARRAY
17885: PPUSH
17886: LD_EXP 15
17890: PUSH
17891: LD_VAR 0 3
17895: ARRAY
17896: PUSH
17897: LD_INT 3
17899: ARRAY
17900: PUSH
17901: LD_INT 2
17903: ARRAY
17904: PPUSH
17905: CALL 5803 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
17909: LD_EXP 15
17913: PUSH
17914: LD_VAR 0 3
17918: ARRAY
17919: PUSH
17920: LD_INT 2
17922: ARRAY
17923: PUSH
17924: LD_INT 0
17926: EQUAL
17927: IFFALSE 17997
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
17929: LD_VAR 0 4
17933: PPUSH
17934: LD_EXP 15
17938: PUSH
17939: LD_VAR 0 3
17943: ARRAY
17944: PUSH
17945: LD_INT 3
17947: ARRAY
17948: PUSH
17949: LD_INT 1
17951: ARRAY
17952: PPUSH
17953: LD_EXP 15
17957: PUSH
17958: LD_VAR 0 3
17962: ARRAY
17963: PUSH
17964: LD_INT 3
17966: ARRAY
17967: PUSH
17968: LD_INT 2
17970: ARRAY
17971: PPUSH
17972: LD_EXP 15
17976: PUSH
17977: LD_VAR 0 3
17981: ARRAY
17982: PUSH
17983: LD_INT 3
17985: ARRAY
17986: PUSH
17987: LD_INT 3
17989: ARRAY
17990: PPUSH
17991: CALL 9953 0 4
17995: GO 18166
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
17997: LD_EXP 15
18001: PUSH
18002: LD_VAR 0 3
18006: ARRAY
18007: PUSH
18008: LD_INT 2
18010: ARRAY
18011: PUSH
18012: LD_INT 6
18014: EQUAL
18015: IFFALSE 18085
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
18017: LD_VAR 0 4
18021: PPUSH
18022: LD_EXP 15
18026: PUSH
18027: LD_VAR 0 3
18031: ARRAY
18032: PUSH
18033: LD_INT 3
18035: ARRAY
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: LD_EXP 15
18045: PUSH
18046: LD_VAR 0 3
18050: ARRAY
18051: PUSH
18052: LD_INT 3
18054: ARRAY
18055: PUSH
18056: LD_INT 2
18058: ARRAY
18059: PPUSH
18060: LD_EXP 15
18064: PUSH
18065: LD_VAR 0 3
18069: ARRAY
18070: PUSH
18071: LD_INT 3
18073: ARRAY
18074: PUSH
18075: LD_INT 3
18077: ARRAY
18078: PPUSH
18079: CALL 10082 0 4
18083: GO 18166
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
18085: LD_VAR 0 4
18089: PPUSH
18090: LD_EXP 15
18094: PUSH
18095: LD_VAR 0 3
18099: ARRAY
18100: PUSH
18101: LD_INT 2
18103: ARRAY
18104: PPUSH
18105: LD_EXP 15
18109: PUSH
18110: LD_VAR 0 3
18114: ARRAY
18115: PUSH
18116: LD_INT 3
18118: ARRAY
18119: PUSH
18120: LD_INT 1
18122: ARRAY
18123: PPUSH
18124: LD_EXP 15
18128: PUSH
18129: LD_VAR 0 3
18133: ARRAY
18134: PUSH
18135: LD_INT 3
18137: ARRAY
18138: PUSH
18139: LD_INT 2
18141: ARRAY
18142: PPUSH
18143: LD_EXP 15
18147: PUSH
18148: LD_VAR 0 3
18152: ARRAY
18153: PUSH
18154: LD_INT 3
18156: ARRAY
18157: PUSH
18158: LD_INT 3
18160: ARRAY
18161: PPUSH
18162: CALL 11586 0 5
// break ;
18166: GO 18170
// end ;
18168: GO 17794
18170: POP
18171: POP
// end else
18172: GO 18258
// if MREG_ForSide ( side , MREG_ToDismantle ) then
18174: LD_VAR 0 4
18178: PPUSH
18179: LD_EXP 21
18183: PPUSH
18184: CALL 5142 0 2
18188: IFFALSE 18258
// begin for i = 1 to MREG_ToDismantle do
18190: LD_ADDR_VAR 0 3
18194: PUSH
18195: DOUBLE
18196: LD_INT 1
18198: DEC
18199: ST_TO_ADDR
18200: LD_EXP 21
18204: PUSH
18205: FOR_TO
18206: IFFALSE 18256
// if MREG_ToDismantle [ i ] [ 1 ] = side then
18208: LD_EXP 21
18212: PUSH
18213: LD_VAR 0 3
18217: ARRAY
18218: PUSH
18219: LD_INT 1
18221: ARRAY
18222: PUSH
18223: LD_VAR 0 4
18227: EQUAL
18228: IFFALSE 18254
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
18230: LD_VAR 0 4
18234: PPUSH
18235: LD_EXP 21
18239: PUSH
18240: LD_VAR 0 3
18244: ARRAY
18245: PUSH
18246: LD_INT 2
18248: ARRAY
18249: PPUSH
18250: CALL 12252 0 2
// end ;
18254: GO 18205
18256: POP
18257: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18258: LD_VAR 0 4
18262: PPUSH
18263: LD_INT 30
18265: PUSH
18266: LD_INT 1
18268: PUSH
18269: EMPTY
18270: LIST
18271: LIST
18272: PPUSH
18273: CALL 0 0 2
18277: IFFALSE 18288
// MCT_CollectCrates ( side ) ;
18279: LD_VAR 0 4
18283: PPUSH
18284: CALL 7034 0 1
// end ;
18288: GO 16823
18290: POP
18291: POP
// end ;
18292: GO 16763
// end ;
18294: LD_VAR 0 2
18298: RET
// every 0 0$03 trigger mc_game_live do var i , j , un , side , b , v , c , e , f , all , eng , mech , sci , ct , tmp , at_war ;
18299: LD_EXP 32
18303: IFFALSE 20267
18305: GO 18307
18307: DISABLE
18308: LD_INT 0
18310: PPUSH
18311: PPUSH
18312: PPUSH
18313: PPUSH
18314: PPUSH
18315: PPUSH
18316: PPUSH
18317: PPUSH
18318: PPUSH
18319: PPUSH
18320: PPUSH
18321: PPUSH
18322: PPUSH
18323: PPUSH
18324: PPUSH
18325: PPUSH
// begin enable ;
18326: ENABLE
// for i = 1 to 8 do
18327: LD_ADDR_VAR 0 1
18331: PUSH
18332: DOUBLE
18333: LD_INT 1
18335: DEC
18336: ST_TO_ADDR
18337: LD_INT 8
18339: PUSH
18340: FOR_TO
18341: IFFALSE 20265
// begin if MREG_SidesList [ i ] = 0 then
18343: LD_EXP 7
18347: PUSH
18348: LD_VAR 0 1
18352: ARRAY
18353: PUSH
18354: LD_INT 0
18356: EQUAL
18357: IFFALSE 18361
// continue ;
18359: GO 18340
// at_war := false ;
18361: LD_ADDR_VAR 0 16
18365: PUSH
18366: LD_INT 0
18368: ST_TO_ADDR
// if MREG_Heal [ i ] then
18369: LD_EXP 3
18373: PUSH
18374: LD_VAR 0 1
18378: ARRAY
18379: IFFALSE 18527
// begin if MCF_Class ( i , 4 , [ ] ) then
18381: LD_VAR 0 1
18385: PPUSH
18386: LD_INT 4
18388: PPUSH
18389: EMPTY
18390: PPUSH
18391: CALL 83 0 3
18395: IFFALSE 18525
// for j in MCF_Class ( i , 4 , [ ] ) do
18397: LD_ADDR_VAR 0 2
18401: PUSH
18402: LD_VAR 0 1
18406: PPUSH
18407: LD_INT 4
18409: PPUSH
18410: EMPTY
18411: PPUSH
18412: CALL 83 0 3
18416: PUSH
18417: FOR_IN
18418: IFFALSE 18523
// if not GetTag ( j ) = 4 then
18420: LD_VAR 0 2
18424: PPUSH
18425: CALL_OW 110
18429: PUSH
18430: LD_INT 4
18432: EQUAL
18433: NOT
18434: IFFALSE 18470
// begin SetTag ( j , 4 ) ;
18436: LD_VAR 0 2
18440: PPUSH
18441: LD_INT 4
18443: PPUSH
18444: CALL_OW 109
// if IsInUnit ( j ) then
18448: LD_VAR 0 2
18452: PPUSH
18453: CALL_OW 310
18457: IFFALSE 18468
// ComExitBuilding ( j ) ;
18459: LD_VAR 0 2
18463: PPUSH
18464: CALL_OW 122
// end else
18468: GO 18521
// if not WantHeal ( j , MREG_Heal [ i ] [ 1 ] ) then
18470: LD_VAR 0 2
18474: PPUSH
18475: LD_EXP 3
18479: PUSH
18480: LD_VAR 0 1
18484: ARRAY
18485: PUSH
18486: LD_INT 1
18488: ARRAY
18489: PPUSH
18490: CALL 24761 0 2
18494: NOT
18495: IFFALSE 18521
// MCP_Heal ( j , MREG_Heal [ i ] [ 1 ] ) ;
18497: LD_VAR 0 2
18501: PPUSH
18502: LD_EXP 3
18506: PUSH
18507: LD_VAR 0 1
18511: ARRAY
18512: PUSH
18513: LD_INT 1
18515: ARRAY
18516: PPUSH
18517: CALL 25717 0 2
18521: GO 18417
18523: POP
18524: POP
// end else
18525: GO 18759
// if MCF_Class ( i , 4 , [ ] ) and MCF_Tag ( i , 4 , [ ] ) then
18527: LD_VAR 0 1
18531: PPUSH
18532: LD_INT 4
18534: PPUSH
18535: EMPTY
18536: PPUSH
18537: CALL 83 0 3
18541: PUSH
18542: LD_VAR 0 1
18546: PPUSH
18547: LD_INT 4
18549: PPUSH
18550: EMPTY
18551: PPUSH
18552: CALL 627 0 3
18556: AND
18557: IFFALSE 18759
// for j in MCF_Class ( i , 4 , [ ] ) do
18559: LD_ADDR_VAR 0 2
18563: PUSH
18564: LD_VAR 0 1
18568: PPUSH
18569: LD_INT 4
18571: PPUSH
18572: EMPTY
18573: PPUSH
18574: CALL 83 0 3
18578: PUSH
18579: FOR_IN
18580: IFFALSE 18757
// begin if GetTag ( j ) = 4 then
18582: LD_VAR 0 2
18586: PPUSH
18587: CALL_OW 110
18591: PUSH
18592: LD_INT 4
18594: EQUAL
18595: IFFALSE 18755
// begin SetTag ( j , 0 ) ;
18597: LD_VAR 0 2
18601: PPUSH
18602: LD_INT 0
18604: PPUSH
18605: CALL_OW 109
// if MCF_Lab ( i ) and not MCL_GetTechList ( i ) then
18609: LD_VAR 0 1
18613: PPUSH
18614: CALL 39 0 1
18618: PUSH
18619: LD_VAR 0 1
18623: PPUSH
18624: CALL 13982 0 1
18628: NOT
18629: AND
18630: IFFALSE 18655
// ComEnterUnit ( j , MCF_Lab ( i ) [ 1 ] ) ;
18632: LD_VAR 0 2
18636: PPUSH
18637: LD_VAR 0 1
18641: PPUSH
18642: CALL 39 0 1
18646: PUSH
18647: LD_INT 1
18649: ARRAY
18650: PPUSH
18651: CALL_OW 120
// if not MCF_Lab ( i ) and MCF_Get ( i , [ f_btype , b_warehouse ] ) then
18655: LD_VAR 0 1
18659: PPUSH
18660: CALL 39 0 1
18664: NOT
18665: PUSH
18666: LD_VAR 0 1
18670: PPUSH
18671: LD_INT 30
18673: PUSH
18674: LD_INT 1
18676: PUSH
18677: EMPTY
18678: LIST
18679: LIST
18680: PPUSH
18681: CALL 0 0 2
18685: AND
18686: IFFALSE 18755
// ComMoveXY ( j , GetX ( MCF_Get ( i , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( i , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18688: LD_VAR 0 2
18692: PPUSH
18693: LD_VAR 0 1
18697: PPUSH
18698: LD_INT 30
18700: PUSH
18701: LD_INT 1
18703: PUSH
18704: EMPTY
18705: LIST
18706: LIST
18707: PPUSH
18708: CALL 0 0 2
18712: PUSH
18713: LD_INT 1
18715: ARRAY
18716: PPUSH
18717: CALL_OW 250
18721: PPUSH
18722: LD_VAR 0 1
18726: PPUSH
18727: LD_INT 30
18729: PUSH
18730: LD_INT 1
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: PPUSH
18737: CALL 0 0 2
18741: PUSH
18742: LD_INT 1
18744: ARRAY
18745: PPUSH
18746: CALL_OW 251
18750: PPUSH
18751: CALL_OW 111
// end ; end ;
18755: GO 18579
18757: POP
18758: POP
// if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and not at_war and not MREG_Heal [ i ] and not MCL_GetTechList ( i ) and MCF_Class ( i , 4 , [ ] ) then
18759: LD_INT 1
18761: PPUSH
18762: LD_VAR 0 2
18766: PPUSH
18767: CALL_OW 255
18771: PPUSH
18772: CALL_OW 321
18776: PUSH
18777: LD_INT 2
18779: EQUAL
18780: PUSH
18781: LD_VAR 0 16
18785: NOT
18786: AND
18787: PUSH
18788: LD_EXP 3
18792: PUSH
18793: LD_VAR 0 1
18797: ARRAY
18798: NOT
18799: AND
18800: PUSH
18801: LD_VAR 0 1
18805: PPUSH
18806: CALL 13982 0 1
18810: NOT
18811: AND
18812: PUSH
18813: LD_VAR 0 1
18817: PPUSH
18818: LD_INT 4
18820: PPUSH
18821: EMPTY
18822: PPUSH
18823: CALL 83 0 3
18827: AND
18828: IFFALSE 18876
// for j in MCF_Class ( i , 4 , [ ] ) do
18830: LD_ADDR_VAR 0 2
18834: PUSH
18835: LD_VAR 0 1
18839: PPUSH
18840: LD_INT 4
18842: PPUSH
18843: EMPTY
18844: PPUSH
18845: CALL 83 0 3
18849: PUSH
18850: FOR_IN
18851: IFFALSE 18874
// MCN_Tame ( GetSide ( j ) , j ) ;
18853: LD_VAR 0 2
18857: PPUSH
18858: CALL_OW 255
18862: PPUSH
18863: LD_VAR 0 2
18867: PPUSH
18868: CALL 25049 0 2
18872: GO 18850
18874: POP
18875: POP
// if at_war then
18876: LD_VAR 0 16
18880: IFFALSE 18884
// begin end else
18882: GO 20263
// begin all := MCF_All ( i , [ ] ) ;
18884: LD_ADDR_VAR 0 10
18888: PUSH
18889: LD_VAR 0 1
18893: PPUSH
18894: EMPTY
18895: PPUSH
18896: CALL 135 0 2
18900: ST_TO_ADDR
// eng := MREG_ToDep [ i ] ;
18901: LD_ADDR_VAR 0 11
18905: PUSH
18906: LD_EXP 26
18910: PUSH
18911: LD_VAR 0 1
18915: ARRAY
18916: ST_TO_ADDR
// mech := MREG_ToFac [ i ] ;
18917: LD_ADDR_VAR 0 12
18921: PUSH
18922: LD_EXP 24
18926: PUSH
18927: LD_VAR 0 1
18931: ARRAY
18932: ST_TO_ADDR
// sci := MREG_ToLab [ i ] ;
18933: LD_ADDR_VAR 0 13
18937: PUSH
18938: LD_EXP 23
18942: PUSH
18943: LD_VAR 0 1
18947: ARRAY
18948: ST_TO_ADDR
// if not at_war and MREG_ToArm [ i ] then
18949: LD_VAR 0 16
18953: NOT
18954: PUSH
18955: LD_EXP 25
18959: PUSH
18960: LD_VAR 0 1
18964: ARRAY
18965: AND
18966: IFFALSE 18983
// MCF_RemoveClass ( i , ToArm , 1 ) ;
18968: LD_VAR 0 1
18972: PPUSH
18973: LD_STRING ToArm
18975: PPUSH
18976: LD_INT 1
18978: PPUSH
18979: CALL 2160 0 3
// if MCL_GetTechList ( i ) and MCF_Lab ( i ) and not MREG_Heal [ i ] then
18983: LD_VAR 0 1
18987: PPUSH
18988: CALL 13982 0 1
18992: PUSH
18993: LD_VAR 0 1
18997: PPUSH
18998: CALL 39 0 1
19002: AND
19003: PUSH
19004: LD_EXP 3
19008: PUSH
19009: LD_VAR 0 1
19013: ARRAY
19014: NOT
19015: AND
19016: IFFALSE 19448
// begin for j = 1 to MCF_Lab ( i ) do
19018: LD_ADDR_VAR 0 2
19022: PUSH
19023: DOUBLE
19024: LD_INT 1
19026: DEC
19027: ST_TO_ADDR
19028: LD_VAR 0 1
19032: PPUSH
19033: CALL 39 0 1
19037: PUSH
19038: FOR_TO
19039: IFFALSE 19099
// if BuildingStatus ( MCF_Lab ( i ) [ j ] ) in [ bs_working , bs_need_people ] then
19041: LD_VAR 0 1
19045: PPUSH
19046: CALL 39 0 1
19050: PUSH
19051: LD_VAR 0 2
19055: ARRAY
19056: PPUSH
19057: CALL_OW 461
19061: PUSH
19062: LD_INT 3
19064: PUSH
19065: LD_INT 6
19067: PUSH
19068: EMPTY
19069: LIST
19070: LIST
19071: IN
19072: IFFALSE 19097
// begin b := MCF_Lab ( i ) [ j ] ;
19074: LD_ADDR_VAR 0 5
19078: PUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: CALL 39 0 1
19088: PUSH
19089: LD_VAR 0 2
19093: ARRAY
19094: ST_TO_ADDR
// break ;
19095: GO 19099
// end ;
19097: GO 19038
19099: POP
19100: POP
// if MCF_Class ( i , 4 , [ ] ) then
19101: LD_VAR 0 1
19105: PPUSH
19106: LD_INT 4
19108: PPUSH
19109: EMPTY
19110: PPUSH
19111: CALL 83 0 3
19115: IFFALSE 19290
// for j in MCF_Class ( i , 4 , [ ] ) do
19117: LD_ADDR_VAR 0 2
19121: PUSH
19122: LD_VAR 0 1
19126: PPUSH
19127: LD_INT 4
19129: PPUSH
19130: EMPTY
19131: PPUSH
19132: CALL 83 0 3
19136: PUSH
19137: FOR_IN
19138: IFFALSE 19288
// begin if GetTag ( j ) = 0 then
19140: LD_VAR 0 2
19144: PPUSH
19145: CALL_OW 110
19149: PUSH
19150: LD_INT 0
19152: EQUAL
19153: IFFALSE 19244
// begin if IsInUnit ( j ) and b then
19155: LD_VAR 0 2
19159: PPUSH
19160: CALL_OW 310
19164: PUSH
19165: LD_VAR 0 5
19169: AND
19170: IFFALSE 19218
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
19172: LD_VAR 0 2
19176: PPUSH
19177: CALL_OW 310
19181: PPUSH
19182: CALL_OW 461
19186: PUSH
19187: LD_INT 2
19189: EQUAL
19190: PUSH
19191: LD_VAR 0 2
19195: PPUSH
19196: CALL_OW 310
19200: PUSH
19201: LD_VAR 0 5
19205: NONEQUAL
19206: AND
19207: IFFALSE 19218
// ComExitBuilding ( j ) ;
19209: LD_VAR 0 2
19213: PPUSH
19214: CALL_OW 122
// if not IsInUnit ( j ) then
19218: LD_VAR 0 2
19222: PPUSH
19223: CALL_OW 310
19227: NOT
19228: IFFALSE 19244
// ComEnterUnit ( j , b ) ;
19230: LD_VAR 0 2
19234: PPUSH
19235: LD_VAR 0 5
19239: PPUSH
19240: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched then
19244: LD_INT 1
19246: PPUSH
19247: LD_VAR 0 2
19251: PPUSH
19252: CALL_OW 255
19256: PPUSH
19257: CALL_OW 321
19261: PUSH
19262: LD_INT 2
19264: EQUAL
19265: IFFALSE 19286
// MCN_Tame ( GetSide ( j ) , j ) ;
19267: LD_VAR 0 2
19271: PPUSH
19272: CALL_OW 255
19276: PPUSH
19277: LD_VAR 0 2
19281: PPUSH
19282: CALL 25049 0 2
// end ;
19286: GO 19137
19288: POP
19289: POP
// if all > 6 then
19290: LD_VAR 0 10
19294: PUSH
19295: LD_INT 6
19297: GREATER
19298: IFFALSE 19406
// begin if sci < 6 then
19300: LD_VAR 0 13
19304: PUSH
19305: LD_INT 6
19307: LESS
19308: IFFALSE 19404
// begin if MCF_Get ( i , [ f_btype , b_warehouse ] ) then
19310: LD_VAR 0 1
19314: PPUSH
19315: LD_INT 30
19317: PUSH
19318: LD_INT 1
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: PPUSH
19325: CALL 0 0 2
19329: IFFALSE 19346
// MCF_RemoveClass ( i , ToDep , 1 ) ;
19331: LD_VAR 0 1
19335: PPUSH
19336: LD_STRING ToDep
19338: PPUSH
19339: LD_INT 1
19341: PPUSH
19342: CALL 2160 0 3
// if MCF_Get ( i , [ f_btype , b_factory ] ) = 0 then
19346: LD_VAR 0 1
19350: PPUSH
19351: LD_INT 30
19353: PUSH
19354: LD_INT 3
19356: PUSH
19357: EMPTY
19358: LIST
19359: LIST
19360: PPUSH
19361: CALL 0 0 2
19365: PUSH
19366: LD_INT 0
19368: EQUAL
19369: IFFALSE 19386
// MCF_RemoveClass ( i , ToFac , 1 ) ;
19371: LD_VAR 0 1
19375: PPUSH
19376: LD_STRING ToFac
19378: PPUSH
19379: LD_INT 1
19381: PPUSH
19382: CALL 2160 0 3
// MCH_TrainScientist ( i , 6 - sci ) ;
19386: LD_VAR 0 1
19390: PPUSH
19391: LD_INT 6
19393: PUSH
19394: LD_VAR 0 13
19398: MINUS
19399: PPUSH
19400: CALL 22456 0 2
// end ; end else
19404: GO 19446
// if sci < all - 1 then
19406: LD_VAR 0 13
19410: PUSH
19411: LD_VAR 0 10
19415: PUSH
19416: LD_INT 1
19418: MINUS
19419: LESS
19420: IFFALSE 19446
// MCH_TrainScientist ( i , ( all - 1 ) - sci ) ;
19422: LD_VAR 0 1
19426: PPUSH
19427: LD_VAR 0 10
19431: PUSH
19432: LD_INT 1
19434: MINUS
19435: PUSH
19436: LD_VAR 0 13
19440: MINUS
19441: PPUSH
19442: CALL 22456 0 2
// end else
19446: GO 19542
// if MCL_GetTechList ( i ) = 0 then
19448: LD_VAR 0 1
19452: PPUSH
19453: CALL 13982 0 1
19457: PUSH
19458: LD_INT 0
19460: EQUAL
19461: IFFALSE 19542
// begin if all <= 6 then
19463: LD_VAR 0 10
19467: PUSH
19468: LD_INT 6
19470: LESSEQUAL
19471: IFFALSE 19490
// MCF_RemoveClass ( i , ToLab , 1 ) else
19473: LD_VAR 0 1
19477: PPUSH
19478: LD_STRING ToLab
19480: PPUSH
19481: LD_INT 1
19483: PPUSH
19484: CALL 2160 0 3
19488: GO 19542
// if all > 6 and all < 12 then
19490: LD_VAR 0 10
19494: PUSH
19495: LD_INT 6
19497: GREATER
19498: PUSH
19499: LD_VAR 0 10
19503: PUSH
19504: LD_INT 12
19506: LESS
19507: AND
19508: IFFALSE 19527
// MCF_RemoveClass ( i , ToLab , 2 ) else
19510: LD_VAR 0 1
19514: PPUSH
19515: LD_STRING ToLab
19517: PPUSH
19518: LD_INT 2
19520: PPUSH
19521: CALL 2160 0 3
19525: GO 19542
// MCF_RemoveClass ( i , ToLab , 3 ) ;
19527: LD_VAR 0 1
19531: PPUSH
19532: LD_STRING ToLab
19534: PPUSH
19535: LD_INT 3
19537: PPUSH
19538: CALL 2160 0 3
// end ; if MCF_Get ( i , [ f_btype , b_factory ] ) then
19542: LD_VAR 0 1
19546: PPUSH
19547: LD_INT 30
19549: PUSH
19550: LD_INT 3
19552: PUSH
19553: EMPTY
19554: LIST
19555: LIST
19556: PPUSH
19557: CALL 0 0 2
19561: IFFALSE 20099
// begin b := MCF_Get ( i , [ f_btype , b_factory ] ) [ 1 ] ;
19563: LD_ADDR_VAR 0 5
19567: PUSH
19568: LD_VAR 0 1
19572: PPUSH
19573: LD_INT 30
19575: PUSH
19576: LD_INT 3
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: PPUSH
19583: CALL 0 0 2
19587: PUSH
19588: LD_INT 1
19590: ARRAY
19591: ST_TO_ADDR
// if MCF_Class ( i , 3 , [ f_not , [ f_inside ] ] ) then
19592: LD_VAR 0 1
19596: PPUSH
19597: LD_INT 3
19599: PPUSH
19600: LD_INT 3
19602: PUSH
19603: LD_INT 54
19605: PUSH
19606: EMPTY
19607: LIST
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: PPUSH
19613: CALL 83 0 3
19617: IFFALSE 19686
// for j in MCF_Class ( i , 3 , [ f_not , [ f_inside ] ] ) do
19619: LD_ADDR_VAR 0 2
19623: PUSH
19624: LD_VAR 0 1
19628: PPUSH
19629: LD_INT 3
19631: PPUSH
19632: LD_INT 3
19634: PUSH
19635: LD_INT 54
19637: PUSH
19638: EMPTY
19639: LIST
19640: PUSH
19641: EMPTY
19642: LIST
19643: LIST
19644: PPUSH
19645: CALL 83 0 3
19649: PUSH
19650: FOR_IN
19651: IFFALSE 19684
// if GetTag ( j ) = 0 then
19653: LD_VAR 0 2
19657: PPUSH
19658: CALL_OW 110
19662: PUSH
19663: LD_INT 0
19665: EQUAL
19666: IFFALSE 19682
// ComEnterUnit ( j , b ) ;
19668: LD_VAR 0 2
19672: PPUSH
19673: LD_VAR 0 5
19677: PPUSH
19678: CALL_OW 120
19682: GO 19650
19684: POP
19685: POP
// if all - sci > 1 and BuildingStatus ( b ) = bs_need_people then
19686: LD_VAR 0 10
19690: PUSH
19691: LD_VAR 0 13
19695: MINUS
19696: PUSH
19697: LD_INT 1
19699: GREATER
19700: PUSH
19701: LD_VAR 0 5
19705: PPUSH
19706: CALL_OW 461
19710: PUSH
19711: LD_INT 6
19713: EQUAL
19714: AND
19715: IFFALSE 19827
// begin if mech < 6 then
19717: LD_VAR 0 12
19721: PUSH
19722: LD_INT 6
19724: LESS
19725: IFFALSE 19827
// begin if MCF_Get ( i , [ f_btype , b_warehouse ] ) then
19727: LD_VAR 0 1
19731: PPUSH
19732: LD_INT 30
19734: PUSH
19735: LD_INT 1
19737: PUSH
19738: EMPTY
19739: LIST
19740: LIST
19741: PPUSH
19742: CALL 0 0 2
19746: IFFALSE 19763
// MCF_RemoveClass ( i , ToDep , 2 ) ;
19748: LD_VAR 0 1
19752: PPUSH
19753: LD_STRING ToDep
19755: PPUSH
19756: LD_INT 2
19758: PPUSH
19759: CALL 2160 0 3
// if all - ( sci + 1 ) > 6 then
19763: LD_VAR 0 10
19767: PUSH
19768: LD_VAR 0 13
19772: PUSH
19773: LD_INT 1
19775: PLUS
19776: MINUS
19777: PUSH
19778: LD_INT 6
19780: GREATER
19781: IFFALSE 19793
// v := 6 else
19783: LD_ADDR_VAR 0 6
19787: PUSH
19788: LD_INT 6
19790: ST_TO_ADDR
19791: GO 19813
// v := all - ( sci + 1 ) ;
19793: LD_ADDR_VAR 0 6
19797: PUSH
19798: LD_VAR 0 10
19802: PUSH
19803: LD_VAR 0 13
19807: PUSH
19808: LD_INT 1
19810: PLUS
19811: MINUS
19812: ST_TO_ADDR
// MCH_TrainMechanic ( i , v ) ;
19813: LD_VAR 0 1
19817: PPUSH
19818: LD_VAR 0 6
19822: PPUSH
19823: CALL 22218 0 2
// end ; end ; ct := MCF_Get ( i , [ f_btype , b_control_tower ] ) ;
19827: LD_ADDR_VAR 0 14
19831: PUSH
19832: LD_VAR 0 1
19836: PPUSH
19837: LD_INT 30
19839: PUSH
19840: LD_INT 36
19842: PUSH
19843: EMPTY
19844: LIST
19845: LIST
19846: PPUSH
19847: CALL 0 0 2
19851: ST_TO_ADDR
// if ct and mech and MCF_Class ( i , 3 , [ ] ) then
19852: LD_VAR 0 14
19856: PUSH
19857: LD_VAR 0 12
19861: AND
19862: PUSH
19863: LD_VAR 0 1
19867: PPUSH
19868: LD_INT 3
19870: PPUSH
19871: EMPTY
19872: PPUSH
19873: CALL 83 0 3
19877: AND
19878: IFFALSE 20006
// if MCF_Tag ( i , 9 , [ ] ) < 3 then
19880: LD_VAR 0 1
19884: PPUSH
19885: LD_INT 9
19887: PPUSH
19888: EMPTY
19889: PPUSH
19890: CALL 627 0 3
19894: PUSH
19895: LD_INT 3
19897: LESS
19898: IFFALSE 20006
// begin if mech < 3 then
19900: LD_VAR 0 12
19904: PUSH
19905: LD_INT 3
19907: LESS
19908: IFFALSE 19922
// f := mech else
19910: LD_ADDR_VAR 0 9
19914: PUSH
19915: LD_VAR 0 12
19919: ST_TO_ADDR
19920: GO 19930
// f := 3 ;
19922: LD_ADDR_VAR 0 9
19926: PUSH
19927: LD_INT 3
19929: ST_TO_ADDR
// for c = 1 to f do
19930: LD_ADDR_VAR 0 7
19934: PUSH
19935: DOUBLE
19936: LD_INT 1
19938: DEC
19939: ST_TO_ADDR
19940: LD_VAR 0 9
19944: PUSH
19945: FOR_TO
19946: IFFALSE 20004
// if GetClass ( mech [ c ] ) = 3 then
19948: LD_VAR 0 12
19952: PUSH
19953: LD_VAR 0 7
19957: ARRAY
19958: PPUSH
19959: CALL_OW 257
19963: PUSH
19964: LD_INT 3
19966: EQUAL
19967: IFFALSE 20002
// begin SetTag ( mech [ c ] , 9 ) ;
19969: LD_VAR 0 12
19973: PUSH
19974: LD_VAR 0 7
19978: ARRAY
19979: PPUSH
19980: LD_INT 9
19982: PPUSH
19983: CALL_OW 109
// ComExitBuilding ( mech [ c ] ) ;
19987: LD_VAR 0 12
19991: PUSH
19992: LD_VAR 0 7
19996: ARRAY
19997: PPUSH
19998: CALL_OW 122
// end ;
20002: GO 19945
20004: POP
20005: POP
// end ; if MCF_Tag ( i , 9 , [ ] ) then
20006: LD_VAR 0 1
20010: PPUSH
20011: LD_INT 9
20013: PPUSH
20014: EMPTY
20015: PPUSH
20016: CALL 627 0 3
20020: IFFALSE 20099
// for c in MCF_Tag ( i , 9 , [ ] ) do
20022: LD_ADDR_VAR 0 7
20026: PUSH
20027: LD_VAR 0 1
20031: PPUSH
20032: LD_INT 9
20034: PPUSH
20035: EMPTY
20036: PPUSH
20037: CALL 627 0 3
20041: PUSH
20042: FOR_IN
20043: IFFALSE 20097
// if not IsInUnit ( c ) then
20045: LD_VAR 0 7
20049: PPUSH
20050: CALL_OW 310
20054: NOT
20055: IFFALSE 20095
// if ct then
20057: LD_VAR 0 14
20061: IFFALSE 20083
// ComEnterUnit ( c , ct [ 1 ] ) else
20063: LD_VAR 0 7
20067: PPUSH
20068: LD_VAR 0 14
20072: PUSH
20073: LD_INT 1
20075: ARRAY
20076: PPUSH
20077: CALL_OW 120
20081: GO 20095
// SetTag ( c , 0 ) ;
20083: LD_VAR 0 7
20087: PPUSH
20088: LD_INT 0
20090: PPUSH
20091: CALL_OW 109
20095: GO 20042
20097: POP
20098: POP
// end ; if MCF_Get ( i , [ f_btype , b_warehouse ] ) then
20099: LD_VAR 0 1
20103: PPUSH
20104: LD_INT 30
20106: PUSH
20107: LD_INT 1
20109: PUSH
20110: EMPTY
20111: LIST
20112: LIST
20113: PPUSH
20114: CALL 0 0 2
20118: IFFALSE 20263
// begin b := MCF_Get ( i , [ f_btype , b_warehouse ] ) ;
20120: LD_ADDR_VAR 0 5
20124: PUSH
20125: LD_VAR 0 1
20129: PPUSH
20130: LD_INT 30
20132: PUSH
20133: LD_INT 1
20135: PUSH
20136: EMPTY
20137: LIST
20138: LIST
20139: PPUSH
20140: CALL 0 0 2
20144: ST_TO_ADDR
// if BuildingStatus ( b ) <> bs_build then
20145: LD_VAR 0 5
20149: PPUSH
20150: CALL_OW 461
20154: PUSH
20155: LD_INT 1
20157: NONEQUAL
20158: IFFALSE 20263
// begin if eng < all - sci - mech then
20160: LD_VAR 0 11
20164: PUSH
20165: LD_VAR 0 10
20169: PUSH
20170: LD_VAR 0 13
20174: MINUS
20175: PUSH
20176: LD_VAR 0 12
20180: MINUS
20181: LESS
20182: IFFALSE 20210
// MCH_TrainEngineer ( i , all - sci - mech ) ;
20184: LD_VAR 0 1
20188: PPUSH
20189: LD_VAR 0 10
20193: PUSH
20194: LD_VAR 0 13
20198: MINUS
20199: PUSH
20200: LD_VAR 0 12
20204: MINUS
20205: PPUSH
20206: CALL 21980 0 2
// if UnitsInside ( b ) and MCF_UnfinishedBuilding ( i ) then
20210: LD_VAR 0 5
20214: PPUSH
20215: CALL_OW 313
20219: PUSH
20220: LD_VAR 0 1
20224: PPUSH
20225: CALL 3022 0 1
20229: AND
20230: IFFALSE 20263
// for e in UnitsInside ( b ) do
20232: LD_ADDR_VAR 0 8
20236: PUSH
20237: LD_VAR 0 5
20241: PPUSH
20242: CALL_OW 313
20246: PUSH
20247: FOR_IN
20248: IFFALSE 20261
// ComExitBuilding ( e ) ;
20250: LD_VAR 0 8
20254: PPUSH
20255: CALL_OW 122
20259: GO 20247
20261: POP
20262: POP
// end ; end ; end ; end ;
20263: GO 18340
20265: POP
20266: POP
// end ; end_of_file
20267: PPOPN 16
20269: END
// on SailEvent ( event ) do begin if isEditor then
20270: LD_INT 1
20272: IFFALSE 20283
// MC_Show ( event ) ;
20274: LD_VAR 0 1
20278: PPUSH
20279: CALL 3814 0 1
// end ;
20283: PPOPN 1
20285: END
// on BuildingStarted ( b , unit ) do var side , i ;
20286: LD_INT 0
20288: PPUSH
20289: PPUSH
// begin side := GetSide ( b ) ;
20290: LD_ADDR_VAR 0 3
20294: PUSH
20295: LD_VAR 0 1
20299: PPUSH
20300: CALL_OW 255
20304: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
20305: LD_VAR 0 3
20309: PPUSH
20310: LD_INT 21
20312: PUSH
20313: LD_INT 3
20315: PUSH
20316: EMPTY
20317: LIST
20318: LIST
20319: PPUSH
20320: CALL 0 0 2
20324: PUSH
20325: LD_INT 1
20327: EQUAL
20328: IFFALSE 20419
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
20330: LD_ADDR_VAR 0 4
20334: PUSH
20335: LD_VAR 0 3
20339: PPUSH
20340: LD_INT 21
20342: PUSH
20343: LD_INT 1
20345: PUSH
20346: EMPTY
20347: LIST
20348: LIST
20349: PPUSH
20350: CALL 0 0 2
20354: PUSH
20355: LD_VAR 0 3
20359: PPUSH
20360: LD_INT 2
20362: PPUSH
20363: EMPTY
20364: PPUSH
20365: CALL 83 0 3
20369: DIFF
20370: PUSH
20371: FOR_IN
20372: IFFALSE 20417
// if not HasTask ( i ) then
20374: LD_VAR 0 4
20378: PPUSH
20379: CALL_OW 314
20383: NOT
20384: IFFALSE 20415
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
20386: LD_VAR 0 4
20390: PPUSH
20391: LD_VAR 0 1
20395: PPUSH
20396: CALL_OW 250
20400: PPUSH
20401: LD_VAR 0 1
20405: PPUSH
20406: CALL_OW 251
20410: PPUSH
20411: CALL_OW 111
20415: GO 20371
20417: POP
20418: POP
// end ;
20419: PPOPN 4
20421: END
// on BuildingComplete ( b ) do begin MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
20422: LD_ADDR_EXP 15
20426: PUSH
20427: LD_EXP 15
20431: PPUSH
20432: LD_VAR 0 1
20436: PPUSH
20437: CALL_OW 255
20441: PPUSH
20442: LD_VAR 0 1
20446: PPUSH
20447: CALL_OW 266
20451: PPUSH
20452: LD_VAR 0 1
20456: PPUSH
20457: CALL_OW 250
20461: PUSH
20462: LD_VAR 0 1
20466: PPUSH
20467: CALL_OW 251
20471: PUSH
20472: LD_VAR 0 1
20476: PPUSH
20477: CALL_OW 254
20481: PUSH
20482: EMPTY
20483: LIST
20484: LIST
20485: LIST
20486: PPUSH
20487: CALL 4139 0 4
20491: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
20492: LD_VAR 0 1
20496: PPUSH
20497: CALL_OW 266
20501: PUSH
20502: LD_INT 6
20504: EQUAL
20505: IFFALSE 20539
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
20507: LD_ADDR_EXP 8
20511: PUSH
20512: LD_EXP 8
20516: PPUSH
20517: LD_VAR 0 1
20521: PPUSH
20522: CALL_OW 255
20526: PPUSH
20527: LD_VAR 0 1
20531: PPUSH
20532: EMPTY
20533: PPUSH
20534: CALL 4048 0 4
20538: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
20539: LD_VAR 0 1
20543: PPUSH
20544: CALL_OW 266
20548: PUSH
20549: LD_INT 0
20551: EQUAL
20552: IFFALSE 20662
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
20554: LD_ADDR_EXP 17
20558: PUSH
20559: LD_EXP 17
20563: PPUSH
20564: LD_VAR 0 1
20568: PPUSH
20569: CALL_OW 255
20573: PPUSH
20574: LD_INT 0
20576: PPUSH
20577: EMPTY
20578: PPUSH
20579: CALL 4048 0 4
20583: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
20584: LD_VAR 0 1
20588: PPUSH
20589: CALL_OW 274
20593: PPUSH
20594: LD_INT 1
20596: PPUSH
20597: LD_EXP 31
20601: PUSH
20602: LD_INT 1
20604: ARRAY
20605: PPUSH
20606: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
20610: LD_VAR 0 1
20614: PPUSH
20615: CALL_OW 274
20619: PPUSH
20620: LD_INT 2
20622: PPUSH
20623: LD_EXP 31
20627: PUSH
20628: LD_INT 2
20630: ARRAY
20631: PPUSH
20632: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
20636: LD_VAR 0 1
20640: PPUSH
20641: CALL_OW 274
20645: PPUSH
20646: LD_INT 3
20648: PPUSH
20649: LD_EXP 31
20653: PUSH
20654: LD_INT 3
20656: ARRAY
20657: PPUSH
20658: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
20662: LD_VAR 0 1
20666: PPUSH
20667: CALL_OW 266
20671: PUSH
20672: LD_INT 2
20674: EQUAL
20675: IFFALSE 20707
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
20677: LD_ADDR_EXP 17
20681: PUSH
20682: LD_EXP 17
20686: PPUSH
20687: LD_VAR 0 1
20691: PPUSH
20692: CALL_OW 255
20696: PPUSH
20697: LD_INT 2
20699: PPUSH
20700: EMPTY
20701: PPUSH
20702: CALL 4048 0 4
20706: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
20707: LD_VAR 0 1
20711: PPUSH
20712: CALL_OW 266
20716: PUSH
20717: LD_INT 4
20719: EQUAL
20720: IFFALSE 20752
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
20722: LD_ADDR_EXP 17
20726: PUSH
20727: LD_EXP 17
20731: PPUSH
20732: LD_VAR 0 1
20736: PPUSH
20737: CALL_OW 255
20741: PPUSH
20742: LD_INT 4
20744: PPUSH
20745: EMPTY
20746: PPUSH
20747: CALL 4048 0 4
20751: ST_TO_ADDR
// end ;
20752: PPOPN 1
20754: END
// on ResearchComplete ( tech , lab ) do var i ;
20755: LD_INT 0
20757: PPUSH
// begin for i = 1 to MREG_ToRes do
20758: LD_ADDR_VAR 0 3
20762: PUSH
20763: DOUBLE
20764: LD_INT 1
20766: DEC
20767: ST_TO_ADDR
20768: LD_EXP 19
20772: PUSH
20773: FOR_TO
20774: IFFALSE 20861
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
20776: LD_EXP 19
20780: PUSH
20781: LD_VAR 0 3
20785: ARRAY
20786: PUSH
20787: LD_INT 1
20789: ARRAY
20790: PUSH
20791: LD_VAR 0 2
20795: PPUSH
20796: CALL_OW 255
20800: EQUAL
20801: PUSH
20802: LD_EXP 19
20806: PUSH
20807: LD_VAR 0 3
20811: ARRAY
20812: PUSH
20813: LD_INT 2
20815: ARRAY
20816: PUSH
20817: LD_VAR 0 1
20821: EQUAL
20822: AND
20823: IFFALSE 20859
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
20825: LD_ADDR_EXP 19
20829: PUSH
20830: LD_EXP 19
20834: PPUSH
20835: LD_VAR 0 2
20839: PPUSH
20840: CALL_OW 255
20844: PPUSH
20845: LD_VAR 0 1
20849: PPUSH
20850: EMPTY
20851: PPUSH
20852: CALL 4139 0 4
20856: ST_TO_ADDR
// break ;
20857: GO 20861
// end ;
20859: GO 20773
20861: POP
20862: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
20863: LD_VAR 0 1
20867: PUSH
20868: LD_INT 2
20870: PUSH
20871: LD_INT 11
20873: PUSH
20874: LD_INT 4
20876: PUSH
20877: LD_INT 3
20879: PUSH
20880: EMPTY
20881: LIST
20882: LIST
20883: LIST
20884: LIST
20885: IN
20886: IFFALSE 21003
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
20888: LD_ADDR_VAR 0 3
20892: PUSH
20893: LD_VAR 0 2
20897: PPUSH
20898: CALL_OW 255
20902: PPUSH
20903: LD_INT 16
20905: PPUSH
20906: LD_INT 25
20908: PUSH
20909: LD_INT 4
20911: PUSH
20912: EMPTY
20913: LIST
20914: LIST
20915: PPUSH
20916: CALL 627 0 3
20920: ST_TO_ADDR
// if i then
20921: LD_VAR 0 3
20925: IFFALSE 20943
// SetTag ( i [ 1 ] , 0 ) ;
20927: LD_VAR 0 3
20931: PUSH
20932: LD_INT 1
20934: ARRAY
20935: PPUSH
20936: LD_INT 0
20938: PPUSH
20939: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
20943: LD_ADDR_VAR 0 3
20947: PUSH
20948: LD_VAR 0 2
20952: PPUSH
20953: CALL_OW 255
20957: PPUSH
20958: LD_INT 171
20960: PPUSH
20961: EMPTY
20962: PPUSH
20963: CALL 627 0 3
20967: ST_TO_ADDR
// if i then
20968: LD_VAR 0 3
20972: IFFALSE 21003
// begin SetTag ( i [ 1 ] , 0 ) ;
20974: LD_VAR 0 3
20978: PUSH
20979: LD_INT 1
20981: ARRAY
20982: PPUSH
20983: LD_INT 0
20985: PPUSH
20986: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
20990: LD_VAR 0 3
20994: PUSH
20995: LD_INT 1
20997: ARRAY
20998: PPUSH
20999: CALL_OW 122
// end ; end ; end ;
21003: PPOPN 3
21005: END
// on VehicleConstructed ( veh , b ) do var i , side ;
21006: LD_INT 0
21008: PPUSH
21009: PPUSH
// begin side := GetSide ( veh ) ;
21010: LD_ADDR_VAR 0 4
21014: PUSH
21015: LD_VAR 0 1
21019: PPUSH
21020: CALL_OW 255
21024: ST_TO_ADDR
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
21025: LD_VAR 0 1
21029: PPUSH
21030: CALL_OW 264
21034: PUSH
21035: LD_INT 13
21037: PUSH
21038: LD_INT 12
21040: PUSH
21041: LD_INT 14
21043: PUSH
21044: LD_INT 51
21046: PUSH
21047: LD_INT 53
21049: PUSH
21050: LD_INT 52
21052: PUSH
21053: LD_INT 32
21055: PUSH
21056: EMPTY
21057: LIST
21058: LIST
21059: LIST
21060: LIST
21061: LIST
21062: LIST
21063: LIST
21064: IN
21065: NOT
21066: IFFALSE 21108
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
21068: LD_ADDR_EXP 28
21072: PUSH
21073: LD_EXP 28
21077: PPUSH
21078: LD_VAR 0 4
21082: PPUSH
21083: LD_EXP 28
21087: PUSH
21088: LD_VAR 0 4
21092: ARRAY
21093: PUSH
21094: LD_INT 1
21096: PLUS
21097: PPUSH
21098: LD_VAR 0 1
21102: PPUSH
21103: CALL 23459 0 4
21107: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 264
21117: PUSH
21118: LD_INT 31
21120: EQUAL
21121: IFFALSE 21140
// SetTag ( GetDriver ( veh ) , 9 ) ;
21123: LD_VAR 0 1
21127: PPUSH
21128: CALL 24070 0 1
21132: PPUSH
21133: LD_INT 9
21135: PPUSH
21136: CALL_OW 109
// MCV_Parking ( GetSide ( veh ) , veh ) ;
21140: LD_VAR 0 1
21144: PPUSH
21145: CALL_OW 255
21149: PPUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: CALL 14671 0 2
// end ;
21159: PPOPN 4
21161: END
// on ApemanTamed ( ape , unit ) do begin if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
21162: LD_INT 11
21164: PPUSH
21165: LD_VAR 0 2
21169: PPUSH
21170: CALL_OW 255
21174: PPUSH
21175: CALL_OW 321
21179: PUSH
21180: LD_INT 2
21182: EQUAL
21183: NOT
21184: PUSH
21185: LD_INT 2
21187: PPUSH
21188: LD_VAR 0 2
21192: PPUSH
21193: CALL_OW 255
21197: PPUSH
21198: CALL_OW 321
21202: PUSH
21203: LD_INT 2
21205: EQUAL
21206: NOT
21207: OR
21208: PUSH
21209: LD_VAR 0 2
21213: PPUSH
21214: CALL_OW 255
21218: PPUSH
21219: LD_INT 171
21221: PPUSH
21222: EMPTY
21223: PPUSH
21224: CALL 627 0 3
21228: PUSH
21229: LD_INT 0
21231: EQUAL
21232: AND
21233: IFFALSE 21247
// begin SetTag ( ape , 171 ) ;
21235: LD_VAR 0 1
21239: PPUSH
21240: LD_INT 171
21242: PPUSH
21243: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
21247: LD_VAR 0 2
21251: PPUSH
21252: CALL_OW 255
21256: PPUSH
21257: LD_INT 30
21259: PUSH
21260: LD_INT 1
21262: PUSH
21263: EMPTY
21264: LIST
21265: LIST
21266: PPUSH
21267: CALL 0 0 2
21271: IFFALSE 21350
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
21273: LD_VAR 0 1
21277: PPUSH
21278: LD_VAR 0 2
21282: PPUSH
21283: CALL_OW 255
21287: PPUSH
21288: LD_INT 30
21290: PUSH
21291: LD_INT 1
21293: PUSH
21294: EMPTY
21295: LIST
21296: LIST
21297: PPUSH
21298: CALL 0 0 2
21302: PUSH
21303: LD_INT 1
21305: ARRAY
21306: PPUSH
21307: CALL_OW 250
21311: PPUSH
21312: LD_VAR 0 2
21316: PPUSH
21317: CALL_OW 255
21321: PPUSH
21322: LD_INT 30
21324: PUSH
21325: LD_INT 1
21327: PUSH
21328: EMPTY
21329: LIST
21330: LIST
21331: PPUSH
21332: CALL 0 0 2
21336: PUSH
21337: LD_INT 1
21339: ARRAY
21340: PPUSH
21341: CALL_OW 251
21345: PPUSH
21346: CALL_OW 111
// end ;
21350: PPOPN 2
21352: END
// on EnterBuilding ( b , un ) do begin if un in MCF_Ape ( GetSide ( un ) ) then
21353: LD_VAR 0 2
21357: PUSH
21358: LD_VAR 0 2
21362: PPUSH
21363: CALL_OW 255
21367: PPUSH
21368: CALL 337 0 1
21372: IN
21373: IFFALSE 21523
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
21375: LD_VAR 0 1
21379: PPUSH
21380: CALL_OW 266
21384: PUSH
21385: LD_INT 0
21387: PUSH
21388: LD_INT 1
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: IN
21395: IFFALSE 21425
// begin Wait ( 0 0$0.3 ) ;
21397: LD_INT 10
21399: PPUSH
21400: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
21404: LD_VAR 0 2
21408: PPUSH
21409: LD_INT 16
21411: PPUSH
21412: CALL_OW 336
// ComExitBuilding ( un ) ;
21416: LD_VAR 0 2
21420: PPUSH
21421: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
21425: LD_VAR 0 1
21429: PPUSH
21430: CALL_OW 266
21434: PUSH
21435: LD_INT 4
21437: PUSH
21438: LD_INT 5
21440: PUSH
21441: EMPTY
21442: LIST
21443: LIST
21444: IN
21445: IFFALSE 21523
// begin Wait ( 0 0$0.3 ) ;
21447: LD_INT 10
21449: PPUSH
21450: CALL_OW 67
// if GetTag ( un ) = 0 then
21454: LD_VAR 0 2
21458: PPUSH
21459: CALL_OW 110
21463: PUSH
21464: LD_INT 0
21466: EQUAL
21467: IFFALSE 21483
// SetClass ( un , class_apeman_soldier ) else
21469: LD_VAR 0 2
21473: PPUSH
21474: LD_INT 15
21476: PPUSH
21477: CALL_OW 336
21481: GO 21514
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
21483: LD_INT 3
21485: PPUSH
21486: LD_VAR 0 2
21490: PPUSH
21491: CALL_OW 255
21495: PPUSH
21496: CALL_OW 321
21500: IFFALSE 21514
// SetClass ( un , class_apeman_kamikaze ) ;
21502: LD_VAR 0 2
21506: PPUSH
21507: LD_INT 17
21509: PPUSH
21510: CALL_OW 336
// ComExitBuilding ( un ) ;
21514: LD_VAR 0 2
21518: PPUSH
21519: CALL_OW 122
// end ; end ; end ;
21523: PPOPN 2
21525: END
// on UnitDestroyed ( un ) do begin if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
21526: LD_VAR 0 1
21530: PUSH
21531: LD_VAR 0 1
21535: PPUSH
21536: CALL_OW 255
21540: PPUSH
21541: LD_INT 21
21543: PUSH
21544: LD_INT 1
21546: PUSH
21547: EMPTY
21548: LIST
21549: LIST
21550: PPUSH
21551: CALL 0 0 2
21555: IN
21556: IFFALSE 21712
// begin if MCF_HasClass ( un ) then
21558: LD_VAR 0 1
21562: PPUSH
21563: CALL 2478 0 1
21567: IFFALSE 21712
// case MCF_HasClass ( un ) of 1 :
21569: LD_VAR 0 1
21573: PPUSH
21574: CALL 2478 0 1
21578: PUSH
21579: LD_INT 1
21581: DOUBLE
21582: EQUAL
21583: IFTRUE 21587
21585: GO 21612
21587: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
21588: LD_VAR 0 1
21592: PPUSH
21593: CALL_OW 255
21597: PPUSH
21598: LD_STRING ToArm
21600: PPUSH
21601: LD_VAR 0 1
21605: PPUSH
21606: CALL 2625 0 3
21610: GO 21712
21612: LD_INT 2
21614: DOUBLE
21615: EQUAL
21616: IFTRUE 21620
21618: GO 21645
21620: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
21621: LD_VAR 0 1
21625: PPUSH
21626: CALL_OW 255
21630: PPUSH
21631: LD_STRING ToDep
21633: PPUSH
21634: LD_VAR 0 1
21638: PPUSH
21639: CALL 2625 0 3
21643: GO 21712
21645: LD_INT 3
21647: DOUBLE
21648: EQUAL
21649: IFTRUE 21653
21651: GO 21678
21653: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
21654: LD_VAR 0 1
21658: PPUSH
21659: CALL_OW 255
21663: PPUSH
21664: LD_STRING ToFac
21666: PPUSH
21667: LD_VAR 0 1
21671: PPUSH
21672: CALL 2625 0 3
21676: GO 21712
21678: LD_INT 4
21680: DOUBLE
21681: EQUAL
21682: IFTRUE 21686
21684: GO 21711
21686: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
21687: LD_VAR 0 1
21691: PPUSH
21692: CALL_OW 255
21696: PPUSH
21697: LD_STRING ToLab
21699: PPUSH
21700: LD_VAR 0 1
21704: PPUSH
21705: CALL 2625 0 3
21709: GO 21712
21711: POP
// end ; end ;
21712: PPOPN 1
21714: END
// on UnitGoesToRed ( un ) do begin if GetControl ( un ) = control_remote then
21715: LD_VAR 0 1
21719: PPUSH
21720: CALL_OW 263
21724: PUSH
21725: LD_INT 2
21727: EQUAL
21728: IFFALSE 21739
// ComUnlink ( un ) ;
21730: LD_VAR 0 1
21734: PPUSH
21735: CALL_OW 136
// end ; end_of_file
21739: PPOPN 1
21741: END
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
21742: LD_INT 0
21744: PPUSH
21745: PPUSH
21746: PPUSH
21747: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
21748: LD_ADDR_VAR 0 5
21752: PUSH
21753: LD_VAR 0 1
21757: PPUSH
21758: LD_INT 2
21760: PUSH
21761: LD_INT 25
21763: PUSH
21764: LD_INT 2
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: PUSH
21771: LD_INT 25
21773: PUSH
21774: LD_INT 3
21776: PUSH
21777: EMPTY
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 25
21783: PUSH
21784: LD_INT 4
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: PUSH
21791: EMPTY
21792: LIST
21793: LIST
21794: LIST
21795: LIST
21796: PPUSH
21797: CALL 0 0 2
21801: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
21802: LD_ADDR_VAR 0 5
21806: PUSH
21807: LD_VAR 0 5
21811: PPUSH
21812: LD_INT 0
21814: PPUSH
21815: CALL 2073 0 2
21819: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
21820: LD_ADDR_VAR 0 6
21824: PUSH
21825: LD_VAR 0 1
21829: PPUSH
21830: LD_VAR 0 5
21834: PPUSH
21835: LD_INT 1
21837: PPUSH
21838: CALL 1693 0 3
21842: ST_TO_ADDR
// if n > sk then
21843: LD_VAR 0 2
21847: PUSH
21848: LD_VAR 0 6
21852: GREATER
21853: IFFALSE 21865
// n := sk ;
21855: LD_ADDR_VAR 0 2
21859: PUSH
21860: LD_VAR 0 6
21864: ST_TO_ADDR
// for i = 1 to n do
21865: LD_ADDR_VAR 0 4
21869: PUSH
21870: DOUBLE
21871: LD_INT 1
21873: DEC
21874: ST_TO_ADDR
21875: LD_VAR 0 2
21879: PUSH
21880: FOR_TO
21881: IFFALSE 21973
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
21883: LD_ADDR_EXP 22
21887: PUSH
21888: LD_EXP 22
21892: PPUSH
21893: LD_VAR 0 1
21897: PPUSH
21898: LD_VAR 0 6
21902: PUSH
21903: LD_VAR 0 4
21907: ARRAY
21908: PUSH
21909: LD_INT 1
21911: ARRAY
21912: PPUSH
21913: LD_INT 1
21915: PPUSH
21916: CALL 4048 0 4
21920: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
21921: LD_ADDR_EXP 25
21925: PUSH
21926: LD_EXP 25
21930: PPUSH
21931: LD_VAR 0 1
21935: PPUSH
21936: LD_EXP 25
21940: PUSH
21941: LD_VAR 0 1
21945: ARRAY
21946: PUSH
21947: LD_INT 1
21949: PLUS
21950: PPUSH
21951: LD_VAR 0 6
21955: PUSH
21956: LD_VAR 0 4
21960: ARRAY
21961: PUSH
21962: LD_INT 1
21964: ARRAY
21965: PPUSH
21966: CALL 23459 0 4
21970: ST_TO_ADDR
// end ;
21971: GO 21880
21973: POP
21974: POP
// end ;
21975: LD_VAR 0 3
21979: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
21980: LD_INT 0
21982: PPUSH
21983: PPUSH
21984: PPUSH
21985: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
21986: LD_ADDR_VAR 0 5
21990: PUSH
21991: LD_VAR 0 1
21995: PPUSH
21996: LD_INT 2
21998: PUSH
21999: LD_INT 25
22001: PUSH
22002: LD_INT 1
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: PUSH
22009: LD_INT 25
22011: PUSH
22012: LD_INT 3
22014: PUSH
22015: EMPTY
22016: LIST
22017: LIST
22018: PUSH
22019: LD_INT 25
22021: PUSH
22022: LD_INT 4
22024: PUSH
22025: EMPTY
22026: LIST
22027: LIST
22028: PUSH
22029: EMPTY
22030: LIST
22031: LIST
22032: LIST
22033: LIST
22034: PPUSH
22035: CALL 0 0 2
22039: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
22040: LD_ADDR_VAR 0 5
22044: PUSH
22045: LD_VAR 0 5
22049: PPUSH
22050: LD_INT 0
22052: PPUSH
22053: CALL 2073 0 2
22057: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
22058: LD_ADDR_VAR 0 6
22062: PUSH
22063: LD_VAR 0 1
22067: PPUSH
22068: LD_VAR 0 5
22072: PPUSH
22073: LD_INT 2
22075: PPUSH
22076: CALL 1693 0 3
22080: ST_TO_ADDR
// if n > sk then
22081: LD_VAR 0 2
22085: PUSH
22086: LD_VAR 0 6
22090: GREATER
22091: IFFALSE 22103
// n := sk ;
22093: LD_ADDR_VAR 0 2
22097: PUSH
22098: LD_VAR 0 6
22102: ST_TO_ADDR
// for i = 1 to n do
22103: LD_ADDR_VAR 0 4
22107: PUSH
22108: DOUBLE
22109: LD_INT 1
22111: DEC
22112: ST_TO_ADDR
22113: LD_VAR 0 2
22117: PUSH
22118: FOR_TO
22119: IFFALSE 22211
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
22121: LD_ADDR_EXP 22
22125: PUSH
22126: LD_EXP 22
22130: PPUSH
22131: LD_VAR 0 1
22135: PPUSH
22136: LD_VAR 0 6
22140: PUSH
22141: LD_VAR 0 4
22145: ARRAY
22146: PUSH
22147: LD_INT 1
22149: ARRAY
22150: PPUSH
22151: LD_INT 2
22153: PPUSH
22154: CALL 4048 0 4
22158: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
22159: LD_ADDR_EXP 26
22163: PUSH
22164: LD_EXP 26
22168: PPUSH
22169: LD_VAR 0 1
22173: PPUSH
22174: LD_EXP 26
22178: PUSH
22179: LD_VAR 0 1
22183: ARRAY
22184: PUSH
22185: LD_INT 1
22187: PLUS
22188: PPUSH
22189: LD_VAR 0 6
22193: PUSH
22194: LD_VAR 0 4
22198: ARRAY
22199: PUSH
22200: LD_INT 1
22202: ARRAY
22203: PPUSH
22204: CALL 23459 0 4
22208: ST_TO_ADDR
// end ;
22209: GO 22118
22211: POP
22212: POP
// end ;
22213: LD_VAR 0 3
22217: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
22218: LD_INT 0
22220: PPUSH
22221: PPUSH
22222: PPUSH
22223: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
22224: LD_ADDR_VAR 0 5
22228: PUSH
22229: LD_VAR 0 1
22233: PPUSH
22234: LD_INT 2
22236: PUSH
22237: LD_INT 25
22239: PUSH
22240: LD_INT 1
22242: PUSH
22243: EMPTY
22244: LIST
22245: LIST
22246: PUSH
22247: LD_INT 25
22249: PUSH
22250: LD_INT 2
22252: PUSH
22253: EMPTY
22254: LIST
22255: LIST
22256: PUSH
22257: LD_INT 25
22259: PUSH
22260: LD_INT 4
22262: PUSH
22263: EMPTY
22264: LIST
22265: LIST
22266: PUSH
22267: EMPTY
22268: LIST
22269: LIST
22270: LIST
22271: LIST
22272: PPUSH
22273: CALL 0 0 2
22277: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
22278: LD_ADDR_VAR 0 5
22282: PUSH
22283: LD_VAR 0 5
22287: PPUSH
22288: LD_INT 0
22290: PPUSH
22291: CALL 2073 0 2
22295: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
22296: LD_ADDR_VAR 0 6
22300: PUSH
22301: LD_VAR 0 1
22305: PPUSH
22306: LD_VAR 0 5
22310: PPUSH
22311: LD_INT 3
22313: PPUSH
22314: CALL 1693 0 3
22318: ST_TO_ADDR
// if n > sk then
22319: LD_VAR 0 2
22323: PUSH
22324: LD_VAR 0 6
22328: GREATER
22329: IFFALSE 22341
// n := sk ;
22331: LD_ADDR_VAR 0 2
22335: PUSH
22336: LD_VAR 0 6
22340: ST_TO_ADDR
// for i = 1 to n do
22341: LD_ADDR_VAR 0 4
22345: PUSH
22346: DOUBLE
22347: LD_INT 1
22349: DEC
22350: ST_TO_ADDR
22351: LD_VAR 0 2
22355: PUSH
22356: FOR_TO
22357: IFFALSE 22449
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
22359: LD_ADDR_EXP 22
22363: PUSH
22364: LD_EXP 22
22368: PPUSH
22369: LD_VAR 0 1
22373: PPUSH
22374: LD_VAR 0 6
22378: PUSH
22379: LD_VAR 0 4
22383: ARRAY
22384: PUSH
22385: LD_INT 1
22387: ARRAY
22388: PPUSH
22389: LD_INT 3
22391: PPUSH
22392: CALL 4048 0 4
22396: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
22397: LD_ADDR_EXP 24
22401: PUSH
22402: LD_EXP 24
22406: PPUSH
22407: LD_VAR 0 1
22411: PPUSH
22412: LD_EXP 24
22416: PUSH
22417: LD_VAR 0 1
22421: ARRAY
22422: PUSH
22423: LD_INT 1
22425: PLUS
22426: PPUSH
22427: LD_VAR 0 6
22431: PUSH
22432: LD_VAR 0 4
22436: ARRAY
22437: PUSH
22438: LD_INT 1
22440: ARRAY
22441: PPUSH
22442: CALL 23459 0 4
22446: ST_TO_ADDR
// end ;
22447: GO 22356
22449: POP
22450: POP
// end ;
22451: LD_VAR 0 3
22455: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
22456: LD_INT 0
22458: PPUSH
22459: PPUSH
22460: PPUSH
22461: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] ) ;
22462: LD_ADDR_VAR 0 5
22466: PUSH
22467: LD_VAR 0 1
22471: PPUSH
22472: LD_INT 2
22474: PUSH
22475: LD_INT 25
22477: PUSH
22478: LD_INT 1
22480: PUSH
22481: EMPTY
22482: LIST
22483: LIST
22484: PUSH
22485: LD_INT 25
22487: PUSH
22488: LD_INT 2
22490: PUSH
22491: EMPTY
22492: LIST
22493: LIST
22494: PUSH
22495: LD_INT 25
22497: PUSH
22498: LD_INT 3
22500: PUSH
22501: EMPTY
22502: LIST
22503: LIST
22504: PUSH
22505: EMPTY
22506: LIST
22507: LIST
22508: LIST
22509: LIST
22510: PPUSH
22511: CALL 0 0 2
22515: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
22516: LD_ADDR_VAR 0 5
22520: PUSH
22521: LD_VAR 0 5
22525: PPUSH
22526: LD_INT 0
22528: PPUSH
22529: CALL 2073 0 2
22533: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
22534: LD_ADDR_VAR 0 6
22538: PUSH
22539: LD_VAR 0 1
22543: PPUSH
22544: LD_VAR 0 5
22548: PPUSH
22549: LD_INT 4
22551: PPUSH
22552: CALL 1693 0 3
22556: ST_TO_ADDR
// if n > sk then
22557: LD_VAR 0 2
22561: PUSH
22562: LD_VAR 0 6
22566: GREATER
22567: IFFALSE 22579
// n := sk ;
22569: LD_ADDR_VAR 0 2
22573: PUSH
22574: LD_VAR 0 6
22578: ST_TO_ADDR
// for i = 1 to n do
22579: LD_ADDR_VAR 0 4
22583: PUSH
22584: DOUBLE
22585: LD_INT 1
22587: DEC
22588: ST_TO_ADDR
22589: LD_VAR 0 2
22593: PUSH
22594: FOR_TO
22595: IFFALSE 22687
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
22597: LD_ADDR_EXP 22
22601: PUSH
22602: LD_EXP 22
22606: PPUSH
22607: LD_VAR 0 1
22611: PPUSH
22612: LD_VAR 0 6
22616: PUSH
22617: LD_VAR 0 4
22621: ARRAY
22622: PUSH
22623: LD_INT 1
22625: ARRAY
22626: PPUSH
22627: LD_INT 4
22629: PPUSH
22630: CALL 4048 0 4
22634: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
22635: LD_ADDR_EXP 23
22639: PUSH
22640: LD_EXP 23
22644: PPUSH
22645: LD_VAR 0 1
22649: PPUSH
22650: LD_EXP 23
22654: PUSH
22655: LD_VAR 0 1
22659: ARRAY
22660: PUSH
22661: LD_INT 1
22663: PLUS
22664: PPUSH
22665: LD_VAR 0 6
22669: PUSH
22670: LD_VAR 0 4
22674: ARRAY
22675: PUSH
22676: LD_INT 1
22678: ARRAY
22679: PPUSH
22680: CALL 23459 0 4
22684: ST_TO_ADDR
// end ;
22685: GO 22594
22687: POP
22688: POP
// end ;
22689: LD_VAR 0 3
22693: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
22694: LD_INT 0
22696: PPUSH
22697: PPUSH
22698: PPUSH
22699: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
22700: LD_ADDR_VAR 0 6
22704: PUSH
22705: LD_VAR 0 1
22709: PPUSH
22710: LD_INT 2
22712: PUSH
22713: LD_INT 25
22715: PUSH
22716: LD_INT 1
22718: PUSH
22719: EMPTY
22720: LIST
22721: LIST
22722: PUSH
22723: LD_INT 25
22725: PUSH
22726: LD_INT 2
22728: PUSH
22729: EMPTY
22730: LIST
22731: LIST
22732: PUSH
22733: LD_INT 25
22735: PUSH
22736: LD_INT 3
22738: PUSH
22739: EMPTY
22740: LIST
22741: LIST
22742: PUSH
22743: LD_INT 25
22745: PUSH
22746: LD_INT 4
22748: PUSH
22749: EMPTY
22750: LIST
22751: LIST
22752: PUSH
22753: EMPTY
22754: LIST
22755: LIST
22756: LIST
22757: LIST
22758: LIST
22759: PPUSH
22760: CALL 0 0 2
22764: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
22765: LD_ADDR_VAR 0 6
22769: PUSH
22770: LD_VAR 0 6
22774: PPUSH
22775: LD_INT 0
22777: PPUSH
22778: CALL 2073 0 2
22782: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
22783: LD_ADDR_VAR 0 7
22787: PUSH
22788: LD_VAR 0 1
22792: PPUSH
22793: LD_VAR 0 6
22797: PPUSH
22798: LD_INT 1
22800: PPUSH
22801: CALL 1693 0 3
22805: ST_TO_ADDR
// if n > sk then
22806: LD_VAR 0 2
22810: PUSH
22811: LD_VAR 0 7
22815: GREATER
22816: IFFALSE 22828
// n := sk ;
22818: LD_ADDR_VAR 0 2
22822: PUSH
22823: LD_VAR 0 7
22827: ST_TO_ADDR
// for i = 1 to n do
22828: LD_ADDR_VAR 0 5
22832: PUSH
22833: DOUBLE
22834: LD_INT 1
22836: DEC
22837: ST_TO_ADDR
22838: LD_VAR 0 2
22842: PUSH
22843: FOR_TO
22844: IFFALSE 22888
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
22846: LD_ADDR_EXP 22
22850: PUSH
22851: LD_EXP 22
22855: PPUSH
22856: LD_VAR 0 1
22860: PPUSH
22861: LD_VAR 0 7
22865: PUSH
22866: LD_VAR 0 5
22870: ARRAY
22871: PUSH
22872: LD_INT 1
22874: ARRAY
22875: PPUSH
22876: LD_VAR 0 3
22880: PPUSH
22881: CALL 4048 0 4
22885: ST_TO_ADDR
// end ;
22886: GO 22843
22888: POP
22889: POP
// end ;
22890: LD_VAR 0 4
22894: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
22895: LD_INT 0
22897: PPUSH
22898: PPUSH
22899: PPUSH
// b := false ;
22900: LD_ADDR_VAR 0 6
22904: PUSH
22905: LD_INT 0
22907: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
22908: LD_VAR 0 3
22912: PUSH
22913: LD_INT 1
22915: PUSH
22916: LD_INT 9
22918: PUSH
22919: LD_INT 5
22921: PUSH
22922: LD_INT 8
22924: PUSH
22925: EMPTY
22926: LIST
22927: LIST
22928: LIST
22929: LIST
22930: IN
22931: IFFALSE 23019
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
22933: LD_VAR 0 1
22937: PPUSH
22938: LD_INT 2
22940: PUSH
22941: LD_INT 30
22943: PUSH
22944: LD_INT 4
22946: PUSH
22947: EMPTY
22948: LIST
22949: LIST
22950: PUSH
22951: LD_INT 30
22953: PUSH
22954: LD_INT 5
22956: PUSH
22957: EMPTY
22958: LIST
22959: LIST
22960: PUSH
22961: EMPTY
22962: LIST
22963: LIST
22964: LIST
22965: PPUSH
22966: CALL 0 0 2
22970: IFFALSE 23019
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
22972: LD_ADDR_VAR 0 6
22976: PUSH
22977: LD_VAR 0 1
22981: PPUSH
22982: LD_INT 2
22984: PUSH
22985: LD_INT 30
22987: PUSH
22988: LD_INT 4
22990: PUSH
22991: EMPTY
22992: LIST
22993: LIST
22994: PUSH
22995: LD_INT 30
22997: PUSH
22998: LD_INT 5
23000: PUSH
23001: EMPTY
23002: LIST
23003: LIST
23004: PUSH
23005: EMPTY
23006: LIST
23007: LIST
23008: LIST
23009: PPUSH
23010: CALL 0 0 2
23014: PUSH
23015: LD_INT 1
23017: ARRAY
23018: ST_TO_ADDR
// if class = class_engineer then
23019: LD_VAR 0 3
23023: PUSH
23024: LD_INT 2
23026: EQUAL
23027: IFFALSE 23115
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23029: LD_VAR 0 1
23033: PPUSH
23034: LD_INT 2
23036: PUSH
23037: LD_INT 30
23039: PUSH
23040: LD_INT 0
23042: PUSH
23043: EMPTY
23044: LIST
23045: LIST
23046: PUSH
23047: LD_INT 30
23049: PUSH
23050: LD_INT 1
23052: PUSH
23053: EMPTY
23054: LIST
23055: LIST
23056: PUSH
23057: EMPTY
23058: LIST
23059: LIST
23060: LIST
23061: PPUSH
23062: CALL 0 0 2
23066: IFFALSE 23115
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
23068: LD_ADDR_VAR 0 6
23072: PUSH
23073: LD_VAR 0 1
23077: PPUSH
23078: LD_INT 2
23080: PUSH
23081: LD_INT 30
23083: PUSH
23084: LD_INT 0
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: PUSH
23091: LD_INT 30
23093: PUSH
23094: LD_INT 1
23096: PUSH
23097: EMPTY
23098: LIST
23099: LIST
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: LIST
23105: PPUSH
23106: CALL 0 0 2
23110: PUSH
23111: LD_INT 1
23113: ARRAY
23114: ST_TO_ADDR
// if class = class_mechanic then
23115: LD_VAR 0 3
23119: PUSH
23120: LD_INT 3
23122: EQUAL
23123: IFFALSE 23193
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
23125: LD_VAR 0 1
23129: PPUSH
23130: LD_INT 30
23132: PUSH
23133: LD_INT 3
23135: PUSH
23136: EMPTY
23137: LIST
23138: LIST
23139: PPUSH
23140: CALL 0 0 2
23144: IFFALSE 23193
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23146: LD_ADDR_VAR 0 6
23150: PUSH
23151: LD_VAR 0 1
23155: PPUSH
23156: LD_INT 2
23158: PUSH
23159: LD_INT 30
23161: PUSH
23162: LD_INT 2
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: PUSH
23169: LD_INT 30
23171: PUSH
23172: LD_INT 3
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: PUSH
23179: EMPTY
23180: LIST
23181: LIST
23182: LIST
23183: PPUSH
23184: CALL 0 0 2
23188: PUSH
23189: LD_INT 1
23191: ARRAY
23192: ST_TO_ADDR
// if class = class_scientistic then
23193: LD_VAR 0 3
23197: PUSH
23198: LD_INT 4
23200: EQUAL
23201: IFFALSE 23311
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
23203: LD_VAR 0 1
23207: PPUSH
23208: LD_INT 2
23210: PUSH
23211: LD_INT 30
23213: PUSH
23214: LD_INT 6
23216: PUSH
23217: EMPTY
23218: LIST
23219: LIST
23220: PUSH
23221: LD_INT 30
23223: PUSH
23224: LD_INT 7
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: PUSH
23231: LD_INT 30
23233: PUSH
23234: LD_INT 8
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: LIST
23245: LIST
23246: PPUSH
23247: CALL 0 0 2
23251: IFFALSE 23311
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
23253: LD_ADDR_VAR 0 6
23257: PUSH
23258: LD_VAR 0 1
23262: PPUSH
23263: LD_INT 2
23265: PUSH
23266: LD_INT 30
23268: PUSH
23269: LD_INT 6
23271: PUSH
23272: EMPTY
23273: LIST
23274: LIST
23275: PUSH
23276: LD_INT 30
23278: PUSH
23279: LD_INT 7
23281: PUSH
23282: EMPTY
23283: LIST
23284: LIST
23285: PUSH
23286: LD_INT 30
23288: PUSH
23289: LD_INT 8
23291: PUSH
23292: EMPTY
23293: LIST
23294: LIST
23295: PUSH
23296: EMPTY
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: PPUSH
23302: CALL 0 0 2
23306: PUSH
23307: LD_INT 1
23309: ARRAY
23310: ST_TO_ADDR
// if GetClass ( unit ) = class then
23311: LD_VAR 0 2
23315: PPUSH
23316: CALL_OW 257
23320: PUSH
23321: LD_VAR 0 3
23325: EQUAL
23326: IFFALSE 23360
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
23328: LD_ADDR_EXP 22
23332: PUSH
23333: LD_EXP 22
23337: PPUSH
23338: LD_VAR 0 1
23342: PPUSH
23343: LD_VAR 0 2
23347: PPUSH
23348: LD_VAR 0 3
23352: PPUSH
23353: CALL 4139 0 4
23357: ST_TO_ADDR
// end else
23358: GO 23454
// if b then
23360: LD_VAR 0 6
23364: IFFALSE 23446
// begin if IsInUnit ( unit ) and not unit in UnitsInside ( b ) then
23366: LD_VAR 0 2
23370: PPUSH
23371: CALL_OW 310
23375: PUSH
23376: LD_VAR 0 2
23380: PUSH
23381: LD_VAR 0 6
23385: PPUSH
23386: CALL_OW 313
23390: IN
23391: NOT
23392: AND
23393: IFFALSE 23404
// ComExitBuilding ( unit ) ;
23395: LD_VAR 0 2
23399: PPUSH
23400: CALL_OW 122
// if not IsInUnit ( unit ) then
23404: LD_VAR 0 2
23408: PPUSH
23409: CALL_OW 310
23413: NOT
23414: IFFALSE 23430
// AddComEnterUnit ( unit , b ) ;
23416: LD_VAR 0 2
23420: PPUSH
23421: LD_VAR 0 6
23425: PPUSH
23426: CALL_OW 180
// AddComChangeProfession ( unit , class ) ;
23430: LD_VAR 0 2
23434: PPUSH
23435: LD_VAR 0 3
23439: PPUSH
23440: CALL_OW 183
// end else
23444: GO 23454
// result := false ;
23446: LD_ADDR_VAR 0 4
23450: PUSH
23451: LD_INT 0
23453: ST_TO_ADDR
// end ; end_of_file end_of_file
23454: LD_VAR 0 4
23458: RET
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
23459: LD_INT 0
23461: PPUSH
23462: PPUSH
23463: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
23464: LD_ADDR_VAR 0 7
23468: PUSH
23469: LD_VAR 0 1
23473: PUSH
23474: LD_VAR 0 2
23478: ARRAY
23479: PPUSH
23480: LD_VAR 0 3
23484: PPUSH
23485: LD_VAR 0 4
23489: PPUSH
23490: CALL_OW 1
23494: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
23495: LD_ADDR_VAR 0 1
23499: PUSH
23500: LD_VAR 0 1
23504: PPUSH
23505: LD_VAR 0 2
23509: PPUSH
23510: LD_VAR 0 7
23514: PPUSH
23515: CALL_OW 1
23519: ST_TO_ADDR
// result := tab ;
23520: LD_ADDR_VAR 0 5
23524: PUSH
23525: LD_VAR 0 1
23529: ST_TO_ADDR
// end ;
23530: LD_VAR 0 5
23534: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
23535: LD_INT 0
23537: PPUSH
23538: PPUSH
23539: PPUSH
23540: PPUSH
// i := 1 ;
23541: LD_ADDR_VAR 0 5
23545: PUSH
23546: LD_INT 1
23548: ST_TO_ADDR
// while ( i <= tab ) do
23549: LD_VAR 0 5
23553: PUSH
23554: LD_VAR 0 1
23558: LESSEQUAL
23559: IFFALSE 23934
// begin if not tab [ i ] then
23561: LD_VAR 0 1
23565: PUSH
23566: LD_VAR 0 5
23570: ARRAY
23571: NOT
23572: IFFALSE 23576
// break ;
23574: GO 23934
// if value in tab then
23576: LD_VAR 0 2
23580: PUSH
23581: LD_VAR 0 1
23585: IN
23586: IFFALSE 23699
// begin if not mode then
23588: LD_VAR 0 3
23592: NOT
23593: IFFALSE 23613
// tab := tab diff value else
23595: LD_ADDR_VAR 0 1
23599: PUSH
23600: LD_VAR 0 1
23604: PUSH
23605: LD_VAR 0 2
23609: DIFF
23610: ST_TO_ADDR
23611: GO 23675
// for j = 1 to tab do
23613: LD_ADDR_VAR 0 6
23617: PUSH
23618: DOUBLE
23619: LD_INT 1
23621: DEC
23622: ST_TO_ADDR
23623: LD_VAR 0 1
23627: PUSH
23628: FOR_TO
23629: IFFALSE 23673
// if tab [ j ] = value then
23631: LD_VAR 0 1
23635: PUSH
23636: LD_VAR 0 6
23640: ARRAY
23641: PUSH
23642: LD_VAR 0 2
23646: EQUAL
23647: IFFALSE 23671
// begin tab := Delete ( tab , j ) ;
23649: LD_ADDR_VAR 0 1
23653: PUSH
23654: LD_VAR 0 1
23658: PPUSH
23659: LD_VAR 0 6
23663: PPUSH
23664: CALL_OW 3
23668: ST_TO_ADDR
// break ;
23669: GO 23673
// end ;
23671: GO 23628
23673: POP
23674: POP
// i := i - 1 ;
23675: LD_ADDR_VAR 0 5
23679: PUSH
23680: LD_VAR 0 5
23684: PUSH
23685: LD_INT 1
23687: MINUS
23688: ST_TO_ADDR
// if mode then
23689: LD_VAR 0 3
23693: IFFALSE 23697
// break ;
23695: GO 23934
// end else
23697: GO 23918
// if tab [ i ] and value in tab [ i ] then
23699: LD_VAR 0 1
23703: PUSH
23704: LD_VAR 0 5
23708: ARRAY
23709: PUSH
23710: LD_VAR 0 2
23714: PUSH
23715: LD_VAR 0 1
23719: PUSH
23720: LD_VAR 0 5
23724: ARRAY
23725: IN
23726: AND
23727: IFFALSE 23918
// begin if not mode then
23729: LD_VAR 0 3
23733: NOT
23734: IFFALSE 23760
// tmp := tab [ i ] diff value else
23736: LD_ADDR_VAR 0 7
23740: PUSH
23741: LD_VAR 0 1
23745: PUSH
23746: LD_VAR 0 5
23750: ARRAY
23751: PUSH
23752: LD_VAR 0 2
23756: DIFF
23757: ST_TO_ADDR
23758: GO 23840
// for j = 1 to tab [ i ] do
23760: LD_ADDR_VAR 0 6
23764: PUSH
23765: DOUBLE
23766: LD_INT 1
23768: DEC
23769: ST_TO_ADDR
23770: LD_VAR 0 1
23774: PUSH
23775: LD_VAR 0 5
23779: ARRAY
23780: PUSH
23781: FOR_TO
23782: IFFALSE 23838
// if value = tab [ i ] [ j ] then
23784: LD_VAR 0 2
23788: PUSH
23789: LD_VAR 0 1
23793: PUSH
23794: LD_VAR 0 5
23798: ARRAY
23799: PUSH
23800: LD_VAR 0 6
23804: ARRAY
23805: EQUAL
23806: IFFALSE 23836
// begin tmp := Delete ( tab [ i ] , j ) ;
23808: LD_ADDR_VAR 0 7
23812: PUSH
23813: LD_VAR 0 1
23817: PUSH
23818: LD_VAR 0 5
23822: ARRAY
23823: PPUSH
23824: LD_VAR 0 6
23828: PPUSH
23829: CALL_OW 3
23833: ST_TO_ADDR
// break ;
23834: GO 23838
// end ;
23836: GO 23781
23838: POP
23839: POP
// if tmp = [ ] then
23840: LD_VAR 0 7
23844: PUSH
23845: EMPTY
23846: EQUAL
23847: IFFALSE 23871
// begin tab := Delete ( tab , i ) ;
23849: LD_ADDR_VAR 0 1
23853: PUSH
23854: LD_VAR 0 1
23858: PPUSH
23859: LD_VAR 0 5
23863: PPUSH
23864: CALL_OW 3
23868: ST_TO_ADDR
// end else
23869: GO 23896
// tab := Replace ( tab , i , tmp ) ;
23871: LD_ADDR_VAR 0 1
23875: PUSH
23876: LD_VAR 0 1
23880: PPUSH
23881: LD_VAR 0 5
23885: PPUSH
23886: LD_VAR 0 7
23890: PPUSH
23891: CALL_OW 1
23895: ST_TO_ADDR
// i := i - 1 ;
23896: LD_ADDR_VAR 0 5
23900: PUSH
23901: LD_VAR 0 5
23905: PUSH
23906: LD_INT 1
23908: MINUS
23909: ST_TO_ADDR
// if mode then
23910: LD_VAR 0 3
23914: IFFALSE 23918
// break ;
23916: GO 23934
// end ; i := i + 1 ;
23918: LD_ADDR_VAR 0 5
23922: PUSH
23923: LD_VAR 0 5
23927: PUSH
23928: LD_INT 1
23930: PLUS
23931: ST_TO_ADDR
// end ;
23932: GO 23549
// result := tab ;
23934: LD_ADDR_VAR 0 4
23938: PUSH
23939: LD_VAR 0 1
23943: ST_TO_ADDR
// end ;
23944: LD_VAR 0 4
23948: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
23949: LD_INT 0
23951: PPUSH
23952: PPUSH
// for i = 1 to values do
23953: LD_ADDR_VAR 0 4
23957: PUSH
23958: DOUBLE
23959: LD_INT 1
23961: DEC
23962: ST_TO_ADDR
23963: LD_VAR 0 2
23967: PUSH
23968: FOR_TO
23969: IFFALSE 24002
// tab := Remove ( tab , values [ i ] , false ) ;
23971: LD_ADDR_VAR 0 1
23975: PUSH
23976: LD_VAR 0 1
23980: PPUSH
23981: LD_VAR 0 2
23985: PUSH
23986: LD_VAR 0 4
23990: ARRAY
23991: PPUSH
23992: LD_INT 0
23994: PPUSH
23995: CALL 23535 0 3
23999: ST_TO_ADDR
24000: GO 23968
24002: POP
24003: POP
// result := tab ;
24004: LD_ADDR_VAR 0 3
24008: PUSH
24009: LD_VAR 0 1
24013: ST_TO_ADDR
// end ;
24014: LD_VAR 0 3
24018: RET
// export function IsDriver ( unit ) ; begin
24019: LD_INT 0
24021: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
24022: LD_VAR 0 1
24026: PUSH
24027: LD_INT 55
24029: PUSH
24030: EMPTY
24031: LIST
24032: PPUSH
24033: CALL_OW 69
24037: IN
24038: IFFALSE 24057
// result := IsInUnit ( unit ) else
24040: LD_ADDR_VAR 0 2
24044: PUSH
24045: LD_VAR 0 1
24049: PPUSH
24050: CALL_OW 310
24054: ST_TO_ADDR
24055: GO 24065
// result := false ;
24057: LD_ADDR_VAR 0 2
24061: PUSH
24062: LD_INT 0
24064: ST_TO_ADDR
// end ;
24065: LD_VAR 0 2
24069: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
24070: LD_INT 0
24072: PPUSH
24073: PPUSH
24074: PPUSH
// if not GetControl ( veh ) = control_manual then
24075: LD_VAR 0 1
24079: PPUSH
24080: CALL_OW 263
24084: PUSH
24085: LD_INT 1
24087: EQUAL
24088: NOT
24089: IFFALSE 24101
// result := false else
24091: LD_ADDR_VAR 0 2
24095: PUSH
24096: LD_INT 0
24098: ST_TO_ADDR
24099: GO 24246
// if veh in FilterAllUnits ( [ f_empty ] ) then
24101: LD_VAR 0 1
24105: PUSH
24106: LD_INT 58
24108: PUSH
24109: EMPTY
24110: LIST
24111: PPUSH
24112: CALL_OW 69
24116: IN
24117: IFFALSE 24129
// result := false else
24119: LD_ADDR_VAR 0 2
24123: PUSH
24124: LD_INT 0
24126: ST_TO_ADDR
24127: GO 24246
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
24129: LD_ADDR_VAR 0 4
24133: PUSH
24134: LD_INT 22
24136: PUSH
24137: LD_VAR 0 1
24141: PPUSH
24142: CALL_OW 255
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: PUSH
24151: LD_INT 55
24153: PUSH
24154: EMPTY
24155: LIST
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PPUSH
24161: CALL_OW 69
24165: ST_TO_ADDR
// if not filter then
24166: LD_VAR 0 4
24170: NOT
24171: IFFALSE 24183
// result := false else
24173: LD_ADDR_VAR 0 2
24177: PUSH
24178: LD_INT 0
24180: ST_TO_ADDR
24181: GO 24246
// for i = 1 to filter do
24183: LD_ADDR_VAR 0 3
24187: PUSH
24188: DOUBLE
24189: LD_INT 1
24191: DEC
24192: ST_TO_ADDR
24193: LD_VAR 0 4
24197: PUSH
24198: FOR_TO
24199: IFFALSE 24244
// if IsDriver ( filter [ i ] ) = veh then
24201: LD_VAR 0 4
24205: PUSH
24206: LD_VAR 0 3
24210: ARRAY
24211: PPUSH
24212: CALL 24019 0 1
24216: PUSH
24217: LD_VAR 0 1
24221: EQUAL
24222: IFFALSE 24242
// begin result := filter [ i ] ;
24224: LD_ADDR_VAR 0 2
24228: PUSH
24229: LD_VAR 0 4
24233: PUSH
24234: LD_VAR 0 3
24238: ARRAY
24239: ST_TO_ADDR
// break ;
24240: GO 24244
// end ;
24242: GO 24198
24244: POP
24245: POP
// end ; end ;
24246: LD_VAR 0 2
24250: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24251: LD_INT 0
24253: PPUSH
24254: PPUSH
// if BuildingStatus ( b ) = bs_build then
24255: LD_VAR 0 2
24259: PPUSH
24260: CALL_OW 461
24264: PUSH
24265: LD_INT 1
24267: EQUAL
24268: IFFALSE 24328
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24270: LD_VAR 0 1
24274: PPUSH
24275: LD_STRING h
24277: PUSH
24278: LD_VAR 0 2
24282: PPUSH
24283: CALL_OW 250
24287: PUSH
24288: LD_VAR 0 2
24292: PPUSH
24293: CALL_OW 251
24297: PUSH
24298: LD_VAR 0 2
24302: PUSH
24303: LD_INT 0
24305: PUSH
24306: LD_INT 0
24308: PUSH
24309: LD_INT 0
24311: PUSH
24312: EMPTY
24313: LIST
24314: LIST
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: LIST
24320: PUSH
24321: EMPTY
24322: LIST
24323: PPUSH
24324: CALL_OW 446
// end ;
24328: LD_VAR 0 3
24332: RET
// export function Compare ( val1 , val2 ) ; begin
24333: LD_INT 0
24335: PPUSH
// if val1 = val2 then
24336: LD_VAR 0 1
24340: PUSH
24341: LD_VAR 0 2
24345: EQUAL
24346: IFFALSE 24358
// result := true else
24348: LD_ADDR_VAR 0 3
24352: PUSH
24353: LD_INT 1
24355: ST_TO_ADDR
24356: GO 24366
// result := false ;
24358: LD_ADDR_VAR 0 3
24362: PUSH
24363: LD_INT 0
24365: ST_TO_ADDR
// end ;
24366: LD_VAR 0 3
24370: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24371: LD_INT 0
24373: PPUSH
24374: PPUSH
// result := true ;
24375: LD_ADDR_VAR 0 3
24379: PUSH
24380: LD_INT 1
24382: ST_TO_ADDR
// if array1 = array2 then
24383: LD_VAR 0 1
24387: PUSH
24388: LD_VAR 0 2
24392: EQUAL
24393: IFFALSE 24458
// begin for i = 1 to array1 do
24395: LD_ADDR_VAR 0 4
24399: PUSH
24400: DOUBLE
24401: LD_INT 1
24403: DEC
24404: ST_TO_ADDR
24405: LD_VAR 0 1
24409: PUSH
24410: FOR_TO
24411: IFFALSE 24454
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
24413: LD_VAR 0 1
24417: PUSH
24418: LD_VAR 0 4
24422: ARRAY
24423: PPUSH
24424: LD_VAR 0 2
24428: PUSH
24429: LD_VAR 0 4
24433: ARRAY
24434: PPUSH
24435: CALL 24333 0 2
24439: NOT
24440: IFFALSE 24452
// begin result := false ;
24442: LD_ADDR_VAR 0 3
24446: PUSH
24447: LD_INT 0
24449: ST_TO_ADDR
// break ;
24450: GO 24454
// end ;
24452: GO 24410
24454: POP
24455: POP
// end else
24456: GO 24466
// result := false ;
24458: LD_ADDR_VAR 0 3
24462: PUSH
24463: LD_INT 0
24465: ST_TO_ADDR
// end ;
24466: LD_VAR 0 3
24470: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
24471: LD_INT 0
24473: PPUSH
24474: PPUSH
// result := false ;
24475: LD_ADDR_VAR 0 3
24479: PUSH
24480: LD_INT 0
24482: ST_TO_ADDR
// for j = 1 to e2 do
24483: LD_ADDR_VAR 0 4
24487: PUSH
24488: DOUBLE
24489: LD_INT 1
24491: DEC
24492: ST_TO_ADDR
24493: LD_VAR 0 2
24497: PUSH
24498: FOR_TO
24499: IFFALSE 24533
// if Compare ( e1 , e2 [ j ] ) then
24501: LD_VAR 0 1
24505: PPUSH
24506: LD_VAR 0 2
24510: PUSH
24511: LD_VAR 0 4
24515: ARRAY
24516: PPUSH
24517: CALL 24333 0 2
24521: IFFALSE 24531
// result := true ;
24523: LD_ADDR_VAR 0 3
24527: PUSH
24528: LD_INT 1
24530: ST_TO_ADDR
24531: GO 24498
24533: POP
24534: POP
// end ;
24535: LD_VAR 0 3
24539: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
24540: LD_INT 0
24542: PPUSH
24543: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
24544: LD_VAR 0 1
24548: PPUSH
24549: LD_STRING C
24551: PUSH
24552: LD_VAR 0 2
24556: PUSH
24557: LD_VAR 0 3
24561: PUSH
24562: LD_INT 0
24564: PUSH
24565: LD_INT 0
24567: PUSH
24568: LD_INT 0
24570: PUSH
24571: LD_INT 0
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: LIST
24578: LIST
24579: LIST
24580: LIST
24581: LIST
24582: PUSH
24583: LD_STRING v
24585: PUSH
24586: LD_VAR 0 4
24590: PPUSH
24591: CALL_OW 250
24595: PUSH
24596: LD_VAR 0 4
24600: PPUSH
24601: CALL_OW 251
24605: PUSH
24606: LD_VAR 0 4
24610: PUSH
24611: LD_INT 0
24613: PUSH
24614: LD_INT 0
24616: PUSH
24617: LD_INT 0
24619: PUSH
24620: EMPTY
24621: LIST
24622: LIST
24623: LIST
24624: LIST
24625: LIST
24626: LIST
24627: LIST
24628: PUSH
24629: EMPTY
24630: LIST
24631: LIST
24632: PPUSH
24633: CALL_OW 446
// end ;
24637: LD_VAR 0 5
24641: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
24642: LD_INT 0
24644: PPUSH
24645: PPUSH
24646: PPUSH
// linked := UnitsLinked ( unit ) ;
24647: LD_ADDR_VAR 0 4
24651: PUSH
24652: LD_VAR 0 1
24656: PPUSH
24657: CALL_OW 432
24661: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
24662: LD_ADDR_VAR 0 3
24666: PUSH
24667: LD_VAR 0 1
24671: PPUSH
24672: LD_INT 3
24674: PPUSH
24675: CALL_OW 259
24679: ST_TO_ADDR
// if sk > linked then
24680: LD_VAR 0 3
24684: PUSH
24685: LD_VAR 0 4
24689: GREATER
24690: IFFALSE 24702
// result := true else
24692: LD_ADDR_VAR 0 2
24696: PUSH
24697: LD_INT 1
24699: ST_TO_ADDR
24700: GO 24710
// result := false ;
24702: LD_ADDR_VAR 0 2
24706: PUSH
24707: LD_INT 0
24709: ST_TO_ADDR
// end ;
24710: LD_VAR 0 2
24714: RET
// export function NotTask ( unit ) ; begin
24715: LD_INT 0
24717: PPUSH
// result := true ;
24718: LD_ADDR_VAR 0 2
24722: PUSH
24723: LD_INT 1
24725: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
24726: LD_VAR 0 1
24730: PPUSH
24731: CALL_OW 437
24735: PUSH
24736: LD_VAR 0 1
24740: PPUSH
24741: CALL_OW 314
24745: OR
24746: IFFALSE 24756
// result := false ;
24748: LD_ADDR_VAR 0 2
24752: PUSH
24753: LD_INT 0
24755: ST_TO_ADDR
// end ;
24756: LD_VAR 0 2
24760: RET
// export function WantHeal ( sci , unit ) ; begin
24761: LD_INT 0
24763: PPUSH
// if GetTaskList ( sci ) > 0 then
24764: LD_VAR 0 1
24768: PPUSH
24769: CALL_OW 437
24773: PUSH
24774: LD_INT 0
24776: GREATER
24777: IFFALSE 24847
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
24779: LD_VAR 0 1
24783: PPUSH
24784: CALL_OW 437
24788: PUSH
24789: LD_INT 1
24791: ARRAY
24792: PUSH
24793: LD_INT 1
24795: ARRAY
24796: PUSH
24797: LD_STRING l
24799: EQUAL
24800: PUSH
24801: LD_VAR 0 1
24805: PPUSH
24806: CALL_OW 437
24810: PUSH
24811: LD_INT 1
24813: ARRAY
24814: PUSH
24815: LD_INT 4
24817: ARRAY
24818: PUSH
24819: LD_VAR 0 2
24823: EQUAL
24824: AND
24825: IFFALSE 24837
// result := true else
24827: LD_ADDR_VAR 0 3
24831: PUSH
24832: LD_INT 1
24834: ST_TO_ADDR
24835: GO 24845
// result := false ;
24837: LD_ADDR_VAR 0 3
24841: PUSH
24842: LD_INT 0
24844: ST_TO_ADDR
// end else
24845: GO 24855
// result := false ;
24847: LD_ADDR_VAR 0 3
24851: PUSH
24852: LD_INT 0
24854: ST_TO_ADDR
// end ; end_of_file
24855: LD_VAR 0 3
24859: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
24860: LD_INT 0
24862: PPUSH
24863: PPUSH
24864: PPUSH
// uc_side := 0 ;
24865: LD_ADDR_OWVAR 20
24869: PUSH
24870: LD_INT 0
24872: ST_TO_ADDR
// uc_nation := 0 ;
24873: LD_ADDR_OWVAR 21
24877: PUSH
24878: LD_INT 0
24880: ST_TO_ADDR
// for i = 1 to n do
24881: LD_ADDR_VAR 0 5
24885: PUSH
24886: DOUBLE
24887: LD_INT 1
24889: DEC
24890: ST_TO_ADDR
24891: LD_VAR 0 2
24895: PUSH
24896: FOR_TO
24897: IFFALSE 25042
// begin hc_importance := 0 ;
24899: LD_ADDR_OWVAR 32
24903: PUSH
24904: LD_INT 0
24906: ST_TO_ADDR
// hc_gallery :=  ;
24907: LD_ADDR_OWVAR 33
24911: PUSH
24912: LD_STRING 
24914: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
24915: LD_ADDR_OWVAR 35
24919: PUSH
24920: LD_VAR 0 3
24924: PUSH
24925: LD_INT 20
24927: MINUS
24928: PPUSH
24929: LD_VAR 0 3
24933: PUSH
24934: LD_INT 20
24936: PLUS
24937: PPUSH
24938: CALL_OW 12
24942: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
24943: LD_ADDR_OWVAR 31
24947: PUSH
24948: LD_INT 0
24950: PPUSH
24951: LD_INT 2
24953: PPUSH
24954: CALL_OW 12
24958: PUSH
24959: LD_INT 0
24961: PUSH
24962: LD_INT 0
24964: PUSH
24965: LD_INT 0
24967: PUSH
24968: EMPTY
24969: LIST
24970: LIST
24971: LIST
24972: LIST
24973: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
24974: LD_ADDR_OWVAR 30
24978: PUSH
24979: LD_INT 0
24981: PUSH
24982: LD_INT 0
24984: PUSH
24985: LD_INT 0
24987: PUSH
24988: LD_INT 0
24990: PUSH
24991: EMPTY
24992: LIST
24993: LIST
24994: LIST
24995: LIST
24996: ST_TO_ADDR
// hc_name :=  ;
24997: LD_ADDR_OWVAR 26
25001: PUSH
25002: LD_STRING 
25004: ST_TO_ADDR
// hc_class := class_apeman ;
25005: LD_ADDR_OWVAR 28
25009: PUSH
25010: LD_INT 12
25012: ST_TO_ADDR
// ape := CreateHuman ;
25013: LD_ADDR_VAR 0 6
25017: PUSH
25018: CALL_OW 44
25022: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
25023: LD_VAR 0 6
25027: PPUSH
25028: LD_VAR 0 1
25032: PPUSH
25033: LD_INT 0
25035: PPUSH
25036: CALL_OW 49
// end ;
25040: GO 24896
25042: POP
25043: POP
// end ;
25044: LD_VAR 0 4
25048: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
25049: LD_INT 0
25051: PPUSH
25052: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
25053: LD_VAR 0 1
25057: PPUSH
25058: CALL 337 0 1
25062: PUSH
25063: LD_EXP 5
25067: PUSH
25068: LD_VAR 0 1
25072: ARRAY
25073: GREATEREQUAL
25074: IFFALSE 25251
// begin if GetTag ( unit ) = 17 then
25076: LD_VAR 0 2
25080: PPUSH
25081: CALL_OW 110
25085: PUSH
25086: LD_INT 17
25088: EQUAL
25089: IFFALSE 25249
// begin SetTag ( unit , 0 ) ;
25091: LD_VAR 0 2
25095: PPUSH
25096: LD_INT 0
25098: PPUSH
25099: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
25103: LD_VAR 0 1
25107: PPUSH
25108: CALL 39 0 1
25112: PUSH
25113: LD_VAR 0 1
25117: PPUSH
25118: CALL 13982 0 1
25122: NOT
25123: AND
25124: IFFALSE 25149
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
25126: LD_VAR 0 2
25130: PPUSH
25131: LD_VAR 0 1
25135: PPUSH
25136: CALL 39 0 1
25140: PUSH
25141: LD_INT 1
25143: ARRAY
25144: PPUSH
25145: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
25149: LD_VAR 0 1
25153: PPUSH
25154: CALL 39 0 1
25158: NOT
25159: PUSH
25160: LD_VAR 0 1
25164: PPUSH
25165: LD_INT 30
25167: PUSH
25168: LD_INT 1
25170: PUSH
25171: EMPTY
25172: LIST
25173: LIST
25174: PPUSH
25175: CALL 0 0 2
25179: AND
25180: IFFALSE 25249
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
25182: LD_VAR 0 2
25186: PPUSH
25187: LD_VAR 0 1
25191: PPUSH
25192: LD_INT 30
25194: PUSH
25195: LD_INT 1
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: PPUSH
25202: CALL 0 0 2
25206: PUSH
25207: LD_INT 1
25209: ARRAY
25210: PPUSH
25211: CALL_OW 250
25215: PPUSH
25216: LD_VAR 0 1
25220: PPUSH
25221: LD_INT 30
25223: PUSH
25224: LD_INT 1
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: PPUSH
25231: CALL 0 0 2
25235: PUSH
25236: LD_INT 1
25238: ARRAY
25239: PPUSH
25240: CALL_OW 251
25244: PPUSH
25245: CALL_OW 111
// end ; end else
25249: GO 25435
// if GetClass ( unit ) <> 4 then
25251: LD_VAR 0 2
25255: PPUSH
25256: CALL_OW 257
25260: PUSH
25261: LD_INT 4
25263: NONEQUAL
25264: IFFALSE 25270
// exit else
25266: GO 25435
25268: GO 25435
// if GetTag ( unit ) = 0 then
25270: LD_VAR 0 2
25274: PPUSH
25275: CALL_OW 110
25279: PUSH
25280: LD_INT 0
25282: EQUAL
25283: IFFALSE 25299
// SetTag ( unit , 17 ) else
25285: LD_VAR 0 2
25289: PPUSH
25290: LD_INT 17
25292: PPUSH
25293: CALL_OW 109
25297: GO 25435
// begin if IsInUnit ( unit ) then
25299: LD_VAR 0 2
25303: PPUSH
25304: CALL_OW 310
25308: IFFALSE 25319
// ComExitBuilding ( unit ) ;
25310: LD_VAR 0 2
25314: PPUSH
25315: CALL_OW 122
// Wait ( 1 ) ;
25319: LD_INT 1
25321: PPUSH
25322: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
25326: LD_ADDR_VAR 0 4
25330: PUSH
25331: LD_INT 22
25333: PUSH
25334: LD_INT 0
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: PUSH
25341: LD_INT 25
25343: PUSH
25344: LD_INT 12
25346: PUSH
25347: EMPTY
25348: LIST
25349: LIST
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: PPUSH
25355: CALL_OW 69
25359: PPUSH
25360: LD_VAR 0 2
25364: PPUSH
25365: CALL_OW 74
25369: ST_TO_ADDR
// if not ape then
25370: LD_VAR 0 4
25374: NOT
25375: IFFALSE 25381
// exit else
25377: GO 25435
25379: GO 25390
// ComHold ( ape ) ;
25381: LD_VAR 0 4
25385: PPUSH
25386: CALL_OW 140
// if not HasTask ( unit ) then
25390: LD_VAR 0 2
25394: PPUSH
25395: CALL_OW 314
25399: NOT
25400: IFFALSE 25433
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
25402: LD_VAR 0 2
25406: PPUSH
25407: LD_VAR 0 4
25411: PPUSH
25412: CALL_OW 250
25416: PPUSH
25417: LD_VAR 0 4
25421: PPUSH
25422: CALL_OW 251
25426: PPUSH
25427: CALL_OW 131
25431: GO 25435
// exit ;
25433: GO 25435
// end ; end ;
25435: LD_VAR 0 3
25439: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
25440: LD_INT 0
25442: PPUSH
25443: PPUSH
25444: PPUSH
25445: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
25446: LD_ADDR_VAR 0 4
25450: PUSH
25451: LD_EXP 6
25455: PUSH
25456: LD_VAR 0 1
25460: ARRAY
25461: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
25462: LD_ADDR_VAR 0 5
25466: PUSH
25467: LD_VAR 0 1
25471: PPUSH
25472: LD_STRING normal
25474: PPUSH
25475: CALL 421 0 2
25479: ST_TO_ADDR
// if apes then
25480: LD_VAR 0 5
25484: IFFALSE 25712
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
25486: LD_INT 2
25488: PPUSH
25489: LD_VAR 0 1
25493: PPUSH
25494: CALL_OW 321
25498: PUSH
25499: LD_INT 2
25501: EQUAL
25502: PUSH
25503: LD_VAR 0 4
25507: PUSH
25508: LD_INT 2
25510: ARRAY
25511: PUSH
25512: LD_INT 1
25514: EQUAL
25515: AND
25516: PUSH
25517: LD_VAR 0 1
25521: PPUSH
25522: LD_STRING engineer
25524: PPUSH
25525: CALL 421 0 2
25529: PUSH
25530: LD_INT 3
25532: LESS
25533: AND
25534: PUSH
25535: LD_VAR 0 1
25539: PPUSH
25540: LD_INT 30
25542: PUSH
25543: LD_INT 1
25545: PUSH
25546: EMPTY
25547: LIST
25548: LIST
25549: PPUSH
25550: CALL 0 0 2
25554: AND
25555: IFFALSE 25609
// begin for i in apes do
25557: LD_ADDR_VAR 0 3
25561: PUSH
25562: LD_VAR 0 5
25566: PUSH
25567: FOR_IN
25568: IFFALSE 25605
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
25570: LD_VAR 0 3
25574: PPUSH
25575: LD_VAR 0 1
25579: PPUSH
25580: LD_INT 30
25582: PUSH
25583: LD_INT 1
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PPUSH
25590: CALL 0 0 2
25594: PUSH
25595: LD_INT 1
25597: ARRAY
25598: PPUSH
25599: CALL_OW 120
// end ;
25603: GO 25567
25605: POP
25606: POP
// end else
25607: GO 25712
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
25609: LD_INT 11
25611: PPUSH
25612: LD_VAR 0 1
25616: PPUSH
25617: CALL_OW 321
25621: PUSH
25622: LD_INT 2
25624: EQUAL
25625: PUSH
25626: LD_VAR 0 4
25630: PUSH
25631: LD_INT 1
25633: ARRAY
25634: PUSH
25635: LD_INT 1
25637: EQUAL
25638: AND
25639: PUSH
25640: LD_VAR 0 1
25644: PPUSH
25645: LD_INT 30
25647: PUSH
25648: LD_INT 5
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PPUSH
25655: CALL 0 0 2
25659: AND
25660: IFFALSE 25712
// begin for i in apes do
25662: LD_ADDR_VAR 0 3
25666: PUSH
25667: LD_VAR 0 5
25671: PUSH
25672: FOR_IN
25673: IFFALSE 25710
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
25675: LD_VAR 0 3
25679: PPUSH
25680: LD_VAR 0 1
25684: PPUSH
25685: LD_INT 30
25687: PUSH
25688: LD_INT 5
25690: PUSH
25691: EMPTY
25692: LIST
25693: LIST
25694: PPUSH
25695: CALL 0 0 2
25699: PUSH
25700: LD_INT 1
25702: ARRAY
25703: PPUSH
25704: CALL_OW 120
// end ;
25708: GO 25672
25710: POP
25711: POP
// end ; end ; end ; end_of_file
25712: LD_VAR 0 2
25716: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
25717: LD_INT 0
25719: PPUSH
25720: PPUSH
// if not GetClass ( unit ) = 4 or not target then
25721: LD_VAR 0 1
25725: PPUSH
25726: CALL_OW 257
25730: PUSH
25731: LD_INT 4
25733: EQUAL
25734: NOT
25735: PUSH
25736: LD_VAR 0 2
25740: NOT
25741: OR
25742: IFFALSE 25748
// exit else
25744: GO 25782
25746: GO 25782
// if not GetTag ( unit ) = 4 then
25748: LD_VAR 0 1
25752: PPUSH
25753: CALL_OW 110
25757: PUSH
25758: LD_INT 4
25760: EQUAL
25761: NOT
25762: IFFALSE 25768
// exit else
25764: GO 25782
25766: GO 25782
// ComHeal ( unit , target ) ;
25768: LD_VAR 0 1
25772: PPUSH
25773: LD_VAR 0 2
25777: PPUSH
25778: CALL_OW 128
// end ;
25782: LD_VAR 0 3
25786: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
25787: LD_INT 0
25789: PPUSH
25790: PPUSH
25791: PPUSH
25792: PPUSH
25793: PPUSH
25794: PPUSH
25795: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25796: LD_ADDR_VAR 0 5
25800: PUSH
25801: LD_INT 22
25803: PUSH
25804: LD_VAR 0 1
25808: PUSH
25809: EMPTY
25810: LIST
25811: LIST
25812: PUSH
25813: LD_INT 21
25815: PUSH
25816: LD_INT 1
25818: PUSH
25819: EMPTY
25820: LIST
25821: LIST
25822: PUSH
25823: LD_INT 3
25825: PUSH
25826: LD_INT 24
25828: PUSH
25829: LD_INT 1000
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: EMPTY
25841: LIST
25842: LIST
25843: LIST
25844: PPUSH
25845: CALL_OW 69
25849: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
25850: LD_ADDR_VAR 0 8
25854: PUSH
25855: LD_VAR 0 1
25859: PPUSH
25860: LD_INT 30
25862: PUSH
25863: LD_INT 1
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PPUSH
25870: CALL 0 0 2
25874: ST_TO_ADDR
// r := [ ] ;
25875: LD_ADDR_VAR 0 6
25879: PUSH
25880: EMPTY
25881: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
25882: LD_VAR 0 1
25886: PPUSH
25887: LD_INT 5
25889: PPUSH
25890: EMPTY
25891: PPUSH
25892: CALL 627 0 3
25896: IFFALSE 25952
// for j in MCF_Tag ( side , 5 , [ ] ) do
25898: LD_ADDR_VAR 0 4
25902: PUSH
25903: LD_VAR 0 1
25907: PPUSH
25908: LD_INT 5
25910: PPUSH
25911: EMPTY
25912: PPUSH
25913: CALL 627 0 3
25917: PUSH
25918: FOR_IN
25919: IFFALSE 25950
// if GetLives ( j ) = 1000 then
25921: LD_VAR 0 4
25925: PPUSH
25926: CALL_OW 256
25930: PUSH
25931: LD_INT 1000
25933: EQUAL
25934: IFFALSE 25948
// SetTag ( j , 0 ) ;
25936: LD_VAR 0 4
25940: PPUSH
25941: LD_INT 0
25943: PPUSH
25944: CALL_OW 109
25948: GO 25918
25950: POP
25951: POP
// if tmp then
25952: LD_VAR 0 5
25956: IFFALSE 26285
// begin r := [ tmp [ 1 ] ] ;
25958: LD_ADDR_VAR 0 6
25962: PUSH
25963: LD_VAR 0 5
25967: PUSH
25968: LD_INT 1
25970: ARRAY
25971: PUSH
25972: EMPTY
25973: LIST
25974: ST_TO_ADDR
// for i = 2 to tmp do
25975: LD_ADDR_VAR 0 3
25979: PUSH
25980: DOUBLE
25981: LD_INT 2
25983: DEC
25984: ST_TO_ADDR
25985: LD_VAR 0 5
25989: PUSH
25990: FOR_TO
25991: IFFALSE 26283
// begin m := false ;
25993: LD_ADDR_VAR 0 7
25997: PUSH
25998: LD_INT 0
26000: ST_TO_ADDR
// if d then
26001: LD_VAR 0 8
26005: IFFALSE 26160
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
26007: LD_VAR 0 5
26011: PUSH
26012: LD_VAR 0 3
26016: ARRAY
26017: PPUSH
26018: CALL_OW 256
26022: PUSH
26023: LD_INT 650
26025: LESS
26026: PUSH
26027: LD_VAR 0 5
26031: PUSH
26032: LD_VAR 0 3
26036: ARRAY
26037: PPUSH
26038: LD_VAR 0 8
26042: PUSH
26043: LD_INT 1
26045: ARRAY
26046: PPUSH
26047: CALL_OW 250
26051: PPUSH
26052: LD_VAR 0 8
26056: PUSH
26057: LD_INT 1
26059: ARRAY
26060: PPUSH
26061: CALL_OW 251
26065: PPUSH
26066: CALL_OW 297
26070: PUSH
26071: LD_INT 10
26073: GREATER
26074: AND
26075: IFFALSE 26160
// begin if not GetTag ( tmp [ i ] ) = 5 then
26077: LD_VAR 0 5
26081: PUSH
26082: LD_VAR 0 3
26086: ARRAY
26087: PPUSH
26088: CALL_OW 110
26092: PUSH
26093: LD_INT 5
26095: EQUAL
26096: NOT
26097: IFFALSE 26117
// SetTag ( tmp [ i ] , 5 ) ;
26099: LD_VAR 0 5
26103: PUSH
26104: LD_VAR 0 3
26108: ARRAY
26109: PPUSH
26110: LD_INT 5
26112: PPUSH
26113: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
26117: LD_VAR 0 5
26121: PUSH
26122: LD_VAR 0 3
26126: ARRAY
26127: PPUSH
26128: LD_VAR 0 8
26132: PUSH
26133: LD_INT 1
26135: ARRAY
26136: PPUSH
26137: CALL_OW 250
26141: PPUSH
26142: LD_VAR 0 8
26146: PUSH
26147: LD_INT 1
26149: ARRAY
26150: PPUSH
26151: CALL_OW 251
26155: PPUSH
26156: CALL_OW 111
// end ; for j = 1 to r do
26160: LD_ADDR_VAR 0 4
26164: PUSH
26165: DOUBLE
26166: LD_INT 1
26168: DEC
26169: ST_TO_ADDR
26170: LD_VAR 0 6
26174: PUSH
26175: FOR_TO
26176: IFFALSE 26250
// if GetLives ( tmp [ i ] ) < r [ j ] then
26178: LD_VAR 0 5
26182: PUSH
26183: LD_VAR 0 3
26187: ARRAY
26188: PPUSH
26189: CALL_OW 256
26193: PUSH
26194: LD_VAR 0 6
26198: PUSH
26199: LD_VAR 0 4
26203: ARRAY
26204: LESS
26205: IFFALSE 26248
// begin r := Insert ( r , j , tmp [ i ] ) ;
26207: LD_ADDR_VAR 0 6
26211: PUSH
26212: LD_VAR 0 6
26216: PPUSH
26217: LD_VAR 0 4
26221: PPUSH
26222: LD_VAR 0 5
26226: PUSH
26227: LD_VAR 0 3
26231: ARRAY
26232: PPUSH
26233: CALL_OW 2
26237: ST_TO_ADDR
// m := true ;
26238: LD_ADDR_VAR 0 7
26242: PUSH
26243: LD_INT 1
26245: ST_TO_ADDR
// break ;
26246: GO 26250
// end ;
26248: GO 26175
26250: POP
26251: POP
// if not m then
26252: LD_VAR 0 7
26256: NOT
26257: IFFALSE 26281
// r := r ^ tmp [ i ] ;
26259: LD_ADDR_VAR 0 6
26263: PUSH
26264: LD_VAR 0 6
26268: PUSH
26269: LD_VAR 0 5
26273: PUSH
26274: LD_VAR 0 3
26278: ARRAY
26279: ADD
26280: ST_TO_ADDR
// end ;
26281: GO 25990
26283: POP
26284: POP
// end ; result := r end ;
26285: LD_ADDR_VAR 0 2
26289: PUSH
26290: LD_VAR 0 6
26294: ST_TO_ADDR
26295: LD_VAR 0 2
26299: RET
