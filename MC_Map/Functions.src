Export Function Replace2(tab, j, k, value);
var i, tmp;
begin
tmp := Replace(tab[j], k, value);
tab := Replace(tab, j, tmp);

result := tab;
End;

Export Function Remove(tab, value, mode);
var i, j, tmp;
begin
i := 1;

     while(i <= tab) do
       begin
       if not tab[i] then
          break;

       if value in tab then
          begin
          if not mode then
             tab := tab diff value
              else
               for j = 1 to tab do
                   if tab[j] = value then
                      begin
                      tab := Delete(tab, j);
                      break;
                      end;

          i := i - 1;

          if mode then
             break;
          end
           else
            if tab[i] and value in tab[i] then
               begin
               if not mode then
                  tmp := tab[i] diff value
                   else
                    for j = 1 to tab[i] do
                        if value = tab[i][j] then
                           begin
                           tmp := Delete(tab[i], j);
                           break;
                           end;

               if tmp = [] then
                  begin
                  tab := Delete(tab, i);
                  end
                   else
                    tab := Replace(tab, i, tmp);

               i := i - 1;

               if mode then
                  break;
               end;

       i := i + 1;
       end;

result := tab;
End;

Export Function RemoveAll(tab, values);
var i;
begin
for i = 1 to values do
    tab := Remove(tab, values[i], false);
result := tab;
End;

Export Function IsDriver(unit);
begin
if unit in FilterAllUnits([f_driving]) then
   result := IsInUnit(unit)
    else
     result := false;
End;

Export Function GetDriver(veh);
var i, filter;
begin
if not GetControl(veh) = control_manual then
   result := false
    else
     if veh in FilterAllUnits([f_empty]) then
        result := false
         else
          begin
          filter := FilterAllUnits([[f_side, GetSide(veh)], [f_driving]]);

          if not filter then
             result := false
              else
               for i = 1 to filter do
                   if IsDriver(filter[i]) = veh then
                      begin
                      result := filter[i];
                      break;
                      end;
         end;
End;

Export Function ComComplete(unit, b);
var i;
begin
if BuildingStatus(b) = bs_build then
   SetTaskList(unit, [['h', GetX(b), GetY(b), b, 0, 0, 0]]);
End;

Export Function Compare(val1, val2);
begin
if val1 = val2 then
   result := true
    else
     result := false;
End;

Export Function CompareArray(array1, array2);
var i;
begin
result := true;

     if array1 = array2 then
        begin
        for i = 1 to array1 do
            if not Compare(array1[i], array2[i]) then
               begin
               result := false;
               break;
               end;
        end
         else
          result := false;
End;

Export Function Compare3(e1, e2);
var j;
begin
result := false;
    for j = 1 to e2 do
        if Compare(e1, e2[j]) then
           result := true;
End;

Export Function ComTake(unit, x, y, dep);
var t;
begin
SetTaskList(unit, [['C', x, y, 0, 0, 0, 0],
                   ['v', GetX(dep), GetY(dep), dep, 0, 0, 0]]);
End;

Export Function CanControl(unit);
var sk, linked;
begin
linked := UnitsLinked(unit);
sk := GetSkill(unit, 3);

if sk > linked then
   result := true
    else
     result := false;
End;

Export Function NotTask(unit);
begin
result := true;

if GetTaskList(unit) or HasTask(unit) then
   result := false;
End;

Export Function WantHeal(sci, unit);
begin
if GetTaskList(sci) > 0 then
   begin
   if GetTaskList(sci)[1][1] = 'l' and GetTaskList(sci)[1][4] = unit then
      result := true
       else
        result := false;
   end
    else
     result := false;
End;