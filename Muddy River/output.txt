// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 2665 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , rforce ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// rforce := [ ] ;
 124: LD_ADDR_EXP 27
 128: PUSH
 129: EMPTY
 130: ST_TO_ADDR
// if Multiplayer then
 131: LD_OWVAR 4
 135: IFFALSE 257
// begin Game_Type := mp_game_type ;
 137: LD_ADDR_EXP 1
 141: PUSH
 142: LD_OWVAR 6
 146: ST_TO_ADDR
// Your_Side := mp_player_side ;
 147: LD_ADDR_OWVAR 2
 151: PUSH
 152: LD_OWVAR 7
 156: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 157: LD_ADDR_EXP 2
 161: PUSH
 162: LD_OWVAR 17
 166: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 167: LD_ADDR_EXP 3
 171: PUSH
 172: LD_OWVAR 15
 176: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 177: LD_ADDR_EXP 4
 181: PUSH
 182: LD_OWVAR 16
 186: ST_TO_ADDR
// Teams := mp_teams ;
 187: LD_ADDR_EXP 5
 191: PUSH
 192: LD_OWVAR 12
 196: ST_TO_ADDR
// for i = 0 to 6 do
 197: LD_ADDR_VAR 0 2
 201: PUSH
 202: DOUBLE
 203: LD_INT 0
 205: DEC
 206: ST_TO_ADDR
 207: LD_INT 6
 209: PUSH
 210: FOR_TO
 211: IFFALSE 253
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 213: LD_ADDR_EXP 16
 217: PUSH
 218: LD_EXP 16
 222: PPUSH
 223: LD_EXP 16
 227: PUSH
 228: LD_INT 1
 230: PLUS
 231: PPUSH
 232: LD_VAR 0 2
 236: PPUSH
 237: CALL_OW 426
 241: PUSH
 242: LD_INT 1
 244: PLUS
 245: PPUSH
 246: CALL_OW 2
 250: ST_TO_ADDR
 251: GO 210
 253: POP
 254: POP
// end else
 255: GO 408
// begin Game_Type := 1 ;
 257: LD_ADDR_EXP 1
 261: PUSH
 262: LD_INT 1
 264: ST_TO_ADDR
// Your_Side := 1 ;
 265: LD_ADDR_OWVAR 2
 269: PUSH
 270: LD_INT 1
 272: ST_TO_ADDR
// Side_Positions := [ 1 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] ;
 273: LD_ADDR_EXP 2
 277: PUSH
 278: LD_INT 1
 280: PUSH
 281: LD_INT 0
 283: PUSH
 284: LD_INT 0
 286: PUSH
 287: LD_INT 2
 289: PUSH
 290: LD_INT 0
 292: PUSH
 293: LD_INT 0
 295: PUSH
 296: LD_INT 0
 298: PUSH
 299: LD_INT 0
 301: PUSH
 302: EMPTY
 303: LIST
 304: LIST
 305: LIST
 306: LIST
 307: LIST
 308: LIST
 309: LIST
 310: LIST
 311: ST_TO_ADDR
// Side_Teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] ;
 312: LD_ADDR_EXP 3
 316: PUSH
 317: LD_INT 1
 319: PUSH
 320: LD_INT 0
 322: PUSH
 323: LD_INT 0
 325: PUSH
 326: LD_INT 1
 328: PUSH
 329: LD_INT 0
 331: PUSH
 332: LD_INT 0
 334: PUSH
 335: LD_INT 0
 337: PUSH
 338: LD_INT 0
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: LIST
 346: LIST
 347: LIST
 348: LIST
 349: LIST
 350: ST_TO_ADDR
// Side_Nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] ;
 351: LD_ADDR_EXP 4
 355: PUSH
 356: LD_INT 1
 358: PUSH
 359: LD_INT 0
 361: PUSH
 362: LD_INT 0
 364: PUSH
 365: LD_INT 1
 367: PUSH
 368: LD_INT 0
 370: PUSH
 371: LD_INT 0
 373: PUSH
 374: LD_INT 0
 376: PUSH
 377: LD_INT 0
 379: PUSH
 380: EMPTY
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: ST_TO_ADDR
// Teams := [ [ 1 , 4 ] ] ;
 390: LD_ADDR_EXP 5
 394: PUSH
 395: LD_INT 1
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: EMPTY
 406: LIST
 407: ST_TO_ADDR
// end ; Side_Start := [ [ 83 , 148 ] , [ 187 , 144 ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 408: LD_ADDR_EXP 7
 412: PUSH
 413: LD_INT 83
 415: PUSH
 416: LD_INT 148
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: PUSH
 423: LD_INT 187
 425: PUSH
 426: LD_INT 144
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: PUSH
 433: EMPTY
 434: PUSH
 435: EMPTY
 436: PUSH
 437: EMPTY
 438: PUSH
 439: EMPTY
 440: PUSH
 441: EMPTY
 442: PUSH
 443: EMPTY
 444: PUSH
 445: EMPTY
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: ST_TO_ADDR
// Bot_Side := 2 ;
 455: LD_ADDR_EXP 8
 459: PUSH
 460: LD_INT 2
 462: ST_TO_ADDR
// for i = 1 to 8 do
 463: LD_ADDR_VAR 0 2
 467: PUSH
 468: DOUBLE
 469: LD_INT 1
 471: DEC
 472: ST_TO_ADDR
 473: LD_INT 8
 475: PUSH
 476: FOR_TO
 477: IFFALSE 609
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
 479: LD_VAR 0 2
 483: PPUSH
 484: CALL_OW 530
 488: IFFALSE 562
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 490: LD_ADDR_EXP 2
 494: PUSH
 495: LD_EXP 2
 499: PPUSH
 500: LD_VAR 0 2
 504: PPUSH
 505: LD_INT 0
 507: PPUSH
 508: CALL_OW 1
 512: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 513: LD_ADDR_EXP 5
 517: PUSH
 518: LD_EXP 5
 522: PPUSH
 523: LD_EXP 3
 527: PUSH
 528: LD_VAR 0 2
 532: ARRAY
 533: PPUSH
 534: LD_EXP 5
 538: PUSH
 539: LD_EXP 3
 543: PUSH
 544: LD_VAR 0 2
 548: ARRAY
 549: ARRAY
 550: PUSH
 551: LD_VAR 0 2
 555: DIFF
 556: PPUSH
 557: CALL_OW 1
 561: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 1 then
 562: LD_EXP 4
 566: PUSH
 567: LD_VAR 0 2
 571: ARRAY
 572: PUSH
 573: LD_EXP 4
 577: PUSH
 578: LD_INT 1
 580: NONEQUAL
 581: AND
 582: IFFALSE 607
// Side_Nations := Replace ( Side_Nations , i , 1 ) ;
 584: LD_ADDR_EXP 4
 588: PUSH
 589: LD_EXP 4
 593: PPUSH
 594: LD_VAR 0 2
 598: PPUSH
 599: LD_INT 1
 601: PPUSH
 602: CALL_OW 1
 606: ST_TO_ADDR
// end ;
 607: GO 476
 609: POP
 610: POP
// if 2 = bot_side and Side_Positions [ 2 ] then
 611: LD_INT 2
 613: PUSH
 614: LD_EXP 8
 618: EQUAL
 619: PUSH
 620: LD_EXP 2
 624: PUSH
 625: LD_INT 2
 627: ARRAY
 628: AND
 629: IFFALSE 639
// bot_side := 5 ;
 631: LD_ADDR_EXP 8
 635: PUSH
 636: LD_INT 5
 638: ST_TO_ADDR
// if 5 = bot_side and Side_Positions [ 5 ] then
 639: LD_INT 5
 641: PUSH
 642: LD_EXP 8
 646: EQUAL
 647: PUSH
 648: LD_EXP 2
 652: PUSH
 653: LD_INT 5
 655: ARRAY
 656: AND
 657: IFFALSE 667
// bot_side := 8 ;
 659: LD_ADDR_EXP 8
 663: PUSH
 664: LD_INT 8
 666: ST_TO_ADDR
// Team_Game := false ;
 667: LD_ADDR_EXP 6
 671: PUSH
 672: LD_INT 0
 674: ST_TO_ADDR
// for i = 1 to 8 do
 675: LD_ADDR_VAR 0 2
 679: PUSH
 680: DOUBLE
 681: LD_INT 1
 683: DEC
 684: ST_TO_ADDR
 685: LD_INT 8
 687: PUSH
 688: FOR_TO
 689: IFFALSE 715
// if Side_Teams [ i ] then
 691: LD_EXP 3
 695: PUSH
 696: LD_VAR 0 2
 700: ARRAY
 701: IFFALSE 713
// begin Team_Game := true ;
 703: LD_ADDR_EXP 6
 707: PUSH
 708: LD_INT 1
 710: ST_TO_ADDR
// break ;
 711: GO 715
// end ;
 713: GO 688
 715: POP
 716: POP
// for i in Teams do
 717: LD_ADDR_VAR 0 2
 721: PUSH
 722: LD_EXP 5
 726: PUSH
 727: FOR_IN
 728: IFFALSE 808
// for j = 2 to i do
 730: LD_ADDR_VAR 0 3
 734: PUSH
 735: DOUBLE
 736: LD_INT 2
 738: DEC
 739: ST_TO_ADDR
 740: LD_VAR 0 2
 744: PUSH
 745: FOR_TO
 746: IFFALSE 804
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
 748: LD_VAR 0 2
 752: PUSH
 753: LD_VAR 0 3
 757: ARRAY
 758: PPUSH
 759: LD_VAR 0 2
 763: PUSH
 764: LD_INT 1
 766: ARRAY
 767: PPUSH
 768: CALL_OW 343
// SetAttitude ( i [ j ] , i [ 1 ] , att_friend , true ) ;
 772: LD_VAR 0 2
 776: PUSH
 777: LD_VAR 0 3
 781: ARRAY
 782: PPUSH
 783: LD_VAR 0 2
 787: PUSH
 788: LD_INT 1
 790: ARRAY
 791: PPUSH
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: CALL_OW 80
// end ;
 802: GO 745
 804: POP
 805: POP
 806: GO 727
 808: POP
 809: POP
// if not Multiplayer then
 810: LD_OWVAR 4
 814: NOT
 815: IFFALSE 852
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 817: LD_ADDR_EXP 16
 821: PUSH
 822: LD_INT 1
 824: PUSH
 825: LD_INT 1
 827: PUSH
 828: LD_INT 1
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 2
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 3
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: ST_TO_ADDR
// number_of_people := [ 5 , 9 , 12 , 15 ] [ definitions [ 1 ] ] ;
 852: LD_ADDR_EXP 10
 856: PUSH
 857: LD_INT 5
 859: PUSH
 860: LD_INT 9
 862: PUSH
 863: LD_INT 12
 865: PUSH
 866: LD_INT 15
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: LIST
 873: LIST
 874: PUSH
 875: LD_EXP 16
 879: PUSH
 880: LD_INT 1
 882: ARRAY
 883: ARRAY
 884: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 885: LD_ADDR_EXP 11
 889: PUSH
 890: LD_INT 2
 892: PUSH
 893: LD_INT 4
 895: PUSH
 896: LD_INT 6
 898: PUSH
 899: LD_INT 8
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_EXP 16
 912: PUSH
 913: LD_INT 2
 915: ARRAY
 916: ARRAY
 917: ST_TO_ADDR
// crates_spawn := [ 1 1$20 , 1 1$05 , 0 0$51 , 0 0$47 ] [ definitions [ 3 ] ] ;
 918: LD_ADDR_EXP 12
 922: PUSH
 923: LD_INT 2800
 925: PUSH
 926: LD_INT 2275
 928: PUSH
 929: LD_INT 1785
 931: PUSH
 932: LD_INT 1645
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: PUSH
 941: LD_EXP 16
 945: PUSH
 946: LD_INT 3
 948: ARRAY
 949: ARRAY
 950: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 ] [ 1 ] ;
 951: LD_ADDR_EXP 13
 955: PUSH
 956: LD_INT 0
 958: PUSH
 959: EMPTY
 960: LIST
 961: PUSH
 962: LD_INT 1
 964: ARRAY
 965: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 ] [ 1 ] ;
 966: LD_ADDR_EXP 14
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: EMPTY
 975: LIST
 976: PUSH
 977: LD_INT 1
 979: ARRAY
 980: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 4 ] ] ;
 981: LD_ADDR_EXP 15
 985: PUSH
 986: LD_INT 0
 988: PUSH
 989: LD_INT 3
 991: PUSH
 992: LD_INT 5
 994: PUSH
 995: LD_INT 7
 997: PUSH
 998: EMPTY
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_EXP 16
1008: PUSH
1009: LD_INT 4
1011: ARRAY
1012: ARRAY
1013: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 5 ] ] ;
1014: LD_ADDR_OWVAR 67
1018: PUSH
1019: LD_INT 1
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 3
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: LD_EXP 16
1037: PUSH
1038: LD_INT 5
1040: ARRAY
1041: ARRAY
1042: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 6 ] ] ;
1043: LD_ADDR_EXP 26
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 1
1053: PUSH
1054: LD_INT 2
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_EXP 16
1066: PUSH
1067: LD_INT 6
1069: ARRAY
1070: ARRAY
1071: ST_TO_ADDR
// queue_codes := [ 11353 , 12244 , 44444 , 12345 , 43413 , 14152 ] ;
1072: LD_ADDR_EXP 23
1076: PUSH
1077: LD_INT 11353
1079: PUSH
1080: LD_INT 12244
1082: PUSH
1083: LD_INT 44444
1085: PUSH
1086: LD_INT 12345
1088: PUSH
1089: LD_INT 43413
1091: PUSH
1092: LD_INT 14152
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: LIST
1102: ST_TO_ADDR
// rng := Rand ( 1 , 6 ) ;
1103: LD_ADDR_EXP 24
1107: PUSH
1108: LD_INT 1
1110: PPUSH
1111: LD_INT 6
1113: PPUSH
1114: CALL_OW 12
1118: ST_TO_ADDR
// if bot_side <> 2 then
1119: LD_EXP 8
1123: PUSH
1124: LD_INT 2
1126: NONEQUAL
1127: IFFALSE 1170
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1129: LD_ADDR_VAR 0 2
1133: PUSH
1134: LD_INT 22
1136: PUSH
1137: LD_INT 2
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL_OW 69
1148: PUSH
1149: FOR_IN
1150: IFFALSE 1168
// SetSide ( i , bot_side ) ;
1152: LD_VAR 0 2
1156: PPUSH
1157: LD_EXP 8
1161: PPUSH
1162: CALL_OW 235
1166: GO 1149
1168: POP
1169: POP
// ResetFog ;
1170: CALL_OW 335
// PreparePeople ( ) ;
1174: CALL 7403 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1178: LD_ADDR_EXP 18
1182: PUSH
1183: LD_INT 4
1185: PUSH
1186: LD_INT 5
1188: PUSH
1189: LD_INT 6
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: ST_TO_ADDR
// if amount_of_apeman then
1197: LD_EXP 15
1201: IFFALSE 1251
// for j in apeman_areas do
1203: LD_ADDR_VAR 0 3
1207: PUSH
1208: LD_EXP 18
1212: PUSH
1213: FOR_IN
1214: IFFALSE 1249
// for i = 1 to amount_of_apeman do
1216: LD_ADDR_VAR 0 2
1220: PUSH
1221: DOUBLE
1222: LD_INT 1
1224: DEC
1225: ST_TO_ADDR
1226: LD_EXP 15
1230: PUSH
1231: FOR_TO
1232: IFFALSE 1245
// AddApeman ( j ) ;
1234: LD_VAR 0 3
1238: PPUSH
1239: CALL 8450 0 1
1243: GO 1231
1245: POP
1246: POP
1247: GO 1213
1249: POP
1250: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1251: LD_INT 22
1253: PUSH
1254: LD_OWVAR 2
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: PPUSH
1263: CALL_OW 69
1267: PUSH
1268: LD_INT 1
1270: ARRAY
1271: PPUSH
1272: CALL_OW 87
// disable ( 17 ) ;
1276: LD_INT 17
1278: DISABLE_MARKED
// end ;
1279: LD_VAR 0 1
1283: RET
// every 0 0$03 trigger GetSide ( ar_base_sout ) <> bot_side or IsDead ( ar_base_sout ) do var i ;
1284: LD_INT 5
1286: PPUSH
1287: CALL_OW 255
1291: PUSH
1292: LD_EXP 8
1296: NONEQUAL
1297: PUSH
1298: LD_INT 5
1300: PPUSH
1301: CALL_OW 301
1305: OR
1306: IFFALSE 1391
1308: GO 1310
1310: DISABLE
1311: LD_INT 0
1313: PPUSH
// begin for i = 1 to rforce do
1314: LD_ADDR_VAR 0 1
1318: PUSH
1319: DOUBLE
1320: LD_INT 1
1322: DEC
1323: ST_TO_ADDR
1324: LD_EXP 27
1328: PUSH
1329: FOR_TO
1330: IFFALSE 1389
// PlaceUnitXYR ( rforce [ i ] [ 1 ] , rforce [ i ] [ 2 ] , rforce [ i ] [ 3 ] , 6 , false ) ;
1332: LD_EXP 27
1336: PUSH
1337: LD_VAR 0 1
1341: ARRAY
1342: PUSH
1343: LD_INT 1
1345: ARRAY
1346: PPUSH
1347: LD_EXP 27
1351: PUSH
1352: LD_VAR 0 1
1356: ARRAY
1357: PUSH
1358: LD_INT 2
1360: ARRAY
1361: PPUSH
1362: LD_EXP 27
1366: PUSH
1367: LD_VAR 0 1
1371: ARRAY
1372: PUSH
1373: LD_INT 3
1375: ARRAY
1376: PPUSH
1377: LD_INT 6
1379: PPUSH
1380: LD_INT 0
1382: PPUSH
1383: CALL_OW 50
1387: GO 1329
1389: POP
1390: POP
// end ;
1391: PPOPN 1
1393: END
// every 0 0$01 + 0 0$30 trigger game_start do var cr , cr_queue ;
1394: LD_EXP 9
1398: IFFALSE 2050
1400: GO 1402
1402: DISABLE
1403: LD_INT 0
1405: PPUSH
1406: PPUSH
// begin cr := 1 ;
1407: LD_ADDR_VAR 0 1
1411: PUSH
1412: LD_INT 1
1414: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1415: LD_ADDR_VAR 0 2
1419: PUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 3
1425: PPUSH
1426: CALL_OW 12
1430: PUSH
1431: LD_INT 2
1433: PPUSH
1434: LD_INT 4
1436: PPUSH
1437: CALL_OW 12
1441: PUSH
1442: LD_INT 3
1444: PPUSH
1445: LD_INT 5
1447: PPUSH
1448: CALL_OW 12
1452: PUSH
1453: LD_INT 3
1455: PPUSH
1456: LD_INT 5
1458: PPUSH
1459: CALL_OW 12
1463: PUSH
1464: LD_INT 2
1466: PPUSH
1467: LD_INT 5
1469: PPUSH
1470: CALL_OW 12
1474: PUSH
1475: LD_INT 1
1477: PPUSH
1478: LD_INT 5
1480: PPUSH
1481: CALL_OW 12
1485: PUSH
1486: EMPTY
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: ST_TO_ADDR
// while ( true ) do
1494: LD_INT 1
1496: IFFALSE 2050
// begin Wait ( crates_spawn + ( tick mod 35 * 60 ) ) ;
1498: LD_EXP 12
1502: PUSH
1503: LD_OWVAR 1
1507: PUSH
1508: LD_INT 35
1510: MOD
1511: PUSH
1512: LD_INT 60
1514: MUL
1515: PLUS
1516: PPUSH
1517: CALL_OW 67
// if cr mod 3 = 0 then
1521: LD_VAR 0 1
1525: PUSH
1526: LD_INT 3
1528: MOD
1529: PUSH
1530: LD_INT 0
1532: EQUAL
1533: IFFALSE 1686
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1535: LD_VAR 0 2
1539: PUSH
1540: LD_VAR 0 1
1544: PUSH
1545: LD_VAR 0 2
1549: MOD
1550: PUSH
1551: LD_INT 1
1553: PLUS
1554: ARRAY
1555: PPUSH
1556: LD_INT 1
1558: PPUSH
1559: LD_INT 1
1561: PPUSH
1562: CALL_OW 55
// Wait ( crates_spawn ) ;
1566: LD_EXP 12
1570: PPUSH
1571: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1575: LD_VAR 0 2
1579: PUSH
1580: LD_VAR 0 1
1584: PUSH
1585: LD_VAR 0 2
1589: MOD
1590: PUSH
1591: LD_INT 1
1593: PLUS
1594: ARRAY
1595: PPUSH
1596: LD_INT 2
1598: PPUSH
1599: LD_INT 1
1601: PPUSH
1602: CALL_OW 55
// Wait ( crates_spawn ) ;
1606: LD_EXP 12
1610: PPUSH
1611: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1615: LD_VAR 0 2
1619: PUSH
1620: LD_VAR 0 1
1624: PUSH
1625: LD_VAR 0 2
1629: MOD
1630: PUSH
1631: LD_INT 1
1633: PLUS
1634: ARRAY
1635: PPUSH
1636: LD_INT 3
1638: PPUSH
1639: LD_INT 1
1641: PPUSH
1642: CALL_OW 55
// Wait ( crates_spawn ) ;
1646: LD_EXP 12
1650: PPUSH
1651: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1655: LD_VAR 0 2
1659: PUSH
1660: LD_VAR 0 1
1664: PUSH
1665: LD_VAR 0 2
1669: MOD
1670: PUSH
1671: LD_INT 1
1673: PLUS
1674: ARRAY
1675: PPUSH
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 1
1681: PPUSH
1682: CALL_OW 55
// end ; if cr mod 3 = 1 then
1686: LD_VAR 0 1
1690: PUSH
1691: LD_INT 3
1693: MOD
1694: PUSH
1695: LD_INT 1
1697: EQUAL
1698: IFFALSE 1851
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1700: LD_VAR 0 2
1704: PUSH
1705: LD_VAR 0 1
1709: PUSH
1710: LD_VAR 0 2
1714: MOD
1715: PUSH
1716: LD_INT 1
1718: PLUS
1719: ARRAY
1720: PPUSH
1721: LD_INT 2
1723: PPUSH
1724: LD_INT 1
1726: PPUSH
1727: CALL_OW 55
// Wait ( crates_spawn ) ;
1731: LD_EXP 12
1735: PPUSH
1736: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1740: LD_VAR 0 2
1744: PUSH
1745: LD_VAR 0 1
1749: PUSH
1750: LD_VAR 0 2
1754: MOD
1755: PUSH
1756: LD_INT 1
1758: PLUS
1759: ARRAY
1760: PPUSH
1761: LD_INT 1
1763: PPUSH
1764: LD_INT 1
1766: PPUSH
1767: CALL_OW 55
// Wait ( crates_spawn ) ;
1771: LD_EXP 12
1775: PPUSH
1776: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1780: LD_VAR 0 2
1784: PUSH
1785: LD_VAR 0 1
1789: PUSH
1790: LD_VAR 0 2
1794: MOD
1795: PUSH
1796: LD_INT 1
1798: PLUS
1799: ARRAY
1800: PPUSH
1801: LD_INT 3
1803: PPUSH
1804: LD_INT 1
1806: PPUSH
1807: CALL_OW 55
// Wait ( crates_spawn ) ;
1811: LD_EXP 12
1815: PPUSH
1816: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1820: LD_VAR 0 2
1824: PUSH
1825: LD_VAR 0 1
1829: PUSH
1830: LD_VAR 0 2
1834: MOD
1835: PUSH
1836: LD_INT 1
1838: PLUS
1839: ARRAY
1840: PPUSH
1841: LD_INT 2
1843: PPUSH
1844: LD_INT 1
1846: PPUSH
1847: CALL_OW 55
// end ; if cr mod 3 = 2 then
1851: LD_VAR 0 1
1855: PUSH
1856: LD_INT 3
1858: MOD
1859: PUSH
1860: LD_INT 2
1862: EQUAL
1863: IFFALSE 2016
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1865: LD_VAR 0 2
1869: PUSH
1870: LD_VAR 0 1
1874: PUSH
1875: LD_VAR 0 2
1879: MOD
1880: PUSH
1881: LD_INT 1
1883: PLUS
1884: ARRAY
1885: PPUSH
1886: LD_INT 3
1888: PPUSH
1889: LD_INT 1
1891: PPUSH
1892: CALL_OW 55
// Wait ( crates_spawn ) ;
1896: LD_EXP 12
1900: PPUSH
1901: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1905: LD_VAR 0 2
1909: PUSH
1910: LD_VAR 0 1
1914: PUSH
1915: LD_VAR 0 2
1919: MOD
1920: PUSH
1921: LD_INT 1
1923: PLUS
1924: ARRAY
1925: PPUSH
1926: LD_INT 2
1928: PPUSH
1929: LD_INT 1
1931: PPUSH
1932: CALL_OW 55
// Wait ( crates_spawn ) ;
1936: LD_EXP 12
1940: PPUSH
1941: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1945: LD_VAR 0 2
1949: PUSH
1950: LD_VAR 0 1
1954: PUSH
1955: LD_VAR 0 2
1959: MOD
1960: PUSH
1961: LD_INT 1
1963: PLUS
1964: ARRAY
1965: PPUSH
1966: LD_INT 1
1968: PPUSH
1969: LD_INT 1
1971: PPUSH
1972: CALL_OW 55
// Wait ( crates_spawn ) ;
1976: LD_EXP 12
1980: PPUSH
1981: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1985: LD_VAR 0 2
1989: PUSH
1990: LD_VAR 0 1
1994: PUSH
1995: LD_VAR 0 2
1999: MOD
2000: PUSH
2001: LD_INT 1
2003: PLUS
2004: ARRAY
2005: PPUSH
2006: LD_INT 3
2008: PPUSH
2009: LD_INT 1
2011: PPUSH
2012: CALL_OW 55
// end ; cr := cr + 1 ;
2016: LD_ADDR_VAR 0 1
2020: PUSH
2021: LD_VAR 0 1
2025: PUSH
2026: LD_INT 1
2028: PLUS
2029: ST_TO_ADDR
// if cr > 150 then
2030: LD_VAR 0 1
2034: PUSH
2035: LD_INT 150
2037: GREATER
2038: IFFALSE 2048
// cr := 43 ;
2040: LD_ADDR_VAR 0 1
2044: PUSH
2045: LD_INT 43
2047: ST_TO_ADDR
// end ;
2048: GO 1494
// end ; end_of_file
2050: PPOPN 2
2052: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
2053: LD_INT 0
2055: PPUSH
2056: PPUSH
2057: PPUSH
2058: PPUSH
// begin if un in attackers then
2059: LD_VAR 0 1
2063: PUSH
2064: LD_EXP 20
2068: IN
2069: IFFALSE 2087
// attackers := attackers diff un ;
2071: LD_ADDR_EXP 20
2075: PUSH
2076: LD_EXP 20
2080: PUSH
2081: LD_VAR 0 1
2085: DIFF
2086: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
2087: LD_VAR 0 1
2091: PPUSH
2092: CALL_OW 255
2096: PUSH
2097: LD_EXP 8
2101: NONEQUAL
2102: PUSH
2103: LD_VAR 0 1
2107: PPUSH
2108: CALL_OW 255
2112: PUSH
2113: LD_INT 0
2115: GREATER
2116: AND
2117: PUSH
2118: LD_VAR 0 1
2122: PUSH
2123: LD_INT 21
2125: PUSH
2126: LD_INT 1
2128: PUSH
2129: EMPTY
2130: LIST
2131: LIST
2132: PPUSH
2133: CALL_OW 69
2137: IN
2138: AND
2139: IFFALSE 2317
// begin if respawning_time_min > 0 0$00 then
2141: LD_EXP 13
2145: PUSH
2146: LD_INT 0
2148: GREATER
2149: IFFALSE 2317
// begin s := GetSide ( un ) ;
2151: LD_ADDR_VAR 0 4
2155: PUSH
2156: LD_VAR 0 1
2160: PPUSH
2161: CALL_OW 255
2165: ST_TO_ADDR
// n := GetNation ( un ) ;
2166: LD_ADDR_VAR 0 5
2170: PUSH
2171: LD_VAR 0 1
2175: PPUSH
2176: CALL_OW 248
2180: ST_TO_ADDR
// cl := GetClass ( un ) ;
2181: LD_ADDR_VAR 0 3
2185: PUSH
2186: LD_VAR 0 1
2190: PPUSH
2191: CALL_OW 257
2195: ST_TO_ADDR
// wait ( respawning_time_min ) ;
2196: LD_EXP 13
2200: PPUSH
2201: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) ) ;
2205: LD_EXP 14
2209: PUSH
2210: LD_INT 350
2212: PUSH
2213: LD_OWVAR 1
2217: MUL
2218: PUSH
2219: LD_INT 10
2221: MOD
2222: PUSH
2223: LD_INT 1
2225: PLUS
2226: MINUS
2227: PPUSH
2228: CALL_OW 67
// uc_side := s ;
2232: LD_ADDR_OWVAR 20
2236: PUSH
2237: LD_VAR 0 4
2241: ST_TO_ADDR
// uc_nation := n ;
2242: LD_ADDR_OWVAR 21
2246: PUSH
2247: LD_VAR 0 5
2251: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
2252: LD_INT 0
2254: PPUSH
2255: LD_VAR 0 3
2259: PPUSH
2260: LD_EXP 11
2264: PUSH
2265: LD_INT 2
2267: MINUS
2268: PPUSH
2269: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
2273: CALL_OW 44
2277: PPUSH
2278: LD_INT 1
2280: PUSH
2281: LD_INT 3
2283: PUSH
2284: LD_INT 2
2286: PUSH
2287: LD_INT 3
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: LIST
2294: LIST
2295: PUSH
2296: LD_VAR 0 3
2300: PUSH
2301: LD_INT 4
2303: MOD
2304: PUSH
2305: LD_INT 1
2307: PLUS
2308: ARRAY
2309: PPUSH
2310: LD_INT 1
2312: PPUSH
2313: CALL_OW 49
// end ; end ; end ;
2317: PPOPN 5
2319: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = bot_side and un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_type , unit_vehicle ] ] ) then
2320: LD_VAR 0 1
2324: PPUSH
2325: CALL_OW 255
2329: PUSH
2330: LD_EXP 8
2334: EQUAL
2335: PUSH
2336: LD_VAR 0 1
2340: PUSH
2341: LD_INT 33
2343: PUSH
2344: LD_INT 2
2346: PUSH
2347: EMPTY
2348: LIST
2349: LIST
2350: PUSH
2351: LD_INT 21
2353: PUSH
2354: LD_INT 2
2356: PUSH
2357: EMPTY
2358: LIST
2359: LIST
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: IN
2370: AND
2371: IFFALSE 2461
// begin Wait ( 0 0$0.3 ) ;
2373: LD_INT 10
2375: PPUSH
2376: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
2380: LD_VAR 0 1
2384: PPUSH
2385: CALL_OW 250
2389: PPUSH
2390: LD_VAR 0 1
2394: PPUSH
2395: CALL_OW 251
2399: PPUSH
2400: LD_INT 1
2402: PPUSH
2403: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
2407: LD_VAR 0 1
2411: PPUSH
2412: CALL_OW 250
2416: PPUSH
2417: LD_VAR 0 1
2421: PPUSH
2422: CALL_OW 251
2426: PPUSH
2427: LD_INT 1
2429: PPUSH
2430: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
2434: LD_VAR 0 1
2438: PPUSH
2439: CALL_OW 250
2443: PPUSH
2444: LD_VAR 0 1
2448: PPUSH
2449: CALL_OW 251
2453: PPUSH
2454: LD_INT 1
2456: PPUSH
2457: CALL_OW 453
// end ; if GetControl ( un ) = control_remote then
2461: LD_VAR 0 1
2465: PPUSH
2466: CALL_OW 263
2470: PUSH
2471: LD_INT 2
2473: EQUAL
2474: IFFALSE 2485
// ComUnlink ( un ) ;
2476: LD_VAR 0 1
2480: PPUSH
2481: CALL_OW 136
// end ;
2485: PPOPN 1
2487: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
2488: LD_VAR 0 1
2492: PPUSH
2493: CALL_OW 255
2497: PUSH
2498: LD_EXP 8
2502: EQUAL
2503: IFFALSE 2534
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
2505: LD_ADDR_EXP 20
2509: PUSH
2510: LD_EXP 20
2514: PPUSH
2515: LD_EXP 20
2519: PUSH
2520: LD_INT 1
2522: PLUS
2523: PPUSH
2524: LD_VAR 0 1
2528: PPUSH
2529: CALL_OW 2
2533: ST_TO_ADDR
// end ;
2534: PPOPN 2
2536: END
// on LeaveBuilding ( b , un ) do var i , arm , tmp ;
2537: LD_INT 0
2539: PPUSH
2540: PPUSH
2541: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
2542: LD_VAR 0 1
2546: PPUSH
2547: CALL_OW 255
2551: PUSH
2552: LD_EXP 8
2556: EQUAL
2557: PUSH
2558: LD_VAR 0 1
2562: PPUSH
2563: CALL_OW 266
2567: PUSH
2568: LD_INT 32
2570: EQUAL
2571: AND
2572: IFFALSE 2662
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
2574: LD_ADDR_VAR 0 4
2578: PUSH
2579: LD_INT 22
2581: PUSH
2582: LD_EXP 8
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: PUSH
2591: LD_INT 30
2593: PUSH
2594: LD_INT 5
2596: PUSH
2597: EMPTY
2598: LIST
2599: LIST
2600: PUSH
2601: EMPTY
2602: LIST
2603: LIST
2604: PPUSH
2605: CALL_OW 69
2609: ST_TO_ADDR
// tmp := NearestUnitToUnit ( arm , un ) ;
2610: LD_ADDR_VAR 0 5
2614: PUSH
2615: LD_VAR 0 4
2619: PPUSH
2620: LD_VAR 0 2
2624: PPUSH
2625: CALL_OW 74
2629: ST_TO_ADDR
// if tmp then
2630: LD_VAR 0 5
2634: IFFALSE 2662
// begin ComEnterUnit ( un , tmp ) ;
2636: LD_VAR 0 2
2640: PPUSH
2641: LD_VAR 0 5
2645: PPUSH
2646: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
2650: LD_VAR 0 2
2654: PPUSH
2655: LD_INT 8
2657: PPUSH
2658: CALL_OW 183
// end ; end ; end ; end_of_file
2662: PPOPN 5
2664: END
// export south_force , north_force , east_force , river_guard ; export function InitBot ; var i , ct , hex , side , un , veh , weapons , skill ; begin
2665: LD_INT 0
2667: PPUSH
2668: PPUSH
2669: PPUSH
2670: PPUSH
2671: PPUSH
2672: PPUSH
2673: PPUSH
2674: PPUSH
2675: PPUSH
// side := Bot_Side ;
2676: LD_ADDR_VAR 0 5
2680: PUSH
2681: LD_EXP 8
2685: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
2686: LD_ADDR_VAR 0 9
2690: PUSH
2691: LD_INT 4
2693: PUSH
2694: LD_INT 6
2696: PUSH
2697: LD_INT 8
2699: PUSH
2700: EMPTY
2701: LIST
2702: LIST
2703: LIST
2704: PUSH
2705: LD_OWVAR 67
2709: ARRAY
2710: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
2711: LD_ADDR_VAR 0 8
2715: PUSH
2716: LD_INT 27
2718: PUSH
2719: LD_INT 28
2721: PUSH
2722: LD_INT 25
2724: PUSH
2725: LD_INT 26
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: LIST
2732: LIST
2733: ST_TO_ADDR
// veh_counter := [ 4 , 5 , 6 ] [ Difficulty ] ;
2734: LD_ADDR_EXP 22
2738: PUSH
2739: LD_INT 4
2741: PUSH
2742: LD_INT 5
2744: PUSH
2745: LD_INT 6
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: PUSH
2753: LD_OWVAR 67
2757: ARRAY
2758: ST_TO_ADDR
// ct := [ ] ;
2759: LD_ADDR_VAR 0 3
2763: PUSH
2764: EMPTY
2765: ST_TO_ADDR
// patrols := [ ] ;
2766: LD_ADDR_EXP 19
2770: PUSH
2771: EMPTY
2772: ST_TO_ADDR
// attackers := [ ] ;
2773: LD_ADDR_EXP 20
2777: PUSH
2778: EMPTY
2779: ST_TO_ADDR
// river_guard := [ ] ;
2780: LD_ADDR_EXP 31
2784: PUSH
2785: EMPTY
2786: ST_TO_ADDR
// south_force := Defcon ( [ 3 , 3 , 4 ] [ Difficulty ] , 118 , 130 , false ) ;
2787: LD_ADDR_EXP 28
2791: PUSH
2792: LD_INT 3
2794: PUSH
2795: LD_INT 3
2797: PUSH
2798: LD_INT 4
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: LIST
2805: PUSH
2806: LD_OWVAR 67
2810: ARRAY
2811: PPUSH
2812: LD_INT 118
2814: PPUSH
2815: LD_INT 130
2817: PPUSH
2818: LD_INT 0
2820: PPUSH
2821: CALL 4651 0 4
2825: ST_TO_ADDR
// north_force := Defcon ( [ 4 , 5 , 6 ] [ Difficulty ] , 21 , 16 , false ) ;
2826: LD_ADDR_EXP 29
2830: PUSH
2831: LD_INT 4
2833: PUSH
2834: LD_INT 5
2836: PUSH
2837: LD_INT 6
2839: PUSH
2840: EMPTY
2841: LIST
2842: LIST
2843: LIST
2844: PUSH
2845: LD_OWVAR 67
2849: ARRAY
2850: PPUSH
2851: LD_INT 21
2853: PPUSH
2854: LD_INT 16
2856: PPUSH
2857: LD_INT 0
2859: PPUSH
2860: CALL 4651 0 4
2864: ST_TO_ADDR
// east_force := Defcon ( [ 4 , 5 , 5 ] [ Difficulty ] , 111 , 21 , true ) ;
2865: LD_ADDR_EXP 30
2869: PUSH
2870: LD_INT 4
2872: PUSH
2873: LD_INT 5
2875: PUSH
2876: LD_INT 5
2878: PUSH
2879: EMPTY
2880: LIST
2881: LIST
2882: LIST
2883: PUSH
2884: LD_OWVAR 67
2888: ARRAY
2889: PPUSH
2890: LD_INT 111
2892: PPUSH
2893: LD_INT 21
2895: PPUSH
2896: LD_INT 1
2898: PPUSH
2899: CALL 4651 0 4
2903: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
2904: LD_ADDR_EXP 21
2908: PUSH
2909: LD_INT 14
2911: PUSH
2912: LD_INT 1
2914: PUSH
2915: LD_INT 2
2917: PUSH
2918: LD_INT 27
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: PUSH
2927: LD_INT 14
2929: PUSH
2930: LD_INT 1
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: LD_INT 25
2938: PUSH
2939: EMPTY
2940: LIST
2941: LIST
2942: LIST
2943: LIST
2944: PUSH
2945: LD_INT 14
2947: PUSH
2948: LD_INT 1
2950: PUSH
2951: LD_INT 2
2953: PUSH
2954: LD_INT 28
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: LIST
2961: LIST
2962: PUSH
2963: LD_INT 14
2965: PUSH
2966: LD_INT 1
2968: PUSH
2969: LD_INT 2
2971: PUSH
2972: LD_INT 29
2974: PUSH
2975: EMPTY
2976: LIST
2977: LIST
2978: LIST
2979: LIST
2980: PUSH
2981: LD_INT 14
2983: PUSH
2984: LD_INT 1
2986: PUSH
2987: LD_INT 2
2989: PUSH
2990: LD_INT 27
2992: PUSH
2993: EMPTY
2994: LIST
2995: LIST
2996: LIST
2997: LIST
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: LIST
3004: LIST
3005: ST_TO_ADDR
// SetResourceType ( GetBase ( ar_base_east ) , mat_cans , 90000 ) ;
3006: LD_INT 81
3008: PPUSH
3009: CALL_OW 274
3013: PPUSH
3014: LD_INT 1
3016: PPUSH
3017: LD_INT 90000
3019: PPUSH
3020: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_oil , 9000 ) ;
3024: LD_INT 81
3026: PPUSH
3027: CALL_OW 274
3031: PPUSH
3032: LD_INT 2
3034: PPUSH
3035: LD_INT 9000
3037: PPUSH
3038: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_siberit , 3000 ) ;
3042: LD_INT 81
3044: PPUSH
3045: CALL_OW 274
3049: PPUSH
3050: LD_INT 3
3052: PPUSH
3053: LD_INT 3000
3055: PPUSH
3056: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_cans , 10000 ) ;
3060: LD_INT 81
3062: PPUSH
3063: CALL_OW 274
3067: PPUSH
3068: LD_INT 1
3070: PPUSH
3071: LD_INT 10000
3073: PPUSH
3074: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_oil , 1000 ) ;
3078: LD_INT 81
3080: PPUSH
3081: CALL_OW 274
3085: PPUSH
3086: LD_INT 2
3088: PPUSH
3089: LD_INT 1000
3091: PPUSH
3092: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_siberit , 1000 ) ;
3096: LD_INT 81
3098: PPUSH
3099: CALL_OW 274
3103: PPUSH
3104: LD_INT 3
3106: PPUSH
3107: LD_INT 1000
3109: PPUSH
3110: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_sout ) , mat_cans , [ 2000 , 1500 , 1000 ] [ Difficulty ] ) ;
3114: LD_INT 5
3116: PPUSH
3117: CALL_OW 274
3121: PPUSH
3122: LD_INT 1
3124: PPUSH
3125: LD_INT 2000
3127: PUSH
3128: LD_INT 1500
3130: PUSH
3131: LD_INT 1000
3133: PUSH
3134: EMPTY
3135: LIST
3136: LIST
3137: LIST
3138: PUSH
3139: LD_OWVAR 67
3143: ARRAY
3144: PPUSH
3145: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_sout ) , mat_oil , 1000 ) ;
3149: LD_INT 5
3151: PPUSH
3152: CALL_OW 274
3156: PPUSH
3157: LD_INT 2
3159: PPUSH
3160: LD_INT 1000
3162: PPUSH
3163: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_sout ) , mat_siberit , 100 ) ;
3167: LD_INT 5
3169: PPUSH
3170: CALL_OW 274
3174: PPUSH
3175: LD_INT 3
3177: PPUSH
3178: LD_INT 100
3180: PPUSH
3181: CALL_OW 277
// if Difficulty > 1 then
3185: LD_OWVAR 67
3189: PUSH
3190: LD_INT 1
3192: GREATER
3193: IFFALSE 3210
// SetTech ( 5 , side , state_researched ) ;
3195: LD_INT 5
3197: PPUSH
3198: LD_VAR 0 5
3202: PPUSH
3203: LD_INT 2
3205: PPUSH
3206: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
3210: LD_INT 51
3212: PPUSH
3213: LD_VAR 0 5
3217: PPUSH
3218: LD_INT 2
3220: PPUSH
3221: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
3225: LD_INT 52
3227: PPUSH
3228: LD_VAR 0 5
3232: PPUSH
3233: LD_INT 2
3235: PPUSH
3236: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
3240: LD_INT 53
3242: PPUSH
3243: LD_VAR 0 5
3247: PPUSH
3248: LD_INT 2
3250: PPUSH
3251: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
3255: LD_INT 60
3257: PPUSH
3258: LD_VAR 0 5
3262: PPUSH
3263: LD_INT 2
3265: PPUSH
3266: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
3270: LD_INT 61
3272: PPUSH
3273: LD_VAR 0 5
3277: PPUSH
3278: LD_INT 2
3280: PPUSH
3281: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
3285: LD_INT 62
3287: PPUSH
3288: LD_VAR 0 5
3292: PPUSH
3293: LD_INT 2
3295: PPUSH
3296: CALL_OW 322
// SetTech ( tech_bio1 , side , state_researched ) ;
3300: LD_INT 66
3302: PPUSH
3303: LD_VAR 0 5
3307: PPUSH
3308: LD_INT 2
3310: PPUSH
3311: CALL_OW 322
// if Difficulty > 1 then
3315: LD_OWVAR 67
3319: PUSH
3320: LD_INT 1
3322: GREATER
3323: IFFALSE 3340
// SetTech ( tech_bio2 , side , state_researched ) ;
3325: LD_INT 67
3327: PPUSH
3328: LD_VAR 0 5
3332: PPUSH
3333: LD_INT 2
3335: PPUSH
3336: CALL_OW 322
// if Difficulty > 2 then
3340: LD_OWVAR 67
3344: PUSH
3345: LD_INT 2
3347: GREATER
3348: IFFALSE 3365
// SetTech ( tech_bio3 , side , state_researched ) ;
3350: LD_INT 68
3352: PPUSH
3353: LD_VAR 0 5
3357: PPUSH
3358: LD_INT 2
3360: PPUSH
3361: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
3365: LD_ADDR_VAR 0 2
3369: PUSH
3370: LD_INT 22
3372: PUSH
3373: LD_VAR 0 5
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: PUSH
3382: LD_INT 21
3384: PUSH
3385: LD_INT 3
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: PPUSH
3396: CALL_OW 69
3400: PUSH
3401: FOR_IN
3402: IFFALSE 3435
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
3404: LD_VAR 0 2
3408: PPUSH
3409: LD_INT 6
3411: PUSH
3412: LD_INT 8
3414: PUSH
3415: LD_INT 10
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: LIST
3422: PUSH
3423: LD_OWVAR 67
3427: ARRAY
3428: PPUSH
3429: CALL_OW 241
3433: GO 3401
3435: POP
3436: POP
// PlaceMines ( mine_west_zone , [ 5 , 7 , 9 ] [ Difficulty ] ) ;
3437: LD_INT 7
3439: PPUSH
3440: LD_INT 5
3442: PUSH
3443: LD_INT 7
3445: PUSH
3446: LD_INT 9
3448: PUSH
3449: EMPTY
3450: LIST
3451: LIST
3452: LIST
3453: PUSH
3454: LD_OWVAR 67
3458: ARRAY
3459: PPUSH
3460: CALL 8536 0 2
// PlaceMines ( mine_east_zone , [ 20 , 25 , 30 ] [ Difficulty ] ) ;
3464: LD_INT 9
3466: PPUSH
3467: LD_INT 20
3469: PUSH
3470: LD_INT 25
3472: PUSH
3473: LD_INT 30
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: PUSH
3481: LD_OWVAR 67
3485: ARRAY
3486: PPUSH
3487: CALL 8536 0 2
// PlaceMines ( mine_center_zone , [ 6 , 8 , 9 ] [ Difficulty ] ) ;
3491: LD_INT 8
3493: PPUSH
3494: LD_INT 6
3496: PUSH
3497: LD_INT 8
3499: PUSH
3500: LD_INT 9
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: LIST
3507: PUSH
3508: LD_OWVAR 67
3512: ARRAY
3513: PPUSH
3514: CALL 8536 0 2
// PlaceMines ( mine_pass_zone , [ 4 , 6 , 9 ] [ Difficulty ] ) ;
3518: LD_INT 10
3520: PPUSH
3521: LD_INT 4
3523: PUSH
3524: LD_INT 6
3526: PUSH
3527: LD_INT 9
3529: PUSH
3530: EMPTY
3531: LIST
3532: LIST
3533: LIST
3534: PUSH
3535: LD_OWVAR 67
3539: ARRAY
3540: PPUSH
3541: CALL 8536 0 2
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
3545: LD_INT 11
3547: PPUSH
3548: LD_INT 2
3550: PUSH
3551: LD_INT 5
3553: PUSH
3554: LD_INT 8
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: PUSH
3562: LD_OWVAR 67
3566: ARRAY
3567: PPUSH
3568: CALL 8536 0 2
// PlaceMines ( mine_southpass_zone , [ 2 , 4 , 6 ] [ Difficulty ] ) ;
3572: LD_INT 12
3574: PPUSH
3575: LD_INT 2
3577: PUSH
3578: LD_INT 4
3580: PUSH
3581: LD_INT 6
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: LIST
3588: PUSH
3589: LD_OWVAR 67
3593: ARRAY
3594: PPUSH
3595: CALL 8536 0 2
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
3599: LD_ADDR_VAR 0 2
3603: PUSH
3604: DOUBLE
3605: LD_INT 1
3607: DEC
3608: ST_TO_ADDR
3609: LD_INT 8
3611: PUSH
3612: LD_INT 11
3614: PUSH
3615: LD_INT 14
3617: PUSH
3618: EMPTY
3619: LIST
3620: LIST
3621: LIST
3622: PUSH
3623: LD_OWVAR 67
3627: ARRAY
3628: PUSH
3629: FOR_TO
3630: IFFALSE 3805
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
3632: LD_ADDR_VAR 0 4
3636: PUSH
3637: LD_INT 134
3639: PPUSH
3640: LD_INT 73
3642: PPUSH
3643: LD_INT 10
3645: PPUSH
3646: LD_INT 0
3648: PPUSH
3649: CALL_OW 17
3653: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
3654: LD_VAR 0 4
3658: PUSH
3659: LD_INT 1
3661: ARRAY
3662: PPUSH
3663: LD_VAR 0 4
3667: PUSH
3668: LD_INT 2
3670: ARRAY
3671: PPUSH
3672: CALL_OW 428
3676: PUSH
3677: LD_INT 0
3679: EQUAL
3680: PUSH
3681: LD_VAR 0 4
3685: PUSH
3686: LD_INT 1
3688: ARRAY
3689: PPUSH
3690: LD_VAR 0 4
3694: PUSH
3695: LD_INT 2
3697: ARRAY
3698: PPUSH
3699: CALL_OW 458
3703: NOT
3704: AND
3705: IFFALSE 3803
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
3707: LD_ADDR_EXP 17
3711: PUSH
3712: LD_EXP 17
3716: PPUSH
3717: LD_EXP 17
3721: PUSH
3722: LD_INT 1
3724: PLUS
3725: PPUSH
3726: LD_VAR 0 4
3730: PUSH
3731: LD_INT 1
3733: ARRAY
3734: PPUSH
3735: CALL_OW 2
3739: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
3740: LD_ADDR_EXP 17
3744: PUSH
3745: LD_EXP 17
3749: PPUSH
3750: LD_EXP 17
3754: PUSH
3755: LD_INT 1
3757: PLUS
3758: PPUSH
3759: LD_VAR 0 4
3763: PUSH
3764: LD_INT 2
3766: ARRAY
3767: PPUSH
3768: CALL_OW 2
3772: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
3773: LD_VAR 0 4
3777: PUSH
3778: LD_INT 1
3780: ARRAY
3781: PPUSH
3782: LD_VAR 0 4
3786: PUSH
3787: LD_INT 2
3789: ARRAY
3790: PPUSH
3791: LD_EXP 8
3795: PPUSH
3796: LD_INT 0
3798: PPUSH
3799: CALL_OW 454
// end ; end ;
3803: GO 3629
3805: POP
3806: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
3807: LD_ADDR_VAR 0 2
3811: PUSH
3812: LD_INT 22
3814: PUSH
3815: LD_VAR 0 5
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: LD_INT 30
3826: PUSH
3827: LD_INT 32
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: PPUSH
3838: CALL_OW 69
3842: PUSH
3843: FOR_IN
3844: IFFALSE 3876
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
3846: LD_VAR 0 2
3850: PPUSH
3851: LD_VAR 0 8
3855: PUSH
3856: LD_INT 1
3858: PPUSH
3859: LD_VAR 0 8
3863: PPUSH
3864: CALL_OW 12
3868: ARRAY
3869: PPUSH
3870: CALL_OW 431
3874: GO 3843
3876: POP
3877: POP
// uc_side := side ;
3878: LD_ADDR_OWVAR 20
3882: PUSH
3883: LD_VAR 0 5
3887: ST_TO_ADDR
// uc_nation := 2 ;
3888: LD_ADDR_OWVAR 21
3892: PUSH
3893: LD_INT 2
3895: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
3896: LD_ADDR_VAR 0 2
3900: PUSH
3901: DOUBLE
3902: LD_INT 1
3904: DEC
3905: ST_TO_ADDR
3906: LD_INT 1
3908: PUSH
3909: LD_OWVAR 67
3913: PLUS
3914: PUSH
3915: FOR_TO
3916: IFFALSE 4006
// begin vc_chassis := ar_half_tracked ;
3918: LD_ADDR_OWVAR 37
3922: PUSH
3923: LD_INT 14
3925: ST_TO_ADDR
// vc_engine := engine_combustion ;
3926: LD_ADDR_OWVAR 39
3930: PUSH
3931: LD_INT 1
3933: ST_TO_ADDR
// vc_control := control_manual ;
3934: LD_ADDR_OWVAR 38
3938: PUSH
3939: LD_INT 1
3941: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3942: LD_ADDR_OWVAR 40
3946: PUSH
3947: LD_INT 31
3949: ST_TO_ADDR
// veh := CreateVehicle ;
3950: LD_ADDR_VAR 0 7
3954: PUSH
3955: CALL_OW 45
3959: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
3960: LD_VAR 0 7
3964: PPUSH
3965: LD_INT 13
3967: PPUSH
3968: LD_INT 0
3970: PPUSH
3971: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3975: LD_INT 0
3977: PPUSH
3978: LD_INT 3
3980: PPUSH
3981: LD_VAR 0 9
3985: PPUSH
3986: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3990: CALL_OW 44
3994: PPUSH
3995: LD_VAR 0 7
3999: PPUSH
4000: CALL_OW 52
// end ;
4004: GO 3915
4006: POP
4007: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4008: LD_ADDR_VAR 0 2
4012: PUSH
4013: LD_INT 22
4015: PUSH
4016: LD_VAR 0 5
4020: PUSH
4021: EMPTY
4022: LIST
4023: LIST
4024: PUSH
4025: LD_INT 30
4027: PUSH
4028: LD_INT 32
4030: PUSH
4031: EMPTY
4032: LIST
4033: LIST
4034: PUSH
4035: EMPTY
4036: LIST
4037: LIST
4038: PPUSH
4039: CALL_OW 69
4043: PUSH
4044: FOR_IN
4045: IFFALSE 4078
// begin PrepareHuman ( false , 1 , skill ) ;
4047: LD_INT 0
4049: PPUSH
4050: LD_INT 1
4052: PPUSH
4053: LD_VAR 0 9
4057: PPUSH
4058: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4062: CALL_OW 44
4066: PPUSH
4067: LD_VAR 0 2
4071: PPUSH
4072: CALL_OW 52
// end ;
4076: GO 4044
4078: POP
4079: POP
// for i = 1 to 4 do
4080: LD_ADDR_VAR 0 2
4084: PUSH
4085: DOUBLE
4086: LD_INT 1
4088: DEC
4089: ST_TO_ADDR
4090: LD_INT 4
4092: PUSH
4093: FOR_TO
4094: IFFALSE 4125
// begin PrepareHuman ( false , 2 , skill ) ;
4096: LD_INT 0
4098: PPUSH
4099: LD_INT 2
4101: PPUSH
4102: LD_VAR 0 9
4106: PPUSH
4107: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_base_east ) ;
4111: CALL_OW 44
4115: PPUSH
4116: LD_INT 81
4118: PPUSH
4119: CALL_OW 52
// end ;
4123: GO 4093
4125: POP
4126: POP
// for i = 1 to 6 do
4127: LD_ADDR_VAR 0 2
4131: PUSH
4132: DOUBLE
4133: LD_INT 1
4135: DEC
4136: ST_TO_ADDR
4137: LD_INT 6
4139: PUSH
4140: FOR_TO
4141: IFFALSE 4172
// begin PrepareHuman ( false , 3 , skill ) ;
4143: LD_INT 0
4145: PPUSH
4146: LD_INT 3
4148: PPUSH
4149: LD_VAR 0 9
4153: PPUSH
4154: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac_east ) ;
4158: CALL_OW 44
4162: PPUSH
4163: LD_INT 88
4165: PPUSH
4166: CALL_OW 52
// end ;
4170: GO 4140
4172: POP
4173: POP
// for i = 1 to 4 do
4174: LD_ADDR_VAR 0 2
4178: PUSH
4179: DOUBLE
4180: LD_INT 1
4182: DEC
4183: ST_TO_ADDR
4184: LD_INT 4
4186: PUSH
4187: FOR_TO
4188: IFFALSE 4245
// begin PrepareHuman ( false , 4 , skill ) ;
4190: LD_INT 0
4192: PPUSH
4193: LD_INT 4
4195: PPUSH
4196: LD_VAR 0 9
4200: PPUSH
4201: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
4205: CALL_OW 44
4209: PPUSH
4210: LD_INT 30
4212: PUSH
4213: LD_INT 8
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PPUSH
4220: CALL_OW 69
4224: PUSH
4225: LD_VAR 0 2
4229: PUSH
4230: LD_INT 2
4232: MOD
4233: PUSH
4234: LD_INT 1
4236: PLUS
4237: ARRAY
4238: PPUSH
4239: CALL_OW 52
// end ;
4243: GO 4187
4245: POP
4246: POP
// PrepareHuman ( false , class_sniper , skill ) ;
4247: LD_INT 0
4249: PPUSH
4250: LD_INT 5
4252: PPUSH
4253: LD_VAR 0 9
4257: PPUSH
4258: CALL_OW 380
// un := CreateHuman ;
4262: LD_ADDR_VAR 0 6
4266: PUSH
4267: CALL_OW 44
4271: ST_TO_ADDR
// SetDir ( un , 3 ) ;
4272: LD_VAR 0 6
4276: PPUSH
4277: LD_INT 3
4279: PPUSH
4280: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
4284: LD_VAR 0 6
4288: PPUSH
4289: LD_INT 52
4291: PPUSH
4292: CALL_OW 52
// for i = 1 to 4 do
4296: LD_ADDR_VAR 0 2
4300: PUSH
4301: DOUBLE
4302: LD_INT 1
4304: DEC
4305: ST_TO_ADDR
4306: LD_INT 4
4308: PUSH
4309: FOR_TO
4310: IFFALSE 4366
// begin uc_nation := 0 ;
4312: LD_ADDR_OWVAR 21
4316: PUSH
4317: LD_INT 0
4319: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
4320: LD_INT 0
4322: PPUSH
4323: LD_INT 16
4325: PPUSH
4326: LD_INT 1
4328: PPUSH
4329: CALL_OW 380
// un := CreateHuman ;
4333: LD_ADDR_VAR 0 6
4337: PUSH
4338: CALL_OW 44
4342: ST_TO_ADDR
// PlaceUnitXYR ( un , 116 , 128 , 8 , false ) ;
4343: LD_VAR 0 6
4347: PPUSH
4348: LD_INT 116
4350: PPUSH
4351: LD_INT 128
4353: PPUSH
4354: LD_INT 8
4356: PPUSH
4357: LD_INT 0
4359: PPUSH
4360: CALL_OW 50
// end ;
4364: GO 4309
4366: POP
4367: POP
// for i = 1 to 3 do
4368: LD_ADDR_VAR 0 2
4372: PUSH
4373: DOUBLE
4374: LD_INT 1
4376: DEC
4377: ST_TO_ADDR
4378: LD_INT 3
4380: PUSH
4381: FOR_TO
4382: IFFALSE 4438
// begin uc_nation := 0 ;
4384: LD_ADDR_OWVAR 21
4388: PUSH
4389: LD_INT 0
4391: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
4392: LD_INT 0
4394: PPUSH
4395: LD_INT 16
4397: PPUSH
4398: LD_INT 1
4400: PPUSH
4401: CALL_OW 380
// un := CreateHuman ;
4405: LD_ADDR_VAR 0 6
4409: PUSH
4410: CALL_OW 44
4414: ST_TO_ADDR
// PlaceUnitXYR ( un , 23 , 19 , 8 , false ) ;
4415: LD_VAR 0 6
4419: PPUSH
4420: LD_INT 23
4422: PPUSH
4423: LD_INT 19
4425: PPUSH
4426: LD_INT 8
4428: PPUSH
4429: LD_INT 0
4431: PPUSH
4432: CALL_OW 50
// end ;
4436: GO 4381
4438: POP
4439: POP
// for i = 1 to 3 * Difficulty do
4440: LD_ADDR_VAR 0 2
4444: PUSH
4445: DOUBLE
4446: LD_INT 1
4448: DEC
4449: ST_TO_ADDR
4450: LD_INT 3
4452: PUSH
4453: LD_OWVAR 67
4457: MUL
4458: PUSH
4459: FOR_TO
4460: IFFALSE 4534
// begin uc_nation := 0 ;
4462: LD_ADDR_OWVAR 21
4466: PUSH
4467: LD_INT 0
4469: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
4470: LD_INT 0
4472: PPUSH
4473: LD_INT 17
4475: PPUSH
4476: LD_INT 3
4478: PPUSH
4479: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
4483: LD_ADDR_OWVAR 29
4487: PUSH
4488: LD_INT 11
4490: PUSH
4491: LD_INT 13
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: ST_TO_ADDR
// un := CreateHuman ;
4498: LD_ADDR_VAR 0 6
4502: PUSH
4503: CALL_OW 44
4507: ST_TO_ADDR
// PlaceUnitArea ( un , ap1 , false ) ;
4508: LD_VAR 0 6
4512: PPUSH
4513: LD_INT 14
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 49
// ComHold ( un ) ;
4523: LD_VAR 0 6
4527: PPUSH
4528: CALL_OW 140
// end ;
4532: GO 4459
4534: POP
4535: POP
// for i = 1 to Difficulty do
4536: LD_ADDR_VAR 0 2
4540: PUSH
4541: DOUBLE
4542: LD_INT 1
4544: DEC
4545: ST_TO_ADDR
4546: LD_OWVAR 67
4550: PUSH
4551: FOR_TO
4552: IFFALSE 4644
// begin uc_nation := nation_arabian ;
4554: LD_ADDR_OWVAR 21
4558: PUSH
4559: LD_INT 2
4561: ST_TO_ADDR
// vc_chassis := ar_hovercraft ;
4562: LD_ADDR_OWVAR 37
4566: PUSH
4567: LD_INT 11
4569: ST_TO_ADDR
// vc_engine := engine_solar ;
4570: LD_ADDR_OWVAR 39
4574: PUSH
4575: LD_INT 2
4577: ST_TO_ADDR
// vc_control := control_remote ;
4578: LD_ADDR_OWVAR 38
4582: PUSH
4583: LD_INT 2
4585: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
4586: LD_ADDR_OWVAR 40
4590: PUSH
4591: LD_INT 24
4593: ST_TO_ADDR
// veh := CreateVehicle ;
4594: LD_ADDR_VAR 0 7
4598: PUSH
4599: CALL_OW 45
4603: ST_TO_ADDR
// river_guard := Insert ( river_guard , 1 , veh ) ;
4604: LD_ADDR_EXP 31
4608: PUSH
4609: LD_EXP 31
4613: PPUSH
4614: LD_INT 1
4616: PPUSH
4617: LD_VAR 0 7
4621: PPUSH
4622: CALL_OW 2
4626: ST_TO_ADDR
// PlaceUnitArea ( veh , river_spawn , false ) ;
4627: LD_VAR 0 7
4631: PPUSH
4632: LD_INT 19
4634: PPUSH
4635: LD_INT 0
4637: PPUSH
4638: CALL_OW 49
// end ;
4642: GO 4551
4644: POP
4645: POP
// end ;
4646: LD_VAR 0 1
4650: RET
// export function Defcon ( n , x , y , type ) ; var i , un , veh , list ; begin
4651: LD_INT 0
4653: PPUSH
4654: PPUSH
4655: PPUSH
4656: PPUSH
4657: PPUSH
// list := [ ] ;
4658: LD_ADDR_VAR 0 9
4662: PUSH
4663: EMPTY
4664: ST_TO_ADDR
// uc_side := bot_side ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_EXP 8
4674: ST_TO_ADDR
// uc_nation := nation_arabian ;
4675: LD_ADDR_OWVAR 21
4679: PUSH
4680: LD_INT 2
4682: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4683: LD_ADDR_OWVAR 37
4687: PUSH
4688: LD_INT 14
4690: ST_TO_ADDR
// vc_engine := engine_siberite ;
4691: LD_ADDR_OWVAR 39
4695: PUSH
4696: LD_INT 3
4698: ST_TO_ADDR
// if type then
4699: LD_VAR 0 4
4703: IFFALSE 4715
// vc_control := control_manual else
4705: LD_ADDR_OWVAR 38
4709: PUSH
4710: LD_INT 1
4712: ST_TO_ADDR
4713: GO 4723
// vc_control := control_apeman ;
4715: LD_ADDR_OWVAR 38
4719: PUSH
4720: LD_INT 5
4722: ST_TO_ADDR
// for i = 1 to n do
4723: LD_ADDR_VAR 0 6
4727: PUSH
4728: DOUBLE
4729: LD_INT 1
4731: DEC
4732: ST_TO_ADDR
4733: LD_VAR 0 1
4737: PUSH
4738: FOR_TO
4739: IFFALSE 4882
// begin vc_weapon := [ ar_rocket_launcher , ar_flame_thrower , ar_gun ] [ Rand ( 1 , 3 ) ] ;
4741: LD_ADDR_OWVAR 40
4745: PUSH
4746: LD_INT 28
4748: PUSH
4749: LD_INT 26
4751: PUSH
4752: LD_INT 27
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: LIST
4759: PUSH
4760: LD_INT 1
4762: PPUSH
4763: LD_INT 3
4765: PPUSH
4766: CALL_OW 12
4770: ARRAY
4771: ST_TO_ADDR
// veh := CreateVehicle ;
4772: LD_ADDR_VAR 0 8
4776: PUSH
4777: CALL_OW 45
4781: ST_TO_ADDR
// PlaceUnitXYR ( veh , x , y , 13 , false ) ;
4782: LD_VAR 0 8
4786: PPUSH
4787: LD_VAR 0 2
4791: PPUSH
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_INT 13
4799: PPUSH
4800: LD_INT 0
4802: PPUSH
4803: CALL_OW 50
// if type then
4807: LD_VAR 0 4
4811: IFFALSE 4857
// begin PrepareHuman ( false , 3 , [ 4 , 6 , 8 ] [ Difficulty ] ) ;
4813: LD_INT 0
4815: PPUSH
4816: LD_INT 3
4818: PPUSH
4819: LD_INT 4
4821: PUSH
4822: LD_INT 6
4824: PUSH
4825: LD_INT 8
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: LIST
4832: PUSH
4833: LD_OWVAR 67
4837: ARRAY
4838: PPUSH
4839: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4843: CALL_OW 44
4847: PPUSH
4848: LD_VAR 0 8
4852: PPUSH
4853: CALL_OW 52
// end ; list := Insert ( list , 1 , veh ) ;
4857: LD_ADDR_VAR 0 9
4861: PUSH
4862: LD_VAR 0 9
4866: PPUSH
4867: LD_INT 1
4869: PPUSH
4870: LD_VAR 0 8
4874: PPUSH
4875: CALL_OW 2
4879: ST_TO_ADDR
// end ;
4880: GO 4738
4882: POP
4883: POP
// result := list ;
4884: LD_ADDR_VAR 0 5
4888: PUSH
4889: LD_VAR 0 9
4893: ST_TO_ADDR
// end ;
4894: LD_VAR 0 5
4898: RET
// every 0 0$03 trigger FilterUnitsInArea ( pass_guard , [ f_enemy , bot_side ] ) do var i ;
4899: LD_INT 16
4901: PPUSH
4902: LD_INT 81
4904: PUSH
4905: LD_EXP 8
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: PPUSH
4914: CALL_OW 70
4918: IFFALSE 4996
4920: GO 4922
4922: DISABLE
4923: LD_INT 0
4925: PPUSH
// begin if not north_force then
4926: LD_EXP 29
4930: NOT
4931: IFFALSE 4935
// exit ;
4933: GO 4996
// for i = 1 to north_force do
4935: LD_ADDR_VAR 0 1
4939: PUSH
4940: DOUBLE
4941: LD_INT 1
4943: DEC
4944: ST_TO_ADDR
4945: LD_EXP 29
4949: PUSH
4950: FOR_TO
4951: IFFALSE 4976
// begin ComMoveXY ( north_force [ i ] , 38 , 57 ) ;
4953: LD_EXP 29
4957: PUSH
4958: LD_VAR 0 1
4962: ARRAY
4963: PPUSH
4964: LD_INT 38
4966: PPUSH
4967: LD_INT 57
4969: PPUSH
4970: CALL_OW 111
// end ;
4974: GO 4950
4976: POP
4977: POP
// PlaceSeeing ( 54 , 69 , bot_side , 10 ) ;
4978: LD_INT 54
4980: PPUSH
4981: LD_INT 69
4983: PPUSH
4984: LD_EXP 8
4988: PPUSH
4989: LD_INT 10
4991: PPUSH
4992: CALL_OW 330
// end ;
4996: PPOPN 1
4998: END
// every 0 0$03 trigger FilterUnitsInArea ( bridge_protect , [ f_enemy , bot_side ] ) do var i ;
4999: LD_INT 18
5001: PPUSH
5002: LD_INT 81
5004: PUSH
5005: LD_EXP 8
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PPUSH
5014: CALL_OW 70
5018: IFFALSE 5078
5020: GO 5022
5022: DISABLE
5023: LD_INT 0
5025: PPUSH
// begin if not south_force then
5026: LD_EXP 28
5030: NOT
5031: IFFALSE 5035
// exit ;
5033: GO 5078
// for i = 1 to south_force do
5035: LD_ADDR_VAR 0 1
5039: PUSH
5040: DOUBLE
5041: LD_INT 1
5043: DEC
5044: ST_TO_ADDR
5045: LD_EXP 28
5049: PUSH
5050: FOR_TO
5051: IFFALSE 5076
// begin ComMoveXY ( south_force [ i ] , 157 , 140 ) ;
5053: LD_EXP 28
5057: PUSH
5058: LD_VAR 0 1
5062: ARRAY
5063: PPUSH
5064: LD_INT 157
5066: PPUSH
5067: LD_INT 140
5069: PPUSH
5070: CALL_OW 111
// end ;
5074: GO 5050
5076: POP
5077: POP
// end ;
5078: PPOPN 1
5080: END
// every 12 12$00 trigger ar_fac_east and FilterAllUnits ( [ [ f_enemy , bot_side ] , [ f_btype , b_warehouse ] ] ) do var i , tmp , p ;
5081: LD_INT 88
5083: PUSH
5084: LD_INT 81
5086: PUSH
5087: LD_EXP 8
5091: PUSH
5092: EMPTY
5093: LIST
5094: LIST
5095: PUSH
5096: LD_INT 30
5098: PUSH
5099: LD_INT 1
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: EMPTY
5107: LIST
5108: LIST
5109: PPUSH
5110: CALL_OW 69
5114: AND
5115: IFFALSE 5351
5117: GO 5119
5119: DISABLE
5120: LD_INT 0
5122: PPUSH
5123: PPUSH
5124: PPUSH
// begin enable ;
5125: ENABLE
// tmp := queue_codes [ rng ] ;
5126: LD_ADDR_VAR 0 2
5130: PUSH
5131: LD_EXP 23
5135: PUSH
5136: LD_EXP 24
5140: ARRAY
5141: ST_TO_ADDR
// p := 1 ;
5142: LD_ADDR_VAR 0 3
5146: PUSH
5147: LD_INT 1
5149: ST_TO_ADDR
// for i = 1 to veh_counter do
5150: LD_ADDR_VAR 0 1
5154: PUSH
5155: DOUBLE
5156: LD_INT 1
5158: DEC
5159: ST_TO_ADDR
5160: LD_EXP 22
5164: PUSH
5165: FOR_TO
5166: IFFALSE 5315
// begin AddComConstruct ( ar_fac_east , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
5168: LD_INT 88
5170: PPUSH
5171: LD_EXP 21
5175: PUSH
5176: LD_VAR 0 2
5180: PUSH
5181: LD_INT 10
5183: MOD
5184: ARRAY
5185: PUSH
5186: LD_INT 1
5188: ARRAY
5189: PPUSH
5190: LD_EXP 21
5194: PUSH
5195: LD_VAR 0 2
5199: PUSH
5200: LD_INT 10
5202: MOD
5203: ARRAY
5204: PUSH
5205: LD_INT 2
5207: ARRAY
5208: PPUSH
5209: LD_EXP 21
5213: PUSH
5214: LD_VAR 0 2
5218: PUSH
5219: LD_INT 10
5221: MOD
5222: ARRAY
5223: PUSH
5224: LD_INT 3
5226: ARRAY
5227: PPUSH
5228: LD_EXP 21
5232: PUSH
5233: LD_VAR 0 2
5237: PUSH
5238: LD_INT 10
5240: MOD
5241: ARRAY
5242: PUSH
5243: LD_INT 4
5245: ARRAY
5246: PPUSH
5247: CALL_OW 185
// tmp := tmp / 10 ;
5251: LD_ADDR_VAR 0 2
5255: PUSH
5256: LD_VAR 0 2
5260: PUSH
5261: LD_INT 10
5263: DIVREAL
5264: ST_TO_ADDR
// p := p + 1 ;
5265: LD_ADDR_VAR 0 3
5269: PUSH
5270: LD_VAR 0 3
5274: PUSH
5275: LD_INT 1
5277: PLUS
5278: ST_TO_ADDR
// if p > 5 then
5279: LD_VAR 0 3
5283: PUSH
5284: LD_INT 5
5286: GREATER
5287: IFFALSE 5313
// begin p := 1 ;
5289: LD_ADDR_VAR 0 3
5293: PUSH
5294: LD_INT 1
5296: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
5297: LD_ADDR_VAR 0 2
5301: PUSH
5302: LD_EXP 23
5306: PUSH
5307: LD_EXP 24
5311: ARRAY
5312: ST_TO_ADDR
// end ; end ;
5313: GO 5165
5315: POP
5316: POP
// rng := rng + 1 ;
5317: LD_ADDR_EXP 24
5321: PUSH
5322: LD_EXP 24
5326: PUSH
5327: LD_INT 1
5329: PLUS
5330: ST_TO_ADDR
// if rng > queue_codes then
5331: LD_EXP 24
5335: PUSH
5336: LD_EXP 23
5340: GREATER
5341: IFFALSE 5351
// rng := 1 ;
5343: LD_ADDR_EXP 24
5347: PUSH
5348: LD_INT 1
5350: ST_TO_ADDR
// end ;
5351: PPOPN 3
5353: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
5354: LD_INT 25
5356: PUSH
5357: LD_INT 17
5359: PUSH
5360: EMPTY
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL_OW 69
5368: IFFALSE 5471
5370: GO 5372
5372: DISABLE
5373: LD_INT 0
5375: PPUSH
5376: PPUSH
// begin enable ;
5377: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
5378: LD_ADDR_VAR 0 1
5382: PUSH
5383: LD_INT 25
5385: PUSH
5386: LD_INT 17
5388: PUSH
5389: EMPTY
5390: LIST
5391: LIST
5392: PPUSH
5393: CALL_OW 69
5397: PUSH
5398: FOR_IN
5399: IFFALSE 5469
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
5401: LD_ADDR_VAR 0 2
5405: PUSH
5406: LD_INT 81
5408: PUSH
5409: LD_EXP 8
5413: PUSH
5414: EMPTY
5415: LIST
5416: LIST
5417: PPUSH
5418: CALL_OW 69
5422: PPUSH
5423: LD_VAR 0 1
5427: PPUSH
5428: CALL_OW 74
5432: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
5433: LD_VAR 0 1
5437: PPUSH
5438: LD_VAR 0 2
5442: PPUSH
5443: CALL_OW 296
5447: PUSH
5448: LD_INT 15
5450: LESS
5451: IFFALSE 5467
// ComAttackUnit ( i , un ) ;
5453: LD_VAR 0 1
5457: PPUSH
5458: LD_VAR 0 2
5462: PPUSH
5463: CALL_OW 115
// end ;
5467: GO 5398
5469: POP
5470: POP
// end ;
5471: PPOPN 2
5473: END
// every 0 0$01 trigger attackers marked 17 do var i ;
5474: LD_EXP 20
5478: IFFALSE 5572
5480: GO 5482
5482: DISABLE
5483: LD_INT 0
5485: PPUSH
// begin enable ;
5486: ENABLE
// if target = 0 then
5487: LD_EXP 25
5491: PUSH
5492: LD_INT 0
5494: EQUAL
5495: IFFALSE 5519
// target := FilterAllUnits ( [ f_enemy , bot_side ] ) ;
5497: LD_ADDR_EXP 25
5501: PUSH
5502: LD_INT 81
5504: PUSH
5505: LD_EXP 8
5509: PUSH
5510: EMPTY
5511: LIST
5512: LIST
5513: PPUSH
5514: CALL_OW 69
5518: ST_TO_ADDR
// for i in attackers do
5519: LD_ADDR_VAR 0 1
5523: PUSH
5524: LD_EXP 20
5528: PUSH
5529: FOR_IN
5530: IFFALSE 5570
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , target ] ) , i ) ) ;
5532: LD_VAR 0 1
5536: PPUSH
5537: LD_INT 22
5539: PUSH
5540: LD_EXP 25
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: PPUSH
5549: CALL_OW 69
5553: PPUSH
5554: LD_VAR 0 1
5558: PPUSH
5559: CALL_OW 74
5563: PPUSH
5564: CALL_OW 115
5568: GO 5529
5570: POP
5571: POP
// end ;
5572: PPOPN 1
5574: END
// every 0 0$01 trigger not attackers marked 17 do
5575: LD_EXP 20
5579: NOT
5580: IFFALSE 5589
5582: GO 5584
5584: DISABLE
// begin enable ;
5585: ENABLE
// disable ( 17 ) ;
5586: LD_INT 17
5588: DISABLE_MARKED
// end ;
5589: END
// every 3 3$00 trigger veh_counter <= attackers do var max , i ;
5590: LD_EXP 22
5594: PUSH
5595: LD_EXP 20
5599: LESSEQUAL
5600: IFFALSE 5709
5602: GO 5604
5604: DISABLE
5605: LD_INT 0
5607: PPUSH
5608: PPUSH
// begin enable ;
5609: ENABLE
// enable ( 17 ) ;
5610: LD_INT 17
5612: ENABLE_MARKED
// max := 1 ;
5613: LD_ADDR_VAR 0 1
5617: PUSH
5618: LD_INT 1
5620: ST_TO_ADDR
// for i = 1 to 8 do
5621: LD_ADDR_VAR 0 2
5625: PUSH
5626: DOUBLE
5627: LD_INT 1
5629: DEC
5630: ST_TO_ADDR
5631: LD_INT 8
5633: PUSH
5634: FOR_TO
5635: IFFALSE 5707
// if i <> bot_side then
5637: LD_VAR 0 2
5641: PUSH
5642: LD_EXP 8
5646: NONEQUAL
5647: IFFALSE 5705
// begin if max < FilterAllUnits ( [ f_side , i ] ) then
5649: LD_VAR 0 1
5653: PUSH
5654: LD_INT 22
5656: PUSH
5657: LD_VAR 0 2
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PPUSH
5666: CALL_OW 69
5670: LESS
5671: IFFALSE 5705
// begin max := FilterAllUnits ( [ f_side , i ] ) ;
5673: LD_ADDR_VAR 0 1
5677: PUSH
5678: LD_INT 22
5680: PUSH
5681: LD_VAR 0 2
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PPUSH
5690: CALL_OW 69
5694: ST_TO_ADDR
// target := i ;
5695: LD_ADDR_EXP 25
5699: PUSH
5700: LD_VAR 0 2
5704: ST_TO_ADDR
// end ; end ;
5705: GO 5634
5707: POP
5708: POP
// end ;
5709: PPOPN 2
5711: END
// every 0 0$01 trigger game_start and tick >= 20 20$00 do
5712: LD_EXP 9
5716: PUSH
5717: LD_OWVAR 1
5721: PUSH
5722: LD_INT 42000
5724: GREATEREQUAL
5725: AND
5726: IFFALSE 5745
5728: GO 5730
5730: DISABLE
// begin veh_counter := veh_counter + 1 ;
5731: LD_ADDR_EXP 22
5735: PUSH
5736: LD_EXP 22
5740: PUSH
5741: LD_INT 1
5743: PLUS
5744: ST_TO_ADDR
// end ;
5745: END
// every 0 0$01 trigger game_start and tick >= 40 40$00 do
5746: LD_EXP 9
5750: PUSH
5751: LD_OWVAR 1
5755: PUSH
5756: LD_INT 84000
5758: GREATEREQUAL
5759: AND
5760: IFFALSE 5779
5762: GO 5764
5764: DISABLE
// begin veh_counter := veh_counter + 2 ;
5765: LD_ADDR_EXP 22
5769: PUSH
5770: LD_EXP 22
5774: PUSH
5775: LD_INT 2
5777: PLUS
5778: ST_TO_ADDR
// end ;
5779: END
// every 0 0$01 trigger game_start and tick >= 60 60$00 do
5780: LD_EXP 9
5784: PUSH
5785: LD_OWVAR 1
5789: PUSH
5790: LD_INT 126000
5792: GREATEREQUAL
5793: AND
5794: IFFALSE 5813
5796: GO 5798
5798: DISABLE
// begin veh_counter := veh_counter + 3 ;
5799: LD_ADDR_EXP 22
5803: PUSH
5804: LD_EXP 22
5808: PUSH
5809: LD_INT 3
5811: PLUS
5812: ST_TO_ADDR
// end ;
5813: END
// every 0 0$03 trigger FilterUnitsInArea ( bridge2_protect , [ f_enemy , bot_side ] ) do var i ;
5814: LD_INT 24
5816: PPUSH
5817: LD_INT 81
5819: PUSH
5820: LD_EXP 8
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: PPUSH
5829: CALL_OW 70
5833: IFFALSE 5881
5835: GO 5837
5837: DISABLE
5838: LD_INT 0
5840: PPUSH
// begin for i = 1 to river_guard do
5841: LD_ADDR_VAR 0 1
5845: PUSH
5846: DOUBLE
5847: LD_INT 1
5849: DEC
5850: ST_TO_ADDR
5851: LD_EXP 31
5855: PUSH
5856: FOR_TO
5857: IFFALSE 5879
// ComMoveToArea ( river_guard [ i ] , bridge2_protect ) ;
5859: LD_EXP 31
5863: PUSH
5864: LD_VAR 0 1
5868: ARRAY
5869: PPUSH
5870: LD_INT 24
5872: PPUSH
5873: CALL_OW 113
5877: GO 5856
5879: POP
5880: POP
// end ;
5881: PPOPN 1
5883: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
5884: LD_INT 22
5886: PUSH
5887: LD_EXP 8
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PUSH
5896: LD_INT 33
5898: PUSH
5899: LD_INT 2
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PPUSH
5910: CALL_OW 69
5914: IFFALSE 6130
5916: GO 5918
5918: DISABLE
5919: LD_INT 0
5921: PPUSH
5922: PPUSH
5923: PPUSH
5924: PPUSH
5925: PPUSH
5926: PPUSH
5927: PPUSH
// begin enable ;
5928: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
5929: LD_ADDR_VAR 0 4
5933: PUSH
5934: LD_INT 22
5936: PUSH
5937: LD_EXP 8
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: PUSH
5946: LD_INT 33
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: PUSH
5956: LD_INT 3
5958: PUSH
5959: LD_INT 61
5961: PUSH
5962: EMPTY
5963: LIST
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: PPUSH
5974: CALL_OW 69
5978: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
5979: LD_ADDR_VAR 0 3
5983: PUSH
5984: LD_INT 22
5986: PUSH
5987: LD_EXP 8
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: PUSH
5996: LD_INT 34
5998: PUSH
5999: LD_INT 31
6001: PUSH
6002: EMPTY
6003: LIST
6004: LIST
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: ST_TO_ADDR
// best := 10 ;
6015: LD_ADDR_VAR 0 5
6019: PUSH
6020: LD_INT 10
6022: ST_TO_ADDR
// best_mechanic := - 1 ;
6023: LD_ADDR_VAR 0 6
6027: PUSH
6028: LD_INT 1
6030: NEG
6031: ST_TO_ADDR
// if vehs then
6032: LD_VAR 0 4
6036: IFFALSE 6130
// begin for j in cts do
6038: LD_ADDR_VAR 0 2
6042: PUSH
6043: LD_VAR 0 3
6047: PUSH
6048: FOR_IN
6049: IFFALSE 6110
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
6051: LD_ADDR_VAR 0 7
6055: PUSH
6056: LD_VAR 0 2
6060: PPUSH
6061: CALL 8888 0 1
6065: PPUSH
6066: CALL_OW 432
6070: ST_TO_ADDR
// if p < best then
6071: LD_VAR 0 7
6075: PUSH
6076: LD_VAR 0 5
6080: LESS
6081: IFFALSE 6108
// begin best := p ;
6083: LD_ADDR_VAR 0 5
6087: PUSH
6088: LD_VAR 0 7
6092: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
6093: LD_ADDR_VAR 0 6
6097: PUSH
6098: LD_VAR 0 2
6102: PPUSH
6103: CALL 8888 0 1
6107: ST_TO_ADDR
// end ; end ;
6108: GO 6048
6110: POP
6111: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
6112: LD_VAR 0 4
6116: PUSH
6117: LD_INT 1
6119: ARRAY
6120: PPUSH
6121: LD_VAR 0 6
6125: PPUSH
6126: CALL_OW 135
// end ; end ;
6130: PPOPN 7
6132: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
6133: GO 6135
6135: DISABLE
6136: LD_INT 0
6138: PPUSH
6139: PPUSH
6140: PPUSH
6141: PPUSH
6142: PPUSH
6143: PPUSH
6144: PPUSH
// begin enable ;
6145: ENABLE
// b := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6146: LD_ADDR_VAR 0 6
6150: PUSH
6151: LD_INT 17
6153: PPUSH
6154: LD_INT 22
6156: PUSH
6157: LD_EXP 8
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 21
6168: PUSH
6169: LD_INT 3
6171: PUSH
6172: EMPTY
6173: LIST
6174: LIST
6175: PUSH
6176: LD_INT 3
6178: PUSH
6179: LD_INT 24
6181: PUSH
6182: LD_INT 1000
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: PPUSH
6198: CALL_OW 70
6202: ST_TO_ADDR
// h := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6203: LD_ADDR_VAR 0 3
6207: PUSH
6208: LD_INT 17
6210: PPUSH
6211: LD_INT 22
6213: PUSH
6214: LD_EXP 8
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: PUSH
6223: LD_INT 2
6225: PUSH
6226: LD_INT 25
6228: PUSH
6229: LD_INT 1
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_INT 25
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 25
6248: PUSH
6249: LD_INT 3
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: PUSH
6262: LD_INT 3
6264: PUSH
6265: LD_INT 24
6267: PUSH
6268: LD_INT 750
6270: PUSH
6271: EMPTY
6272: LIST
6273: LIST
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: PUSH
6279: EMPTY
6280: LIST
6281: LIST
6282: LIST
6283: PPUSH
6284: CALL_OW 70
6288: ST_TO_ADDR
// sci := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ;
6289: LD_ADDR_VAR 0 4
6293: PUSH
6294: LD_INT 17
6296: PPUSH
6297: LD_INT 22
6299: PUSH
6300: LD_EXP 8
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: PUSH
6309: LD_INT 25
6311: PUSH
6312: LD_INT 4
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: PPUSH
6323: CALL_OW 70
6327: ST_TO_ADDR
// eng := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
6328: LD_ADDR_VAR 0 5
6332: PUSH
6333: LD_INT 17
6335: PPUSH
6336: LD_INT 22
6338: PUSH
6339: LD_EXP 8
6343: PUSH
6344: EMPTY
6345: LIST
6346: LIST
6347: PUSH
6348: LD_INT 25
6350: PUSH
6351: LD_INT 2
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: PPUSH
6362: CALL_OW 70
6366: ST_TO_ADDR
// if not h and not b then
6367: LD_VAR 0 3
6371: NOT
6372: PUSH
6373: LD_VAR 0 6
6377: NOT
6378: AND
6379: IFFALSE 6675
// begin if sci then
6381: LD_VAR 0 4
6385: IFFALSE 6528
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
6387: LD_VAR 0 4
6391: PPUSH
6392: LD_INT 3
6394: PUSH
6395: LD_INT 54
6397: PUSH
6398: EMPTY
6399: LIST
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: PPUSH
6405: CALL_OW 72
6409: PUSH
6410: LD_INT 17
6412: PPUSH
6413: LD_INT 22
6415: PUSH
6416: LD_EXP 8
6420: PUSH
6421: EMPTY
6422: LIST
6423: LIST
6424: PUSH
6425: LD_INT 30
6427: PUSH
6428: LD_INT 8
6430: PUSH
6431: EMPTY
6432: LIST
6433: LIST
6434: PUSH
6435: EMPTY
6436: LIST
6437: LIST
6438: PPUSH
6439: CALL_OW 70
6443: AND
6444: IFFALSE 6528
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
6446: LD_ADDR_VAR 0 2
6450: PUSH
6451: LD_VAR 0 4
6455: PPUSH
6456: LD_INT 3
6458: PUSH
6459: LD_INT 54
6461: PUSH
6462: EMPTY
6463: LIST
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: PPUSH
6469: CALL_OW 72
6473: PUSH
6474: FOR_IN
6475: IFFALSE 6526
// ComEnterUnit ( j , FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6477: LD_VAR 0 2
6481: PPUSH
6482: LD_INT 17
6484: PPUSH
6485: LD_INT 22
6487: PUSH
6488: LD_EXP 8
6492: PUSH
6493: EMPTY
6494: LIST
6495: LIST
6496: PUSH
6497: LD_INT 30
6499: PUSH
6500: LD_INT 8
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PPUSH
6511: CALL_OW 70
6515: PUSH
6516: LD_INT 1
6518: ARRAY
6519: PPUSH
6520: CALL_OW 120
6524: GO 6474
6526: POP
6527: POP
// if eng then
6528: LD_VAR 0 5
6532: IFFALSE 6675
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
6534: LD_VAR 0 5
6538: PPUSH
6539: LD_INT 3
6541: PUSH
6542: LD_INT 54
6544: PUSH
6545: EMPTY
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PPUSH
6552: CALL_OW 72
6556: PUSH
6557: LD_INT 17
6559: PPUSH
6560: LD_INT 22
6562: PUSH
6563: LD_EXP 8
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: PUSH
6572: LD_INT 30
6574: PUSH
6575: LD_INT 1
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: PUSH
6582: EMPTY
6583: LIST
6584: LIST
6585: PPUSH
6586: CALL_OW 70
6590: AND
6591: IFFALSE 6675
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: LD_VAR 0 5
6602: PPUSH
6603: LD_INT 3
6605: PUSH
6606: LD_INT 54
6608: PUSH
6609: EMPTY
6610: LIST
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: PPUSH
6616: CALL_OW 72
6620: PUSH
6621: FOR_IN
6622: IFFALSE 6673
// ComEnterUnit ( j , FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6624: LD_VAR 0 2
6628: PPUSH
6629: LD_INT 17
6631: PPUSH
6632: LD_INT 22
6634: PUSH
6635: LD_EXP 8
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: LD_INT 30
6646: PUSH
6647: LD_INT 1
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PPUSH
6658: CALL_OW 70
6662: PUSH
6663: LD_INT 1
6665: ARRAY
6666: PPUSH
6667: CALL_OW 120
6671: GO 6621
6673: POP
6674: POP
// end ; p := 1 ;
6675: LD_ADDR_VAR 0 7
6679: PUSH
6680: LD_INT 1
6682: ST_TO_ADDR
// if b and eng then
6683: LD_VAR 0 6
6687: PUSH
6688: LD_VAR 0 5
6692: AND
6693: IFFALSE 6827
// for j in eng do
6695: LD_ADDR_VAR 0 2
6699: PUSH
6700: LD_VAR 0 5
6704: PUSH
6705: FOR_IN
6706: IFFALSE 6825
// begin if IsInUnit ( j ) then
6708: LD_VAR 0 2
6712: PPUSH
6713: CALL_OW 310
6717: IFFALSE 6730
// ComExitBuilding ( j ) else
6719: LD_VAR 0 2
6723: PPUSH
6724: CALL_OW 122
6728: GO 6823
// if not HasTask ( j ) and GetLives ( j ) > 750 then
6730: LD_VAR 0 2
6734: PPUSH
6735: CALL_OW 314
6739: NOT
6740: PUSH
6741: LD_VAR 0 2
6745: PPUSH
6746: CALL_OW 256
6750: PUSH
6751: LD_INT 750
6753: GREATER
6754: AND
6755: IFFALSE 6823
// begin if b > p then
6757: LD_VAR 0 6
6761: PUSH
6762: LD_VAR 0 7
6766: GREATER
6767: IFFALSE 6805
// begin ComRepairBuilding ( j , b [ p ] ) ;
6769: LD_VAR 0 2
6773: PPUSH
6774: LD_VAR 0 6
6778: PUSH
6779: LD_VAR 0 7
6783: ARRAY
6784: PPUSH
6785: CALL_OW 130
// p := p + 1 ;
6789: LD_ADDR_VAR 0 7
6793: PUSH
6794: LD_VAR 0 7
6798: PUSH
6799: LD_INT 1
6801: PLUS
6802: ST_TO_ADDR
// end else
6803: GO 6823
// ComRepairBuilding ( j , b [ 1 ] ) ;
6805: LD_VAR 0 2
6809: PPUSH
6810: LD_VAR 0 6
6814: PUSH
6815: LD_INT 1
6817: ARRAY
6818: PPUSH
6819: CALL_OW 130
// end ; end ;
6823: GO 6705
6825: POP
6826: POP
// if h and sci then
6827: LD_VAR 0 3
6831: PUSH
6832: LD_VAR 0 4
6836: AND
6837: IFFALSE 6976
// for i in h do
6839: LD_ADDR_VAR 0 1
6843: PUSH
6844: LD_VAR 0 3
6848: PUSH
6849: FOR_IN
6850: IFFALSE 6974
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
6852: LD_VAR 0 1
6856: PPUSH
6857: LD_INT 108
6859: PPUSH
6860: LD_INT 42
6862: PPUSH
6863: CALL_OW 297
6867: PUSH
6868: LD_INT 10
6870: GREATER
6871: IFFALSE 6890
// ComMoveXY ( i , 108 , 42 ) else
6873: LD_VAR 0 1
6877: PPUSH
6878: LD_INT 108
6880: PPUSH
6881: LD_INT 42
6883: PPUSH
6884: CALL_OW 111
6888: GO 6972
// begin for j in sci do
6890: LD_ADDR_VAR 0 2
6894: PUSH
6895: LD_VAR 0 4
6899: PUSH
6900: FOR_IN
6901: IFFALSE 6970
// begin if GetTag ( j ) > 0 then
6903: LD_VAR 0 2
6907: PPUSH
6908: CALL_OW 110
6912: PUSH
6913: LD_INT 0
6915: GREATER
6916: IFFALSE 6920
// continue ;
6918: GO 6900
// if IsInUnit ( j ) then
6920: LD_VAR 0 2
6924: PPUSH
6925: CALL_OW 310
6929: IFFALSE 6942
// ComExitBuilding ( j ) else
6931: LD_VAR 0 2
6935: PPUSH
6936: CALL_OW 122
6940: GO 6968
// if not HasTask ( j ) then
6942: LD_VAR 0 2
6946: PPUSH
6947: CALL_OW 314
6951: NOT
6952: IFFALSE 6968
// ComHeal ( j , h ) ;
6954: LD_VAR 0 2
6958: PPUSH
6959: LD_VAR 0 3
6963: PPUSH
6964: CALL_OW 128
// end ;
6968: GO 6900
6970: POP
6971: POP
// end ;
6972: GO 6849
6974: POP
6975: POP
// end ;
6976: PPOPN 7
6978: END
// every 0 0$01 trigger mines_list do var i , p ;
6979: LD_EXP 17
6983: IFFALSE 7209
6985: GO 6987
6987: DISABLE
6988: LD_INT 0
6990: PPUSH
6991: PPUSH
// begin enable ;
6992: ENABLE
// p := 1 ;
6993: LD_ADDR_VAR 0 2
6997: PUSH
6998: LD_INT 1
7000: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
7001: LD_ADDR_VAR 0 1
7005: PUSH
7006: DOUBLE
7007: LD_INT 1
7009: DEC
7010: ST_TO_ADDR
7011: LD_EXP 17
7015: PUSH
7016: LD_INT 2
7018: DIVREAL
7019: PUSH
7020: FOR_TO
7021: IFFALSE 7207
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
7023: LD_EXP 17
7027: PUSH
7028: LD_VAR 0 2
7032: ARRAY
7033: PPUSH
7034: LD_EXP 17
7038: PUSH
7039: LD_VAR 0 2
7043: PUSH
7044: LD_INT 1
7046: PLUS
7047: ARRAY
7048: PPUSH
7049: CALL_OW 428
7053: PUSH
7054: LD_INT 0
7056: GREATER
7057: IFFALSE 7191
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
7059: LD_EXP 17
7063: PUSH
7064: LD_VAR 0 2
7068: ARRAY
7069: PPUSH
7070: LD_EXP 17
7074: PUSH
7075: LD_VAR 0 2
7079: PUSH
7080: LD_INT 1
7082: PLUS
7083: ARRAY
7084: PPUSH
7085: CALL_OW 428
7089: PPUSH
7090: CALL_OW 255
7094: PUSH
7095: LD_EXP 8
7099: NONEQUAL
7100: IFFALSE 7191
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
7102: LD_EXP 17
7106: PUSH
7107: LD_VAR 0 2
7111: ARRAY
7112: PPUSH
7113: LD_EXP 17
7117: PUSH
7118: LD_VAR 0 2
7122: PUSH
7123: LD_INT 1
7125: PLUS
7126: ARRAY
7127: PPUSH
7128: LD_EXP 8
7132: PPUSH
7133: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
7137: LD_ADDR_EXP 17
7141: PUSH
7142: LD_EXP 17
7146: PPUSH
7147: LD_VAR 0 2
7151: PPUSH
7152: CALL_OW 3
7156: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
7157: LD_ADDR_EXP 17
7161: PUSH
7162: LD_EXP 17
7166: PPUSH
7167: LD_VAR 0 2
7171: PPUSH
7172: CALL_OW 3
7176: ST_TO_ADDR
// p := p - 2 ;
7177: LD_ADDR_VAR 0 2
7181: PUSH
7182: LD_VAR 0 2
7186: PUSH
7187: LD_INT 2
7189: MINUS
7190: ST_TO_ADDR
// end ; p := p + 2 ;
7191: LD_ADDR_VAR 0 2
7195: PUSH
7196: LD_VAR 0 2
7200: PUSH
7201: LD_INT 2
7203: PLUS
7204: ST_TO_ADDR
// end ;
7205: GO 7020
7207: POP
7208: POP
// end ;
7209: PPOPN 2
7211: END
// every 0 0$03 do var i , p , skr , filter , dep ;
7212: GO 7214
7214: DISABLE
7215: LD_INT 0
7217: PPUSH
7218: PPUSH
7219: PPUSH
7220: PPUSH
7221: PPUSH
// begin enable ;
7222: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) ;
7223: LD_ADDR_VAR 0 4
7227: PUSH
7228: LD_INT 50
7230: PUSH
7231: EMPTY
7232: LIST
7233: PUSH
7234: LD_INT 22
7236: PUSH
7237: LD_EXP 8
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: PUSH
7246: LD_INT 25
7248: PUSH
7249: LD_INT 16
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: PPUSH
7261: CALL_OW 69
7265: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7266: LD_ADDR_VAR 0 5
7270: PUSH
7271: LD_INT 22
7273: PUSH
7274: LD_EXP 8
7278: PUSH
7279: EMPTY
7280: LIST
7281: LIST
7282: PUSH
7283: LD_INT 2
7285: PUSH
7286: LD_INT 30
7288: PUSH
7289: LD_INT 0
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 30
7298: PUSH
7299: LD_INT 1
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: LIST
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: PPUSH
7315: CALL_OW 69
7319: ST_TO_ADDR
// skr := GetListOfCratesInArea ( collect_crates ) ;
7320: LD_ADDR_VAR 0 3
7324: PUSH
7325: LD_INT 15
7327: PPUSH
7328: CALL_OW 435
7332: ST_TO_ADDR
// if filter and skr then
7333: LD_VAR 0 4
7337: PUSH
7338: LD_VAR 0 3
7342: AND
7343: IFFALSE 7400
// for i = 1 to filter do
7345: LD_ADDR_VAR 0 1
7349: PUSH
7350: DOUBLE
7351: LD_INT 1
7353: DEC
7354: ST_TO_ADDR
7355: LD_VAR 0 4
7359: PUSH
7360: FOR_TO
7361: IFFALSE 7398
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
7363: LD_VAR 0 4
7367: PUSH
7368: LD_VAR 0 1
7372: ARRAY
7373: PPUSH
7374: LD_VAR 0 3
7378: PUSH
7379: LD_INT 1
7381: ARRAY
7382: PPUSH
7383: LD_VAR 0 3
7387: PUSH
7388: LD_INT 2
7390: ARRAY
7391: PPUSH
7392: CALL_OW 117
7396: GO 7360
7398: POP
7399: POP
// end ; end_of_file
7400: PPOPN 5
7402: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
7403: LD_INT 0
7405: PPUSH
7406: PPUSH
7407: PPUSH
7408: PPUSH
7409: PPUSH
7410: PPUSH
7411: PPUSH
7412: PPUSH
7413: PPUSH
// to_copy := [ ] ;
7414: LD_ADDR_VAR 0 5
7418: PUSH
7419: EMPTY
7420: ST_TO_ADDR
// for i = 1 to 8 do
7421: LD_ADDR_VAR 0 2
7425: PUSH
7426: DOUBLE
7427: LD_INT 1
7429: DEC
7430: ST_TO_ADDR
7431: LD_INT 8
7433: PUSH
7434: FOR_TO
7435: IFFALSE 8443
// begin if Side_Positions [ i ] then
7437: LD_EXP 2
7441: PUSH
7442: LD_VAR 0 2
7446: ARRAY
7447: IFFALSE 8441
// begin uc_side := i ;
7449: LD_ADDR_OWVAR 20
7453: PUSH
7454: LD_VAR 0 2
7458: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
7459: LD_ADDR_OWVAR 21
7463: PUSH
7464: LD_EXP 4
7468: PUSH
7469: LD_VAR 0 2
7473: ARRAY
7474: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
7475: LD_ADDR_VAR 0 6
7479: PUSH
7480: LD_EXP 7
7484: PUSH
7485: LD_EXP 2
7489: PUSH
7490: LD_VAR 0 2
7494: ARRAY
7495: ARRAY
7496: PUSH
7497: LD_INT 1
7499: ARRAY
7500: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
7501: LD_ADDR_VAR 0 7
7505: PUSH
7506: LD_EXP 7
7510: PUSH
7511: LD_EXP 2
7515: PUSH
7516: LD_VAR 0 2
7520: ARRAY
7521: ARRAY
7522: PUSH
7523: LD_INT 2
7525: ARRAY
7526: ST_TO_ADDR
// hc_importance := 100 ;
7527: LD_ADDR_OWVAR 32
7531: PUSH
7532: LD_INT 100
7534: ST_TO_ADDR
// if Multiplayer then
7535: LD_OWVAR 4
7539: IFFALSE 7597
// begin hc_name := mp_sides_players_names [ uc_side ] ;
7541: LD_ADDR_OWVAR 26
7545: PUSH
7546: LD_OWVAR 19
7550: PUSH
7551: LD_OWVAR 20
7555: ARRAY
7556: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
7557: LD_ADDR_OWVAR 33
7561: PUSH
7562: LD_STRING MULTIAVATARS
7564: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
7565: LD_ADDR_OWVAR 34
7569: PUSH
7570: LD_OWVAR 20
7574: PPUSH
7575: CALL_OW 525
7579: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
7580: LD_ADDR_OWVAR 27
7584: PUSH
7585: LD_OWVAR 20
7589: PPUSH
7590: CALL_OW 526
7594: ST_TO_ADDR
// end else
7595: GO 7629
// begin hc_name :=  ;
7597: LD_ADDR_OWVAR 26
7601: PUSH
7602: LD_STRING 
7604: ST_TO_ADDR
// hc_gallery :=  ;
7605: LD_ADDR_OWVAR 33
7609: PUSH
7610: LD_STRING 
7612: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
7613: LD_ADDR_OWVAR 27
7617: PUSH
7618: LD_INT 1
7620: PPUSH
7621: LD_INT 2
7623: PPUSH
7624: CALL_OW 12
7628: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
7629: LD_OWVAR 27
7633: PPUSH
7634: LD_INT 1
7636: PPUSH
7637: LD_EXP 11
7641: PPUSH
7642: CALL_OW 380
// un := CreateHuman ;
7646: LD_ADDR_VAR 0 4
7650: PUSH
7651: CALL_OW 44
7655: ST_TO_ADDR
// if not to_copy then
7656: LD_VAR 0 5
7660: NOT
7661: IFFALSE 7688
// to_copy := Replace ( to_copy , 1 , un ) else
7663: LD_ADDR_VAR 0 5
7667: PUSH
7668: LD_VAR 0 5
7672: PPUSH
7673: LD_INT 1
7675: PPUSH
7676: LD_VAR 0 4
7680: PPUSH
7681: CALL_OW 1
7685: ST_TO_ADDR
7686: GO 7764
// begin CopySkills ( to_copy [ 1 ] , un ) ;
7688: LD_VAR 0 5
7692: PUSH
7693: LD_INT 1
7695: ARRAY
7696: PPUSH
7697: LD_VAR 0 4
7701: PPUSH
7702: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
7706: LD_VAR 0 4
7710: PPUSH
7711: LD_INT 2
7713: PPUSH
7714: LD_VAR 0 5
7718: PUSH
7719: LD_INT 1
7721: ARRAY
7722: PPUSH
7723: LD_INT 2
7725: PPUSH
7726: CALL_OW 260
7730: PPUSH
7731: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
7735: LD_VAR 0 4
7739: PPUSH
7740: LD_INT 1
7742: PPUSH
7743: LD_VAR 0 5
7747: PUSH
7748: LD_INT 1
7750: ARRAY
7751: PPUSH
7752: LD_INT 1
7754: PPUSH
7755: CALL_OW 260
7759: PPUSH
7760: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
7764: LD_VAR 0 4
7768: PPUSH
7769: LD_VAR 0 6
7773: PPUSH
7774: LD_VAR 0 7
7778: PPUSH
7779: LD_INT 10
7781: PPUSH
7782: LD_INT 0
7784: PPUSH
7785: CALL_OW 50
// hc_importance := 0 ;
7789: LD_ADDR_OWVAR 32
7793: PUSH
7794: LD_INT 0
7796: ST_TO_ADDR
// hc_name :=  ;
7797: LD_ADDR_OWVAR 26
7801: PUSH
7802: LD_STRING 
7804: ST_TO_ADDR
// hc_gallery :=  ;
7805: LD_ADDR_OWVAR 33
7809: PUSH
7810: LD_STRING 
7812: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
7813: LD_ADDR_VAR 0 9
7817: PUSH
7818: LD_EXP 10
7822: PUSH
7823: LD_INT 1
7825: MINUS
7826: PUSH
7827: LD_INT 4
7829: DIVREAL
7830: ST_TO_ADDR
// c := 1 ;
7831: LD_ADDR_VAR 0 8
7835: PUSH
7836: LD_INT 1
7838: ST_TO_ADDR
// for j = 2 to number_of_people do
7839: LD_ADDR_VAR 0 3
7843: PUSH
7844: DOUBLE
7845: LD_INT 2
7847: DEC
7848: ST_TO_ADDR
7849: LD_EXP 10
7853: PUSH
7854: FOR_TO
7855: IFFALSE 8103
// begin PrepareHuman ( false , c , skill_level ) ;
7857: LD_INT 0
7859: PPUSH
7860: LD_VAR 0 8
7864: PPUSH
7865: LD_EXP 11
7869: PPUSH
7870: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
7874: LD_VAR 0 3
7878: PUSH
7879: LD_INT 1
7881: MINUS
7882: PUSH
7883: LD_VAR 0 9
7887: MOD
7888: PUSH
7889: LD_INT 0
7891: EQUAL
7892: IFFALSE 7908
// c := c + 1 ;
7894: LD_ADDR_VAR 0 8
7898: PUSH
7899: LD_VAR 0 8
7903: PUSH
7904: LD_INT 1
7906: PLUS
7907: ST_TO_ADDR
// un := CreateHuman ;
7908: LD_ADDR_VAR 0 4
7912: PUSH
7913: CALL_OW 44
7917: ST_TO_ADDR
// if to_copy < j then
7918: LD_VAR 0 5
7922: PUSH
7923: LD_VAR 0 3
7927: LESS
7928: IFFALSE 7957
// to_copy := Replace ( to_copy , j , un ) else
7930: LD_ADDR_VAR 0 5
7934: PUSH
7935: LD_VAR 0 5
7939: PPUSH
7940: LD_VAR 0 3
7944: PPUSH
7945: LD_VAR 0 4
7949: PPUSH
7950: CALL_OW 1
7954: ST_TO_ADDR
7955: GO 8039
// begin CopySkills ( to_copy [ j ] , un ) ;
7957: LD_VAR 0 5
7961: PUSH
7962: LD_VAR 0 3
7966: ARRAY
7967: PPUSH
7968: LD_VAR 0 4
7972: PPUSH
7973: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
7977: LD_VAR 0 4
7981: PPUSH
7982: LD_INT 2
7984: PPUSH
7985: LD_VAR 0 5
7989: PUSH
7990: LD_VAR 0 3
7994: ARRAY
7995: PPUSH
7996: LD_INT 2
7998: PPUSH
7999: CALL_OW 260
8003: PPUSH
8004: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
8008: LD_VAR 0 4
8012: PPUSH
8013: LD_INT 1
8015: PPUSH
8016: LD_VAR 0 5
8020: PUSH
8021: LD_VAR 0 3
8025: ARRAY
8026: PPUSH
8027: LD_INT 1
8029: PPUSH
8030: CALL_OW 260
8034: PPUSH
8035: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
8039: LD_VAR 0 4
8043: PPUSH
8044: LD_VAR 0 6
8048: PPUSH
8049: LD_VAR 0 7
8053: PPUSH
8054: LD_INT 10
8056: PPUSH
8057: LD_INT 0
8059: PPUSH
8060: CALL_OW 50
// if GetClass ( un ) = 3 and handicap < 2 then
8064: LD_VAR 0 4
8068: PPUSH
8069: CALL_OW 257
8073: PUSH
8074: LD_INT 3
8076: EQUAL
8077: PUSH
8078: LD_EXP 26
8082: PUSH
8083: LD_INT 2
8085: LESS
8086: AND
8087: IFFALSE 8101
// SetClass ( un , 1 ) ;
8089: LD_VAR 0 4
8093: PPUSH
8094: LD_INT 1
8096: PPUSH
8097: CALL_OW 336
// end ;
8101: GO 7854
8103: POP
8104: POP
// if handicap then
8105: LD_EXP 26
8109: IFFALSE 8441
// begin for j = 1 to 2 do
8111: LD_ADDR_VAR 0 3
8115: PUSH
8116: DOUBLE
8117: LD_INT 1
8119: DEC
8120: ST_TO_ADDR
8121: LD_INT 2
8123: PUSH
8124: FOR_TO
8125: IFFALSE 8209
// begin vc_chassis := us_medium_wheeled ;
8127: LD_ADDR_OWVAR 37
8131: PUSH
8132: LD_INT 2
8134: ST_TO_ADDR
// vc_engine := engine_siberite ;
8135: LD_ADDR_OWVAR 39
8139: PUSH
8140: LD_INT 3
8142: ST_TO_ADDR
// vc_control := control_computer ;
8143: LD_ADDR_OWVAR 38
8147: PUSH
8148: LD_INT 3
8150: ST_TO_ADDR
// vc_weapon := us_rocket_launcher ;
8151: LD_ADDR_OWVAR 40
8155: PUSH
8156: LD_INT 7
8158: ST_TO_ADDR
// un := CreateVehicle ;
8159: LD_ADDR_VAR 0 4
8163: PUSH
8164: CALL_OW 45
8168: ST_TO_ADDR
// rforce := Insert ( rforce , 1 , [ un , x , y ] ) ;
8169: LD_ADDR_EXP 27
8173: PUSH
8174: LD_EXP 27
8178: PPUSH
8179: LD_INT 1
8181: PPUSH
8182: LD_VAR 0 4
8186: PUSH
8187: LD_VAR 0 6
8191: PUSH
8192: LD_VAR 0 7
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: LIST
8201: PPUSH
8202: CALL_OW 2
8206: ST_TO_ADDR
// end ;
8207: GO 8124
8209: POP
8210: POP
// if handicap = 1 then
8211: LD_EXP 26
8215: PUSH
8216: LD_INT 1
8218: EQUAL
8219: IFFALSE 8278
// begin vc_chassis := us_medium_tracked ;
8221: LD_ADDR_OWVAR 37
8225: PUSH
8226: LD_INT 3
8228: ST_TO_ADDR
// vc_engine := engine_solar ;
8229: LD_ADDR_OWVAR 39
8233: PUSH
8234: LD_INT 2
8236: ST_TO_ADDR
// vc_control := control_computer ;
8237: LD_ADDR_OWVAR 38
8241: PUSH
8242: LD_INT 3
8244: ST_TO_ADDR
// vc_weapon := us_radar ;
8245: LD_ADDR_OWVAR 40
8249: PUSH
8250: LD_INT 11
8252: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
8253: CALL_OW 45
8257: PPUSH
8258: LD_VAR 0 6
8262: PPUSH
8263: LD_VAR 0 7
8267: PPUSH
8268: LD_INT 13
8270: PPUSH
8271: LD_INT 0
8273: PPUSH
8274: CALL_OW 50
// end ; if handicap = 2 then
8278: LD_EXP 26
8282: PUSH
8283: LD_INT 2
8285: EQUAL
8286: IFFALSE 8441
// begin for j = 1 to 2 do
8288: LD_ADDR_VAR 0 3
8292: PUSH
8293: DOUBLE
8294: LD_INT 1
8296: DEC
8297: ST_TO_ADDR
8298: LD_INT 2
8300: PUSH
8301: FOR_TO
8302: IFFALSE 8382
// begin vc_chassis := us_medium_tracked ;
8304: LD_ADDR_OWVAR 37
8308: PUSH
8309: LD_INT 3
8311: ST_TO_ADDR
// vc_engine := engine_siberite ;
8312: LD_ADDR_OWVAR 39
8316: PUSH
8317: LD_INT 3
8319: ST_TO_ADDR
// vc_control := control_manual ;
8320: LD_ADDR_OWVAR 38
8324: PUSH
8325: LD_INT 1
8327: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
8328: LD_ADDR_OWVAR 40
8332: PUSH
8333: LD_INT 4
8335: PUSH
8336: LD_INT 5
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PUSH
8343: LD_INT 1
8345: PPUSH
8346: LD_INT 2
8348: PPUSH
8349: CALL_OW 12
8353: ARRAY
8354: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
8355: CALL_OW 45
8359: PPUSH
8360: LD_VAR 0 6
8364: PPUSH
8365: LD_VAR 0 7
8369: PPUSH
8370: LD_INT 13
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 50
// end ;
8380: GO 8301
8382: POP
8383: POP
// vc_chassis := us_medium_tracked ;
8384: LD_ADDR_OWVAR 37
8388: PUSH
8389: LD_INT 3
8391: ST_TO_ADDR
// vc_engine := engine_solar ;
8392: LD_ADDR_OWVAR 39
8396: PUSH
8397: LD_INT 2
8399: ST_TO_ADDR
// vc_control := control_computer ;
8400: LD_ADDR_OWVAR 38
8404: PUSH
8405: LD_INT 3
8407: ST_TO_ADDR
// vc_weapon := us_radar ;
8408: LD_ADDR_OWVAR 40
8412: PUSH
8413: LD_INT 11
8415: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
8416: CALL_OW 45
8420: PPUSH
8421: LD_VAR 0 6
8425: PPUSH
8426: LD_VAR 0 7
8430: PPUSH
8431: LD_INT 13
8433: PPUSH
8434: LD_INT 0
8436: PPUSH
8437: CALL_OW 50
// end ; end ; end ; end ;
8441: GO 7434
8443: POP
8444: POP
// end ;
8445: LD_VAR 0 1
8449: RET
// export function AddApeman ( area ) ; begin
8450: LD_INT 0
8452: PPUSH
// uc_nation := 0 ;
8453: LD_ADDR_OWVAR 21
8457: PUSH
8458: LD_INT 0
8460: ST_TO_ADDR
// uc_side := 0 ;
8461: LD_ADDR_OWVAR 20
8465: PUSH
8466: LD_INT 0
8468: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
8469: LD_ADDR_OWVAR 35
8473: PUSH
8474: LD_INT 10
8476: NEG
8477: PPUSH
8478: LD_INT 15
8480: PPUSH
8481: CALL_OW 12
8485: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
8486: LD_INT 0
8488: PPUSH
8489: LD_INT 12
8491: PPUSH
8492: LD_INT 0
8494: PPUSH
8495: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
8499: LD_ADDR_OWVAR 29
8503: PUSH
8504: LD_INT 10
8506: PUSH
8507: LD_INT 12
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
8514: CALL_OW 44
8518: PPUSH
8519: LD_VAR 0 1
8523: PPUSH
8524: LD_INT 0
8526: PPUSH
8527: CALL_OW 49
// end ;
8531: LD_VAR 0 2
8535: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
8536: LD_INT 0
8538: PPUSH
8539: PPUSH
8540: PPUSH
8541: PPUSH
// r := 100 ;
8542: LD_ADDR_VAR 0 5
8546: PUSH
8547: LD_INT 100
8549: ST_TO_ADDR
// x := 0 ;
8550: LD_ADDR_VAR 0 6
8554: PUSH
8555: LD_INT 0
8557: ST_TO_ADDR
// while ( x < n ) do
8558: LD_VAR 0 6
8562: PUSH
8563: LD_VAR 0 2
8567: LESS
8568: IFFALSE 8883
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
8570: LD_ADDR_VAR 0 4
8574: PUSH
8575: DOUBLE
8576: LD_INT 1
8578: DEC
8579: ST_TO_ADDR
8580: LD_VAR 0 1
8584: PPUSH
8585: LD_INT 0
8587: PPUSH
8588: CALL_OW 517
8592: PUSH
8593: LD_INT 1
8595: ARRAY
8596: PUSH
8597: FOR_TO
8598: IFFALSE 8879
// begin if r > 50 then
8600: LD_VAR 0 5
8604: PUSH
8605: LD_INT 50
8607: GREATER
8608: IFFALSE 8855
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
8610: LD_VAR 0 1
8614: PPUSH
8615: LD_INT 0
8617: PPUSH
8618: CALL_OW 517
8622: PUSH
8623: LD_INT 1
8625: ARRAY
8626: PUSH
8627: LD_VAR 0 4
8631: ARRAY
8632: PPUSH
8633: LD_VAR 0 1
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 517
8645: PUSH
8646: LD_INT 2
8648: ARRAY
8649: PUSH
8650: LD_VAR 0 4
8654: ARRAY
8655: PPUSH
8656: CALL_OW 458
8660: NOT
8661: IFFALSE 8839
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
8663: LD_VAR 0 1
8667: PPUSH
8668: LD_INT 0
8670: PPUSH
8671: CALL_OW 517
8675: PUSH
8676: LD_INT 1
8678: ARRAY
8679: PUSH
8680: LD_VAR 0 4
8684: ARRAY
8685: PPUSH
8686: LD_VAR 0 1
8690: PPUSH
8691: LD_INT 0
8693: PPUSH
8694: CALL_OW 517
8698: PUSH
8699: LD_INT 2
8701: ARRAY
8702: PUSH
8703: LD_VAR 0 4
8707: ARRAY
8708: PPUSH
8709: LD_EXP 8
8713: PPUSH
8714: LD_INT 0
8716: PPUSH
8717: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
8721: LD_ADDR_EXP 17
8725: PUSH
8726: LD_EXP 17
8730: PPUSH
8731: LD_EXP 17
8735: PUSH
8736: LD_INT 1
8738: PLUS
8739: PPUSH
8740: LD_VAR 0 1
8744: PPUSH
8745: LD_INT 0
8747: PPUSH
8748: CALL_OW 517
8752: PUSH
8753: LD_INT 1
8755: ARRAY
8756: PUSH
8757: LD_VAR 0 4
8761: ARRAY
8762: PPUSH
8763: CALL_OW 2
8767: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
8768: LD_ADDR_EXP 17
8772: PUSH
8773: LD_EXP 17
8777: PPUSH
8778: LD_EXP 17
8782: PUSH
8783: LD_INT 1
8785: PLUS
8786: PPUSH
8787: LD_VAR 0 1
8791: PPUSH
8792: LD_INT 0
8794: PPUSH
8795: CALL_OW 517
8799: PUSH
8800: LD_INT 2
8802: ARRAY
8803: PUSH
8804: LD_VAR 0 4
8808: ARRAY
8809: PPUSH
8810: CALL_OW 2
8814: ST_TO_ADDR
// r := 0 ;
8815: LD_ADDR_VAR 0 5
8819: PUSH
8820: LD_INT 0
8822: ST_TO_ADDR
// x := x + 1 ;
8823: LD_ADDR_VAR 0 6
8827: PUSH
8828: LD_VAR 0 6
8832: PUSH
8833: LD_INT 1
8835: PLUS
8836: ST_TO_ADDR
// end else
8837: GO 8853
// r := r + 35 ;
8839: LD_ADDR_VAR 0 5
8843: PUSH
8844: LD_VAR 0 5
8848: PUSH
8849: LD_INT 35
8851: PLUS
8852: ST_TO_ADDR
// end else
8853: GO 8877
// r := r + rand ( 10 , 25 ) ;
8855: LD_ADDR_VAR 0 5
8859: PUSH
8860: LD_VAR 0 5
8864: PUSH
8865: LD_INT 10
8867: PPUSH
8868: LD_INT 25
8870: PPUSH
8871: CALL_OW 12
8875: PLUS
8876: ST_TO_ADDR
// end ;
8877: GO 8597
8879: POP
8880: POP
8881: GO 8558
// end ;
8883: LD_VAR 0 3
8887: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
8888: LD_INT 0
8890: PPUSH
8891: PPUSH
8892: PPUSH
// if not GetControl ( veh ) = control_manual then
8893: LD_VAR 0 1
8897: PPUSH
8898: CALL_OW 263
8902: PUSH
8903: LD_INT 1
8905: EQUAL
8906: NOT
8907: IFFALSE 8919
// result := false else
8909: LD_ADDR_VAR 0 2
8913: PUSH
8914: LD_INT 0
8916: ST_TO_ADDR
8917: GO 9064
// if veh in FilterAllUnits ( [ f_empty ] ) then
8919: LD_VAR 0 1
8923: PUSH
8924: LD_INT 58
8926: PUSH
8927: EMPTY
8928: LIST
8929: PPUSH
8930: CALL_OW 69
8934: IN
8935: IFFALSE 8947
// result := false else
8937: LD_ADDR_VAR 0 2
8941: PUSH
8942: LD_INT 0
8944: ST_TO_ADDR
8945: GO 9064
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
8947: LD_ADDR_VAR 0 4
8951: PUSH
8952: LD_INT 22
8954: PUSH
8955: LD_VAR 0 1
8959: PPUSH
8960: CALL_OW 255
8964: PUSH
8965: EMPTY
8966: LIST
8967: LIST
8968: PUSH
8969: LD_INT 55
8971: PUSH
8972: EMPTY
8973: LIST
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: PPUSH
8979: CALL_OW 69
8983: ST_TO_ADDR
// if not filter then
8984: LD_VAR 0 4
8988: NOT
8989: IFFALSE 9001
// result := false else
8991: LD_ADDR_VAR 0 2
8995: PUSH
8996: LD_INT 0
8998: ST_TO_ADDR
8999: GO 9064
// for i = 1 to filter do
9001: LD_ADDR_VAR 0 3
9005: PUSH
9006: DOUBLE
9007: LD_INT 1
9009: DEC
9010: ST_TO_ADDR
9011: LD_VAR 0 4
9015: PUSH
9016: FOR_TO
9017: IFFALSE 9062
// if IsDriver ( filter [ i ] ) = veh then
9019: LD_VAR 0 4
9023: PUSH
9024: LD_VAR 0 3
9028: ARRAY
9029: PPUSH
9030: CALL 9069 0 1
9034: PUSH
9035: LD_VAR 0 1
9039: EQUAL
9040: IFFALSE 9060
// begin result := filter [ i ] ;
9042: LD_ADDR_VAR 0 2
9046: PUSH
9047: LD_VAR 0 4
9051: PUSH
9052: LD_VAR 0 3
9056: ARRAY
9057: ST_TO_ADDR
// break ;
9058: GO 9062
// end ;
9060: GO 9016
9062: POP
9063: POP
// end ; end ;
9064: LD_VAR 0 2
9068: RET
// export function IsDriver ( unit ) ; begin
9069: LD_INT 0
9071: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
9072: LD_VAR 0 1
9076: PUSH
9077: LD_INT 55
9079: PUSH
9080: EMPTY
9081: LIST
9082: PPUSH
9083: CALL_OW 69
9087: IN
9088: IFFALSE 9107
// result := IsInUnit ( unit ) else
9090: LD_ADDR_VAR 0 2
9094: PUSH
9095: LD_VAR 0 1
9099: PPUSH
9100: CALL_OW 310
9104: ST_TO_ADDR
9105: GO 9115
// result := false ;
9107: LD_ADDR_VAR 0 2
9111: PUSH
9112: LD_INT 0
9114: ST_TO_ADDR
// end ;
9115: LD_VAR 0 2
9119: RET
