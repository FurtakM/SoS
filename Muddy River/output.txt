// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 2407 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// if Multiplayer then
 124: LD_OWVAR 4
 128: IFFALSE 250
// begin Game_Type := mp_game_type ;
 130: LD_ADDR_EXP 1
 134: PUSH
 135: LD_OWVAR 6
 139: ST_TO_ADDR
// Your_Side := mp_player_side ;
 140: LD_ADDR_OWVAR 2
 144: PUSH
 145: LD_OWVAR 7
 149: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_OWVAR 17
 159: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 160: LD_ADDR_EXP 3
 164: PUSH
 165: LD_OWVAR 15
 169: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 170: LD_ADDR_EXP 4
 174: PUSH
 175: LD_OWVAR 16
 179: ST_TO_ADDR
// Teams := mp_teams ;
 180: LD_ADDR_EXP 5
 184: PUSH
 185: LD_OWVAR 12
 189: ST_TO_ADDR
// for i = 0 to 6 do
 190: LD_ADDR_VAR 0 2
 194: PUSH
 195: DOUBLE
 196: LD_INT 0
 198: DEC
 199: ST_TO_ADDR
 200: LD_INT 6
 202: PUSH
 203: FOR_TO
 204: IFFALSE 246
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 206: LD_ADDR_EXP 16
 210: PUSH
 211: LD_EXP 16
 215: PPUSH
 216: LD_EXP 16
 220: PUSH
 221: LD_INT 1
 223: PLUS
 224: PPUSH
 225: LD_VAR 0 2
 229: PPUSH
 230: CALL_OW 426
 234: PUSH
 235: LD_INT 1
 237: PLUS
 238: PPUSH
 239: CALL_OW 2
 243: ST_TO_ADDR
 244: GO 203
 246: POP
 247: POP
// end else
 248: GO 401
// begin Game_Type := 1 ;
 250: LD_ADDR_EXP 1
 254: PUSH
 255: LD_INT 1
 257: ST_TO_ADDR
// Your_Side := 1 ;
 258: LD_ADDR_OWVAR 2
 262: PUSH
 263: LD_INT 1
 265: ST_TO_ADDR
// Side_Positions := [ 1 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] ;
 266: LD_ADDR_EXP 2
 270: PUSH
 271: LD_INT 1
 273: PUSH
 274: LD_INT 0
 276: PUSH
 277: LD_INT 0
 279: PUSH
 280: LD_INT 2
 282: PUSH
 283: LD_INT 0
 285: PUSH
 286: LD_INT 0
 288: PUSH
 289: LD_INT 0
 291: PUSH
 292: LD_INT 0
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// Side_Teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] ;
 305: LD_ADDR_EXP 3
 309: PUSH
 310: LD_INT 1
 312: PUSH
 313: LD_INT 0
 315: PUSH
 316: LD_INT 0
 318: PUSH
 319: LD_INT 1
 321: PUSH
 322: LD_INT 0
 324: PUSH
 325: LD_INT 0
 327: PUSH
 328: LD_INT 0
 330: PUSH
 331: LD_INT 0
 333: PUSH
 334: EMPTY
 335: LIST
 336: LIST
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: ST_TO_ADDR
// Side_Nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] ;
 344: LD_ADDR_EXP 4
 348: PUSH
 349: LD_INT 1
 351: PUSH
 352: LD_INT 0
 354: PUSH
 355: LD_INT 0
 357: PUSH
 358: LD_INT 1
 360: PUSH
 361: LD_INT 0
 363: PUSH
 364: LD_INT 0
 366: PUSH
 367: LD_INT 0
 369: PUSH
 370: LD_INT 0
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: ST_TO_ADDR
// Teams := [ [ 1 , 4 ] ] ;
 383: LD_ADDR_EXP 5
 387: PUSH
 388: LD_INT 1
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: PUSH
 398: EMPTY
 399: LIST
 400: ST_TO_ADDR
// end ; Side_Start := [ [ 83 , 148 ] , [ 187 , 144 ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 401: LD_ADDR_EXP 7
 405: PUSH
 406: LD_INT 83
 408: PUSH
 409: LD_INT 148
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 187
 418: PUSH
 419: LD_INT 144
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: PUSH
 426: EMPTY
 427: PUSH
 428: EMPTY
 429: PUSH
 430: EMPTY
 431: PUSH
 432: EMPTY
 433: PUSH
 434: EMPTY
 435: PUSH
 436: EMPTY
 437: PUSH
 438: EMPTY
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// Bot_Side := 2 ;
 448: LD_ADDR_EXP 8
 452: PUSH
 453: LD_INT 2
 455: ST_TO_ADDR
// for i = 1 to 8 do
 456: LD_ADDR_VAR 0 2
 460: PUSH
 461: DOUBLE
 462: LD_INT 1
 464: DEC
 465: ST_TO_ADDR
 466: LD_INT 8
 468: PUSH
 469: FOR_TO
 470: IFFALSE 602
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
 472: LD_VAR 0 2
 476: PPUSH
 477: CALL_OW 530
 481: IFFALSE 555
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 483: LD_ADDR_EXP 2
 487: PUSH
 488: LD_EXP 2
 492: PPUSH
 493: LD_VAR 0 2
 497: PPUSH
 498: LD_INT 0
 500: PPUSH
 501: CALL_OW 1
 505: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 506: LD_ADDR_EXP 5
 510: PUSH
 511: LD_EXP 5
 515: PPUSH
 516: LD_EXP 3
 520: PUSH
 521: LD_VAR 0 2
 525: ARRAY
 526: PPUSH
 527: LD_EXP 5
 531: PUSH
 532: LD_EXP 3
 536: PUSH
 537: LD_VAR 0 2
 541: ARRAY
 542: ARRAY
 543: PUSH
 544: LD_VAR 0 2
 548: DIFF
 549: PPUSH
 550: CALL_OW 1
 554: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 1 then
 555: LD_EXP 4
 559: PUSH
 560: LD_VAR 0 2
 564: ARRAY
 565: PUSH
 566: LD_EXP 4
 570: PUSH
 571: LD_INT 1
 573: NONEQUAL
 574: AND
 575: IFFALSE 600
// Side_Nations := Replace ( Side_Nations , i , 1 ) ;
 577: LD_ADDR_EXP 4
 581: PUSH
 582: LD_EXP 4
 586: PPUSH
 587: LD_VAR 0 2
 591: PPUSH
 592: LD_INT 1
 594: PPUSH
 595: CALL_OW 1
 599: ST_TO_ADDR
// end ;
 600: GO 469
 602: POP
 603: POP
// if 2 = bot_side and Side_Positions [ 2 ] then
 604: LD_INT 2
 606: PUSH
 607: LD_EXP 8
 611: EQUAL
 612: PUSH
 613: LD_EXP 2
 617: PUSH
 618: LD_INT 2
 620: ARRAY
 621: AND
 622: IFFALSE 632
// bot_side := 5 ;
 624: LD_ADDR_EXP 8
 628: PUSH
 629: LD_INT 5
 631: ST_TO_ADDR
// if 5 = bot_side and Side_Positions [ 5 ] then
 632: LD_INT 5
 634: PUSH
 635: LD_EXP 8
 639: EQUAL
 640: PUSH
 641: LD_EXP 2
 645: PUSH
 646: LD_INT 5
 648: ARRAY
 649: AND
 650: IFFALSE 660
// bot_side := 8 ;
 652: LD_ADDR_EXP 8
 656: PUSH
 657: LD_INT 8
 659: ST_TO_ADDR
// Team_Game := false ;
 660: LD_ADDR_EXP 6
 664: PUSH
 665: LD_INT 0
 667: ST_TO_ADDR
// for i = 1 to 8 do
 668: LD_ADDR_VAR 0 2
 672: PUSH
 673: DOUBLE
 674: LD_INT 1
 676: DEC
 677: ST_TO_ADDR
 678: LD_INT 8
 680: PUSH
 681: FOR_TO
 682: IFFALSE 708
// if Side_Teams [ i ] then
 684: LD_EXP 3
 688: PUSH
 689: LD_VAR 0 2
 693: ARRAY
 694: IFFALSE 706
// begin Team_Game := true ;
 696: LD_ADDR_EXP 6
 700: PUSH
 701: LD_INT 1
 703: ST_TO_ADDR
// break ;
 704: GO 708
// end ;
 706: GO 681
 708: POP
 709: POP
// for i in Teams do
 710: LD_ADDR_VAR 0 2
 714: PUSH
 715: LD_EXP 5
 719: PUSH
 720: FOR_IN
 721: IFFALSE 801
// for j = 2 to i do
 723: LD_ADDR_VAR 0 3
 727: PUSH
 728: DOUBLE
 729: LD_INT 2
 731: DEC
 732: ST_TO_ADDR
 733: LD_VAR 0 2
 737: PUSH
 738: FOR_TO
 739: IFFALSE 797
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
 741: LD_VAR 0 2
 745: PUSH
 746: LD_VAR 0 3
 750: ARRAY
 751: PPUSH
 752: LD_VAR 0 2
 756: PUSH
 757: LD_INT 1
 759: ARRAY
 760: PPUSH
 761: CALL_OW 343
// SetAttitude ( i [ j ] , i [ 1 ] , att_friend , true ) ;
 765: LD_VAR 0 2
 769: PUSH
 770: LD_VAR 0 3
 774: ARRAY
 775: PPUSH
 776: LD_VAR 0 2
 780: PUSH
 781: LD_INT 1
 783: ARRAY
 784: PPUSH
 785: LD_INT 1
 787: PPUSH
 788: LD_INT 1
 790: PPUSH
 791: CALL_OW 80
// end ;
 795: GO 738
 797: POP
 798: POP
 799: GO 720
 801: POP
 802: POP
// if not Multiplayer then
 803: LD_OWVAR 4
 807: NOT
 808: IFFALSE 845
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 810: LD_ADDR_EXP 16
 814: PUSH
 815: LD_INT 1
 817: PUSH
 818: LD_INT 1
 820: PUSH
 821: LD_INT 1
 823: PUSH
 824: LD_INT 1
 826: PUSH
 827: LD_INT 2
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: LD_INT 3
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: LIST
 843: LIST
 844: ST_TO_ADDR
// number_of_people := [ 5 , 9 , 12 , 15 ] [ definitions [ 1 ] ] ;
 845: LD_ADDR_EXP 10
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 9
 855: PUSH
 856: LD_INT 12
 858: PUSH
 859: LD_INT 15
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: PUSH
 868: LD_EXP 16
 872: PUSH
 873: LD_INT 1
 875: ARRAY
 876: ARRAY
 877: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 878: LD_ADDR_EXP 11
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 4
 888: PUSH
 889: LD_INT 6
 891: PUSH
 892: LD_INT 8
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PUSH
 901: LD_EXP 16
 905: PUSH
 906: LD_INT 2
 908: ARRAY
 909: ARRAY
 910: ST_TO_ADDR
// crates_spawn := [ 1 1$20 , 1 1$05 , 0 0$51 , 0 0$47 ] [ definitions [ 3 ] ] ;
 911: LD_ADDR_EXP 12
 915: PUSH
 916: LD_INT 2800
 918: PUSH
 919: LD_INT 2275
 921: PUSH
 922: LD_INT 1785
 924: PUSH
 925: LD_INT 1645
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_EXP 16
 938: PUSH
 939: LD_INT 3
 941: ARRAY
 942: ARRAY
 943: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 ] [ 1 ] ;
 944: LD_ADDR_EXP 13
 948: PUSH
 949: LD_INT 0
 951: PUSH
 952: EMPTY
 953: LIST
 954: PUSH
 955: LD_INT 1
 957: ARRAY
 958: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 ] [ 1 ] ;
 959: LD_ADDR_EXP 14
 963: PUSH
 964: LD_INT 0
 966: PUSH
 967: EMPTY
 968: LIST
 969: PUSH
 970: LD_INT 1
 972: ARRAY
 973: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 4 ] ] ;
 974: LD_ADDR_EXP 15
 978: PUSH
 979: LD_INT 0
 981: PUSH
 982: LD_INT 3
 984: PUSH
 985: LD_INT 5
 987: PUSH
 988: LD_INT 7
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_EXP 16
1001: PUSH
1002: LD_INT 4
1004: ARRAY
1005: ARRAY
1006: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 5 ] ] ;
1007: LD_ADDR_OWVAR 67
1011: PUSH
1012: LD_INT 1
1014: PUSH
1015: LD_INT 2
1017: PUSH
1018: LD_INT 3
1020: PUSH
1021: EMPTY
1022: LIST
1023: LIST
1024: LIST
1025: PUSH
1026: LD_EXP 16
1030: PUSH
1031: LD_INT 5
1033: ARRAY
1034: ARRAY
1035: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 6 ] ] ;
1036: LD_ADDR_EXP 26
1040: PUSH
1041: LD_INT 0
1043: PUSH
1044: LD_INT 1
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: LD_EXP 16
1059: PUSH
1060: LD_INT 6
1062: ARRAY
1063: ARRAY
1064: ST_TO_ADDR
// queue_codes := [ 11353 , 12244 , 44444 , 12345 , 43413 , 14152 ] ;
1065: LD_ADDR_EXP 23
1069: PUSH
1070: LD_INT 11353
1072: PUSH
1073: LD_INT 12244
1075: PUSH
1076: LD_INT 44444
1078: PUSH
1079: LD_INT 12345
1081: PUSH
1082: LD_INT 43413
1084: PUSH
1085: LD_INT 14152
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: ST_TO_ADDR
// rng := Rand ( 1 , 6 ) ;
1096: LD_ADDR_EXP 24
1100: PUSH
1101: LD_INT 1
1103: PPUSH
1104: LD_INT 6
1106: PPUSH
1107: CALL_OW 12
1111: ST_TO_ADDR
// if bot_side <> 2 then
1112: LD_EXP 8
1116: PUSH
1117: LD_INT 2
1119: NONEQUAL
1120: IFFALSE 1163
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1122: LD_ADDR_VAR 0 2
1126: PUSH
1127: LD_INT 22
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: EMPTY
1134: LIST
1135: LIST
1136: PPUSH
1137: CALL_OW 69
1141: PUSH
1142: FOR_IN
1143: IFFALSE 1161
// SetSide ( i , bot_side ) ;
1145: LD_VAR 0 2
1149: PPUSH
1150: LD_EXP 8
1154: PPUSH
1155: CALL_OW 235
1159: GO 1142
1161: POP
1162: POP
// ResetFog ;
1163: CALL_OW 335
// PreparePeople ( ) ;
1167: CALL 6893 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1171: LD_ADDR_EXP 18
1175: PUSH
1176: LD_INT 4
1178: PUSH
1179: LD_INT 5
1181: PUSH
1182: LD_INT 6
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: ST_TO_ADDR
// if amount_of_apeman then
1190: LD_EXP 15
1194: IFFALSE 1244
// for j in apeman_areas do
1196: LD_ADDR_VAR 0 3
1200: PUSH
1201: LD_EXP 18
1205: PUSH
1206: FOR_IN
1207: IFFALSE 1242
// for i = 1 to amount_of_apeman do
1209: LD_ADDR_VAR 0 2
1213: PUSH
1214: DOUBLE
1215: LD_INT 1
1217: DEC
1218: ST_TO_ADDR
1219: LD_EXP 15
1223: PUSH
1224: FOR_TO
1225: IFFALSE 1238
// AddApeman ( j ) ;
1227: LD_VAR 0 3
1231: PPUSH
1232: CALL 7803 0 1
1236: GO 1224
1238: POP
1239: POP
1240: GO 1206
1242: POP
1243: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1244: LD_INT 22
1246: PUSH
1247: LD_OWVAR 2
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: PPUSH
1256: CALL_OW 69
1260: PUSH
1261: LD_INT 1
1263: ARRAY
1264: PPUSH
1265: CALL_OW 87
// disable ( 17 ) ;
1269: LD_INT 17
1271: DISABLE_MARKED
// end ;
1272: LD_VAR 0 1
1276: RET
// every 0 0$01 + 0 0$30 trigger game_start do var cr , cr_queue ;
1277: LD_EXP 9
1281: IFFALSE 1933
1283: GO 1285
1285: DISABLE
1286: LD_INT 0
1288: PPUSH
1289: PPUSH
// begin cr := 1 ;
1290: LD_ADDR_VAR 0 1
1294: PUSH
1295: LD_INT 1
1297: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1298: LD_ADDR_VAR 0 2
1302: PUSH
1303: LD_INT 1
1305: PPUSH
1306: LD_INT 3
1308: PPUSH
1309: CALL_OW 12
1313: PUSH
1314: LD_INT 2
1316: PPUSH
1317: LD_INT 4
1319: PPUSH
1320: CALL_OW 12
1324: PUSH
1325: LD_INT 3
1327: PPUSH
1328: LD_INT 5
1330: PPUSH
1331: CALL_OW 12
1335: PUSH
1336: LD_INT 3
1338: PPUSH
1339: LD_INT 5
1341: PPUSH
1342: CALL_OW 12
1346: PUSH
1347: LD_INT 2
1349: PPUSH
1350: LD_INT 5
1352: PPUSH
1353: CALL_OW 12
1357: PUSH
1358: LD_INT 1
1360: PPUSH
1361: LD_INT 5
1363: PPUSH
1364: CALL_OW 12
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: ST_TO_ADDR
// while ( true ) do
1377: LD_INT 1
1379: IFFALSE 1933
// begin Wait ( crates_spawn + ( tick mod 35 * 60 ) ) ;
1381: LD_EXP 12
1385: PUSH
1386: LD_OWVAR 1
1390: PUSH
1391: LD_INT 35
1393: MOD
1394: PUSH
1395: LD_INT 60
1397: MUL
1398: PLUS
1399: PPUSH
1400: CALL_OW 67
// if cr mod 3 = 0 then
1404: LD_VAR 0 1
1408: PUSH
1409: LD_INT 3
1411: MOD
1412: PUSH
1413: LD_INT 0
1415: EQUAL
1416: IFFALSE 1569
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1418: LD_VAR 0 2
1422: PUSH
1423: LD_VAR 0 1
1427: PUSH
1428: LD_VAR 0 2
1432: MOD
1433: PUSH
1434: LD_INT 1
1436: PLUS
1437: ARRAY
1438: PPUSH
1439: LD_INT 1
1441: PPUSH
1442: LD_INT 1
1444: PPUSH
1445: CALL_OW 55
// Wait ( crates_spawn ) ;
1449: LD_EXP 12
1453: PPUSH
1454: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1458: LD_VAR 0 2
1462: PUSH
1463: LD_VAR 0 1
1467: PUSH
1468: LD_VAR 0 2
1472: MOD
1473: PUSH
1474: LD_INT 1
1476: PLUS
1477: ARRAY
1478: PPUSH
1479: LD_INT 2
1481: PPUSH
1482: LD_INT 1
1484: PPUSH
1485: CALL_OW 55
// Wait ( crates_spawn ) ;
1489: LD_EXP 12
1493: PPUSH
1494: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1498: LD_VAR 0 2
1502: PUSH
1503: LD_VAR 0 1
1507: PUSH
1508: LD_VAR 0 2
1512: MOD
1513: PUSH
1514: LD_INT 1
1516: PLUS
1517: ARRAY
1518: PPUSH
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 1
1524: PPUSH
1525: CALL_OW 55
// Wait ( crates_spawn ) ;
1529: LD_EXP 12
1533: PPUSH
1534: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1538: LD_VAR 0 2
1542: PUSH
1543: LD_VAR 0 1
1547: PUSH
1548: LD_VAR 0 2
1552: MOD
1553: PUSH
1554: LD_INT 1
1556: PLUS
1557: ARRAY
1558: PPUSH
1559: LD_INT 1
1561: PPUSH
1562: LD_INT 1
1564: PPUSH
1565: CALL_OW 55
// end ; if cr mod 3 = 1 then
1569: LD_VAR 0 1
1573: PUSH
1574: LD_INT 3
1576: MOD
1577: PUSH
1578: LD_INT 1
1580: EQUAL
1581: IFFALSE 1734
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1583: LD_VAR 0 2
1587: PUSH
1588: LD_VAR 0 1
1592: PUSH
1593: LD_VAR 0 2
1597: MOD
1598: PUSH
1599: LD_INT 1
1601: PLUS
1602: ARRAY
1603: PPUSH
1604: LD_INT 2
1606: PPUSH
1607: LD_INT 1
1609: PPUSH
1610: CALL_OW 55
// Wait ( crates_spawn ) ;
1614: LD_EXP 12
1618: PPUSH
1619: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1623: LD_VAR 0 2
1627: PUSH
1628: LD_VAR 0 1
1632: PUSH
1633: LD_VAR 0 2
1637: MOD
1638: PUSH
1639: LD_INT 1
1641: PLUS
1642: ARRAY
1643: PPUSH
1644: LD_INT 1
1646: PPUSH
1647: LD_INT 1
1649: PPUSH
1650: CALL_OW 55
// Wait ( crates_spawn ) ;
1654: LD_EXP 12
1658: PPUSH
1659: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1663: LD_VAR 0 2
1667: PUSH
1668: LD_VAR 0 1
1672: PUSH
1673: LD_VAR 0 2
1677: MOD
1678: PUSH
1679: LD_INT 1
1681: PLUS
1682: ARRAY
1683: PPUSH
1684: LD_INT 3
1686: PPUSH
1687: LD_INT 1
1689: PPUSH
1690: CALL_OW 55
// Wait ( crates_spawn ) ;
1694: LD_EXP 12
1698: PPUSH
1699: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1703: LD_VAR 0 2
1707: PUSH
1708: LD_VAR 0 1
1712: PUSH
1713: LD_VAR 0 2
1717: MOD
1718: PUSH
1719: LD_INT 1
1721: PLUS
1722: ARRAY
1723: PPUSH
1724: LD_INT 2
1726: PPUSH
1727: LD_INT 1
1729: PPUSH
1730: CALL_OW 55
// end ; if cr mod 3 = 2 then
1734: LD_VAR 0 1
1738: PUSH
1739: LD_INT 3
1741: MOD
1742: PUSH
1743: LD_INT 2
1745: EQUAL
1746: IFFALSE 1899
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1748: LD_VAR 0 2
1752: PUSH
1753: LD_VAR 0 1
1757: PUSH
1758: LD_VAR 0 2
1762: MOD
1763: PUSH
1764: LD_INT 1
1766: PLUS
1767: ARRAY
1768: PPUSH
1769: LD_INT 3
1771: PPUSH
1772: LD_INT 1
1774: PPUSH
1775: CALL_OW 55
// Wait ( crates_spawn ) ;
1779: LD_EXP 12
1783: PPUSH
1784: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1788: LD_VAR 0 2
1792: PUSH
1793: LD_VAR 0 1
1797: PUSH
1798: LD_VAR 0 2
1802: MOD
1803: PUSH
1804: LD_INT 1
1806: PLUS
1807: ARRAY
1808: PPUSH
1809: LD_INT 2
1811: PPUSH
1812: LD_INT 1
1814: PPUSH
1815: CALL_OW 55
// Wait ( crates_spawn ) ;
1819: LD_EXP 12
1823: PPUSH
1824: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1828: LD_VAR 0 2
1832: PUSH
1833: LD_VAR 0 1
1837: PUSH
1838: LD_VAR 0 2
1842: MOD
1843: PUSH
1844: LD_INT 1
1846: PLUS
1847: ARRAY
1848: PPUSH
1849: LD_INT 1
1851: PPUSH
1852: LD_INT 1
1854: PPUSH
1855: CALL_OW 55
// Wait ( crates_spawn ) ;
1859: LD_EXP 12
1863: PPUSH
1864: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1868: LD_VAR 0 2
1872: PUSH
1873: LD_VAR 0 1
1877: PUSH
1878: LD_VAR 0 2
1882: MOD
1883: PUSH
1884: LD_INT 1
1886: PLUS
1887: ARRAY
1888: PPUSH
1889: LD_INT 3
1891: PPUSH
1892: LD_INT 1
1894: PPUSH
1895: CALL_OW 55
// end ; cr := cr + 1 ;
1899: LD_ADDR_VAR 0 1
1903: PUSH
1904: LD_VAR 0 1
1908: PUSH
1909: LD_INT 1
1911: PLUS
1912: ST_TO_ADDR
// if cr > 150 then
1913: LD_VAR 0 1
1917: PUSH
1918: LD_INT 150
1920: GREATER
1921: IFFALSE 1931
// cr := 43 ;
1923: LD_ADDR_VAR 0 1
1927: PUSH
1928: LD_INT 43
1930: ST_TO_ADDR
// end ;
1931: GO 1377
// end ; end_of_file
1933: PPOPN 2
1935: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
1936: LD_INT 0
1938: PPUSH
1939: PPUSH
1940: PPUSH
1941: PPUSH
// begin if un in attackers then
1942: LD_VAR 0 1
1946: PUSH
1947: LD_EXP 20
1951: IN
1952: IFFALSE 1970
// attackers := attackers diff un ;
1954: LD_ADDR_EXP 20
1958: PUSH
1959: LD_EXP 20
1963: PUSH
1964: LD_VAR 0 1
1968: DIFF
1969: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
1970: LD_VAR 0 1
1974: PPUSH
1975: CALL_OW 255
1979: PUSH
1980: LD_EXP 8
1984: NONEQUAL
1985: PUSH
1986: LD_VAR 0 1
1990: PPUSH
1991: CALL_OW 255
1995: PUSH
1996: LD_INT 0
1998: GREATER
1999: AND
2000: PUSH
2001: LD_VAR 0 1
2005: PUSH
2006: LD_INT 21
2008: PUSH
2009: LD_INT 1
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: PPUSH
2016: CALL_OW 69
2020: IN
2021: AND
2022: IFFALSE 2200
// begin if respawning_time_min > 0 0$00 then
2024: LD_EXP 13
2028: PUSH
2029: LD_INT 0
2031: GREATER
2032: IFFALSE 2200
// begin s := GetSide ( un ) ;
2034: LD_ADDR_VAR 0 4
2038: PUSH
2039: LD_VAR 0 1
2043: PPUSH
2044: CALL_OW 255
2048: ST_TO_ADDR
// n := GetNation ( un ) ;
2049: LD_ADDR_VAR 0 5
2053: PUSH
2054: LD_VAR 0 1
2058: PPUSH
2059: CALL_OW 248
2063: ST_TO_ADDR
// cl := GetClass ( un ) ;
2064: LD_ADDR_VAR 0 3
2068: PUSH
2069: LD_VAR 0 1
2073: PPUSH
2074: CALL_OW 257
2078: ST_TO_ADDR
// wait ( respawning_time_min ) ;
2079: LD_EXP 13
2083: PPUSH
2084: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) ) ;
2088: LD_EXP 14
2092: PUSH
2093: LD_INT 350
2095: PUSH
2096: LD_OWVAR 1
2100: MUL
2101: PUSH
2102: LD_INT 10
2104: MOD
2105: PUSH
2106: LD_INT 1
2108: PLUS
2109: MINUS
2110: PPUSH
2111: CALL_OW 67
// uc_side := s ;
2115: LD_ADDR_OWVAR 20
2119: PUSH
2120: LD_VAR 0 4
2124: ST_TO_ADDR
// uc_nation := n ;
2125: LD_ADDR_OWVAR 21
2129: PUSH
2130: LD_VAR 0 5
2134: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
2135: LD_INT 0
2137: PPUSH
2138: LD_VAR 0 3
2142: PPUSH
2143: LD_EXP 11
2147: PUSH
2148: LD_INT 2
2150: MINUS
2151: PPUSH
2152: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
2156: CALL_OW 44
2160: PPUSH
2161: LD_INT 1
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 2
2169: PUSH
2170: LD_INT 3
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: PUSH
2179: LD_VAR 0 3
2183: PUSH
2184: LD_INT 4
2186: MOD
2187: PUSH
2188: LD_INT 1
2190: PLUS
2191: ARRAY
2192: PPUSH
2193: LD_INT 1
2195: PPUSH
2196: CALL_OW 49
// end ; end ; end ;
2200: PPOPN 5
2202: END
// on UnitGoesToRed ( un ) do begin if GetControl ( un ) = control_remote then
2203: LD_VAR 0 1
2207: PPUSH
2208: CALL_OW 263
2212: PUSH
2213: LD_INT 2
2215: EQUAL
2216: IFFALSE 2227
// ComUnlink ( un ) ;
2218: LD_VAR 0 1
2222: PPUSH
2223: CALL_OW 136
// end ;
2227: PPOPN 1
2229: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
2230: LD_VAR 0 1
2234: PPUSH
2235: CALL_OW 255
2239: PUSH
2240: LD_EXP 8
2244: EQUAL
2245: IFFALSE 2276
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
2247: LD_ADDR_EXP 20
2251: PUSH
2252: LD_EXP 20
2256: PPUSH
2257: LD_EXP 20
2261: PUSH
2262: LD_INT 1
2264: PLUS
2265: PPUSH
2266: LD_VAR 0 1
2270: PPUSH
2271: CALL_OW 2
2275: ST_TO_ADDR
// end ;
2276: PPOPN 2
2278: END
// on LeaveBuilding ( b , un ) do var i , arm , tmp ;
2279: LD_INT 0
2281: PPUSH
2282: PPUSH
2283: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
2284: LD_VAR 0 1
2288: PPUSH
2289: CALL_OW 255
2293: PUSH
2294: LD_EXP 8
2298: EQUAL
2299: PUSH
2300: LD_VAR 0 1
2304: PPUSH
2305: CALL_OW 266
2309: PUSH
2310: LD_INT 32
2312: EQUAL
2313: AND
2314: IFFALSE 2404
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
2316: LD_ADDR_VAR 0 4
2320: PUSH
2321: LD_INT 22
2323: PUSH
2324: LD_EXP 8
2328: PUSH
2329: EMPTY
2330: LIST
2331: LIST
2332: PUSH
2333: LD_INT 30
2335: PUSH
2336: LD_INT 5
2338: PUSH
2339: EMPTY
2340: LIST
2341: LIST
2342: PUSH
2343: EMPTY
2344: LIST
2345: LIST
2346: PPUSH
2347: CALL_OW 69
2351: ST_TO_ADDR
// tmp := NearestUnitToUnit ( arm , un ) ;
2352: LD_ADDR_VAR 0 5
2356: PUSH
2357: LD_VAR 0 4
2361: PPUSH
2362: LD_VAR 0 2
2366: PPUSH
2367: CALL_OW 74
2371: ST_TO_ADDR
// if tmp then
2372: LD_VAR 0 5
2376: IFFALSE 2404
// begin ComEnterUnit ( un , tmp ) ;
2378: LD_VAR 0 2
2382: PPUSH
2383: LD_VAR 0 5
2387: PPUSH
2388: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
2392: LD_VAR 0 2
2396: PPUSH
2397: LD_INT 8
2399: PPUSH
2400: CALL_OW 183
// end ; end ; end ; end_of_file
2404: PPOPN 5
2406: END
// export south_force , north_force , east_force ; export function InitBot ; var i , ct , hex , side , un , veh , weapons , skill ; begin
2407: LD_INT 0
2409: PPUSH
2410: PPUSH
2411: PPUSH
2412: PPUSH
2413: PPUSH
2414: PPUSH
2415: PPUSH
2416: PPUSH
2417: PPUSH
// side := Bot_Side ;
2418: LD_ADDR_VAR 0 5
2422: PUSH
2423: LD_EXP 8
2427: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
2428: LD_ADDR_VAR 0 9
2432: PUSH
2433: LD_INT 4
2435: PUSH
2436: LD_INT 6
2438: PUSH
2439: LD_INT 8
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: LIST
2446: PUSH
2447: LD_OWVAR 67
2451: ARRAY
2452: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
2453: LD_ADDR_VAR 0 8
2457: PUSH
2458: LD_INT 27
2460: PUSH
2461: LD_INT 28
2463: PUSH
2464: LD_INT 25
2466: PUSH
2467: LD_INT 26
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: LIST
2474: LIST
2475: ST_TO_ADDR
// veh_counter := [ 4 , 5 , 6 ] [ Difficulty ] ;
2476: LD_ADDR_EXP 22
2480: PUSH
2481: LD_INT 4
2483: PUSH
2484: LD_INT 5
2486: PUSH
2487: LD_INT 6
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: PUSH
2495: LD_OWVAR 67
2499: ARRAY
2500: ST_TO_ADDR
// ct := [ ] ;
2501: LD_ADDR_VAR 0 3
2505: PUSH
2506: EMPTY
2507: ST_TO_ADDR
// patrols := [ ] ;
2508: LD_ADDR_EXP 19
2512: PUSH
2513: EMPTY
2514: ST_TO_ADDR
// attackers := [ ] ;
2515: LD_ADDR_EXP 20
2519: PUSH
2520: EMPTY
2521: ST_TO_ADDR
// south_force := Defcon ( [ 3 , 3 , 4 ] [ Difficulty ] , 118 , 130 , false ) ;
2522: LD_ADDR_EXP 27
2526: PUSH
2527: LD_INT 3
2529: PUSH
2530: LD_INT 3
2532: PUSH
2533: LD_INT 4
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: LIST
2540: PUSH
2541: LD_OWVAR 67
2545: ARRAY
2546: PPUSH
2547: LD_INT 118
2549: PPUSH
2550: LD_INT 130
2552: PPUSH
2553: LD_INT 0
2555: PPUSH
2556: CALL 4211 0 4
2560: ST_TO_ADDR
// north_force := Defcon ( [ 4 , 5 , 6 ] [ Difficulty ] , 21 , 16 , false ) ;
2561: LD_ADDR_EXP 28
2565: PUSH
2566: LD_INT 4
2568: PUSH
2569: LD_INT 5
2571: PUSH
2572: LD_INT 6
2574: PUSH
2575: EMPTY
2576: LIST
2577: LIST
2578: LIST
2579: PUSH
2580: LD_OWVAR 67
2584: ARRAY
2585: PPUSH
2586: LD_INT 21
2588: PPUSH
2589: LD_INT 16
2591: PPUSH
2592: LD_INT 0
2594: PPUSH
2595: CALL 4211 0 4
2599: ST_TO_ADDR
// east_force := Defcon ( [ 4 , 5 , 5 ] [ Difficulty ] , 111 , 21 , true ) ;
2600: LD_ADDR_EXP 29
2604: PUSH
2605: LD_INT 4
2607: PUSH
2608: LD_INT 5
2610: PUSH
2611: LD_INT 5
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: LIST
2618: PUSH
2619: LD_OWVAR 67
2623: ARRAY
2624: PPUSH
2625: LD_INT 111
2627: PPUSH
2628: LD_INT 21
2630: PPUSH
2631: LD_INT 1
2633: PPUSH
2634: CALL 4211 0 4
2638: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
2639: LD_ADDR_EXP 21
2643: PUSH
2644: LD_INT 14
2646: PUSH
2647: LD_INT 1
2649: PUSH
2650: LD_INT 2
2652: PUSH
2653: LD_INT 27
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: LIST
2660: LIST
2661: PUSH
2662: LD_INT 14
2664: PUSH
2665: LD_INT 1
2667: PUSH
2668: LD_INT 2
2670: PUSH
2671: LD_INT 25
2673: PUSH
2674: EMPTY
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: PUSH
2680: LD_INT 14
2682: PUSH
2683: LD_INT 1
2685: PUSH
2686: LD_INT 2
2688: PUSH
2689: LD_INT 28
2691: PUSH
2692: EMPTY
2693: LIST
2694: LIST
2695: LIST
2696: LIST
2697: PUSH
2698: LD_INT 14
2700: PUSH
2701: LD_INT 1
2703: PUSH
2704: LD_INT 2
2706: PUSH
2707: LD_INT 29
2709: PUSH
2710: EMPTY
2711: LIST
2712: LIST
2713: LIST
2714: LIST
2715: PUSH
2716: LD_INT 14
2718: PUSH
2719: LD_INT 1
2721: PUSH
2722: LD_INT 2
2724: PUSH
2725: LD_INT 27
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: LIST
2732: LIST
2733: PUSH
2734: EMPTY
2735: LIST
2736: LIST
2737: LIST
2738: LIST
2739: LIST
2740: ST_TO_ADDR
// SetResourceType ( GetBase ( ar_base_east ) , mat_cans , 90000 ) ;
2741: LD_INT 81
2743: PPUSH
2744: CALL_OW 274
2748: PPUSH
2749: LD_INT 1
2751: PPUSH
2752: LD_INT 90000
2754: PPUSH
2755: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_oil , 9000 ) ;
2759: LD_INT 81
2761: PPUSH
2762: CALL_OW 274
2766: PPUSH
2767: LD_INT 2
2769: PPUSH
2770: LD_INT 9000
2772: PPUSH
2773: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_siberit , 3000 ) ;
2777: LD_INT 81
2779: PPUSH
2780: CALL_OW 274
2784: PPUSH
2785: LD_INT 3
2787: PPUSH
2788: LD_INT 3000
2790: PPUSH
2791: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_cans , 10000 ) ;
2795: LD_INT 81
2797: PPUSH
2798: CALL_OW 274
2802: PPUSH
2803: LD_INT 1
2805: PPUSH
2806: LD_INT 10000
2808: PPUSH
2809: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_oil , 1000 ) ;
2813: LD_INT 81
2815: PPUSH
2816: CALL_OW 274
2820: PPUSH
2821: LD_INT 2
2823: PPUSH
2824: LD_INT 1000
2826: PPUSH
2827: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_siberit , 1000 ) ;
2831: LD_INT 81
2833: PPUSH
2834: CALL_OW 274
2838: PPUSH
2839: LD_INT 3
2841: PPUSH
2842: LD_INT 1000
2844: PPUSH
2845: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_sout ) , mat_cans , [ 2000 , 1500 , 1000 ] [ Difficulty ] ) ;
2849: LD_INT 5
2851: PPUSH
2852: CALL_OW 274
2856: PPUSH
2857: LD_INT 1
2859: PPUSH
2860: LD_INT 2000
2862: PUSH
2863: LD_INT 1500
2865: PUSH
2866: LD_INT 1000
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: LIST
2873: PUSH
2874: LD_OWVAR 67
2878: ARRAY
2879: PPUSH
2880: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_sout ) , mat_oil , 1000 ) ;
2884: LD_INT 5
2886: PPUSH
2887: CALL_OW 274
2891: PPUSH
2892: LD_INT 2
2894: PPUSH
2895: LD_INT 1000
2897: PPUSH
2898: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_sout ) , mat_siberit , 100 ) ;
2902: LD_INT 5
2904: PPUSH
2905: CALL_OW 274
2909: PPUSH
2910: LD_INT 3
2912: PPUSH
2913: LD_INT 100
2915: PPUSH
2916: CALL_OW 277
// if Difficulty > 1 then
2920: LD_OWVAR 67
2924: PUSH
2925: LD_INT 1
2927: GREATER
2928: IFFALSE 2945
// SetTech ( 5 , side , state_researched ) ;
2930: LD_INT 5
2932: PPUSH
2933: LD_VAR 0 5
2937: PPUSH
2938: LD_INT 2
2940: PPUSH
2941: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
2945: LD_INT 51
2947: PPUSH
2948: LD_VAR 0 5
2952: PPUSH
2953: LD_INT 2
2955: PPUSH
2956: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
2960: LD_INT 52
2962: PPUSH
2963: LD_VAR 0 5
2967: PPUSH
2968: LD_INT 2
2970: PPUSH
2971: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
2975: LD_INT 53
2977: PPUSH
2978: LD_VAR 0 5
2982: PPUSH
2983: LD_INT 2
2985: PPUSH
2986: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
2990: LD_INT 60
2992: PPUSH
2993: LD_VAR 0 5
2997: PPUSH
2998: LD_INT 2
3000: PPUSH
3001: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
3005: LD_INT 61
3007: PPUSH
3008: LD_VAR 0 5
3012: PPUSH
3013: LD_INT 2
3015: PPUSH
3016: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
3020: LD_INT 62
3022: PPUSH
3023: LD_VAR 0 5
3027: PPUSH
3028: LD_INT 2
3030: PPUSH
3031: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
3035: LD_ADDR_VAR 0 2
3039: PUSH
3040: LD_INT 22
3042: PUSH
3043: LD_VAR 0 5
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 21
3054: PUSH
3055: LD_INT 3
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: PUSH
3062: EMPTY
3063: LIST
3064: LIST
3065: PPUSH
3066: CALL_OW 69
3070: PUSH
3071: FOR_IN
3072: IFFALSE 3105
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
3074: LD_VAR 0 2
3078: PPUSH
3079: LD_INT 6
3081: PUSH
3082: LD_INT 8
3084: PUSH
3085: LD_INT 10
3087: PUSH
3088: EMPTY
3089: LIST
3090: LIST
3091: LIST
3092: PUSH
3093: LD_OWVAR 67
3097: ARRAY
3098: PPUSH
3099: CALL_OW 241
3103: GO 3071
3105: POP
3106: POP
// PlaceMines ( mine_west_zone , [ 5 , 7 , 9 ] [ Difficulty ] ) ;
3107: LD_INT 7
3109: PPUSH
3110: LD_INT 5
3112: PUSH
3113: LD_INT 7
3115: PUSH
3116: LD_INT 9
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: LIST
3123: PUSH
3124: LD_OWVAR 67
3128: ARRAY
3129: PPUSH
3130: CALL 7889 0 2
// PlaceMines ( mine_east_zone , [ 20 , 25 , 30 ] [ Difficulty ] ) ;
3134: LD_INT 9
3136: PPUSH
3137: LD_INT 20
3139: PUSH
3140: LD_INT 25
3142: PUSH
3143: LD_INT 30
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PPUSH
3157: CALL 7889 0 2
// PlaceMines ( mine_center_zone , [ 6 , 8 , 9 ] [ Difficulty ] ) ;
3161: LD_INT 8
3163: PPUSH
3164: LD_INT 6
3166: PUSH
3167: LD_INT 8
3169: PUSH
3170: LD_INT 9
3172: PUSH
3173: EMPTY
3174: LIST
3175: LIST
3176: LIST
3177: PUSH
3178: LD_OWVAR 67
3182: ARRAY
3183: PPUSH
3184: CALL 7889 0 2
// PlaceMines ( mine_pass_zone , [ 4 , 6 , 9 ] [ Difficulty ] ) ;
3188: LD_INT 10
3190: PPUSH
3191: LD_INT 4
3193: PUSH
3194: LD_INT 6
3196: PUSH
3197: LD_INT 9
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PUSH
3205: LD_OWVAR 67
3209: ARRAY
3210: PPUSH
3211: CALL 7889 0 2
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
3215: LD_INT 11
3217: PPUSH
3218: LD_INT 2
3220: PUSH
3221: LD_INT 5
3223: PUSH
3224: LD_INT 8
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: LIST
3231: PUSH
3232: LD_OWVAR 67
3236: ARRAY
3237: PPUSH
3238: CALL 7889 0 2
// PlaceMines ( mine_southpass_zone , [ 2 , 4 , 6 ] [ Difficulty ] ) ;
3242: LD_INT 12
3244: PPUSH
3245: LD_INT 2
3247: PUSH
3248: LD_INT 4
3250: PUSH
3251: LD_INT 6
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: LIST
3258: PUSH
3259: LD_OWVAR 67
3263: ARRAY
3264: PPUSH
3265: CALL 7889 0 2
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
3269: LD_ADDR_VAR 0 2
3273: PUSH
3274: DOUBLE
3275: LD_INT 1
3277: DEC
3278: ST_TO_ADDR
3279: LD_INT 8
3281: PUSH
3282: LD_INT 11
3284: PUSH
3285: LD_INT 14
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: LIST
3292: PUSH
3293: LD_OWVAR 67
3297: ARRAY
3298: PUSH
3299: FOR_TO
3300: IFFALSE 3475
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
3302: LD_ADDR_VAR 0 4
3306: PUSH
3307: LD_INT 134
3309: PPUSH
3310: LD_INT 73
3312: PPUSH
3313: LD_INT 10
3315: PPUSH
3316: LD_INT 0
3318: PPUSH
3319: CALL_OW 17
3323: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
3324: LD_VAR 0 4
3328: PUSH
3329: LD_INT 1
3331: ARRAY
3332: PPUSH
3333: LD_VAR 0 4
3337: PUSH
3338: LD_INT 2
3340: ARRAY
3341: PPUSH
3342: CALL_OW 428
3346: PUSH
3347: LD_INT 0
3349: EQUAL
3350: PUSH
3351: LD_VAR 0 4
3355: PUSH
3356: LD_INT 1
3358: ARRAY
3359: PPUSH
3360: LD_VAR 0 4
3364: PUSH
3365: LD_INT 2
3367: ARRAY
3368: PPUSH
3369: CALL_OW 458
3373: NOT
3374: AND
3375: IFFALSE 3473
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
3377: LD_ADDR_EXP 17
3381: PUSH
3382: LD_EXP 17
3386: PPUSH
3387: LD_EXP 17
3391: PUSH
3392: LD_INT 1
3394: PLUS
3395: PPUSH
3396: LD_VAR 0 4
3400: PUSH
3401: LD_INT 1
3403: ARRAY
3404: PPUSH
3405: CALL_OW 2
3409: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
3410: LD_ADDR_EXP 17
3414: PUSH
3415: LD_EXP 17
3419: PPUSH
3420: LD_EXP 17
3424: PUSH
3425: LD_INT 1
3427: PLUS
3428: PPUSH
3429: LD_VAR 0 4
3433: PUSH
3434: LD_INT 2
3436: ARRAY
3437: PPUSH
3438: CALL_OW 2
3442: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
3443: LD_VAR 0 4
3447: PUSH
3448: LD_INT 1
3450: ARRAY
3451: PPUSH
3452: LD_VAR 0 4
3456: PUSH
3457: LD_INT 2
3459: ARRAY
3460: PPUSH
3461: LD_EXP 8
3465: PPUSH
3466: LD_INT 0
3468: PPUSH
3469: CALL_OW 454
// end ; end ;
3473: GO 3299
3475: POP
3476: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
3477: LD_ADDR_VAR 0 2
3481: PUSH
3482: LD_INT 22
3484: PUSH
3485: LD_VAR 0 5
3489: PUSH
3490: EMPTY
3491: LIST
3492: LIST
3493: PUSH
3494: LD_INT 30
3496: PUSH
3497: LD_INT 32
3499: PUSH
3500: EMPTY
3501: LIST
3502: LIST
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: PPUSH
3508: CALL_OW 69
3512: PUSH
3513: FOR_IN
3514: IFFALSE 3546
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
3516: LD_VAR 0 2
3520: PPUSH
3521: LD_VAR 0 8
3525: PUSH
3526: LD_INT 1
3528: PPUSH
3529: LD_VAR 0 8
3533: PPUSH
3534: CALL_OW 12
3538: ARRAY
3539: PPUSH
3540: CALL_OW 431
3544: GO 3513
3546: POP
3547: POP
// uc_side := side ;
3548: LD_ADDR_OWVAR 20
3552: PUSH
3553: LD_VAR 0 5
3557: ST_TO_ADDR
// uc_nation := 2 ;
3558: LD_ADDR_OWVAR 21
3562: PUSH
3563: LD_INT 2
3565: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
3566: LD_ADDR_VAR 0 2
3570: PUSH
3571: DOUBLE
3572: LD_INT 1
3574: DEC
3575: ST_TO_ADDR
3576: LD_INT 1
3578: PUSH
3579: LD_OWVAR 67
3583: PLUS
3584: PUSH
3585: FOR_TO
3586: IFFALSE 3676
// begin vc_chassis := ar_half_tracked ;
3588: LD_ADDR_OWVAR 37
3592: PUSH
3593: LD_INT 14
3595: ST_TO_ADDR
// vc_engine := engine_combustion ;
3596: LD_ADDR_OWVAR 39
3600: PUSH
3601: LD_INT 1
3603: ST_TO_ADDR
// vc_control := control_manual ;
3604: LD_ADDR_OWVAR 38
3608: PUSH
3609: LD_INT 1
3611: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3612: LD_ADDR_OWVAR 40
3616: PUSH
3617: LD_INT 31
3619: ST_TO_ADDR
// veh := CreateVehicle ;
3620: LD_ADDR_VAR 0 7
3624: PUSH
3625: CALL_OW 45
3629: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
3630: LD_VAR 0 7
3634: PPUSH
3635: LD_INT 13
3637: PPUSH
3638: LD_INT 0
3640: PPUSH
3641: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3645: LD_INT 0
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: LD_VAR 0 9
3655: PPUSH
3656: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3660: CALL_OW 44
3664: PPUSH
3665: LD_VAR 0 7
3669: PPUSH
3670: CALL_OW 52
// end ;
3674: GO 3585
3676: POP
3677: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
3678: LD_ADDR_VAR 0 2
3682: PUSH
3683: LD_INT 22
3685: PUSH
3686: LD_VAR 0 5
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: PUSH
3695: LD_INT 30
3697: PUSH
3698: LD_INT 32
3700: PUSH
3701: EMPTY
3702: LIST
3703: LIST
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PPUSH
3709: CALL_OW 69
3713: PUSH
3714: FOR_IN
3715: IFFALSE 3748
// begin PrepareHuman ( false , 1 , skill ) ;
3717: LD_INT 0
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_VAR 0 9
3727: PPUSH
3728: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3732: CALL_OW 44
3736: PPUSH
3737: LD_VAR 0 2
3741: PPUSH
3742: CALL_OW 52
// end ;
3746: GO 3714
3748: POP
3749: POP
// for i = 1 to 4 do
3750: LD_ADDR_VAR 0 2
3754: PUSH
3755: DOUBLE
3756: LD_INT 1
3758: DEC
3759: ST_TO_ADDR
3760: LD_INT 4
3762: PUSH
3763: FOR_TO
3764: IFFALSE 3795
// begin PrepareHuman ( false , 2 , skill ) ;
3766: LD_INT 0
3768: PPUSH
3769: LD_INT 2
3771: PPUSH
3772: LD_VAR 0 9
3776: PPUSH
3777: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_base_east ) ;
3781: CALL_OW 44
3785: PPUSH
3786: LD_INT 81
3788: PPUSH
3789: CALL_OW 52
// end ;
3793: GO 3763
3795: POP
3796: POP
// for i = 1 to 6 do
3797: LD_ADDR_VAR 0 2
3801: PUSH
3802: DOUBLE
3803: LD_INT 1
3805: DEC
3806: ST_TO_ADDR
3807: LD_INT 6
3809: PUSH
3810: FOR_TO
3811: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill ) ;
3813: LD_INT 0
3815: PPUSH
3816: LD_INT 3
3818: PPUSH
3819: LD_VAR 0 9
3823: PPUSH
3824: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac_east ) ;
3828: CALL_OW 44
3832: PPUSH
3833: LD_INT 88
3835: PPUSH
3836: CALL_OW 52
// end ;
3840: GO 3810
3842: POP
3843: POP
// for i = 1 to 4 do
3844: LD_ADDR_VAR 0 2
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 4
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3915
// begin PrepareHuman ( false , 4 , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 4
3865: PPUSH
3866: LD_VAR 0 9
3870: PPUSH
3871: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
3875: CALL_OW 44
3879: PPUSH
3880: LD_INT 30
3882: PUSH
3883: LD_INT 8
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PPUSH
3890: CALL_OW 69
3894: PUSH
3895: LD_VAR 0 2
3899: PUSH
3900: LD_INT 2
3902: MOD
3903: PUSH
3904: LD_INT 1
3906: PLUS
3907: ARRAY
3908: PPUSH
3909: CALL_OW 52
// end ;
3913: GO 3857
3915: POP
3916: POP
// PrepareHuman ( false , class_sniper , skill ) ;
3917: LD_INT 0
3919: PPUSH
3920: LD_INT 5
3922: PPUSH
3923: LD_VAR 0 9
3927: PPUSH
3928: CALL_OW 380
// un := CreateHuman ;
3932: LD_ADDR_VAR 0 6
3936: PUSH
3937: CALL_OW 44
3941: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3942: LD_VAR 0 6
3946: PPUSH
3947: LD_INT 3
3949: PPUSH
3950: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
3954: LD_VAR 0 6
3958: PPUSH
3959: LD_INT 52
3961: PPUSH
3962: CALL_OW 52
// for i = 1 to 4 do
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: DOUBLE
3972: LD_INT 1
3974: DEC
3975: ST_TO_ADDR
3976: LD_INT 4
3978: PUSH
3979: FOR_TO
3980: IFFALSE 4036
// begin uc_nation := 0 ;
3982: LD_ADDR_OWVAR 21
3986: PUSH
3987: LD_INT 0
3989: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
3990: LD_INT 0
3992: PPUSH
3993: LD_INT 16
3995: PPUSH
3996: LD_INT 1
3998: PPUSH
3999: CALL_OW 380
// un := CreateHuman ;
4003: LD_ADDR_VAR 0 6
4007: PUSH
4008: CALL_OW 44
4012: ST_TO_ADDR
// PlaceUnitXYR ( un , 116 , 128 , 8 , false ) ;
4013: LD_VAR 0 6
4017: PPUSH
4018: LD_INT 116
4020: PPUSH
4021: LD_INT 128
4023: PPUSH
4024: LD_INT 8
4026: PPUSH
4027: LD_INT 0
4029: PPUSH
4030: CALL_OW 50
// end ;
4034: GO 3979
4036: POP
4037: POP
// for i = 1 to 3 do
4038: LD_ADDR_VAR 0 2
4042: PUSH
4043: DOUBLE
4044: LD_INT 1
4046: DEC
4047: ST_TO_ADDR
4048: LD_INT 3
4050: PUSH
4051: FOR_TO
4052: IFFALSE 4108
// begin uc_nation := 0 ;
4054: LD_ADDR_OWVAR 21
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
4062: LD_INT 0
4064: PPUSH
4065: LD_INT 16
4067: PPUSH
4068: LD_INT 1
4070: PPUSH
4071: CALL_OW 380
// un := CreateHuman ;
4075: LD_ADDR_VAR 0 6
4079: PUSH
4080: CALL_OW 44
4084: ST_TO_ADDR
// PlaceUnitXYR ( un , 23 , 19 , 8 , false ) ;
4085: LD_VAR 0 6
4089: PPUSH
4090: LD_INT 23
4092: PPUSH
4093: LD_INT 19
4095: PPUSH
4096: LD_INT 8
4098: PPUSH
4099: LD_INT 0
4101: PPUSH
4102: CALL_OW 50
// end ;
4106: GO 4051
4108: POP
4109: POP
// for i = 1 to 3 * Difficulty do
4110: LD_ADDR_VAR 0 2
4114: PUSH
4115: DOUBLE
4116: LD_INT 1
4118: DEC
4119: ST_TO_ADDR
4120: LD_INT 3
4122: PUSH
4123: LD_OWVAR 67
4127: MUL
4128: PUSH
4129: FOR_TO
4130: IFFALSE 4204
// begin uc_nation := 0 ;
4132: LD_ADDR_OWVAR 21
4136: PUSH
4137: LD_INT 0
4139: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
4140: LD_INT 0
4142: PPUSH
4143: LD_INT 17
4145: PPUSH
4146: LD_INT 3
4148: PPUSH
4149: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
4153: LD_ADDR_OWVAR 29
4157: PUSH
4158: LD_INT 11
4160: PUSH
4161: LD_INT 13
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: ST_TO_ADDR
// un := CreateHuman ;
4168: LD_ADDR_VAR 0 6
4172: PUSH
4173: CALL_OW 44
4177: ST_TO_ADDR
// PlaceUnitArea ( un , ap1 , false ) ;
4178: LD_VAR 0 6
4182: PPUSH
4183: LD_INT 14
4185: PPUSH
4186: LD_INT 0
4188: PPUSH
4189: CALL_OW 49
// ComHold ( un ) ;
4193: LD_VAR 0 6
4197: PPUSH
4198: CALL_OW 140
// end ;
4202: GO 4129
4204: POP
4205: POP
// end ;
4206: LD_VAR 0 1
4210: RET
// export function Defcon ( n , x , y , type ) ; var i , un , veh , list ; begin
4211: LD_INT 0
4213: PPUSH
4214: PPUSH
4215: PPUSH
4216: PPUSH
4217: PPUSH
// list := [ ] ;
4218: LD_ADDR_VAR 0 9
4222: PUSH
4223: EMPTY
4224: ST_TO_ADDR
// uc_side := bot_side ;
4225: LD_ADDR_OWVAR 20
4229: PUSH
4230: LD_EXP 8
4234: ST_TO_ADDR
// uc_nation := nation_arabian ;
4235: LD_ADDR_OWVAR 21
4239: PUSH
4240: LD_INT 2
4242: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4243: LD_ADDR_OWVAR 37
4247: PUSH
4248: LD_INT 14
4250: ST_TO_ADDR
// vc_engine := engine_siberite ;
4251: LD_ADDR_OWVAR 39
4255: PUSH
4256: LD_INT 3
4258: ST_TO_ADDR
// if type then
4259: LD_VAR 0 4
4263: IFFALSE 4275
// vc_control := control_manual else
4265: LD_ADDR_OWVAR 38
4269: PUSH
4270: LD_INT 1
4272: ST_TO_ADDR
4273: GO 4283
// vc_control := control_apeman ;
4275: LD_ADDR_OWVAR 38
4279: PUSH
4280: LD_INT 5
4282: ST_TO_ADDR
// for i = 1 to n do
4283: LD_ADDR_VAR 0 6
4287: PUSH
4288: DOUBLE
4289: LD_INT 1
4291: DEC
4292: ST_TO_ADDR
4293: LD_VAR 0 1
4297: PUSH
4298: FOR_TO
4299: IFFALSE 4442
// begin vc_weapon := [ ar_rocket_launcher , ar_flame_thrower , ar_gun ] [ Rand ( 1 , 3 ) ] ;
4301: LD_ADDR_OWVAR 40
4305: PUSH
4306: LD_INT 28
4308: PUSH
4309: LD_INT 26
4311: PUSH
4312: LD_INT 27
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: LIST
4319: PUSH
4320: LD_INT 1
4322: PPUSH
4323: LD_INT 3
4325: PPUSH
4326: CALL_OW 12
4330: ARRAY
4331: ST_TO_ADDR
// veh := CreateVehicle ;
4332: LD_ADDR_VAR 0 8
4336: PUSH
4337: CALL_OW 45
4341: ST_TO_ADDR
// PlaceUnitXYR ( veh , x , y , 13 , false ) ;
4342: LD_VAR 0 8
4346: PPUSH
4347: LD_VAR 0 2
4351: PPUSH
4352: LD_VAR 0 3
4356: PPUSH
4357: LD_INT 13
4359: PPUSH
4360: LD_INT 0
4362: PPUSH
4363: CALL_OW 50
// if type then
4367: LD_VAR 0 4
4371: IFFALSE 4417
// begin PrepareHuman ( false , 3 , [ 4 , 6 , 8 ] [ Difficulty ] ) ;
4373: LD_INT 0
4375: PPUSH
4376: LD_INT 3
4378: PPUSH
4379: LD_INT 4
4381: PUSH
4382: LD_INT 6
4384: PUSH
4385: LD_INT 8
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: LIST
4392: PUSH
4393: LD_OWVAR 67
4397: ARRAY
4398: PPUSH
4399: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4403: CALL_OW 44
4407: PPUSH
4408: LD_VAR 0 8
4412: PPUSH
4413: CALL_OW 52
// end ; list := Insert ( list , 1 , veh ) ;
4417: LD_ADDR_VAR 0 9
4421: PUSH
4422: LD_VAR 0 9
4426: PPUSH
4427: LD_INT 1
4429: PPUSH
4430: LD_VAR 0 8
4434: PPUSH
4435: CALL_OW 2
4439: ST_TO_ADDR
// end ;
4440: GO 4298
4442: POP
4443: POP
// result := list ;
4444: LD_ADDR_VAR 0 5
4448: PUSH
4449: LD_VAR 0 9
4453: ST_TO_ADDR
// end ;
4454: LD_VAR 0 5
4458: RET
// every 0 0$03 trigger FilterUnitsInArea ( pass_guard , [ f_enemy , bot_side ] ) do var i ;
4459: LD_INT 16
4461: PPUSH
4462: LD_INT 81
4464: PUSH
4465: LD_EXP 8
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PPUSH
4474: CALL_OW 70
4478: IFFALSE 4556
4480: GO 4482
4482: DISABLE
4483: LD_INT 0
4485: PPUSH
// begin if not north_force then
4486: LD_EXP 28
4490: NOT
4491: IFFALSE 4495
// exit ;
4493: GO 4556
// for i = 1 to north_force do
4495: LD_ADDR_VAR 0 1
4499: PUSH
4500: DOUBLE
4501: LD_INT 1
4503: DEC
4504: ST_TO_ADDR
4505: LD_EXP 28
4509: PUSH
4510: FOR_TO
4511: IFFALSE 4536
// begin ComMoveXY ( north_force [ i ] , 38 , 57 ) ;
4513: LD_EXP 28
4517: PUSH
4518: LD_VAR 0 1
4522: ARRAY
4523: PPUSH
4524: LD_INT 38
4526: PPUSH
4527: LD_INT 57
4529: PPUSH
4530: CALL_OW 111
// end ;
4534: GO 4510
4536: POP
4537: POP
// PlaceSeeing ( 54 , 69 , bot_side , 10 ) ;
4538: LD_INT 54
4540: PPUSH
4541: LD_INT 69
4543: PPUSH
4544: LD_EXP 8
4548: PPUSH
4549: LD_INT 10
4551: PPUSH
4552: CALL_OW 330
// end ;
4556: PPOPN 1
4558: END
// every 0 0$03 trigger FilterUnitsInArea ( bridge_protect , [ f_enemy , bot_side ] ) do var i ;
4559: LD_INT 18
4561: PPUSH
4562: LD_INT 81
4564: PUSH
4565: LD_EXP 8
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PPUSH
4574: CALL_OW 70
4578: IFFALSE 4638
4580: GO 4582
4582: DISABLE
4583: LD_INT 0
4585: PPUSH
// begin if not south_force then
4586: LD_EXP 27
4590: NOT
4591: IFFALSE 4595
// exit ;
4593: GO 4638
// for i = 1 to south_force do
4595: LD_ADDR_VAR 0 1
4599: PUSH
4600: DOUBLE
4601: LD_INT 1
4603: DEC
4604: ST_TO_ADDR
4605: LD_EXP 27
4609: PUSH
4610: FOR_TO
4611: IFFALSE 4636
// begin ComMoveXY ( south_force [ i ] , 157 , 140 ) ;
4613: LD_EXP 27
4617: PUSH
4618: LD_VAR 0 1
4622: ARRAY
4623: PPUSH
4624: LD_INT 157
4626: PPUSH
4627: LD_INT 140
4629: PPUSH
4630: CALL_OW 111
// end ;
4634: GO 4610
4636: POP
4637: POP
// end ;
4638: PPOPN 1
4640: END
// every 12 12$00 trigger ar_fac_east and FilterAllUnits ( [ [ f_enemy , bot_side ] , [ f_btype , b_warehouse ] ] ) do var i , tmp , p ;
4641: LD_INT 88
4643: PUSH
4644: LD_INT 81
4646: PUSH
4647: LD_EXP 8
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: PUSH
4656: LD_INT 30
4658: PUSH
4659: LD_INT 1
4661: PUSH
4662: EMPTY
4663: LIST
4664: LIST
4665: PUSH
4666: EMPTY
4667: LIST
4668: LIST
4669: PPUSH
4670: CALL_OW 69
4674: AND
4675: IFFALSE 4911
4677: GO 4679
4679: DISABLE
4680: LD_INT 0
4682: PPUSH
4683: PPUSH
4684: PPUSH
// begin enable ;
4685: ENABLE
// tmp := queue_codes [ rng ] ;
4686: LD_ADDR_VAR 0 2
4690: PUSH
4691: LD_EXP 23
4695: PUSH
4696: LD_EXP 24
4700: ARRAY
4701: ST_TO_ADDR
// p := 1 ;
4702: LD_ADDR_VAR 0 3
4706: PUSH
4707: LD_INT 1
4709: ST_TO_ADDR
// for i = 1 to veh_counter do
4710: LD_ADDR_VAR 0 1
4714: PUSH
4715: DOUBLE
4716: LD_INT 1
4718: DEC
4719: ST_TO_ADDR
4720: LD_EXP 22
4724: PUSH
4725: FOR_TO
4726: IFFALSE 4875
// begin AddComConstruct ( ar_fac_east , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
4728: LD_INT 88
4730: PPUSH
4731: LD_EXP 21
4735: PUSH
4736: LD_VAR 0 2
4740: PUSH
4741: LD_INT 10
4743: MOD
4744: ARRAY
4745: PUSH
4746: LD_INT 1
4748: ARRAY
4749: PPUSH
4750: LD_EXP 21
4754: PUSH
4755: LD_VAR 0 2
4759: PUSH
4760: LD_INT 10
4762: MOD
4763: ARRAY
4764: PUSH
4765: LD_INT 2
4767: ARRAY
4768: PPUSH
4769: LD_EXP 21
4773: PUSH
4774: LD_VAR 0 2
4778: PUSH
4779: LD_INT 10
4781: MOD
4782: ARRAY
4783: PUSH
4784: LD_INT 3
4786: ARRAY
4787: PPUSH
4788: LD_EXP 21
4792: PUSH
4793: LD_VAR 0 2
4797: PUSH
4798: LD_INT 10
4800: MOD
4801: ARRAY
4802: PUSH
4803: LD_INT 4
4805: ARRAY
4806: PPUSH
4807: CALL_OW 185
// tmp := tmp / 10 ;
4811: LD_ADDR_VAR 0 2
4815: PUSH
4816: LD_VAR 0 2
4820: PUSH
4821: LD_INT 10
4823: DIVREAL
4824: ST_TO_ADDR
// p := p + 1 ;
4825: LD_ADDR_VAR 0 3
4829: PUSH
4830: LD_VAR 0 3
4834: PUSH
4835: LD_INT 1
4837: PLUS
4838: ST_TO_ADDR
// if p > 5 then
4839: LD_VAR 0 3
4843: PUSH
4844: LD_INT 5
4846: GREATER
4847: IFFALSE 4873
// begin p := 1 ;
4849: LD_ADDR_VAR 0 3
4853: PUSH
4854: LD_INT 1
4856: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_EXP 23
4866: PUSH
4867: LD_EXP 24
4871: ARRAY
4872: ST_TO_ADDR
// end ; end ;
4873: GO 4725
4875: POP
4876: POP
// rng := rng + 1 ;
4877: LD_ADDR_EXP 24
4881: PUSH
4882: LD_EXP 24
4886: PUSH
4887: LD_INT 1
4889: PLUS
4890: ST_TO_ADDR
// if rng > queue_codes then
4891: LD_EXP 24
4895: PUSH
4896: LD_EXP 23
4900: GREATER
4901: IFFALSE 4911
// rng := 1 ;
4903: LD_ADDR_EXP 24
4907: PUSH
4908: LD_INT 1
4910: ST_TO_ADDR
// end ;
4911: PPOPN 3
4913: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
4914: LD_INT 25
4916: PUSH
4917: LD_INT 17
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: PPUSH
4924: CALL_OW 69
4928: IFFALSE 5031
4930: GO 4932
4932: DISABLE
4933: LD_INT 0
4935: PPUSH
4936: PPUSH
// begin enable ;
4937: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
4938: LD_ADDR_VAR 0 1
4942: PUSH
4943: LD_INT 25
4945: PUSH
4946: LD_INT 17
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PPUSH
4953: CALL_OW 69
4957: PUSH
4958: FOR_IN
4959: IFFALSE 5029
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
4961: LD_ADDR_VAR 0 2
4965: PUSH
4966: LD_INT 81
4968: PUSH
4969: LD_EXP 8
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PPUSH
4978: CALL_OW 69
4982: PPUSH
4983: LD_VAR 0 1
4987: PPUSH
4988: CALL_OW 74
4992: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
4993: LD_VAR 0 1
4997: PPUSH
4998: LD_VAR 0 2
5002: PPUSH
5003: CALL_OW 296
5007: PUSH
5008: LD_INT 15
5010: LESS
5011: IFFALSE 5027
// ComAttackUnit ( i , un ) ;
5013: LD_VAR 0 1
5017: PPUSH
5018: LD_VAR 0 2
5022: PPUSH
5023: CALL_OW 115
// end ;
5027: GO 4958
5029: POP
5030: POP
// end ;
5031: PPOPN 2
5033: END
// every 0 0$01 trigger attackers marked 17 do var i ;
5034: LD_EXP 20
5038: IFFALSE 5132
5040: GO 5042
5042: DISABLE
5043: LD_INT 0
5045: PPUSH
// begin enable ;
5046: ENABLE
// if target = 0 then
5047: LD_EXP 25
5051: PUSH
5052: LD_INT 0
5054: EQUAL
5055: IFFALSE 5079
// target := FilterAllUnits ( [ f_enemy , bot_side ] ) ;
5057: LD_ADDR_EXP 25
5061: PUSH
5062: LD_INT 81
5064: PUSH
5065: LD_EXP 8
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: PPUSH
5074: CALL_OW 69
5078: ST_TO_ADDR
// for i in attackers do
5079: LD_ADDR_VAR 0 1
5083: PUSH
5084: LD_EXP 20
5088: PUSH
5089: FOR_IN
5090: IFFALSE 5130
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , target ] ) , i ) ) ;
5092: LD_VAR 0 1
5096: PPUSH
5097: LD_INT 22
5099: PUSH
5100: LD_EXP 25
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PPUSH
5109: CALL_OW 69
5113: PPUSH
5114: LD_VAR 0 1
5118: PPUSH
5119: CALL_OW 74
5123: PPUSH
5124: CALL_OW 115
5128: GO 5089
5130: POP
5131: POP
// end ;
5132: PPOPN 1
5134: END
// every 0 0$01 trigger not attackers marked 17 do
5135: LD_EXP 20
5139: NOT
5140: IFFALSE 5149
5142: GO 5144
5144: DISABLE
// begin enable ;
5145: ENABLE
// disable ( 17 ) ;
5146: LD_INT 17
5148: DISABLE_MARKED
// end ;
5149: END
// every 3 3$00 trigger veh_counter <= attackers do var max , i ;
5150: LD_EXP 22
5154: PUSH
5155: LD_EXP 20
5159: LESSEQUAL
5160: IFFALSE 5269
5162: GO 5164
5164: DISABLE
5165: LD_INT 0
5167: PPUSH
5168: PPUSH
// begin enable ;
5169: ENABLE
// enable ( 17 ) ;
5170: LD_INT 17
5172: ENABLE_MARKED
// max := 1 ;
5173: LD_ADDR_VAR 0 1
5177: PUSH
5178: LD_INT 1
5180: ST_TO_ADDR
// for i = 1 to 8 do
5181: LD_ADDR_VAR 0 2
5185: PUSH
5186: DOUBLE
5187: LD_INT 1
5189: DEC
5190: ST_TO_ADDR
5191: LD_INT 8
5193: PUSH
5194: FOR_TO
5195: IFFALSE 5267
// if i <> bot_side then
5197: LD_VAR 0 2
5201: PUSH
5202: LD_EXP 8
5206: NONEQUAL
5207: IFFALSE 5265
// begin if max < FilterAllUnits ( [ f_side , i ] ) then
5209: LD_VAR 0 1
5213: PUSH
5214: LD_INT 22
5216: PUSH
5217: LD_VAR 0 2
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PPUSH
5226: CALL_OW 69
5230: LESS
5231: IFFALSE 5265
// begin max := FilterAllUnits ( [ f_side , i ] ) ;
5233: LD_ADDR_VAR 0 1
5237: PUSH
5238: LD_INT 22
5240: PUSH
5241: LD_VAR 0 2
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PPUSH
5250: CALL_OW 69
5254: ST_TO_ADDR
// target := i ;
5255: LD_ADDR_EXP 25
5259: PUSH
5260: LD_VAR 0 2
5264: ST_TO_ADDR
// end ; end ;
5265: GO 5194
5267: POP
5268: POP
// end ;
5269: PPOPN 2
5271: END
// every 0 0$01 trigger game_start and tick >= 20 20$00 do
5272: LD_EXP 9
5276: PUSH
5277: LD_OWVAR 1
5281: PUSH
5282: LD_INT 42000
5284: GREATEREQUAL
5285: AND
5286: IFFALSE 5305
5288: GO 5290
5290: DISABLE
// begin veh_counter := veh_counter + 1 ;
5291: LD_ADDR_EXP 22
5295: PUSH
5296: LD_EXP 22
5300: PUSH
5301: LD_INT 1
5303: PLUS
5304: ST_TO_ADDR
// end ;
5305: END
// every 0 0$01 trigger game_start and tick >= 40 40$00 do
5306: LD_EXP 9
5310: PUSH
5311: LD_OWVAR 1
5315: PUSH
5316: LD_INT 84000
5318: GREATEREQUAL
5319: AND
5320: IFFALSE 5339
5322: GO 5324
5324: DISABLE
// begin veh_counter := veh_counter + 2 ;
5325: LD_ADDR_EXP 22
5329: PUSH
5330: LD_EXP 22
5334: PUSH
5335: LD_INT 2
5337: PLUS
5338: ST_TO_ADDR
// end ;
5339: END
// every 0 0$01 trigger game_start and tick >= 60 60$00 do
5340: LD_EXP 9
5344: PUSH
5345: LD_OWVAR 1
5349: PUSH
5350: LD_INT 126000
5352: GREATEREQUAL
5353: AND
5354: IFFALSE 5373
5356: GO 5358
5358: DISABLE
// begin veh_counter := veh_counter + 3 ;
5359: LD_ADDR_EXP 22
5363: PUSH
5364: LD_EXP 22
5368: PUSH
5369: LD_INT 3
5371: PLUS
5372: ST_TO_ADDR
// end ;
5373: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
5374: LD_INT 22
5376: PUSH
5377: LD_EXP 8
5381: PUSH
5382: EMPTY
5383: LIST
5384: LIST
5385: PUSH
5386: LD_INT 33
5388: PUSH
5389: LD_INT 2
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PPUSH
5400: CALL_OW 69
5404: IFFALSE 5620
5406: GO 5408
5408: DISABLE
5409: LD_INT 0
5411: PPUSH
5412: PPUSH
5413: PPUSH
5414: PPUSH
5415: PPUSH
5416: PPUSH
5417: PPUSH
// begin enable ;
5418: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
5419: LD_ADDR_VAR 0 4
5423: PUSH
5424: LD_INT 22
5426: PUSH
5427: LD_EXP 8
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PUSH
5436: LD_INT 33
5438: PUSH
5439: LD_INT 2
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PUSH
5446: LD_INT 3
5448: PUSH
5449: LD_INT 61
5451: PUSH
5452: EMPTY
5453: LIST
5454: PUSH
5455: EMPTY
5456: LIST
5457: LIST
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: LIST
5463: PPUSH
5464: CALL_OW 69
5468: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
5469: LD_ADDR_VAR 0 3
5473: PUSH
5474: LD_INT 22
5476: PUSH
5477: LD_EXP 8
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PUSH
5486: LD_INT 34
5488: PUSH
5489: LD_INT 31
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: PUSH
5496: EMPTY
5497: LIST
5498: LIST
5499: PPUSH
5500: CALL_OW 69
5504: ST_TO_ADDR
// best := 10 ;
5505: LD_ADDR_VAR 0 5
5509: PUSH
5510: LD_INT 10
5512: ST_TO_ADDR
// best_mechanic := - 1 ;
5513: LD_ADDR_VAR 0 6
5517: PUSH
5518: LD_INT 1
5520: NEG
5521: ST_TO_ADDR
// if vehs then
5522: LD_VAR 0 4
5526: IFFALSE 5620
// begin for j in cts do
5528: LD_ADDR_VAR 0 2
5532: PUSH
5533: LD_VAR 0 3
5537: PUSH
5538: FOR_IN
5539: IFFALSE 5600
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
5541: LD_ADDR_VAR 0 7
5545: PUSH
5546: LD_VAR 0 2
5550: PPUSH
5551: CALL 8241 0 1
5555: PPUSH
5556: CALL_OW 432
5560: ST_TO_ADDR
// if p < best then
5561: LD_VAR 0 7
5565: PUSH
5566: LD_VAR 0 5
5570: LESS
5571: IFFALSE 5598
// begin best := p ;
5573: LD_ADDR_VAR 0 5
5577: PUSH
5578: LD_VAR 0 7
5582: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
5583: LD_ADDR_VAR 0 6
5587: PUSH
5588: LD_VAR 0 2
5592: PPUSH
5593: CALL 8241 0 1
5597: ST_TO_ADDR
// end ; end ;
5598: GO 5538
5600: POP
5601: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
5602: LD_VAR 0 4
5606: PUSH
5607: LD_INT 1
5609: ARRAY
5610: PPUSH
5611: LD_VAR 0 6
5615: PPUSH
5616: CALL_OW 135
// end ; end ;
5620: PPOPN 7
5622: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
5623: GO 5625
5625: DISABLE
5626: LD_INT 0
5628: PPUSH
5629: PPUSH
5630: PPUSH
5631: PPUSH
5632: PPUSH
5633: PPUSH
5634: PPUSH
// begin enable ;
5635: ENABLE
// b := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5636: LD_ADDR_VAR 0 6
5640: PUSH
5641: LD_INT 17
5643: PPUSH
5644: LD_INT 22
5646: PUSH
5647: LD_EXP 8
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 21
5658: PUSH
5659: LD_INT 3
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: LD_INT 3
5668: PUSH
5669: LD_INT 24
5671: PUSH
5672: LD_INT 1000
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: LIST
5687: PPUSH
5688: CALL_OW 70
5692: ST_TO_ADDR
// h := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
5693: LD_ADDR_VAR 0 3
5697: PUSH
5698: LD_INT 17
5700: PPUSH
5701: LD_INT 22
5703: PUSH
5704: LD_EXP 8
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 2
5715: PUSH
5716: LD_INT 25
5718: PUSH
5719: LD_INT 1
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 25
5728: PUSH
5729: LD_INT 2
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: PUSH
5736: LD_INT 25
5738: PUSH
5739: LD_INT 3
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: LIST
5750: LIST
5751: PUSH
5752: LD_INT 3
5754: PUSH
5755: LD_INT 24
5757: PUSH
5758: LD_INT 750
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 70
5778: ST_TO_ADDR
// sci := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ;
5779: LD_ADDR_VAR 0 4
5783: PUSH
5784: LD_INT 17
5786: PPUSH
5787: LD_INT 22
5789: PUSH
5790: LD_EXP 8
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: PUSH
5799: LD_INT 25
5801: PUSH
5802: LD_INT 4
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: PPUSH
5813: CALL_OW 70
5817: ST_TO_ADDR
// eng := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
5818: LD_ADDR_VAR 0 5
5822: PUSH
5823: LD_INT 17
5825: PPUSH
5826: LD_INT 22
5828: PUSH
5829: LD_EXP 8
5833: PUSH
5834: EMPTY
5835: LIST
5836: LIST
5837: PUSH
5838: LD_INT 25
5840: PUSH
5841: LD_INT 2
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL_OW 70
5856: ST_TO_ADDR
// if not h and not b then
5857: LD_VAR 0 3
5861: NOT
5862: PUSH
5863: LD_VAR 0 6
5867: NOT
5868: AND
5869: IFFALSE 6165
// begin if sci then
5871: LD_VAR 0 4
5875: IFFALSE 6018
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
5877: LD_VAR 0 4
5881: PPUSH
5882: LD_INT 3
5884: PUSH
5885: LD_INT 54
5887: PUSH
5888: EMPTY
5889: LIST
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PPUSH
5895: CALL_OW 72
5899: PUSH
5900: LD_INT 17
5902: PPUSH
5903: LD_INT 22
5905: PUSH
5906: LD_EXP 8
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 30
5917: PUSH
5918: LD_INT 8
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: EMPTY
5926: LIST
5927: LIST
5928: PPUSH
5929: CALL_OW 70
5933: AND
5934: IFFALSE 6018
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
5936: LD_ADDR_VAR 0 2
5940: PUSH
5941: LD_VAR 0 4
5945: PPUSH
5946: LD_INT 3
5948: PUSH
5949: LD_INT 54
5951: PUSH
5952: EMPTY
5953: LIST
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: PPUSH
5959: CALL_OW 72
5963: PUSH
5964: FOR_IN
5965: IFFALSE 6016
// ComEnterUnit ( j , FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
5967: LD_VAR 0 2
5971: PPUSH
5972: LD_INT 17
5974: PPUSH
5975: LD_INT 22
5977: PUSH
5978: LD_EXP 8
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PUSH
5987: LD_INT 30
5989: PUSH
5990: LD_INT 8
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: PUSH
5997: EMPTY
5998: LIST
5999: LIST
6000: PPUSH
6001: CALL_OW 70
6005: PUSH
6006: LD_INT 1
6008: ARRAY
6009: PPUSH
6010: CALL_OW 120
6014: GO 5964
6016: POP
6017: POP
// if eng then
6018: LD_VAR 0 5
6022: IFFALSE 6165
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
6024: LD_VAR 0 5
6028: PPUSH
6029: LD_INT 3
6031: PUSH
6032: LD_INT 54
6034: PUSH
6035: EMPTY
6036: LIST
6037: PUSH
6038: EMPTY
6039: LIST
6040: LIST
6041: PPUSH
6042: CALL_OW 72
6046: PUSH
6047: LD_INT 17
6049: PPUSH
6050: LD_INT 22
6052: PUSH
6053: LD_EXP 8
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PUSH
6062: LD_INT 30
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PPUSH
6076: CALL_OW 70
6080: AND
6081: IFFALSE 6165
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
6083: LD_ADDR_VAR 0 2
6087: PUSH
6088: LD_VAR 0 5
6092: PPUSH
6093: LD_INT 3
6095: PUSH
6096: LD_INT 54
6098: PUSH
6099: EMPTY
6100: LIST
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PPUSH
6106: CALL_OW 72
6110: PUSH
6111: FOR_IN
6112: IFFALSE 6163
// ComEnterUnit ( j , FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6114: LD_VAR 0 2
6118: PPUSH
6119: LD_INT 17
6121: PPUSH
6122: LD_INT 22
6124: PUSH
6125: LD_EXP 8
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: PUSH
6134: LD_INT 30
6136: PUSH
6137: LD_INT 1
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 70
6152: PUSH
6153: LD_INT 1
6155: ARRAY
6156: PPUSH
6157: CALL_OW 120
6161: GO 6111
6163: POP
6164: POP
// end ; p := 1 ;
6165: LD_ADDR_VAR 0 7
6169: PUSH
6170: LD_INT 1
6172: ST_TO_ADDR
// if b and eng then
6173: LD_VAR 0 6
6177: PUSH
6178: LD_VAR 0 5
6182: AND
6183: IFFALSE 6317
// for j in eng do
6185: LD_ADDR_VAR 0 2
6189: PUSH
6190: LD_VAR 0 5
6194: PUSH
6195: FOR_IN
6196: IFFALSE 6315
// begin if IsInUnit ( j ) then
6198: LD_VAR 0 2
6202: PPUSH
6203: CALL_OW 310
6207: IFFALSE 6220
// ComExitBuilding ( j ) else
6209: LD_VAR 0 2
6213: PPUSH
6214: CALL_OW 122
6218: GO 6313
// if not HasTask ( j ) and GetLives ( j ) > 750 then
6220: LD_VAR 0 2
6224: PPUSH
6225: CALL_OW 314
6229: NOT
6230: PUSH
6231: LD_VAR 0 2
6235: PPUSH
6236: CALL_OW 256
6240: PUSH
6241: LD_INT 750
6243: GREATER
6244: AND
6245: IFFALSE 6313
// begin if b > p then
6247: LD_VAR 0 6
6251: PUSH
6252: LD_VAR 0 7
6256: GREATER
6257: IFFALSE 6295
// begin ComRepairBuilding ( j , b [ p ] ) ;
6259: LD_VAR 0 2
6263: PPUSH
6264: LD_VAR 0 6
6268: PUSH
6269: LD_VAR 0 7
6273: ARRAY
6274: PPUSH
6275: CALL_OW 130
// p := p + 1 ;
6279: LD_ADDR_VAR 0 7
6283: PUSH
6284: LD_VAR 0 7
6288: PUSH
6289: LD_INT 1
6291: PLUS
6292: ST_TO_ADDR
// end else
6293: GO 6313
// ComRepairBuilding ( j , b [ 1 ] ) ;
6295: LD_VAR 0 2
6299: PPUSH
6300: LD_VAR 0 6
6304: PUSH
6305: LD_INT 1
6307: ARRAY
6308: PPUSH
6309: CALL_OW 130
// end ; end ;
6313: GO 6195
6315: POP
6316: POP
// if h and sci then
6317: LD_VAR 0 3
6321: PUSH
6322: LD_VAR 0 4
6326: AND
6327: IFFALSE 6466
// for i in h do
6329: LD_ADDR_VAR 0 1
6333: PUSH
6334: LD_VAR 0 3
6338: PUSH
6339: FOR_IN
6340: IFFALSE 6464
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
6342: LD_VAR 0 1
6346: PPUSH
6347: LD_INT 108
6349: PPUSH
6350: LD_INT 42
6352: PPUSH
6353: CALL_OW 297
6357: PUSH
6358: LD_INT 10
6360: GREATER
6361: IFFALSE 6380
// ComMoveXY ( i , 108 , 42 ) else
6363: LD_VAR 0 1
6367: PPUSH
6368: LD_INT 108
6370: PPUSH
6371: LD_INT 42
6373: PPUSH
6374: CALL_OW 111
6378: GO 6462
// begin for j in sci do
6380: LD_ADDR_VAR 0 2
6384: PUSH
6385: LD_VAR 0 4
6389: PUSH
6390: FOR_IN
6391: IFFALSE 6460
// begin if GetTag ( j ) > 0 then
6393: LD_VAR 0 2
6397: PPUSH
6398: CALL_OW 110
6402: PUSH
6403: LD_INT 0
6405: GREATER
6406: IFFALSE 6410
// continue ;
6408: GO 6390
// if IsInUnit ( j ) then
6410: LD_VAR 0 2
6414: PPUSH
6415: CALL_OW 310
6419: IFFALSE 6432
// ComExitBuilding ( j ) else
6421: LD_VAR 0 2
6425: PPUSH
6426: CALL_OW 122
6430: GO 6458
// if not HasTask ( j ) then
6432: LD_VAR 0 2
6436: PPUSH
6437: CALL_OW 314
6441: NOT
6442: IFFALSE 6458
// ComHeal ( j , h ) ;
6444: LD_VAR 0 2
6448: PPUSH
6449: LD_VAR 0 3
6453: PPUSH
6454: CALL_OW 128
// end ;
6458: GO 6390
6460: POP
6461: POP
// end ;
6462: GO 6339
6464: POP
6465: POP
// end ;
6466: PPOPN 7
6468: END
// every 0 0$01 trigger mines_list do var i , p ;
6469: LD_EXP 17
6473: IFFALSE 6699
6475: GO 6477
6477: DISABLE
6478: LD_INT 0
6480: PPUSH
6481: PPUSH
// begin enable ;
6482: ENABLE
// p := 1 ;
6483: LD_ADDR_VAR 0 2
6487: PUSH
6488: LD_INT 1
6490: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
6491: LD_ADDR_VAR 0 1
6495: PUSH
6496: DOUBLE
6497: LD_INT 1
6499: DEC
6500: ST_TO_ADDR
6501: LD_EXP 17
6505: PUSH
6506: LD_INT 2
6508: DIVREAL
6509: PUSH
6510: FOR_TO
6511: IFFALSE 6697
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
6513: LD_EXP 17
6517: PUSH
6518: LD_VAR 0 2
6522: ARRAY
6523: PPUSH
6524: LD_EXP 17
6528: PUSH
6529: LD_VAR 0 2
6533: PUSH
6534: LD_INT 1
6536: PLUS
6537: ARRAY
6538: PPUSH
6539: CALL_OW 428
6543: PUSH
6544: LD_INT 0
6546: GREATER
6547: IFFALSE 6681
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
6549: LD_EXP 17
6553: PUSH
6554: LD_VAR 0 2
6558: ARRAY
6559: PPUSH
6560: LD_EXP 17
6564: PUSH
6565: LD_VAR 0 2
6569: PUSH
6570: LD_INT 1
6572: PLUS
6573: ARRAY
6574: PPUSH
6575: CALL_OW 428
6579: PPUSH
6580: CALL_OW 255
6584: PUSH
6585: LD_EXP 8
6589: NONEQUAL
6590: IFFALSE 6681
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
6592: LD_EXP 17
6596: PUSH
6597: LD_VAR 0 2
6601: ARRAY
6602: PPUSH
6603: LD_EXP 17
6607: PUSH
6608: LD_VAR 0 2
6612: PUSH
6613: LD_INT 1
6615: PLUS
6616: ARRAY
6617: PPUSH
6618: LD_EXP 8
6622: PPUSH
6623: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
6627: LD_ADDR_EXP 17
6631: PUSH
6632: LD_EXP 17
6636: PPUSH
6637: LD_VAR 0 2
6641: PPUSH
6642: CALL_OW 3
6646: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
6647: LD_ADDR_EXP 17
6651: PUSH
6652: LD_EXP 17
6656: PPUSH
6657: LD_VAR 0 2
6661: PPUSH
6662: CALL_OW 3
6666: ST_TO_ADDR
// p := p - 2 ;
6667: LD_ADDR_VAR 0 2
6671: PUSH
6672: LD_VAR 0 2
6676: PUSH
6677: LD_INT 2
6679: MINUS
6680: ST_TO_ADDR
// end ; p := p + 2 ;
6681: LD_ADDR_VAR 0 2
6685: PUSH
6686: LD_VAR 0 2
6690: PUSH
6691: LD_INT 2
6693: PLUS
6694: ST_TO_ADDR
// end ;
6695: GO 6510
6697: POP
6698: POP
// end ;
6699: PPOPN 2
6701: END
// every 0 0$03 do var i , p , skr , filter , dep ;
6702: GO 6704
6704: DISABLE
6705: LD_INT 0
6707: PPUSH
6708: PPUSH
6709: PPUSH
6710: PPUSH
6711: PPUSH
// begin enable ;
6712: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) ;
6713: LD_ADDR_VAR 0 4
6717: PUSH
6718: LD_INT 50
6720: PUSH
6721: EMPTY
6722: LIST
6723: PUSH
6724: LD_INT 22
6726: PUSH
6727: LD_EXP 8
6731: PUSH
6732: EMPTY
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 25
6738: PUSH
6739: LD_INT 16
6741: PUSH
6742: EMPTY
6743: LIST
6744: LIST
6745: PUSH
6746: EMPTY
6747: LIST
6748: LIST
6749: LIST
6750: PPUSH
6751: CALL_OW 69
6755: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
6756: LD_ADDR_VAR 0 5
6760: PUSH
6761: LD_INT 22
6763: PUSH
6764: LD_EXP 8
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PUSH
6773: LD_INT 2
6775: PUSH
6776: LD_INT 30
6778: PUSH
6779: LD_INT 0
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: PUSH
6786: LD_INT 30
6788: PUSH
6789: LD_INT 1
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: LIST
6800: PUSH
6801: EMPTY
6802: LIST
6803: LIST
6804: PPUSH
6805: CALL_OW 69
6809: ST_TO_ADDR
// skr := GetListOfCratesInArea ( collect_crates ) ;
6810: LD_ADDR_VAR 0 3
6814: PUSH
6815: LD_INT 15
6817: PPUSH
6818: CALL_OW 435
6822: ST_TO_ADDR
// if filter and skr then
6823: LD_VAR 0 4
6827: PUSH
6828: LD_VAR 0 3
6832: AND
6833: IFFALSE 6890
// for i = 1 to filter do
6835: LD_ADDR_VAR 0 1
6839: PUSH
6840: DOUBLE
6841: LD_INT 1
6843: DEC
6844: ST_TO_ADDR
6845: LD_VAR 0 4
6849: PUSH
6850: FOR_TO
6851: IFFALSE 6888
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
6853: LD_VAR 0 4
6857: PUSH
6858: LD_VAR 0 1
6862: ARRAY
6863: PPUSH
6864: LD_VAR 0 3
6868: PUSH
6869: LD_INT 1
6871: ARRAY
6872: PPUSH
6873: LD_VAR 0 3
6877: PUSH
6878: LD_INT 2
6880: ARRAY
6881: PPUSH
6882: CALL_OW 117
6886: GO 6850
6888: POP
6889: POP
// end ; end_of_file
6890: PPOPN 5
6892: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
6893: LD_INT 0
6895: PPUSH
6896: PPUSH
6897: PPUSH
6898: PPUSH
6899: PPUSH
6900: PPUSH
6901: PPUSH
6902: PPUSH
6903: PPUSH
// to_copy := [ ] ;
6904: LD_ADDR_VAR 0 5
6908: PUSH
6909: EMPTY
6910: ST_TO_ADDR
// for i = 1 to 8 do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: DOUBLE
6917: LD_INT 1
6919: DEC
6920: ST_TO_ADDR
6921: LD_INT 8
6923: PUSH
6924: FOR_TO
6925: IFFALSE 7796
// begin if Side_Positions [ i ] then
6927: LD_EXP 2
6931: PUSH
6932: LD_VAR 0 2
6936: ARRAY
6937: IFFALSE 7794
// begin uc_side := i ;
6939: LD_ADDR_OWVAR 20
6943: PUSH
6944: LD_VAR 0 2
6948: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
6949: LD_ADDR_OWVAR 21
6953: PUSH
6954: LD_EXP 4
6958: PUSH
6959: LD_VAR 0 2
6963: ARRAY
6964: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
6965: LD_ADDR_VAR 0 6
6969: PUSH
6970: LD_EXP 7
6974: PUSH
6975: LD_EXP 2
6979: PUSH
6980: LD_VAR 0 2
6984: ARRAY
6985: ARRAY
6986: PUSH
6987: LD_INT 1
6989: ARRAY
6990: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
6991: LD_ADDR_VAR 0 7
6995: PUSH
6996: LD_EXP 7
7000: PUSH
7001: LD_EXP 2
7005: PUSH
7006: LD_VAR 0 2
7010: ARRAY
7011: ARRAY
7012: PUSH
7013: LD_INT 2
7015: ARRAY
7016: ST_TO_ADDR
// hc_importance := 100 ;
7017: LD_ADDR_OWVAR 32
7021: PUSH
7022: LD_INT 100
7024: ST_TO_ADDR
// if Multiplayer then
7025: LD_OWVAR 4
7029: IFFALSE 7087
// begin hc_name := mp_sides_players_names [ uc_side ] ;
7031: LD_ADDR_OWVAR 26
7035: PUSH
7036: LD_OWVAR 19
7040: PUSH
7041: LD_OWVAR 20
7045: ARRAY
7046: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
7047: LD_ADDR_OWVAR 33
7051: PUSH
7052: LD_STRING MULTIAVATARS
7054: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
7055: LD_ADDR_OWVAR 34
7059: PUSH
7060: LD_OWVAR 20
7064: PPUSH
7065: CALL_OW 525
7069: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
7070: LD_ADDR_OWVAR 27
7074: PUSH
7075: LD_OWVAR 20
7079: PPUSH
7080: CALL_OW 526
7084: ST_TO_ADDR
// end else
7085: GO 7119
// begin hc_name :=  ;
7087: LD_ADDR_OWVAR 26
7091: PUSH
7092: LD_STRING 
7094: ST_TO_ADDR
// hc_gallery :=  ;
7095: LD_ADDR_OWVAR 33
7099: PUSH
7100: LD_STRING 
7102: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
7103: LD_ADDR_OWVAR 27
7107: PUSH
7108: LD_INT 1
7110: PPUSH
7111: LD_INT 2
7113: PPUSH
7114: CALL_OW 12
7118: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
7119: LD_OWVAR 27
7123: PPUSH
7124: LD_INT 1
7126: PPUSH
7127: LD_EXP 11
7131: PPUSH
7132: CALL_OW 380
// un := CreateHuman ;
7136: LD_ADDR_VAR 0 4
7140: PUSH
7141: CALL_OW 44
7145: ST_TO_ADDR
// if not to_copy then
7146: LD_VAR 0 5
7150: NOT
7151: IFFALSE 7178
// to_copy := Replace ( to_copy , 1 , un ) else
7153: LD_ADDR_VAR 0 5
7157: PUSH
7158: LD_VAR 0 5
7162: PPUSH
7163: LD_INT 1
7165: PPUSH
7166: LD_VAR 0 4
7170: PPUSH
7171: CALL_OW 1
7175: ST_TO_ADDR
7176: GO 7254
// begin CopySkills ( to_copy [ 1 ] , un ) ;
7178: LD_VAR 0 5
7182: PUSH
7183: LD_INT 1
7185: ARRAY
7186: PPUSH
7187: LD_VAR 0 4
7191: PPUSH
7192: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
7196: LD_VAR 0 4
7200: PPUSH
7201: LD_INT 2
7203: PPUSH
7204: LD_VAR 0 5
7208: PUSH
7209: LD_INT 1
7211: ARRAY
7212: PPUSH
7213: LD_INT 2
7215: PPUSH
7216: CALL_OW 260
7220: PPUSH
7221: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
7225: LD_VAR 0 4
7229: PPUSH
7230: LD_INT 1
7232: PPUSH
7233: LD_VAR 0 5
7237: PUSH
7238: LD_INT 1
7240: ARRAY
7241: PPUSH
7242: LD_INT 1
7244: PPUSH
7245: CALL_OW 260
7249: PPUSH
7250: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
7254: LD_VAR 0 4
7258: PPUSH
7259: LD_VAR 0 6
7263: PPUSH
7264: LD_VAR 0 7
7268: PPUSH
7269: LD_INT 10
7271: PPUSH
7272: LD_INT 0
7274: PPUSH
7275: CALL_OW 50
// hc_importance := 0 ;
7279: LD_ADDR_OWVAR 32
7283: PUSH
7284: LD_INT 0
7286: ST_TO_ADDR
// hc_name :=  ;
7287: LD_ADDR_OWVAR 26
7291: PUSH
7292: LD_STRING 
7294: ST_TO_ADDR
// hc_gallery :=  ;
7295: LD_ADDR_OWVAR 33
7299: PUSH
7300: LD_STRING 
7302: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
7303: LD_ADDR_VAR 0 9
7307: PUSH
7308: LD_EXP 10
7312: PUSH
7313: LD_INT 1
7315: MINUS
7316: PUSH
7317: LD_INT 4
7319: DIVREAL
7320: ST_TO_ADDR
// c := 1 ;
7321: LD_ADDR_VAR 0 8
7325: PUSH
7326: LD_INT 1
7328: ST_TO_ADDR
// for j = 2 to number_of_people do
7329: LD_ADDR_VAR 0 3
7333: PUSH
7334: DOUBLE
7335: LD_INT 2
7337: DEC
7338: ST_TO_ADDR
7339: LD_EXP 10
7343: PUSH
7344: FOR_TO
7345: IFFALSE 7556
// begin PrepareHuman ( false , c , skill_level ) ;
7347: LD_INT 0
7349: PPUSH
7350: LD_VAR 0 8
7354: PPUSH
7355: LD_EXP 11
7359: PPUSH
7360: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
7364: LD_VAR 0 3
7368: PUSH
7369: LD_INT 1
7371: MINUS
7372: PUSH
7373: LD_VAR 0 9
7377: MOD
7378: PUSH
7379: LD_INT 0
7381: EQUAL
7382: IFFALSE 7398
// c := c + 1 ;
7384: LD_ADDR_VAR 0 8
7388: PUSH
7389: LD_VAR 0 8
7393: PUSH
7394: LD_INT 1
7396: PLUS
7397: ST_TO_ADDR
// un := CreateHuman ;
7398: LD_ADDR_VAR 0 4
7402: PUSH
7403: CALL_OW 44
7407: ST_TO_ADDR
// if to_copy < j then
7408: LD_VAR 0 5
7412: PUSH
7413: LD_VAR 0 3
7417: LESS
7418: IFFALSE 7447
// to_copy := Replace ( to_copy , j , un ) else
7420: LD_ADDR_VAR 0 5
7424: PUSH
7425: LD_VAR 0 5
7429: PPUSH
7430: LD_VAR 0 3
7434: PPUSH
7435: LD_VAR 0 4
7439: PPUSH
7440: CALL_OW 1
7444: ST_TO_ADDR
7445: GO 7529
// begin CopySkills ( to_copy [ j ] , un ) ;
7447: LD_VAR 0 5
7451: PUSH
7452: LD_VAR 0 3
7456: ARRAY
7457: PPUSH
7458: LD_VAR 0 4
7462: PPUSH
7463: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
7467: LD_VAR 0 4
7471: PPUSH
7472: LD_INT 2
7474: PPUSH
7475: LD_VAR 0 5
7479: PUSH
7480: LD_VAR 0 3
7484: ARRAY
7485: PPUSH
7486: LD_INT 2
7488: PPUSH
7489: CALL_OW 260
7493: PPUSH
7494: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
7498: LD_VAR 0 4
7502: PPUSH
7503: LD_INT 1
7505: PPUSH
7506: LD_VAR 0 5
7510: PUSH
7511: LD_VAR 0 3
7515: ARRAY
7516: PPUSH
7517: LD_INT 1
7519: PPUSH
7520: CALL_OW 260
7524: PPUSH
7525: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
7529: LD_VAR 0 4
7533: PPUSH
7534: LD_VAR 0 6
7538: PPUSH
7539: LD_VAR 0 7
7543: PPUSH
7544: LD_INT 10
7546: PPUSH
7547: LD_INT 0
7549: PPUSH
7550: CALL_OW 50
// end ;
7554: GO 7344
7556: POP
7557: POP
// if handicap then
7558: LD_EXP 26
7562: IFFALSE 7794
// begin if handicap = 1 then
7564: LD_EXP 26
7568: PUSH
7569: LD_INT 1
7571: EQUAL
7572: IFFALSE 7631
// begin vc_chassis := us_medium_tracked ;
7574: LD_ADDR_OWVAR 37
7578: PUSH
7579: LD_INT 3
7581: ST_TO_ADDR
// vc_engine := engine_solar ;
7582: LD_ADDR_OWVAR 39
7586: PUSH
7587: LD_INT 2
7589: ST_TO_ADDR
// vc_control := control_computer ;
7590: LD_ADDR_OWVAR 38
7594: PUSH
7595: LD_INT 3
7597: ST_TO_ADDR
// vc_weapon := us_radar ;
7598: LD_ADDR_OWVAR 40
7602: PUSH
7603: LD_INT 11
7605: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
7606: CALL_OW 45
7610: PPUSH
7611: LD_VAR 0 6
7615: PPUSH
7616: LD_VAR 0 7
7620: PPUSH
7621: LD_INT 13
7623: PPUSH
7624: LD_INT 0
7626: PPUSH
7627: CALL_OW 50
// end ; if handicap = 2 then
7631: LD_EXP 26
7635: PUSH
7636: LD_INT 2
7638: EQUAL
7639: IFFALSE 7794
// begin for j = 1 to 2 do
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: DOUBLE
7647: LD_INT 1
7649: DEC
7650: ST_TO_ADDR
7651: LD_INT 2
7653: PUSH
7654: FOR_TO
7655: IFFALSE 7735
// begin vc_chassis := us_medium_tracked ;
7657: LD_ADDR_OWVAR 37
7661: PUSH
7662: LD_INT 3
7664: ST_TO_ADDR
// vc_engine := engine_siberite ;
7665: LD_ADDR_OWVAR 39
7669: PUSH
7670: LD_INT 3
7672: ST_TO_ADDR
// vc_control := control_manual ;
7673: LD_ADDR_OWVAR 38
7677: PUSH
7678: LD_INT 1
7680: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
7681: LD_ADDR_OWVAR 40
7685: PUSH
7686: LD_INT 4
7688: PUSH
7689: LD_INT 5
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: LD_INT 1
7698: PPUSH
7699: LD_INT 2
7701: PPUSH
7702: CALL_OW 12
7706: ARRAY
7707: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
7708: CALL_OW 45
7712: PPUSH
7713: LD_VAR 0 6
7717: PPUSH
7718: LD_VAR 0 7
7722: PPUSH
7723: LD_INT 13
7725: PPUSH
7726: LD_INT 0
7728: PPUSH
7729: CALL_OW 50
// end ;
7733: GO 7654
7735: POP
7736: POP
// vc_chassis := us_medium_tracked ;
7737: LD_ADDR_OWVAR 37
7741: PUSH
7742: LD_INT 3
7744: ST_TO_ADDR
// vc_engine := engine_solar ;
7745: LD_ADDR_OWVAR 39
7749: PUSH
7750: LD_INT 2
7752: ST_TO_ADDR
// vc_control := control_computer ;
7753: LD_ADDR_OWVAR 38
7757: PUSH
7758: LD_INT 3
7760: ST_TO_ADDR
// vc_weapon := us_radar ;
7761: LD_ADDR_OWVAR 40
7765: PUSH
7766: LD_INT 11
7768: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
7769: CALL_OW 45
7773: PPUSH
7774: LD_VAR 0 6
7778: PPUSH
7779: LD_VAR 0 7
7783: PPUSH
7784: LD_INT 13
7786: PPUSH
7787: LD_INT 0
7789: PPUSH
7790: CALL_OW 50
// end ; end ; end ; end ;
7794: GO 6924
7796: POP
7797: POP
// end ;
7798: LD_VAR 0 1
7802: RET
// export function AddApeman ( area ) ; begin
7803: LD_INT 0
7805: PPUSH
// uc_nation := 0 ;
7806: LD_ADDR_OWVAR 21
7810: PUSH
7811: LD_INT 0
7813: ST_TO_ADDR
// uc_side := 0 ;
7814: LD_ADDR_OWVAR 20
7818: PUSH
7819: LD_INT 0
7821: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
7822: LD_ADDR_OWVAR 35
7826: PUSH
7827: LD_INT 10
7829: NEG
7830: PPUSH
7831: LD_INT 15
7833: PPUSH
7834: CALL_OW 12
7838: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
7839: LD_INT 0
7841: PPUSH
7842: LD_INT 12
7844: PPUSH
7845: LD_INT 0
7847: PPUSH
7848: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
7852: LD_ADDR_OWVAR 29
7856: PUSH
7857: LD_INT 10
7859: PUSH
7860: LD_INT 12
7862: PUSH
7863: EMPTY
7864: LIST
7865: LIST
7866: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
7867: CALL_OW 44
7871: PPUSH
7872: LD_VAR 0 1
7876: PPUSH
7877: LD_INT 0
7879: PPUSH
7880: CALL_OW 49
// end ;
7884: LD_VAR 0 2
7888: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
7889: LD_INT 0
7891: PPUSH
7892: PPUSH
7893: PPUSH
7894: PPUSH
// r := 100 ;
7895: LD_ADDR_VAR 0 5
7899: PUSH
7900: LD_INT 100
7902: ST_TO_ADDR
// x := 0 ;
7903: LD_ADDR_VAR 0 6
7907: PUSH
7908: LD_INT 0
7910: ST_TO_ADDR
// while ( x < n ) do
7911: LD_VAR 0 6
7915: PUSH
7916: LD_VAR 0 2
7920: LESS
7921: IFFALSE 8236
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
7923: LD_ADDR_VAR 0 4
7927: PUSH
7928: DOUBLE
7929: LD_INT 1
7931: DEC
7932: ST_TO_ADDR
7933: LD_VAR 0 1
7937: PPUSH
7938: LD_INT 0
7940: PPUSH
7941: CALL_OW 517
7945: PUSH
7946: LD_INT 1
7948: ARRAY
7949: PUSH
7950: FOR_TO
7951: IFFALSE 8232
// begin if r > 50 then
7953: LD_VAR 0 5
7957: PUSH
7958: LD_INT 50
7960: GREATER
7961: IFFALSE 8208
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
7963: LD_VAR 0 1
7967: PPUSH
7968: LD_INT 0
7970: PPUSH
7971: CALL_OW 517
7975: PUSH
7976: LD_INT 1
7978: ARRAY
7979: PUSH
7980: LD_VAR 0 4
7984: ARRAY
7985: PPUSH
7986: LD_VAR 0 1
7990: PPUSH
7991: LD_INT 0
7993: PPUSH
7994: CALL_OW 517
7998: PUSH
7999: LD_INT 2
8001: ARRAY
8002: PUSH
8003: LD_VAR 0 4
8007: ARRAY
8008: PPUSH
8009: CALL_OW 458
8013: NOT
8014: IFFALSE 8192
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
8016: LD_VAR 0 1
8020: PPUSH
8021: LD_INT 0
8023: PPUSH
8024: CALL_OW 517
8028: PUSH
8029: LD_INT 1
8031: ARRAY
8032: PUSH
8033: LD_VAR 0 4
8037: ARRAY
8038: PPUSH
8039: LD_VAR 0 1
8043: PPUSH
8044: LD_INT 0
8046: PPUSH
8047: CALL_OW 517
8051: PUSH
8052: LD_INT 2
8054: ARRAY
8055: PUSH
8056: LD_VAR 0 4
8060: ARRAY
8061: PPUSH
8062: LD_EXP 8
8066: PPUSH
8067: LD_INT 0
8069: PPUSH
8070: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
8074: LD_ADDR_EXP 17
8078: PUSH
8079: LD_EXP 17
8083: PPUSH
8084: LD_EXP 17
8088: PUSH
8089: LD_INT 1
8091: PLUS
8092: PPUSH
8093: LD_VAR 0 1
8097: PPUSH
8098: LD_INT 0
8100: PPUSH
8101: CALL_OW 517
8105: PUSH
8106: LD_INT 1
8108: ARRAY
8109: PUSH
8110: LD_VAR 0 4
8114: ARRAY
8115: PPUSH
8116: CALL_OW 2
8120: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
8121: LD_ADDR_EXP 17
8125: PUSH
8126: LD_EXP 17
8130: PPUSH
8131: LD_EXP 17
8135: PUSH
8136: LD_INT 1
8138: PLUS
8139: PPUSH
8140: LD_VAR 0 1
8144: PPUSH
8145: LD_INT 0
8147: PPUSH
8148: CALL_OW 517
8152: PUSH
8153: LD_INT 2
8155: ARRAY
8156: PUSH
8157: LD_VAR 0 4
8161: ARRAY
8162: PPUSH
8163: CALL_OW 2
8167: ST_TO_ADDR
// r := 0 ;
8168: LD_ADDR_VAR 0 5
8172: PUSH
8173: LD_INT 0
8175: ST_TO_ADDR
// x := x + 1 ;
8176: LD_ADDR_VAR 0 6
8180: PUSH
8181: LD_VAR 0 6
8185: PUSH
8186: LD_INT 1
8188: PLUS
8189: ST_TO_ADDR
// end else
8190: GO 8206
// r := r + 35 ;
8192: LD_ADDR_VAR 0 5
8196: PUSH
8197: LD_VAR 0 5
8201: PUSH
8202: LD_INT 35
8204: PLUS
8205: ST_TO_ADDR
// end else
8206: GO 8230
// r := r + rand ( 10 , 25 ) ;
8208: LD_ADDR_VAR 0 5
8212: PUSH
8213: LD_VAR 0 5
8217: PUSH
8218: LD_INT 10
8220: PPUSH
8221: LD_INT 25
8223: PPUSH
8224: CALL_OW 12
8228: PLUS
8229: ST_TO_ADDR
// end ;
8230: GO 7950
8232: POP
8233: POP
8234: GO 7911
// end ;
8236: LD_VAR 0 3
8240: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
8241: LD_INT 0
8243: PPUSH
8244: PPUSH
8245: PPUSH
// if not GetControl ( veh ) = control_manual then
8246: LD_VAR 0 1
8250: PPUSH
8251: CALL_OW 263
8255: PUSH
8256: LD_INT 1
8258: EQUAL
8259: NOT
8260: IFFALSE 8272
// result := false else
8262: LD_ADDR_VAR 0 2
8266: PUSH
8267: LD_INT 0
8269: ST_TO_ADDR
8270: GO 8417
// if veh in FilterAllUnits ( [ f_empty ] ) then
8272: LD_VAR 0 1
8276: PUSH
8277: LD_INT 58
8279: PUSH
8280: EMPTY
8281: LIST
8282: PPUSH
8283: CALL_OW 69
8287: IN
8288: IFFALSE 8300
// result := false else
8290: LD_ADDR_VAR 0 2
8294: PUSH
8295: LD_INT 0
8297: ST_TO_ADDR
8298: GO 8417
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
8300: LD_ADDR_VAR 0 4
8304: PUSH
8305: LD_INT 22
8307: PUSH
8308: LD_VAR 0 1
8312: PPUSH
8313: CALL_OW 255
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 55
8324: PUSH
8325: EMPTY
8326: LIST
8327: PUSH
8328: EMPTY
8329: LIST
8330: LIST
8331: PPUSH
8332: CALL_OW 69
8336: ST_TO_ADDR
// if not filter then
8337: LD_VAR 0 4
8341: NOT
8342: IFFALSE 8354
// result := false else
8344: LD_ADDR_VAR 0 2
8348: PUSH
8349: LD_INT 0
8351: ST_TO_ADDR
8352: GO 8417
// for i = 1 to filter do
8354: LD_ADDR_VAR 0 3
8358: PUSH
8359: DOUBLE
8360: LD_INT 1
8362: DEC
8363: ST_TO_ADDR
8364: LD_VAR 0 4
8368: PUSH
8369: FOR_TO
8370: IFFALSE 8415
// if IsDriver ( filter [ i ] ) = veh then
8372: LD_VAR 0 4
8376: PUSH
8377: LD_VAR 0 3
8381: ARRAY
8382: PPUSH
8383: CALL 8422 0 1
8387: PUSH
8388: LD_VAR 0 1
8392: EQUAL
8393: IFFALSE 8413
// begin result := filter [ i ] ;
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 4
8404: PUSH
8405: LD_VAR 0 3
8409: ARRAY
8410: ST_TO_ADDR
// break ;
8411: GO 8415
// end ;
8413: GO 8369
8415: POP
8416: POP
// end ; end ;
8417: LD_VAR 0 2
8421: RET
// export function IsDriver ( unit ) ; begin
8422: LD_INT 0
8424: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
8425: LD_VAR 0 1
8429: PUSH
8430: LD_INT 55
8432: PUSH
8433: EMPTY
8434: LIST
8435: PPUSH
8436: CALL_OW 69
8440: IN
8441: IFFALSE 8460
// result := IsInUnit ( unit ) else
8443: LD_ADDR_VAR 0 2
8447: PUSH
8448: LD_VAR 0 1
8452: PPUSH
8453: CALL_OW 310
8457: ST_TO_ADDR
8458: GO 8468
// result := false ;
8460: LD_ADDR_VAR 0 2
8464: PUSH
8465: LD_INT 0
8467: ST_TO_ADDR
// end ;
8468: LD_VAR 0 2
8472: RET
