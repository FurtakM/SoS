// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 3066 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , rforce , rforce2 , att_counter ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// rforce := [ ] ;
 124: LD_ADDR_EXP 27
 128: PUSH
 129: EMPTY
 130: ST_TO_ADDR
// rforce2 := [ ] ;
 131: LD_ADDR_EXP 28
 135: PUSH
 136: EMPTY
 137: ST_TO_ADDR
// if Multiplayer then
 138: LD_OWVAR 4
 142: IFFALSE 264
// begin Game_Type := mp_game_type ;
 144: LD_ADDR_EXP 1
 148: PUSH
 149: LD_OWVAR 6
 153: ST_TO_ADDR
// Your_Side := mp_player_side ;
 154: LD_ADDR_OWVAR 2
 158: PUSH
 159: LD_OWVAR 7
 163: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 164: LD_ADDR_EXP 2
 168: PUSH
 169: LD_OWVAR 17
 173: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 174: LD_ADDR_EXP 3
 178: PUSH
 179: LD_OWVAR 15
 183: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 184: LD_ADDR_EXP 4
 188: PUSH
 189: LD_OWVAR 16
 193: ST_TO_ADDR
// Teams := mp_teams ;
 194: LD_ADDR_EXP 5
 198: PUSH
 199: LD_OWVAR 12
 203: ST_TO_ADDR
// for i = 0 to 6 do
 204: LD_ADDR_VAR 0 2
 208: PUSH
 209: DOUBLE
 210: LD_INT 0
 212: DEC
 213: ST_TO_ADDR
 214: LD_INT 6
 216: PUSH
 217: FOR_TO
 218: IFFALSE 260
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 220: LD_ADDR_EXP 16
 224: PUSH
 225: LD_EXP 16
 229: PPUSH
 230: LD_EXP 16
 234: PUSH
 235: LD_INT 1
 237: PLUS
 238: PPUSH
 239: LD_VAR 0 2
 243: PPUSH
 244: CALL_OW 426
 248: PUSH
 249: LD_INT 1
 251: PLUS
 252: PPUSH
 253: CALL_OW 2
 257: ST_TO_ADDR
 258: GO 217
 260: POP
 261: POP
// end else
 262: GO 415
// begin Game_Type := 1 ;
 264: LD_ADDR_EXP 1
 268: PUSH
 269: LD_INT 1
 271: ST_TO_ADDR
// Your_Side := 1 ;
 272: LD_ADDR_OWVAR 2
 276: PUSH
 277: LD_INT 1
 279: ST_TO_ADDR
// Side_Positions := [ 1 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] ;
 280: LD_ADDR_EXP 2
 284: PUSH
 285: LD_INT 1
 287: PUSH
 288: LD_INT 0
 290: PUSH
 291: LD_INT 0
 293: PUSH
 294: LD_INT 2
 296: PUSH
 297: LD_INT 0
 299: PUSH
 300: LD_INT 0
 302: PUSH
 303: LD_INT 0
 305: PUSH
 306: LD_INT 0
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: LIST
 316: LIST
 317: LIST
 318: ST_TO_ADDR
// Side_Teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] ;
 319: LD_ADDR_EXP 3
 323: PUSH
 324: LD_INT 1
 326: PUSH
 327: LD_INT 0
 329: PUSH
 330: LD_INT 0
 332: PUSH
 333: LD_INT 1
 335: PUSH
 336: LD_INT 0
 338: PUSH
 339: LD_INT 0
 341: PUSH
 342: LD_INT 0
 344: PUSH
 345: LD_INT 0
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: ST_TO_ADDR
// Side_Nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] ;
 358: LD_ADDR_EXP 4
 362: PUSH
 363: LD_INT 1
 365: PUSH
 366: LD_INT 0
 368: PUSH
 369: LD_INT 0
 371: PUSH
 372: LD_INT 1
 374: PUSH
 375: LD_INT 0
 377: PUSH
 378: LD_INT 0
 380: PUSH
 381: LD_INT 0
 383: PUSH
 384: LD_INT 0
 386: PUSH
 387: EMPTY
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: ST_TO_ADDR
// Teams := [ [ 1 , 4 ] ] ;
 397: LD_ADDR_EXP 5
 401: PUSH
 402: LD_INT 1
 404: PUSH
 405: LD_INT 4
 407: PUSH
 408: EMPTY
 409: LIST
 410: LIST
 411: PUSH
 412: EMPTY
 413: LIST
 414: ST_TO_ADDR
// end ; Side_Start := [ [ 83 , 148 ] , [ 187 , 144 ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 415: LD_ADDR_EXP 7
 419: PUSH
 420: LD_INT 83
 422: PUSH
 423: LD_INT 148
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 187
 432: PUSH
 433: LD_INT 144
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: PUSH
 440: EMPTY
 441: PUSH
 442: EMPTY
 443: PUSH
 444: EMPTY
 445: PUSH
 446: EMPTY
 447: PUSH
 448: EMPTY
 449: PUSH
 450: EMPTY
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: ST_TO_ADDR
// Bot_Side := 2 ;
 462: LD_ADDR_EXP 8
 466: PUSH
 467: LD_INT 2
 469: ST_TO_ADDR
// for i = 1 to 8 do
 470: LD_ADDR_VAR 0 2
 474: PUSH
 475: DOUBLE
 476: LD_INT 1
 478: DEC
 479: ST_TO_ADDR
 480: LD_INT 8
 482: PUSH
 483: FOR_TO
 484: IFFALSE 616
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
 486: LD_VAR 0 2
 490: PPUSH
 491: CALL_OW 530
 495: IFFALSE 569
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 497: LD_ADDR_EXP 2
 501: PUSH
 502: LD_EXP 2
 506: PPUSH
 507: LD_VAR 0 2
 511: PPUSH
 512: LD_INT 0
 514: PPUSH
 515: CALL_OW 1
 519: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 520: LD_ADDR_EXP 5
 524: PUSH
 525: LD_EXP 5
 529: PPUSH
 530: LD_EXP 3
 534: PUSH
 535: LD_VAR 0 2
 539: ARRAY
 540: PPUSH
 541: LD_EXP 5
 545: PUSH
 546: LD_EXP 3
 550: PUSH
 551: LD_VAR 0 2
 555: ARRAY
 556: ARRAY
 557: PUSH
 558: LD_VAR 0 2
 562: DIFF
 563: PPUSH
 564: CALL_OW 1
 568: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 1 then
 569: LD_EXP 4
 573: PUSH
 574: LD_VAR 0 2
 578: ARRAY
 579: PUSH
 580: LD_EXP 4
 584: PUSH
 585: LD_INT 1
 587: NONEQUAL
 588: AND
 589: IFFALSE 614
// Side_Nations := Replace ( Side_Nations , i , 1 ) ;
 591: LD_ADDR_EXP 4
 595: PUSH
 596: LD_EXP 4
 600: PPUSH
 601: LD_VAR 0 2
 605: PPUSH
 606: LD_INT 1
 608: PPUSH
 609: CALL_OW 1
 613: ST_TO_ADDR
// end ;
 614: GO 483
 616: POP
 617: POP
// if 2 = bot_side and Side_Positions [ 2 ] then
 618: LD_INT 2
 620: PUSH
 621: LD_EXP 8
 625: EQUAL
 626: PUSH
 627: LD_EXP 2
 631: PUSH
 632: LD_INT 2
 634: ARRAY
 635: AND
 636: IFFALSE 646
// bot_side := 5 ;
 638: LD_ADDR_EXP 8
 642: PUSH
 643: LD_INT 5
 645: ST_TO_ADDR
// if 5 = bot_side and Side_Positions [ 5 ] then
 646: LD_INT 5
 648: PUSH
 649: LD_EXP 8
 653: EQUAL
 654: PUSH
 655: LD_EXP 2
 659: PUSH
 660: LD_INT 5
 662: ARRAY
 663: AND
 664: IFFALSE 674
// bot_side := 8 ;
 666: LD_ADDR_EXP 8
 670: PUSH
 671: LD_INT 8
 673: ST_TO_ADDR
// Team_Game := false ;
 674: LD_ADDR_EXP 6
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// for i = 1 to 8 do
 682: LD_ADDR_VAR 0 2
 686: PUSH
 687: DOUBLE
 688: LD_INT 1
 690: DEC
 691: ST_TO_ADDR
 692: LD_INT 8
 694: PUSH
 695: FOR_TO
 696: IFFALSE 722
// if Side_Teams [ i ] then
 698: LD_EXP 3
 702: PUSH
 703: LD_VAR 0 2
 707: ARRAY
 708: IFFALSE 720
// begin Team_Game := true ;
 710: LD_ADDR_EXP 6
 714: PUSH
 715: LD_INT 1
 717: ST_TO_ADDR
// break ;
 718: GO 722
// end ;
 720: GO 695
 722: POP
 723: POP
// for i in Teams do
 724: LD_ADDR_VAR 0 2
 728: PUSH
 729: LD_EXP 5
 733: PUSH
 734: FOR_IN
 735: IFFALSE 815
// for j = 2 to i do
 737: LD_ADDR_VAR 0 3
 741: PUSH
 742: DOUBLE
 743: LD_INT 2
 745: DEC
 746: ST_TO_ADDR
 747: LD_VAR 0 2
 751: PUSH
 752: FOR_TO
 753: IFFALSE 811
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
 755: LD_VAR 0 2
 759: PUSH
 760: LD_VAR 0 3
 764: ARRAY
 765: PPUSH
 766: LD_VAR 0 2
 770: PUSH
 771: LD_INT 1
 773: ARRAY
 774: PPUSH
 775: CALL_OW 343
// SetAttitude ( i [ j ] , i [ 1 ] , att_friend , true ) ;
 779: LD_VAR 0 2
 783: PUSH
 784: LD_VAR 0 3
 788: ARRAY
 789: PPUSH
 790: LD_VAR 0 2
 794: PUSH
 795: LD_INT 1
 797: ARRAY
 798: PPUSH
 799: LD_INT 1
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 80
// end ;
 809: GO 752
 811: POP
 812: POP
 813: GO 734
 815: POP
 816: POP
// if not Multiplayer then
 817: LD_OWVAR 4
 821: NOT
 822: IFFALSE 859
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 824: LD_ADDR_EXP 16
 828: PUSH
 829: LD_INT 1
 831: PUSH
 832: LD_INT 1
 834: PUSH
 835: LD_INT 1
 837: PUSH
 838: LD_INT 1
 840: PUSH
 841: LD_INT 2
 843: PUSH
 844: LD_INT 3
 846: PUSH
 847: LD_INT 3
 849: PUSH
 850: EMPTY
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: ST_TO_ADDR
// number_of_people := [ 5 , 9 , 12 , 15 ] [ definitions [ 1 ] ] ;
 859: LD_ADDR_EXP 10
 863: PUSH
 864: LD_INT 5
 866: PUSH
 867: LD_INT 9
 869: PUSH
 870: LD_INT 12
 872: PUSH
 873: LD_INT 15
 875: PUSH
 876: EMPTY
 877: LIST
 878: LIST
 879: LIST
 880: LIST
 881: PUSH
 882: LD_EXP 16
 886: PUSH
 887: LD_INT 1
 889: ARRAY
 890: ARRAY
 891: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 892: LD_ADDR_EXP 11
 896: PUSH
 897: LD_INT 2
 899: PUSH
 900: LD_INT 4
 902: PUSH
 903: LD_INT 6
 905: PUSH
 906: LD_INT 8
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: PUSH
 915: LD_EXP 16
 919: PUSH
 920: LD_INT 2
 922: ARRAY
 923: ARRAY
 924: ST_TO_ADDR
// crates_spawn := [ 1 1$10 , 0 0$55 , 0 0$41 , 0 0$31 ] [ definitions [ 3 ] ] ;
 925: LD_ADDR_EXP 12
 929: PUSH
 930: LD_INT 2450
 932: PUSH
 933: LD_INT 1925
 935: PUSH
 936: LD_INT 1435
 938: PUSH
 939: LD_INT 1085
 941: PUSH
 942: EMPTY
 943: LIST
 944: LIST
 945: LIST
 946: LIST
 947: PUSH
 948: LD_EXP 16
 952: PUSH
 953: LD_INT 3
 955: ARRAY
 956: ARRAY
 957: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 ] [ 1 ] ;
 958: LD_ADDR_EXP 13
 962: PUSH
 963: LD_INT 0
 965: PUSH
 966: EMPTY
 967: LIST
 968: PUSH
 969: LD_INT 1
 971: ARRAY
 972: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 ] [ 1 ] ;
 973: LD_ADDR_EXP 14
 977: PUSH
 978: LD_INT 0
 980: PUSH
 981: EMPTY
 982: LIST
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 4 ] ] ;
 988: LD_ADDR_EXP 15
 992: PUSH
 993: LD_INT 0
 995: PUSH
 996: LD_INT 3
 998: PUSH
 999: LD_INT 5
1001: PUSH
1002: LD_INT 7
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: PUSH
1011: LD_EXP 16
1015: PUSH
1016: LD_INT 4
1018: ARRAY
1019: ARRAY
1020: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 5 ] ] ;
1021: LD_ADDR_OWVAR 67
1025: PUSH
1026: LD_INT 1
1028: PUSH
1029: LD_INT 2
1031: PUSH
1032: LD_INT 3
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_EXP 16
1044: PUSH
1045: LD_INT 5
1047: ARRAY
1048: ARRAY
1049: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 6 ] ] ;
1050: LD_ADDR_EXP 26
1054: PUSH
1055: LD_INT 0
1057: PUSH
1058: LD_INT 1
1060: PUSH
1061: LD_INT 2
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: LIST
1068: PUSH
1069: LD_EXP 16
1073: PUSH
1074: LD_INT 6
1076: ARRAY
1077: ARRAY
1078: ST_TO_ADDR
// queue_codes := [ 77474 , 11353 , 12644 , 44646 , 12345 , 43477 , 14652 , 23441 ] ;
1079: LD_ADDR_EXP 23
1083: PUSH
1084: LD_INT 77474
1086: PUSH
1087: LD_INT 11353
1089: PUSH
1090: LD_INT 12644
1092: PUSH
1093: LD_INT 44646
1095: PUSH
1096: LD_INT 12345
1098: PUSH
1099: LD_INT 43477
1101: PUSH
1102: LD_INT 14652
1104: PUSH
1105: LD_INT 23441
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: ST_TO_ADDR
// rng := Rand ( 1 , 8 ) ;
1118: LD_ADDR_EXP 24
1122: PUSH
1123: LD_INT 1
1125: PPUSH
1126: LD_INT 8
1128: PPUSH
1129: CALL_OW 12
1133: ST_TO_ADDR
// if bot_side <> 2 then
1134: LD_EXP 8
1138: PUSH
1139: LD_INT 2
1141: NONEQUAL
1142: IFFALSE 1185
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1144: LD_ADDR_VAR 0 2
1148: PUSH
1149: LD_INT 22
1151: PUSH
1152: LD_INT 2
1154: PUSH
1155: EMPTY
1156: LIST
1157: LIST
1158: PPUSH
1159: CALL_OW 69
1163: PUSH
1164: FOR_IN
1165: IFFALSE 1183
// SetSide ( i , bot_side ) ;
1167: LD_VAR 0 2
1171: PPUSH
1172: LD_EXP 8
1176: PPUSH
1177: CALL_OW 235
1181: GO 1164
1183: POP
1184: POP
// ResetFog ;
1185: CALL_OW 335
// PreparePeople ( ) ;
1189: CALL 9264 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1193: LD_ADDR_EXP 18
1197: PUSH
1198: LD_INT 4
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 6
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// if amount_of_apeman then
1212: LD_EXP 15
1216: IFFALSE 1266
// for j in apeman_areas do
1218: LD_ADDR_VAR 0 3
1222: PUSH
1223: LD_EXP 18
1227: PUSH
1228: FOR_IN
1229: IFFALSE 1264
// for i = 1 to amount_of_apeman do
1231: LD_ADDR_VAR 0 2
1235: PUSH
1236: DOUBLE
1237: LD_INT 1
1239: DEC
1240: ST_TO_ADDR
1241: LD_EXP 15
1245: PUSH
1246: FOR_TO
1247: IFFALSE 1260
// AddApeman ( j ) ;
1249: LD_VAR 0 3
1253: PPUSH
1254: CALL 10502 0 1
1258: GO 1246
1260: POP
1261: POP
1262: GO 1228
1264: POP
1265: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1266: LD_INT 22
1268: PUSH
1269: LD_OWVAR 2
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: PPUSH
1278: CALL_OW 69
1282: PUSH
1283: LD_INT 1
1285: ARRAY
1286: PPUSH
1287: CALL_OW 87
// disable ( 17 ) ;
1291: LD_INT 17
1293: DISABLE_MARKED
// end ;
1294: LD_VAR 0 1
1298: RET
// every 0 0$03 trigger GetSide ( ar_base_sout ) <> bot_side or IsDead ( ar_base_sout ) do var i ;
1299: LD_INT 5
1301: PPUSH
1302: CALL_OW 255
1306: PUSH
1307: LD_EXP 8
1311: NONEQUAL
1312: PUSH
1313: LD_INT 5
1315: PPUSH
1316: CALL_OW 301
1320: OR
1321: IFFALSE 1456
1323: GO 1325
1325: DISABLE
1326: LD_INT 0
1328: PPUSH
// begin for i = 1 to rforce do
1329: LD_ADDR_VAR 0 1
1333: PUSH
1334: DOUBLE
1335: LD_INT 1
1337: DEC
1338: ST_TO_ADDR
1339: LD_EXP 27
1343: PUSH
1344: FOR_TO
1345: IFFALSE 1454
// begin PlaceUnitXYR ( rforce [ i ] [ 1 ] , rforce [ i ] [ 2 ] , rforce [ i ] [ 3 ] , 6 , false ) ;
1347: LD_EXP 27
1351: PUSH
1352: LD_VAR 0 1
1356: ARRAY
1357: PUSH
1358: LD_INT 1
1360: ARRAY
1361: PPUSH
1362: LD_EXP 27
1366: PUSH
1367: LD_VAR 0 1
1371: ARRAY
1372: PUSH
1373: LD_INT 2
1375: ARRAY
1376: PPUSH
1377: LD_EXP 27
1381: PUSH
1382: LD_VAR 0 1
1386: ARRAY
1387: PUSH
1388: LD_INT 3
1390: ARRAY
1391: PPUSH
1392: LD_INT 6
1394: PPUSH
1395: LD_INT 0
1397: PPUSH
1398: CALL_OW 50
// if GetWeapon ( rforce [ i ] [ 1 ] ) = us_cargo_bay then
1402: LD_EXP 27
1406: PUSH
1407: LD_VAR 0 1
1411: ARRAY
1412: PUSH
1413: LD_INT 1
1415: ARRAY
1416: PPUSH
1417: CALL_OW 264
1421: PUSH
1422: LD_INT 12
1424: EQUAL
1425: IFFALSE 1452
// SetCargo ( rforce [ i ] [ 1 ] , mat_cans , 100 ) ;
1427: LD_EXP 27
1431: PUSH
1432: LD_VAR 0 1
1436: ARRAY
1437: PUSH
1438: LD_INT 1
1440: ARRAY
1441: PPUSH
1442: LD_INT 1
1444: PPUSH
1445: LD_INT 100
1447: PPUSH
1448: CALL_OW 290
// end ;
1452: GO 1344
1454: POP
1455: POP
// end ;
1456: PPOPN 1
1458: END
// every 0 0$03 trigger ( GetSide ( ar_base_sout ) <> bot_side or IsDead ( ar_base_sout ) ) and tick > 42000 do var i ;
1459: LD_INT 5
1461: PPUSH
1462: CALL_OW 255
1466: PUSH
1467: LD_EXP 8
1471: NONEQUAL
1472: PUSH
1473: LD_INT 5
1475: PPUSH
1476: CALL_OW 301
1480: OR
1481: PUSH
1482: LD_OWVAR 1
1486: PUSH
1487: LD_INT 42000
1489: GREATER
1490: AND
1491: IFFALSE 1576
1493: GO 1495
1495: DISABLE
1496: LD_INT 0
1498: PPUSH
// begin for i = 1 to rforce2 do
1499: LD_ADDR_VAR 0 1
1503: PUSH
1504: DOUBLE
1505: LD_INT 1
1507: DEC
1508: ST_TO_ADDR
1509: LD_EXP 28
1513: PUSH
1514: FOR_TO
1515: IFFALSE 1574
// begin PlaceUnitXYR ( rforce2 [ i ] [ 1 ] , rforce2 [ i ] [ 2 ] , rforce2 [ i ] [ 3 ] , 6 , false ) ;
1517: LD_EXP 28
1521: PUSH
1522: LD_VAR 0 1
1526: ARRAY
1527: PUSH
1528: LD_INT 1
1530: ARRAY
1531: PPUSH
1532: LD_EXP 28
1536: PUSH
1537: LD_VAR 0 1
1541: ARRAY
1542: PUSH
1543: LD_INT 2
1545: ARRAY
1546: PPUSH
1547: LD_EXP 28
1551: PUSH
1552: LD_VAR 0 1
1556: ARRAY
1557: PUSH
1558: LD_INT 3
1560: ARRAY
1561: PPUSH
1562: LD_INT 6
1564: PPUSH
1565: LD_INT 0
1567: PPUSH
1568: CALL_OW 50
// end ;
1572: GO 1514
1574: POP
1575: POP
// end ;
1576: PPOPN 1
1578: END
// every 0 0$01 + 0 0$30 trigger game_start do var cr , cr_queue ;
1579: LD_EXP 9
1583: IFFALSE 2235
1585: GO 1587
1587: DISABLE
1588: LD_INT 0
1590: PPUSH
1591: PPUSH
// begin cr := 1 ;
1592: LD_ADDR_VAR 0 1
1596: PUSH
1597: LD_INT 1
1599: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1600: LD_ADDR_VAR 0 2
1604: PUSH
1605: LD_INT 1
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: CALL_OW 12
1615: PUSH
1616: LD_INT 2
1618: PPUSH
1619: LD_INT 4
1621: PPUSH
1622: CALL_OW 12
1626: PUSH
1627: LD_INT 3
1629: PPUSH
1630: LD_INT 5
1632: PPUSH
1633: CALL_OW 12
1637: PUSH
1638: LD_INT 3
1640: PPUSH
1641: LD_INT 5
1643: PPUSH
1644: CALL_OW 12
1648: PUSH
1649: LD_INT 2
1651: PPUSH
1652: LD_INT 5
1654: PPUSH
1655: CALL_OW 12
1659: PUSH
1660: LD_INT 1
1662: PPUSH
1663: LD_INT 5
1665: PPUSH
1666: CALL_OW 12
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: ST_TO_ADDR
// while ( true ) do
1679: LD_INT 1
1681: IFFALSE 2235
// begin Wait ( crates_spawn + ( tick mod 35 * 60 ) ) ;
1683: LD_EXP 12
1687: PUSH
1688: LD_OWVAR 1
1692: PUSH
1693: LD_INT 35
1695: MOD
1696: PUSH
1697: LD_INT 60
1699: MUL
1700: PLUS
1701: PPUSH
1702: CALL_OW 67
// if cr mod 3 = 0 then
1706: LD_VAR 0 1
1710: PUSH
1711: LD_INT 3
1713: MOD
1714: PUSH
1715: LD_INT 0
1717: EQUAL
1718: IFFALSE 1871
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1720: LD_VAR 0 2
1724: PUSH
1725: LD_VAR 0 1
1729: PUSH
1730: LD_VAR 0 2
1734: MOD
1735: PUSH
1736: LD_INT 1
1738: PLUS
1739: ARRAY
1740: PPUSH
1741: LD_INT 1
1743: PPUSH
1744: LD_INT 1
1746: PPUSH
1747: CALL_OW 55
// Wait ( crates_spawn ) ;
1751: LD_EXP 12
1755: PPUSH
1756: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1760: LD_VAR 0 2
1764: PUSH
1765: LD_VAR 0 1
1769: PUSH
1770: LD_VAR 0 2
1774: MOD
1775: PUSH
1776: LD_INT 1
1778: PLUS
1779: ARRAY
1780: PPUSH
1781: LD_INT 2
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: CALL_OW 55
// Wait ( crates_spawn ) ;
1791: LD_EXP 12
1795: PPUSH
1796: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1800: LD_VAR 0 2
1804: PUSH
1805: LD_VAR 0 1
1809: PUSH
1810: LD_VAR 0 2
1814: MOD
1815: PUSH
1816: LD_INT 1
1818: PLUS
1819: ARRAY
1820: PPUSH
1821: LD_INT 3
1823: PPUSH
1824: LD_INT 1
1826: PPUSH
1827: CALL_OW 55
// Wait ( crates_spawn ) ;
1831: LD_EXP 12
1835: PPUSH
1836: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1840: LD_VAR 0 2
1844: PUSH
1845: LD_VAR 0 1
1849: PUSH
1850: LD_VAR 0 2
1854: MOD
1855: PUSH
1856: LD_INT 1
1858: PLUS
1859: ARRAY
1860: PPUSH
1861: LD_INT 1
1863: PPUSH
1864: LD_INT 1
1866: PPUSH
1867: CALL_OW 55
// end ; if cr mod 3 = 1 then
1871: LD_VAR 0 1
1875: PUSH
1876: LD_INT 3
1878: MOD
1879: PUSH
1880: LD_INT 1
1882: EQUAL
1883: IFFALSE 2036
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1885: LD_VAR 0 2
1889: PUSH
1890: LD_VAR 0 1
1894: PUSH
1895: LD_VAR 0 2
1899: MOD
1900: PUSH
1901: LD_INT 1
1903: PLUS
1904: ARRAY
1905: PPUSH
1906: LD_INT 2
1908: PPUSH
1909: LD_INT 1
1911: PPUSH
1912: CALL_OW 55
// Wait ( crates_spawn ) ;
1916: LD_EXP 12
1920: PPUSH
1921: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1925: LD_VAR 0 2
1929: PUSH
1930: LD_VAR 0 1
1934: PUSH
1935: LD_VAR 0 2
1939: MOD
1940: PUSH
1941: LD_INT 1
1943: PLUS
1944: ARRAY
1945: PPUSH
1946: LD_INT 1
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: CALL_OW 55
// Wait ( crates_spawn ) ;
1956: LD_EXP 12
1960: PPUSH
1961: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1965: LD_VAR 0 2
1969: PUSH
1970: LD_VAR 0 1
1974: PUSH
1975: LD_VAR 0 2
1979: MOD
1980: PUSH
1981: LD_INT 1
1983: PLUS
1984: ARRAY
1985: PPUSH
1986: LD_INT 3
1988: PPUSH
1989: LD_INT 1
1991: PPUSH
1992: CALL_OW 55
// Wait ( crates_spawn ) ;
1996: LD_EXP 12
2000: PPUSH
2001: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
2005: LD_VAR 0 2
2009: PUSH
2010: LD_VAR 0 1
2014: PUSH
2015: LD_VAR 0 2
2019: MOD
2020: PUSH
2021: LD_INT 1
2023: PLUS
2024: ARRAY
2025: PPUSH
2026: LD_INT 2
2028: PPUSH
2029: LD_INT 1
2031: PPUSH
2032: CALL_OW 55
// end ; if cr mod 3 = 2 then
2036: LD_VAR 0 1
2040: PUSH
2041: LD_INT 3
2043: MOD
2044: PUSH
2045: LD_INT 2
2047: EQUAL
2048: IFFALSE 2201
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
2050: LD_VAR 0 2
2054: PUSH
2055: LD_VAR 0 1
2059: PUSH
2060: LD_VAR 0 2
2064: MOD
2065: PUSH
2066: LD_INT 1
2068: PLUS
2069: ARRAY
2070: PPUSH
2071: LD_INT 3
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: CALL_OW 55
// Wait ( crates_spawn ) ;
2081: LD_EXP 12
2085: PPUSH
2086: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
2090: LD_VAR 0 2
2094: PUSH
2095: LD_VAR 0 1
2099: PUSH
2100: LD_VAR 0 2
2104: MOD
2105: PUSH
2106: LD_INT 1
2108: PLUS
2109: ARRAY
2110: PPUSH
2111: LD_INT 2
2113: PPUSH
2114: LD_INT 1
2116: PPUSH
2117: CALL_OW 55
// Wait ( crates_spawn ) ;
2121: LD_EXP 12
2125: PPUSH
2126: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
2130: LD_VAR 0 2
2134: PUSH
2135: LD_VAR 0 1
2139: PUSH
2140: LD_VAR 0 2
2144: MOD
2145: PUSH
2146: LD_INT 1
2148: PLUS
2149: ARRAY
2150: PPUSH
2151: LD_INT 1
2153: PPUSH
2154: LD_INT 1
2156: PPUSH
2157: CALL_OW 55
// Wait ( crates_spawn ) ;
2161: LD_EXP 12
2165: PPUSH
2166: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
2170: LD_VAR 0 2
2174: PUSH
2175: LD_VAR 0 1
2179: PUSH
2180: LD_VAR 0 2
2184: MOD
2185: PUSH
2186: LD_INT 1
2188: PLUS
2189: ARRAY
2190: PPUSH
2191: LD_INT 3
2193: PPUSH
2194: LD_INT 1
2196: PPUSH
2197: CALL_OW 55
// end ; cr := cr + 1 ;
2201: LD_ADDR_VAR 0 1
2205: PUSH
2206: LD_VAR 0 1
2210: PUSH
2211: LD_INT 1
2213: PLUS
2214: ST_TO_ADDR
// if cr > 110 then
2215: LD_VAR 0 1
2219: PUSH
2220: LD_INT 110
2222: GREATER
2223: IFFALSE 2233
// cr := 43 ;
2225: LD_ADDR_VAR 0 1
2229: PUSH
2230: LD_INT 43
2232: ST_TO_ADDR
// end ;
2233: GO 1679
// end ; end_of_file
2235: PPOPN 2
2237: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
2238: LD_INT 0
2240: PPUSH
2241: PPUSH
2242: PPUSH
2243: PPUSH
// begin if un in FilterAllUnits ( [ f_weapon , 91 ] ) then
2244: LD_VAR 0 1
2248: PUSH
2249: LD_INT 34
2251: PUSH
2252: LD_INT 91
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PPUSH
2259: CALL_OW 69
2263: IN
2264: IFFALSE 2293
// begin ArtContamination ( GetX ( un ) , GetY ( un ) , 10 ) ;
2266: LD_VAR 0 1
2270: PPUSH
2271: CALL_OW 250
2275: PPUSH
2276: LD_VAR 0 1
2280: PPUSH
2281: CALL_OW 251
2285: PPUSH
2286: LD_INT 10
2288: PPUSH
2289: CALL_OW 495
// end ; if un in attackers then
2293: LD_VAR 0 1
2297: PUSH
2298: LD_EXP 20
2302: IN
2303: IFFALSE 2321
// attackers := attackers diff un ;
2305: LD_ADDR_EXP 20
2309: PUSH
2310: LD_EXP 20
2314: PUSH
2315: LD_VAR 0 1
2319: DIFF
2320: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
2321: LD_VAR 0 1
2325: PPUSH
2326: CALL_OW 255
2330: PUSH
2331: LD_EXP 8
2335: NONEQUAL
2336: PUSH
2337: LD_VAR 0 1
2341: PPUSH
2342: CALL_OW 255
2346: PUSH
2347: LD_INT 0
2349: GREATER
2350: AND
2351: PUSH
2352: LD_VAR 0 1
2356: PUSH
2357: LD_INT 21
2359: PUSH
2360: LD_INT 1
2362: PUSH
2363: EMPTY
2364: LIST
2365: LIST
2366: PPUSH
2367: CALL_OW 69
2371: IN
2372: AND
2373: IFFALSE 2551
// begin if respawning_time_min > 0 0$00 then
2375: LD_EXP 13
2379: PUSH
2380: LD_INT 0
2382: GREATER
2383: IFFALSE 2551
// begin s := GetSide ( un ) ;
2385: LD_ADDR_VAR 0 4
2389: PUSH
2390: LD_VAR 0 1
2394: PPUSH
2395: CALL_OW 255
2399: ST_TO_ADDR
// n := GetNation ( un ) ;
2400: LD_ADDR_VAR 0 5
2404: PUSH
2405: LD_VAR 0 1
2409: PPUSH
2410: CALL_OW 248
2414: ST_TO_ADDR
// cl := GetClass ( un ) ;
2415: LD_ADDR_VAR 0 3
2419: PUSH
2420: LD_VAR 0 1
2424: PPUSH
2425: CALL_OW 257
2429: ST_TO_ADDR
// wait ( respawning_time_min ) ;
2430: LD_EXP 13
2434: PPUSH
2435: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) ) ;
2439: LD_EXP 14
2443: PUSH
2444: LD_INT 350
2446: PUSH
2447: LD_OWVAR 1
2451: MUL
2452: PUSH
2453: LD_INT 10
2455: MOD
2456: PUSH
2457: LD_INT 1
2459: PLUS
2460: MINUS
2461: PPUSH
2462: CALL_OW 67
// uc_side := s ;
2466: LD_ADDR_OWVAR 20
2470: PUSH
2471: LD_VAR 0 4
2475: ST_TO_ADDR
// uc_nation := n ;
2476: LD_ADDR_OWVAR 21
2480: PUSH
2481: LD_VAR 0 5
2485: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
2486: LD_INT 0
2488: PPUSH
2489: LD_VAR 0 3
2493: PPUSH
2494: LD_EXP 11
2498: PUSH
2499: LD_INT 2
2501: MINUS
2502: PPUSH
2503: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
2507: CALL_OW 44
2511: PPUSH
2512: LD_INT 1
2514: PUSH
2515: LD_INT 3
2517: PUSH
2518: LD_INT 2
2520: PUSH
2521: LD_INT 3
2523: PUSH
2524: EMPTY
2525: LIST
2526: LIST
2527: LIST
2528: LIST
2529: PUSH
2530: LD_VAR 0 3
2534: PUSH
2535: LD_INT 4
2537: MOD
2538: PUSH
2539: LD_INT 1
2541: PLUS
2542: ARRAY
2543: PPUSH
2544: LD_INT 1
2546: PPUSH
2547: CALL_OW 49
// end ; end ; end ;
2551: PPOPN 5
2553: END
// on UnitGoesToRed ( un ) do var tmp , i ;
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) and GetLives ( ar_lab_main ) > 500 then
2558: LD_VAR 0 1
2562: PUSH
2563: LD_INT 22
2565: PUSH
2566: LD_EXP 8
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 30
2577: PUSH
2578: LD_INT 8
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PPUSH
2589: CALL_OW 69
2593: IN
2594: PUSH
2595: LD_INT 82
2597: PPUSH
2598: CALL_OW 256
2602: PUSH
2603: LD_INT 500
2605: GREATER
2606: AND
2607: IFFALSE 2688
// begin Wait ( 0 0$02 ) ;
2609: LD_INT 70
2611: PPUSH
2612: CALL_OW 67
// for i in FilterAllUnits ( [ [ [ f_side , bot_side ] , [ f_class , 4 ] , [ f_not , [ f_inside ] ] ] ] ) do
2616: LD_ADDR_VAR 0 3
2620: PUSH
2621: LD_INT 22
2623: PUSH
2624: LD_EXP 8
2628: PUSH
2629: EMPTY
2630: LIST
2631: LIST
2632: PUSH
2633: LD_INT 25
2635: PUSH
2636: LD_INT 4
2638: PUSH
2639: EMPTY
2640: LIST
2641: LIST
2642: PUSH
2643: LD_INT 3
2645: PUSH
2646: LD_INT 54
2648: PUSH
2649: EMPTY
2650: LIST
2651: PUSH
2652: EMPTY
2653: LIST
2654: LIST
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: LIST
2660: PUSH
2661: EMPTY
2662: LIST
2663: PPUSH
2664: CALL_OW 69
2668: PUSH
2669: FOR_IN
2670: IFFALSE 2686
// ComEnterUnit ( i , ar_lab_main ) ;
2672: LD_VAR 0 3
2676: PPUSH
2677: LD_INT 82
2679: PPUSH
2680: CALL_OW 120
2684: GO 2669
2686: POP
2687: POP
// end ; if GetSide ( un ) = bot_side and un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_type , unit_vehicle ] ] ) then
2688: LD_VAR 0 1
2692: PPUSH
2693: CALL_OW 255
2697: PUSH
2698: LD_EXP 8
2702: EQUAL
2703: PUSH
2704: LD_VAR 0 1
2708: PUSH
2709: LD_INT 33
2711: PUSH
2712: LD_INT 2
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: PUSH
2719: LD_INT 21
2721: PUSH
2722: LD_INT 2
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: IN
2738: AND
2739: IFFALSE 2862
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> bot_side then
2741: LD_OWVAR 3
2745: PUSH
2746: LD_VAR 0 1
2750: DIFF
2751: PPUSH
2752: LD_VAR 0 1
2756: PPUSH
2757: CALL_OW 74
2761: PPUSH
2762: CALL_OW 255
2766: PUSH
2767: LD_EXP 8
2771: NONEQUAL
2772: IFFALSE 2862
// begin Wait ( 0 0$1.3 ) ;
2774: LD_INT 46
2776: PPUSH
2777: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
2781: LD_VAR 0 1
2785: PPUSH
2786: CALL_OW 250
2790: PPUSH
2791: LD_VAR 0 1
2795: PPUSH
2796: CALL_OW 251
2800: PPUSH
2801: LD_INT 1
2803: PPUSH
2804: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
2808: LD_VAR 0 1
2812: PPUSH
2813: CALL_OW 250
2817: PPUSH
2818: LD_VAR 0 1
2822: PPUSH
2823: CALL_OW 251
2827: PPUSH
2828: LD_INT 1
2830: PPUSH
2831: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
2835: LD_VAR 0 1
2839: PPUSH
2840: CALL_OW 250
2844: PPUSH
2845: LD_VAR 0 1
2849: PPUSH
2850: CALL_OW 251
2854: PPUSH
2855: LD_INT 1
2857: PPUSH
2858: CALL_OW 453
// end ; if GetControl ( un ) = control_remote then
2862: LD_VAR 0 1
2866: PPUSH
2867: CALL_OW 263
2871: PUSH
2872: LD_INT 2
2874: EQUAL
2875: IFFALSE 2886
// ComUnlink ( un ) ;
2877: LD_VAR 0 1
2881: PPUSH
2882: CALL_OW 136
// end ;
2886: PPOPN 3
2888: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
2889: LD_VAR 0 1
2893: PPUSH
2894: CALL_OW 255
2898: PUSH
2899: LD_EXP 8
2903: EQUAL
2904: IFFALSE 2935
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
2906: LD_ADDR_EXP 20
2910: PUSH
2911: LD_EXP 20
2915: PPUSH
2916: LD_EXP 20
2920: PUSH
2921: LD_INT 1
2923: PLUS
2924: PPUSH
2925: LD_VAR 0 1
2929: PPUSH
2930: CALL_OW 2
2934: ST_TO_ADDR
// end ;
2935: PPOPN 2
2937: END
// on LeaveBuilding ( b , un ) do var i , arm , tmp ;
2938: LD_INT 0
2940: PPUSH
2941: PPUSH
2942: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
2943: LD_VAR 0 1
2947: PPUSH
2948: CALL_OW 255
2952: PUSH
2953: LD_EXP 8
2957: EQUAL
2958: PUSH
2959: LD_VAR 0 1
2963: PPUSH
2964: CALL_OW 266
2968: PUSH
2969: LD_INT 32
2971: EQUAL
2972: AND
2973: IFFALSE 3063
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
2975: LD_ADDR_VAR 0 4
2979: PUSH
2980: LD_INT 22
2982: PUSH
2983: LD_EXP 8
2987: PUSH
2988: EMPTY
2989: LIST
2990: LIST
2991: PUSH
2992: LD_INT 30
2994: PUSH
2995: LD_INT 5
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: PPUSH
3006: CALL_OW 69
3010: ST_TO_ADDR
// tmp := NearestUnitToUnit ( arm , un ) ;
3011: LD_ADDR_VAR 0 5
3015: PUSH
3016: LD_VAR 0 4
3020: PPUSH
3021: LD_VAR 0 2
3025: PPUSH
3026: CALL_OW 74
3030: ST_TO_ADDR
// if tmp then
3031: LD_VAR 0 5
3035: IFFALSE 3063
// begin ComEnterUnit ( un , tmp ) ;
3037: LD_VAR 0 2
3041: PPUSH
3042: LD_VAR 0 5
3046: PPUSH
3047: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
3051: LD_VAR 0 2
3055: PPUSH
3056: LD_INT 8
3058: PPUSH
3059: CALL_OW 183
// end ; end ; end ; end_of_file
3063: PPOPN 5
3065: END
// export south_force , north_force , east_force , river_guard , apek , ar_collectors , sup_attack ; export function InitBot ; var i , j , ct , hex , side , un , veh , weapons , skill ; begin
3066: LD_INT 0
3068: PPUSH
3069: PPUSH
3070: PPUSH
3071: PPUSH
3072: PPUSH
3073: PPUSH
3074: PPUSH
3075: PPUSH
3076: PPUSH
3077: PPUSH
// side := Bot_Side ;
3078: LD_ADDR_VAR 0 6
3082: PUSH
3083: LD_EXP 8
3087: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
3088: LD_ADDR_VAR 0 10
3092: PUSH
3093: LD_INT 4
3095: PUSH
3096: LD_INT 6
3098: PUSH
3099: LD_INT 8
3101: PUSH
3102: EMPTY
3103: LIST
3104: LIST
3105: LIST
3106: PUSH
3107: LD_OWVAR 67
3111: ARRAY
3112: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
3113: LD_ADDR_VAR 0 9
3117: PUSH
3118: LD_INT 27
3120: PUSH
3121: LD_INT 28
3123: PUSH
3124: LD_INT 25
3126: PUSH
3127: LD_INT 26
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: LIST
3135: ST_TO_ADDR
// veh_counter := [ 6 , 7 , 8 ] [ Difficulty ] ;
3136: LD_ADDR_EXP 22
3140: PUSH
3141: LD_INT 6
3143: PUSH
3144: LD_INT 7
3146: PUSH
3147: LD_INT 8
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: LIST
3154: PUSH
3155: LD_OWVAR 67
3159: ARRAY
3160: ST_TO_ADDR
// ct := [ ] ;
3161: LD_ADDR_VAR 0 4
3165: PUSH
3166: EMPTY
3167: ST_TO_ADDR
// patrols := [ ] ;
3168: LD_ADDR_EXP 19
3172: PUSH
3173: EMPTY
3174: ST_TO_ADDR
// attackers := [ ] ;
3175: LD_ADDR_EXP 20
3179: PUSH
3180: EMPTY
3181: ST_TO_ADDR
// river_guard := [ ] ;
3182: LD_ADDR_EXP 33
3186: PUSH
3187: EMPTY
3188: ST_TO_ADDR
// apek := [ ] ;
3189: LD_ADDR_EXP 34
3193: PUSH
3194: EMPTY
3195: ST_TO_ADDR
// ar_collectors := [ ] ;
3196: LD_ADDR_EXP 35
3200: PUSH
3201: EMPTY
3202: ST_TO_ADDR
// sup_attack := [ ] ;
3203: LD_ADDR_EXP 36
3207: PUSH
3208: EMPTY
3209: ST_TO_ADDR
// att_counter := 0 ;
3210: LD_ADDR_EXP 29
3214: PUSH
3215: LD_INT 0
3217: ST_TO_ADDR
// south_force := Defcon ( [ 3 , 3 , 4 ] [ Difficulty ] , 118 , 130 , false ) ;
3218: LD_ADDR_EXP 30
3222: PUSH
3223: LD_INT 3
3225: PUSH
3226: LD_INT 3
3228: PUSH
3229: LD_INT 4
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: PUSH
3237: LD_OWVAR 67
3241: ARRAY
3242: PPUSH
3243: LD_INT 118
3245: PPUSH
3246: LD_INT 130
3248: PPUSH
3249: LD_INT 0
3251: PPUSH
3252: CALL 5845 0 4
3256: ST_TO_ADDR
// north_force := Defcon ( [ 4 , 5 , 6 ] [ Difficulty ] , 21 , 16 , false ) ;
3257: LD_ADDR_EXP 31
3261: PUSH
3262: LD_INT 4
3264: PUSH
3265: LD_INT 5
3267: PUSH
3268: LD_INT 6
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: PUSH
3276: LD_OWVAR 67
3280: ARRAY
3281: PPUSH
3282: LD_INT 21
3284: PPUSH
3285: LD_INT 16
3287: PPUSH
3288: LD_INT 0
3290: PPUSH
3291: CALL 5845 0 4
3295: ST_TO_ADDR
// east_force := Defcon ( [ 4 , 5 , 5 ] [ Difficulty ] , 111 , 21 , true ) ;
3296: LD_ADDR_EXP 32
3300: PUSH
3301: LD_INT 4
3303: PUSH
3304: LD_INT 5
3306: PUSH
3307: LD_INT 5
3309: PUSH
3310: EMPTY
3311: LIST
3312: LIST
3313: LIST
3314: PUSH
3315: LD_OWVAR 67
3319: ARRAY
3320: PPUSH
3321: LD_INT 111
3323: PPUSH
3324: LD_INT 21
3326: PPUSH
3327: LD_INT 1
3329: PPUSH
3330: CALL 5845 0 4
3334: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , 91 ] , [ ar_hovercraft , engine_combustion , control_remote , ar_light_gun ] ] ;
3335: LD_ADDR_EXP 21
3339: PUSH
3340: LD_INT 14
3342: PUSH
3343: LD_INT 1
3345: PUSH
3346: LD_INT 2
3348: PUSH
3349: LD_INT 27
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: LIST
3356: LIST
3357: PUSH
3358: LD_INT 14
3360: PUSH
3361: LD_INT 1
3363: PUSH
3364: LD_INT 2
3366: PUSH
3367: LD_INT 25
3369: PUSH
3370: EMPTY
3371: LIST
3372: LIST
3373: LIST
3374: LIST
3375: PUSH
3376: LD_INT 14
3378: PUSH
3379: LD_INT 1
3381: PUSH
3382: LD_INT 2
3384: PUSH
3385: LD_INT 28
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: PUSH
3394: LD_INT 14
3396: PUSH
3397: LD_INT 1
3399: PUSH
3400: LD_INT 2
3402: PUSH
3403: LD_INT 29
3405: PUSH
3406: EMPTY
3407: LIST
3408: LIST
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 14
3414: PUSH
3415: LD_INT 1
3417: PUSH
3418: LD_INT 2
3420: PUSH
3421: LD_INT 27
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: PUSH
3430: LD_INT 14
3432: PUSH
3433: LD_INT 1
3435: PUSH
3436: LD_INT 2
3438: PUSH
3439: LD_INT 91
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: PUSH
3448: LD_INT 11
3450: PUSH
3451: LD_INT 1
3453: PUSH
3454: LD_INT 2
3456: PUSH
3457: LD_INT 23
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: LIST
3464: LIST
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: LIST
3474: ST_TO_ADDR
// SetResourceType ( GetBase ( ar_base_east ) , mat_cans , 90000 ) ;
3475: LD_INT 81
3477: PPUSH
3478: CALL_OW 274
3482: PPUSH
3483: LD_INT 1
3485: PPUSH
3486: LD_INT 90000
3488: PPUSH
3489: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_oil , 9000 ) ;
3493: LD_INT 81
3495: PPUSH
3496: CALL_OW 274
3500: PPUSH
3501: LD_INT 2
3503: PPUSH
3504: LD_INT 9000
3506: PPUSH
3507: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_east ) , mat_siberit , 3000 ) ;
3511: LD_INT 81
3513: PPUSH
3514: CALL_OW 274
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 3000
3524: PPUSH
3525: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_nort ) , mat_cans , 90000 ) ;
3529: LD_INT 55
3531: PPUSH
3532: CALL_OW 274
3536: PPUSH
3537: LD_INT 1
3539: PPUSH
3540: LD_INT 90000
3542: PPUSH
3543: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_nort ) , mat_oil , 9000 ) ;
3547: LD_INT 55
3549: PPUSH
3550: CALL_OW 274
3554: PPUSH
3555: LD_INT 2
3557: PPUSH
3558: LD_INT 9000
3560: PPUSH
3561: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_nort ) , mat_siberit , 1000 ) ;
3565: LD_INT 55
3567: PPUSH
3568: CALL_OW 274
3572: PPUSH
3573: LD_INT 3
3575: PPUSH
3576: LD_INT 1000
3578: PPUSH
3579: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_sout ) , mat_cans , [ 2000 , 1500 , 1000 ] [ Difficulty ] ) ;
3583: LD_INT 5
3585: PPUSH
3586: CALL_OW 274
3590: PPUSH
3591: LD_INT 1
3593: PPUSH
3594: LD_INT 2000
3596: PUSH
3597: LD_INT 1500
3599: PUSH
3600: LD_INT 1000
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: LIST
3607: PUSH
3608: LD_OWVAR 67
3612: ARRAY
3613: PPUSH
3614: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_sout ) , mat_oil , 1000 ) ;
3618: LD_INT 5
3620: PPUSH
3621: CALL_OW 274
3625: PPUSH
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 1000
3631: PPUSH
3632: CALL_OW 277
// SetResourceType ( GetBase ( ar_base_sout ) , mat_siberit , 100 ) ;
3636: LD_INT 5
3638: PPUSH
3639: CALL_OW 274
3643: PPUSH
3644: LD_INT 3
3646: PPUSH
3647: LD_INT 100
3649: PPUSH
3650: CALL_OW 277
// if Difficulty > 1 then
3654: LD_OWVAR 67
3658: PUSH
3659: LD_INT 1
3661: GREATER
3662: IFFALSE 3679
// SetTech ( 5 , side , state_researched ) ;
3664: LD_INT 5
3666: PPUSH
3667: LD_VAR 0 6
3671: PPUSH
3672: LD_INT 2
3674: PPUSH
3675: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
3679: LD_INT 51
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 2
3689: PPUSH
3690: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
3694: LD_INT 52
3696: PPUSH
3697: LD_VAR 0 6
3701: PPUSH
3702: LD_INT 2
3704: PPUSH
3705: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
3709: LD_INT 53
3711: PPUSH
3712: LD_VAR 0 6
3716: PPUSH
3717: LD_INT 2
3719: PPUSH
3720: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
3724: LD_INT 60
3726: PPUSH
3727: LD_VAR 0 6
3731: PPUSH
3732: LD_INT 2
3734: PPUSH
3735: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
3739: LD_INT 61
3741: PPUSH
3742: LD_VAR 0 6
3746: PPUSH
3747: LD_INT 2
3749: PPUSH
3750: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
3754: LD_INT 62
3756: PPUSH
3757: LD_VAR 0 6
3761: PPUSH
3762: LD_INT 2
3764: PPUSH
3765: CALL_OW 322
// SetTech ( tech_bio1 , side , state_researched ) ;
3769: LD_INT 66
3771: PPUSH
3772: LD_VAR 0 6
3776: PPUSH
3777: LD_INT 2
3779: PPUSH
3780: CALL_OW 322
// if Difficulty > 1 then
3784: LD_OWVAR 67
3788: PUSH
3789: LD_INT 1
3791: GREATER
3792: IFFALSE 3809
// SetTech ( tech_bio2 , side , state_researched ) ;
3794: LD_INT 67
3796: PPUSH
3797: LD_VAR 0 6
3801: PPUSH
3802: LD_INT 2
3804: PPUSH
3805: CALL_OW 322
// if Difficulty > 2 then
3809: LD_OWVAR 67
3813: PUSH
3814: LD_INT 2
3816: GREATER
3817: IFFALSE 3834
// SetTech ( tech_bio3 , side , state_researched ) ;
3819: LD_INT 68
3821: PPUSH
3822: LD_VAR 0 6
3826: PPUSH
3827: LD_INT 2
3829: PPUSH
3830: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
3834: LD_ADDR_VAR 0 2
3838: PUSH
3839: LD_INT 22
3841: PUSH
3842: LD_VAR 0 6
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 21
3853: PUSH
3854: LD_INT 3
3856: PUSH
3857: EMPTY
3858: LIST
3859: LIST
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: PPUSH
3865: CALL_OW 69
3869: PUSH
3870: FOR_IN
3871: IFFALSE 3904
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
3873: LD_VAR 0 2
3877: PPUSH
3878: LD_INT 6
3880: PUSH
3881: LD_INT 8
3883: PUSH
3884: LD_INT 10
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: LIST
3891: PUSH
3892: LD_OWVAR 67
3896: ARRAY
3897: PPUSH
3898: CALL_OW 241
3902: GO 3870
3904: POP
3905: POP
// PlaceMines ( mine_west_zone , [ 5 , 7 , 9 ] [ Difficulty ] ) ;
3906: LD_INT 7
3908: PPUSH
3909: LD_INT 5
3911: PUSH
3912: LD_INT 7
3914: PUSH
3915: LD_INT 9
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: LIST
3922: PUSH
3923: LD_OWVAR 67
3927: ARRAY
3928: PPUSH
3929: CALL 10588 0 2
// PlaceMines ( mine_east_zone , [ 20 , 25 , 30 ] [ Difficulty ] ) ;
3933: LD_INT 9
3935: PPUSH
3936: LD_INT 20
3938: PUSH
3939: LD_INT 25
3941: PUSH
3942: LD_INT 30
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: LIST
3949: PUSH
3950: LD_OWVAR 67
3954: ARRAY
3955: PPUSH
3956: CALL 10588 0 2
// PlaceMines ( mine_center_zone , [ 6 , 8 , 9 ] [ Difficulty ] ) ;
3960: LD_INT 8
3962: PPUSH
3963: LD_INT 6
3965: PUSH
3966: LD_INT 8
3968: PUSH
3969: LD_INT 9
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_OWVAR 67
3981: ARRAY
3982: PPUSH
3983: CALL 10588 0 2
// PlaceMines ( mine_pass_zone , [ 4 , 6 , 9 ] [ Difficulty ] ) ;
3987: LD_INT 10
3989: PPUSH
3990: LD_INT 4
3992: PUSH
3993: LD_INT 6
3995: PUSH
3996: LD_INT 9
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: PUSH
4004: LD_OWVAR 67
4008: ARRAY
4009: PPUSH
4010: CALL 10588 0 2
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
4014: LD_INT 11
4016: PPUSH
4017: LD_INT 2
4019: PUSH
4020: LD_INT 5
4022: PUSH
4023: LD_INT 8
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: LIST
4030: PUSH
4031: LD_OWVAR 67
4035: ARRAY
4036: PPUSH
4037: CALL 10588 0 2
// PlaceMines ( mine_southpass_zone , [ 2 , 4 , 6 ] [ Difficulty ] ) ;
4041: LD_INT 12
4043: PPUSH
4044: LD_INT 2
4046: PUSH
4047: LD_INT 4
4049: PUSH
4050: LD_INT 6
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: PUSH
4058: LD_OWVAR 67
4062: ARRAY
4063: PPUSH
4064: CALL 10588 0 2
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
4068: LD_ADDR_VAR 0 2
4072: PUSH
4073: DOUBLE
4074: LD_INT 1
4076: DEC
4077: ST_TO_ADDR
4078: LD_INT 8
4080: PUSH
4081: LD_INT 11
4083: PUSH
4084: LD_INT 14
4086: PUSH
4087: EMPTY
4088: LIST
4089: LIST
4090: LIST
4091: PUSH
4092: LD_OWVAR 67
4096: ARRAY
4097: PUSH
4098: FOR_TO
4099: IFFALSE 4274
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
4101: LD_ADDR_VAR 0 5
4105: PUSH
4106: LD_INT 134
4108: PPUSH
4109: LD_INT 73
4111: PPUSH
4112: LD_INT 10
4114: PPUSH
4115: LD_INT 0
4117: PPUSH
4118: CALL_OW 17
4122: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
4123: LD_VAR 0 5
4127: PUSH
4128: LD_INT 1
4130: ARRAY
4131: PPUSH
4132: LD_VAR 0 5
4136: PUSH
4137: LD_INT 2
4139: ARRAY
4140: PPUSH
4141: CALL_OW 428
4145: PUSH
4146: LD_INT 0
4148: EQUAL
4149: PUSH
4150: LD_VAR 0 5
4154: PUSH
4155: LD_INT 1
4157: ARRAY
4158: PPUSH
4159: LD_VAR 0 5
4163: PUSH
4164: LD_INT 2
4166: ARRAY
4167: PPUSH
4168: CALL_OW 458
4172: NOT
4173: AND
4174: IFFALSE 4272
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
4176: LD_ADDR_EXP 17
4180: PUSH
4181: LD_EXP 17
4185: PPUSH
4186: LD_EXP 17
4190: PUSH
4191: LD_INT 1
4193: PLUS
4194: PPUSH
4195: LD_VAR 0 5
4199: PUSH
4200: LD_INT 1
4202: ARRAY
4203: PPUSH
4204: CALL_OW 2
4208: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
4209: LD_ADDR_EXP 17
4213: PUSH
4214: LD_EXP 17
4218: PPUSH
4219: LD_EXP 17
4223: PUSH
4224: LD_INT 1
4226: PLUS
4227: PPUSH
4228: LD_VAR 0 5
4232: PUSH
4233: LD_INT 2
4235: ARRAY
4236: PPUSH
4237: CALL_OW 2
4241: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
4242: LD_VAR 0 5
4246: PUSH
4247: LD_INT 1
4249: ARRAY
4250: PPUSH
4251: LD_VAR 0 5
4255: PUSH
4256: LD_INT 2
4258: ARRAY
4259: PPUSH
4260: LD_EXP 8
4264: PPUSH
4265: LD_INT 0
4267: PPUSH
4268: CALL_OW 454
// end ; end ;
4272: GO 4098
4274: POP
4275: POP
// for i = 1 to 12 do
4276: LD_ADDR_VAR 0 2
4280: PUSH
4281: DOUBLE
4282: LD_INT 1
4284: DEC
4285: ST_TO_ADDR
4286: LD_INT 12
4288: PUSH
4289: FOR_TO
4290: IFFALSE 4348
// begin uc_nation := 0 ;
4292: LD_ADDR_OWVAR 21
4296: PUSH
4297: LD_INT 0
4299: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 2 ) ;
4300: LD_INT 0
4302: PPUSH
4303: LD_INT 17
4305: PPUSH
4306: LD_INT 2
4308: PPUSH
4309: CALL_OW 380
// un := CreateHuman ;
4313: LD_ADDR_VAR 0 7
4317: PUSH
4318: CALL_OW 44
4322: ST_TO_ADDR
// apek := Insert ( apek , 1 , un ) ;
4323: LD_ADDR_EXP 34
4327: PUSH
4328: LD_EXP 34
4332: PPUSH
4333: LD_INT 1
4335: PPUSH
4336: LD_VAR 0 7
4340: PPUSH
4341: CALL_OW 2
4345: ST_TO_ADDR
// end ;
4346: GO 4289
4348: POP
4349: POP
// uc_nation := 2 ;
4350: LD_ADDR_OWVAR 21
4354: PUSH
4355: LD_INT 2
4357: ST_TO_ADDR
// if Difficulty > 1 then
4358: LD_OWVAR 67
4362: PUSH
4363: LD_INT 1
4365: GREATER
4366: IFFALSE 4397
// begin bc_type := b_bunker ;
4368: LD_ADDR_OWVAR 42
4372: PUSH
4373: LD_INT 32
4375: ST_TO_ADDR
// bc_level := 5 ;
4376: LD_ADDR_OWVAR 43
4380: PUSH
4381: LD_INT 5
4383: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 99 , 131 , 1 ) ;
4384: LD_INT 99
4386: PPUSH
4387: LD_INT 131
4389: PPUSH
4390: LD_INT 1
4392: PPUSH
4393: CALL_OW 47
// end ; for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4397: LD_ADDR_VAR 0 2
4401: PUSH
4402: LD_INT 22
4404: PUSH
4405: LD_VAR 0 6
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: PUSH
4414: LD_INT 30
4416: PUSH
4417: LD_INT 32
4419: PUSH
4420: EMPTY
4421: LIST
4422: LIST
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PPUSH
4428: CALL_OW 69
4432: PUSH
4433: FOR_IN
4434: IFFALSE 4466
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
4436: LD_VAR 0 2
4440: PPUSH
4441: LD_VAR 0 9
4445: PUSH
4446: LD_INT 1
4448: PPUSH
4449: LD_VAR 0 9
4453: PPUSH
4454: CALL_OW 12
4458: ARRAY
4459: PPUSH
4460: CALL_OW 431
4464: GO 4433
4466: POP
4467: POP
// uc_side := side ;
4468: LD_ADDR_OWVAR 20
4472: PUSH
4473: LD_VAR 0 6
4477: ST_TO_ADDR
// uc_nation := 2 ;
4478: LD_ADDR_OWVAR 21
4482: PUSH
4483: LD_INT 2
4485: ST_TO_ADDR
// for i = 1 to 4 do
4486: LD_ADDR_VAR 0 2
4490: PUSH
4491: DOUBLE
4492: LD_INT 1
4494: DEC
4495: ST_TO_ADDR
4496: LD_INT 4
4498: PUSH
4499: FOR_TO
4500: IFFALSE 4590
// begin vc_chassis := ar_half_tracked ;
4502: LD_ADDR_OWVAR 37
4506: PUSH
4507: LD_INT 14
4509: ST_TO_ADDR
// vc_engine := engine_combustion ;
4510: LD_ADDR_OWVAR 39
4514: PUSH
4515: LD_INT 1
4517: ST_TO_ADDR
// vc_control := control_manual ;
4518: LD_ADDR_OWVAR 38
4522: PUSH
4523: LD_INT 1
4525: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4526: LD_ADDR_OWVAR 40
4530: PUSH
4531: LD_INT 31
4533: ST_TO_ADDR
// veh := CreateVehicle ;
4534: LD_ADDR_VAR 0 8
4538: PUSH
4539: CALL_OW 45
4543: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
4544: LD_VAR 0 8
4548: PPUSH
4549: LD_INT 13
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
4559: LD_INT 0
4561: PPUSH
4562: LD_INT 3
4564: PPUSH
4565: LD_VAR 0 10
4569: PPUSH
4570: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4574: CALL_OW 44
4578: PPUSH
4579: LD_VAR 0 8
4583: PPUSH
4584: CALL_OW 52
// end ;
4588: GO 4499
4590: POP
4591: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4592: LD_ADDR_VAR 0 2
4596: PUSH
4597: LD_INT 22
4599: PUSH
4600: LD_VAR 0 6
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 30
4611: PUSH
4612: LD_INT 32
4614: PUSH
4615: EMPTY
4616: LIST
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 69
4627: PUSH
4628: FOR_IN
4629: IFFALSE 4662
// begin PrepareHuman ( false , 1 , skill ) ;
4631: LD_INT 0
4633: PPUSH
4634: LD_INT 1
4636: PPUSH
4637: LD_VAR 0 10
4641: PPUSH
4642: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4646: CALL_OW 44
4650: PPUSH
4651: LD_VAR 0 2
4655: PPUSH
4656: CALL_OW 52
// end ;
4660: GO 4628
4662: POP
4663: POP
// for i = 1 to 4 do
4664: LD_ADDR_VAR 0 2
4668: PUSH
4669: DOUBLE
4670: LD_INT 1
4672: DEC
4673: ST_TO_ADDR
4674: LD_INT 4
4676: PUSH
4677: FOR_TO
4678: IFFALSE 4709
// begin PrepareHuman ( false , 2 , skill ) ;
4680: LD_INT 0
4682: PPUSH
4683: LD_INT 2
4685: PPUSH
4686: LD_VAR 0 10
4690: PPUSH
4691: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_base_east ) ;
4695: CALL_OW 44
4699: PPUSH
4700: LD_INT 81
4702: PPUSH
4703: CALL_OW 52
// end ;
4707: GO 4677
4709: POP
4710: POP
// for i = 1 to 6 do
4711: LD_ADDR_VAR 0 2
4715: PUSH
4716: DOUBLE
4717: LD_INT 1
4719: DEC
4720: ST_TO_ADDR
4721: LD_INT 6
4723: PUSH
4724: FOR_TO
4725: IFFALSE 4756
// begin PrepareHuman ( false , 3 , skill ) ;
4727: LD_INT 0
4729: PPUSH
4730: LD_INT 3
4732: PPUSH
4733: LD_VAR 0 10
4737: PPUSH
4738: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac_east ) ;
4742: CALL_OW 44
4746: PPUSH
4747: LD_INT 88
4749: PPUSH
4750: CALL_OW 52
// end ;
4754: GO 4724
4756: POP
4757: POP
// for i = 1 to 4 do
4758: LD_ADDR_VAR 0 2
4762: PUSH
4763: DOUBLE
4764: LD_INT 1
4766: DEC
4767: ST_TO_ADDR
4768: LD_INT 4
4770: PUSH
4771: FOR_TO
4772: IFFALSE 4803
// begin PrepareHuman ( false , 3 , skill ) ;
4774: LD_INT 0
4776: PPUSH
4777: LD_INT 3
4779: PPUSH
4780: LD_VAR 0 10
4784: PPUSH
4785: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac_north ) ;
4789: CALL_OW 44
4793: PPUSH
4794: LD_INT 61
4796: PPUSH
4797: CALL_OW 52
// end ;
4801: GO 4771
4803: POP
4804: POP
// for i = 1 to 6 do
4805: LD_ADDR_VAR 0 2
4809: PUSH
4810: DOUBLE
4811: LD_INT 1
4813: DEC
4814: ST_TO_ADDR
4815: LD_INT 6
4817: PUSH
4818: FOR_TO
4819: IFFALSE 4915
// begin PrepareHuman ( false , 4 , skill ) ;
4821: LD_INT 0
4823: PPUSH
4824: LD_INT 4
4826: PPUSH
4827: LD_VAR 0 10
4831: PPUSH
4832: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
4836: CALL_OW 44
4840: PPUSH
4841: LD_INT 30
4843: PUSH
4844: LD_INT 8
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 69
4855: PUSH
4856: LD_VAR 0 2
4860: PUSH
4861: LD_INT 2
4863: MOD
4864: PUSH
4865: LD_INT 1
4867: PLUS
4868: ARRAY
4869: PPUSH
4870: CALL_OW 52
// SetSpecResearch ( FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] , 2000 , false ) ;
4874: LD_INT 30
4876: PUSH
4877: LD_INT 8
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PPUSH
4884: CALL_OW 69
4888: PUSH
4889: LD_VAR 0 2
4893: PUSH
4894: LD_INT 2
4896: MOD
4897: PUSH
4898: LD_INT 1
4900: PLUS
4901: ARRAY
4902: PPUSH
4903: LD_INT 2000
4905: PPUSH
4906: LD_INT 0
4908: PPUSH
4909: CALL_OW 486
// end ;
4913: GO 4818
4915: POP
4916: POP
// PrepareHuman ( false , class_sniper , skill ) ;
4917: LD_INT 0
4919: PPUSH
4920: LD_INT 5
4922: PPUSH
4923: LD_VAR 0 10
4927: PPUSH
4928: CALL_OW 380
// un := CreateHuman ;
4932: LD_ADDR_VAR 0 7
4936: PUSH
4937: CALL_OW 44
4941: ST_TO_ADDR
// SetDir ( un , 3 ) ;
4942: LD_VAR 0 7
4946: PPUSH
4947: LD_INT 3
4949: PPUSH
4950: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
4954: LD_VAR 0 7
4958: PPUSH
4959: LD_INT 52
4961: PPUSH
4962: CALL_OW 52
// for i = 1 to 4 do
4966: LD_ADDR_VAR 0 2
4970: PUSH
4971: DOUBLE
4972: LD_INT 1
4974: DEC
4975: ST_TO_ADDR
4976: LD_INT 4
4978: PUSH
4979: FOR_TO
4980: IFFALSE 5036
// begin uc_nation := 0 ;
4982: LD_ADDR_OWVAR 21
4986: PUSH
4987: LD_INT 0
4989: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
4990: LD_INT 0
4992: PPUSH
4993: LD_INT 16
4995: PPUSH
4996: LD_INT 1
4998: PPUSH
4999: CALL_OW 380
// un := CreateHuman ;
5003: LD_ADDR_VAR 0 7
5007: PUSH
5008: CALL_OW 44
5012: ST_TO_ADDR
// PlaceUnitXYR ( un , 116 , 128 , 8 , false ) ;
5013: LD_VAR 0 7
5017: PPUSH
5018: LD_INT 116
5020: PPUSH
5021: LD_INT 128
5023: PPUSH
5024: LD_INT 8
5026: PPUSH
5027: LD_INT 0
5029: PPUSH
5030: CALL_OW 50
// end ;
5034: GO 4979
5036: POP
5037: POP
// for i = 1 to 3 do
5038: LD_ADDR_VAR 0 2
5042: PUSH
5043: DOUBLE
5044: LD_INT 1
5046: DEC
5047: ST_TO_ADDR
5048: LD_INT 3
5050: PUSH
5051: FOR_TO
5052: IFFALSE 5108
// begin uc_nation := 0 ;
5054: LD_ADDR_OWVAR 21
5058: PUSH
5059: LD_INT 0
5061: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5062: LD_INT 0
5064: PPUSH
5065: LD_INT 16
5067: PPUSH
5068: LD_INT 1
5070: PPUSH
5071: CALL_OW 380
// un := CreateHuman ;
5075: LD_ADDR_VAR 0 7
5079: PUSH
5080: CALL_OW 44
5084: ST_TO_ADDR
// PlaceUnitXYR ( un , 23 , 19 , 8 , false ) ;
5085: LD_VAR 0 7
5089: PPUSH
5090: LD_INT 23
5092: PPUSH
5093: LD_INT 19
5095: PPUSH
5096: LD_INT 8
5098: PPUSH
5099: LD_INT 0
5101: PPUSH
5102: CALL_OW 50
// end ;
5106: GO 5051
5108: POP
5109: POP
// for i = 1 to 3 do
5110: LD_ADDR_VAR 0 2
5114: PUSH
5115: DOUBLE
5116: LD_INT 1
5118: DEC
5119: ST_TO_ADDR
5120: LD_INT 3
5122: PUSH
5123: FOR_TO
5124: IFFALSE 5180
// begin uc_nation := 0 ;
5126: LD_ADDR_OWVAR 21
5130: PUSH
5131: LD_INT 0
5133: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5134: LD_INT 0
5136: PPUSH
5137: LD_INT 16
5139: PPUSH
5140: LD_INT 1
5142: PPUSH
5143: CALL_OW 380
// un := CreateHuman ;
5147: LD_ADDR_VAR 0 7
5151: PUSH
5152: CALL_OW 44
5156: ST_TO_ADDR
// PlaceUnitXYR ( un , 154 , 89 , 8 , false ) ;
5157: LD_VAR 0 7
5161: PPUSH
5162: LD_INT 154
5164: PPUSH
5165: LD_INT 89
5167: PPUSH
5168: LD_INT 8
5170: PPUSH
5171: LD_INT 0
5173: PPUSH
5174: CALL_OW 50
// end ;
5178: GO 5123
5180: POP
5181: POP
// for i = 1 to 3 do
5182: LD_ADDR_VAR 0 2
5186: PUSH
5187: DOUBLE
5188: LD_INT 1
5190: DEC
5191: ST_TO_ADDR
5192: LD_INT 3
5194: PUSH
5195: FOR_TO
5196: IFFALSE 5268
// begin uc_nation := 0 ;
5198: LD_ADDR_OWVAR 21
5202: PUSH
5203: LD_INT 0
5205: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5206: LD_INT 0
5208: PPUSH
5209: LD_INT 16
5211: PPUSH
5212: LD_INT 1
5214: PPUSH
5215: CALL_OW 380
// un := CreateHuman ;
5219: LD_ADDR_VAR 0 7
5223: PUSH
5224: CALL_OW 44
5228: ST_TO_ADDR
// ar_collectors := ar_collectors ^ un ;
5229: LD_ADDR_EXP 35
5233: PUSH
5234: LD_EXP 35
5238: PUSH
5239: LD_VAR 0 7
5243: ADD
5244: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 17 , 8 , false ) ;
5245: LD_VAR 0 7
5249: PPUSH
5250: LD_INT 112
5252: PPUSH
5253: LD_INT 17
5255: PPUSH
5256: LD_INT 8
5258: PPUSH
5259: LD_INT 0
5261: PPUSH
5262: CALL_OW 50
// end ;
5266: GO 5195
5268: POP
5269: POP
// for i = 1 to 3 * Difficulty do
5270: LD_ADDR_VAR 0 2
5274: PUSH
5275: DOUBLE
5276: LD_INT 1
5278: DEC
5279: ST_TO_ADDR
5280: LD_INT 3
5282: PUSH
5283: LD_OWVAR 67
5287: MUL
5288: PUSH
5289: FOR_TO
5290: IFFALSE 5364
// begin uc_nation := 0 ;
5292: LD_ADDR_OWVAR 21
5296: PUSH
5297: LD_INT 0
5299: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
5300: LD_INT 0
5302: PPUSH
5303: LD_INT 17
5305: PPUSH
5306: LD_INT 3
5308: PPUSH
5309: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
5313: LD_ADDR_OWVAR 29
5317: PUSH
5318: LD_INT 11
5320: PUSH
5321: LD_INT 13
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: ST_TO_ADDR
// un := CreateHuman ;
5328: LD_ADDR_VAR 0 7
5332: PUSH
5333: CALL_OW 44
5337: ST_TO_ADDR
// PlaceUnitArea ( un , ap1 , false ) ;
5338: LD_VAR 0 7
5342: PPUSH
5343: LD_INT 14
5345: PPUSH
5346: LD_INT 0
5348: PPUSH
5349: CALL_OW 49
// ComHold ( un ) ;
5353: LD_VAR 0 7
5357: PPUSH
5358: CALL_OW 140
// end ;
5362: GO 5289
5364: POP
5365: POP
// for i = 1 to Difficulty do
5366: LD_ADDR_VAR 0 2
5370: PUSH
5371: DOUBLE
5372: LD_INT 1
5374: DEC
5375: ST_TO_ADDR
5376: LD_OWVAR 67
5380: PUSH
5381: FOR_TO
5382: IFFALSE 5474
// begin uc_nation := nation_arabian ;
5384: LD_ADDR_OWVAR 21
5388: PUSH
5389: LD_INT 2
5391: ST_TO_ADDR
// vc_chassis := ar_hovercraft ;
5392: LD_ADDR_OWVAR 37
5396: PUSH
5397: LD_INT 11
5399: ST_TO_ADDR
// vc_engine := engine_solar ;
5400: LD_ADDR_OWVAR 39
5404: PUSH
5405: LD_INT 2
5407: ST_TO_ADDR
// vc_control := control_remote ;
5408: LD_ADDR_OWVAR 38
5412: PUSH
5413: LD_INT 2
5415: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
5416: LD_ADDR_OWVAR 40
5420: PUSH
5421: LD_INT 24
5423: ST_TO_ADDR
// veh := CreateVehicle ;
5424: LD_ADDR_VAR 0 8
5428: PUSH
5429: CALL_OW 45
5433: ST_TO_ADDR
// river_guard := Insert ( river_guard , 1 , veh ) ;
5434: LD_ADDR_EXP 33
5438: PUSH
5439: LD_EXP 33
5443: PPUSH
5444: LD_INT 1
5446: PPUSH
5447: LD_VAR 0 8
5451: PPUSH
5452: CALL_OW 2
5456: ST_TO_ADDR
// PlaceUnitArea ( veh , river_spawn , false ) ;
5457: LD_VAR 0 8
5461: PPUSH
5462: LD_INT 19
5464: PPUSH
5465: LD_INT 0
5467: PPUSH
5468: CALL_OW 49
// end ;
5472: GO 5381
5474: POP
5475: POP
// for i = 1 to Difficulty do
5476: LD_ADDR_VAR 0 2
5480: PUSH
5481: DOUBLE
5482: LD_INT 1
5484: DEC
5485: ST_TO_ADDR
5486: LD_OWVAR 67
5490: PUSH
5491: FOR_TO
5492: IFFALSE 5838
// begin uc_nation := nation_arabian ;
5494: LD_ADDR_OWVAR 21
5498: PUSH
5499: LD_INT 2
5501: ST_TO_ADDR
// for j = 1 to 5 do
5502: LD_ADDR_VAR 0 3
5506: PUSH
5507: DOUBLE
5508: LD_INT 1
5510: DEC
5511: ST_TO_ADDR
5512: LD_INT 5
5514: PUSH
5515: FOR_TO
5516: IFFALSE 5585
// begin PrepareHuman ( false , class_mortar , skill ) ;
5518: LD_INT 0
5520: PPUSH
5521: LD_INT 8
5523: PPUSH
5524: LD_VAR 0 10
5528: PPUSH
5529: CALL_OW 380
// un := CreateHuman ;
5533: LD_ADDR_VAR 0 7
5537: PUSH
5538: CALL_OW 44
5542: ST_TO_ADDR
// sup_attack := Insert ( sup_attack , sup_attack + 1 , [ un , 54 , 102 ] ) ;
5543: LD_ADDR_EXP 36
5547: PUSH
5548: LD_EXP 36
5552: PPUSH
5553: LD_EXP 36
5557: PUSH
5558: LD_INT 1
5560: PLUS
5561: PPUSH
5562: LD_VAR 0 7
5566: PUSH
5567: LD_INT 54
5569: PUSH
5570: LD_INT 102
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: LIST
5577: PPUSH
5578: CALL_OW 2
5582: ST_TO_ADDR
// end ;
5583: GO 5515
5585: POP
5586: POP
// for j = 1 to 3 do
5587: LD_ADDR_VAR 0 3
5591: PUSH
5592: DOUBLE
5593: LD_INT 1
5595: DEC
5596: ST_TO_ADDR
5597: LD_INT 3
5599: PUSH
5600: FOR_TO
5601: IFFALSE 5749
// begin uc_nation := 0 ;
5603: LD_ADDR_OWVAR 21
5607: PUSH
5608: LD_INT 0
5610: ST_TO_ADDR
// vc_chassis := 15 ;
5611: LD_ADDR_OWVAR 37
5615: PUSH
5616: LD_INT 15
5618: ST_TO_ADDR
// vc_control := control_rider ;
5619: LD_ADDR_OWVAR 38
5623: PUSH
5624: LD_INT 4
5626: ST_TO_ADDR
// un := CreateVehicle ;
5627: LD_ADDR_VAR 0 7
5631: PUSH
5632: CALL_OW 45
5636: ST_TO_ADDR
// sup_attack := Insert ( sup_attack , sup_attack + 1 , [ un , 188 , 145 ] ) ;
5637: LD_ADDR_EXP 36
5641: PUSH
5642: LD_EXP 36
5646: PPUSH
5647: LD_EXP 36
5651: PUSH
5652: LD_INT 1
5654: PLUS
5655: PPUSH
5656: LD_VAR 0 7
5660: PUSH
5661: LD_INT 188
5663: PUSH
5664: LD_INT 145
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: LIST
5671: PPUSH
5672: CALL_OW 2
5676: ST_TO_ADDR
// uc_nation := nation_arabian ;
5677: LD_ADDR_OWVAR 21
5681: PUSH
5682: LD_INT 2
5684: ST_TO_ADDR
// PrepareHuman ( false , class_desert_warior , skill ) ;
5685: LD_INT 0
5687: PPUSH
5688: LD_INT 11
5690: PPUSH
5691: LD_VAR 0 10
5695: PPUSH
5696: CALL_OW 380
// un := CreateHuman ;
5700: LD_ADDR_VAR 0 7
5704: PUSH
5705: CALL_OW 44
5709: ST_TO_ADDR
// sup_attack := Insert ( sup_attack , sup_attack + 1 , [ un , - 1 ] ) ;
5710: LD_ADDR_EXP 36
5714: PUSH
5715: LD_EXP 36
5719: PPUSH
5720: LD_EXP 36
5724: PUSH
5725: LD_INT 1
5727: PLUS
5728: PPUSH
5729: LD_VAR 0 7
5733: PUSH
5734: LD_INT 1
5736: NEG
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: PPUSH
5742: CALL_OW 2
5746: ST_TO_ADDR
// end ;
5747: GO 5600
5749: POP
5750: POP
// for j = 1 to 3 do
5751: LD_ADDR_VAR 0 3
5755: PUSH
5756: DOUBLE
5757: LD_INT 1
5759: DEC
5760: ST_TO_ADDR
5761: LD_INT 3
5763: PUSH
5764: FOR_TO
5765: IFFALSE 5834
// begin PrepareHuman ( false , class_mortar , skill ) ;
5767: LD_INT 0
5769: PPUSH
5770: LD_INT 8
5772: PPUSH
5773: LD_VAR 0 10
5777: PPUSH
5778: CALL_OW 380
// un := CreateHuman ;
5782: LD_ADDR_VAR 0 7
5786: PUSH
5787: CALL_OW 44
5791: ST_TO_ADDR
// sup_attack := Insert ( sup_attack , sup_attack + 1 , [ un , 188 , 145 ] ) ;
5792: LD_ADDR_EXP 36
5796: PUSH
5797: LD_EXP 36
5801: PPUSH
5802: LD_EXP 36
5806: PUSH
5807: LD_INT 1
5809: PLUS
5810: PPUSH
5811: LD_VAR 0 7
5815: PUSH
5816: LD_INT 188
5818: PUSH
5819: LD_INT 145
5821: PUSH
5822: EMPTY
5823: LIST
5824: LIST
5825: LIST
5826: PPUSH
5827: CALL_OW 2
5831: ST_TO_ADDR
// end ;
5832: GO 5764
5834: POP
5835: POP
// end ;
5836: GO 5491
5838: POP
5839: POP
// end ;
5840: LD_VAR 0 1
5844: RET
// export function Defcon ( n , x , y , type ) ; var i , un , veh , list ; begin
5845: LD_INT 0
5847: PPUSH
5848: PPUSH
5849: PPUSH
5850: PPUSH
5851: PPUSH
// list := [ ] ;
5852: LD_ADDR_VAR 0 9
5856: PUSH
5857: EMPTY
5858: ST_TO_ADDR
// uc_side := bot_side ;
5859: LD_ADDR_OWVAR 20
5863: PUSH
5864: LD_EXP 8
5868: ST_TO_ADDR
// uc_nation := nation_arabian ;
5869: LD_ADDR_OWVAR 21
5873: PUSH
5874: LD_INT 2
5876: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
5877: LD_ADDR_OWVAR 37
5881: PUSH
5882: LD_INT 14
5884: ST_TO_ADDR
// vc_engine := engine_siberite ;
5885: LD_ADDR_OWVAR 39
5889: PUSH
5890: LD_INT 3
5892: ST_TO_ADDR
// if type then
5893: LD_VAR 0 4
5897: IFFALSE 5909
// vc_control := control_manual else
5899: LD_ADDR_OWVAR 38
5903: PUSH
5904: LD_INT 1
5906: ST_TO_ADDR
5907: GO 5917
// vc_control := control_apeman ;
5909: LD_ADDR_OWVAR 38
5913: PUSH
5914: LD_INT 5
5916: ST_TO_ADDR
// for i = 1 to n do
5917: LD_ADDR_VAR 0 6
5921: PUSH
5922: DOUBLE
5923: LD_INT 1
5925: DEC
5926: ST_TO_ADDR
5927: LD_VAR 0 1
5931: PUSH
5932: FOR_TO
5933: IFFALSE 6076
// begin vc_weapon := [ ar_rocket_launcher , ar_flame_thrower , ar_gun ] [ Rand ( 1 , 3 ) ] ;
5935: LD_ADDR_OWVAR 40
5939: PUSH
5940: LD_INT 28
5942: PUSH
5943: LD_INT 26
5945: PUSH
5946: LD_INT 27
5948: PUSH
5949: EMPTY
5950: LIST
5951: LIST
5952: LIST
5953: PUSH
5954: LD_INT 1
5956: PPUSH
5957: LD_INT 3
5959: PPUSH
5960: CALL_OW 12
5964: ARRAY
5965: ST_TO_ADDR
// veh := CreateVehicle ;
5966: LD_ADDR_VAR 0 8
5970: PUSH
5971: CALL_OW 45
5975: ST_TO_ADDR
// PlaceUnitXYR ( veh , x , y , 13 , false ) ;
5976: LD_VAR 0 8
5980: PPUSH
5981: LD_VAR 0 2
5985: PPUSH
5986: LD_VAR 0 3
5990: PPUSH
5991: LD_INT 13
5993: PPUSH
5994: LD_INT 0
5996: PPUSH
5997: CALL_OW 50
// if type then
6001: LD_VAR 0 4
6005: IFFALSE 6051
// begin PrepareHuman ( false , 3 , [ 4 , 6 , 8 ] [ Difficulty ] ) ;
6007: LD_INT 0
6009: PPUSH
6010: LD_INT 3
6012: PPUSH
6013: LD_INT 4
6015: PUSH
6016: LD_INT 6
6018: PUSH
6019: LD_INT 8
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: LIST
6026: PUSH
6027: LD_OWVAR 67
6031: ARRAY
6032: PPUSH
6033: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6037: CALL_OW 44
6041: PPUSH
6042: LD_VAR 0 8
6046: PPUSH
6047: CALL_OW 52
// end ; list := Insert ( list , 1 , veh ) ;
6051: LD_ADDR_VAR 0 9
6055: PUSH
6056: LD_VAR 0 9
6060: PPUSH
6061: LD_INT 1
6063: PPUSH
6064: LD_VAR 0 8
6068: PPUSH
6069: CALL_OW 2
6073: ST_TO_ADDR
// end ;
6074: GO 5932
6076: POP
6077: POP
// result := list ;
6078: LD_ADDR_VAR 0 5
6082: PUSH
6083: LD_VAR 0 9
6087: ST_TO_ADDR
// end ;
6088: LD_VAR 0 5
6092: RET
// every 0 0$03 trigger FilterUnitsInArea ( pass_guard , [ f_enemy , bot_side ] ) do var i ;
6093: LD_INT 16
6095: PPUSH
6096: LD_INT 81
6098: PUSH
6099: LD_EXP 8
6103: PUSH
6104: EMPTY
6105: LIST
6106: LIST
6107: PPUSH
6108: CALL_OW 70
6112: IFFALSE 6190
6114: GO 6116
6116: DISABLE
6117: LD_INT 0
6119: PPUSH
// begin if not north_force then
6120: LD_EXP 31
6124: NOT
6125: IFFALSE 6129
// exit ;
6127: GO 6190
// for i = 1 to north_force do
6129: LD_ADDR_VAR 0 1
6133: PUSH
6134: DOUBLE
6135: LD_INT 1
6137: DEC
6138: ST_TO_ADDR
6139: LD_EXP 31
6143: PUSH
6144: FOR_TO
6145: IFFALSE 6170
// begin ComMoveXY ( north_force [ i ] , 38 , 57 ) ;
6147: LD_EXP 31
6151: PUSH
6152: LD_VAR 0 1
6156: ARRAY
6157: PPUSH
6158: LD_INT 38
6160: PPUSH
6161: LD_INT 57
6163: PPUSH
6164: CALL_OW 111
// end ;
6168: GO 6144
6170: POP
6171: POP
// PlaceSeeing ( 54 , 69 , bot_side , 10 ) ;
6172: LD_INT 54
6174: PPUSH
6175: LD_INT 69
6177: PPUSH
6178: LD_EXP 8
6182: PPUSH
6183: LD_INT 10
6185: PPUSH
6186: CALL_OW 330
// end ;
6190: PPOPN 1
6192: END
// every 0 0$03 trigger FilterUnitsInArea ( bridge_protect , [ f_enemy , bot_side ] ) do var i ;
6193: LD_INT 18
6195: PPUSH
6196: LD_INT 81
6198: PUSH
6199: LD_EXP 8
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PPUSH
6208: CALL_OW 70
6212: IFFALSE 6272
6214: GO 6216
6216: DISABLE
6217: LD_INT 0
6219: PPUSH
// begin if not south_force then
6220: LD_EXP 30
6224: NOT
6225: IFFALSE 6229
// exit ;
6227: GO 6272
// for i = 1 to south_force do
6229: LD_ADDR_VAR 0 1
6233: PUSH
6234: DOUBLE
6235: LD_INT 1
6237: DEC
6238: ST_TO_ADDR
6239: LD_EXP 30
6243: PUSH
6244: FOR_TO
6245: IFFALSE 6270
// begin ComMoveXY ( south_force [ i ] , 157 , 140 ) ;
6247: LD_EXP 30
6251: PUSH
6252: LD_VAR 0 1
6256: ARRAY
6257: PPUSH
6258: LD_INT 157
6260: PPUSH
6261: LD_INT 140
6263: PPUSH
6264: CALL_OW 111
// end ;
6268: GO 6244
6270: POP
6271: POP
// end ;
6272: PPOPN 1
6274: END
// every 11 11$00 trigger ar_fac_east and FilterAllUnits ( [ [ f_enemy , bot_side ] , [ f_btype , b_warehouse ] ] ) do var i , tmp , p , fac ;
6275: LD_INT 88
6277: PUSH
6278: LD_INT 81
6280: PUSH
6281: LD_EXP 8
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 30
6292: PUSH
6293: LD_INT 1
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PPUSH
6304: CALL_OW 69
6308: AND
6309: IFFALSE 6640
6311: GO 6313
6313: DISABLE
6314: LD_INT 0
6316: PPUSH
6317: PPUSH
6318: PPUSH
6319: PPUSH
// begin enable ;
6320: ENABLE
// tmp := queue_codes [ rng ] ;
6321: LD_ADDR_VAR 0 2
6325: PUSH
6326: LD_EXP 23
6330: PUSH
6331: LD_EXP 24
6335: ARRAY
6336: ST_TO_ADDR
// p := 1 ;
6337: LD_ADDR_VAR 0 3
6341: PUSH
6342: LD_INT 1
6344: ST_TO_ADDR
// for i = 1 to veh_counter do
6345: LD_ADDR_VAR 0 1
6349: PUSH
6350: DOUBLE
6351: LD_INT 1
6353: DEC
6354: ST_TO_ADDR
6355: LD_EXP 22
6359: PUSH
6360: FOR_TO
6361: IFFALSE 6604
// begin fac := [ ar_fac_east , ar_fac_north ] [ i mod 2 + 1 ] ;
6363: LD_ADDR_VAR 0 4
6367: PUSH
6368: LD_INT 88
6370: PUSH
6371: LD_INT 61
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PUSH
6378: LD_VAR 0 1
6382: PUSH
6383: LD_INT 2
6385: MOD
6386: PUSH
6387: LD_INT 1
6389: PLUS
6390: ARRAY
6391: ST_TO_ADDR
// if fac = ar_fac_north and ( GetSide ( ar_fac_north ) <> bot_side or IsDead ( ar_fac_north ) or GetResourceType ( GetBase ( ar_base_nort ) , mat_cans ) < 100 ) then
6392: LD_VAR 0 4
6396: PUSH
6397: LD_INT 61
6399: EQUAL
6400: PUSH
6401: LD_INT 61
6403: PPUSH
6404: CALL_OW 255
6408: PUSH
6409: LD_EXP 8
6413: NONEQUAL
6414: PUSH
6415: LD_INT 61
6417: PPUSH
6418: CALL_OW 301
6422: OR
6423: PUSH
6424: LD_INT 55
6426: PPUSH
6427: CALL_OW 274
6431: PPUSH
6432: LD_INT 1
6434: PPUSH
6435: CALL_OW 275
6439: PUSH
6440: LD_INT 100
6442: LESS
6443: OR
6444: AND
6445: IFFALSE 6455
// fac := ar_fac_east ;
6447: LD_ADDR_VAR 0 4
6451: PUSH
6452: LD_INT 88
6454: ST_TO_ADDR
// AddComConstruct ( fac , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
6455: LD_VAR 0 4
6459: PPUSH
6460: LD_EXP 21
6464: PUSH
6465: LD_VAR 0 2
6469: PUSH
6470: LD_INT 10
6472: MOD
6473: ARRAY
6474: PUSH
6475: LD_INT 1
6477: ARRAY
6478: PPUSH
6479: LD_EXP 21
6483: PUSH
6484: LD_VAR 0 2
6488: PUSH
6489: LD_INT 10
6491: MOD
6492: ARRAY
6493: PUSH
6494: LD_INT 2
6496: ARRAY
6497: PPUSH
6498: LD_EXP 21
6502: PUSH
6503: LD_VAR 0 2
6507: PUSH
6508: LD_INT 10
6510: MOD
6511: ARRAY
6512: PUSH
6513: LD_INT 3
6515: ARRAY
6516: PPUSH
6517: LD_EXP 21
6521: PUSH
6522: LD_VAR 0 2
6526: PUSH
6527: LD_INT 10
6529: MOD
6530: ARRAY
6531: PUSH
6532: LD_INT 4
6534: ARRAY
6535: PPUSH
6536: CALL_OW 185
// tmp := tmp / 10 ;
6540: LD_ADDR_VAR 0 2
6544: PUSH
6545: LD_VAR 0 2
6549: PUSH
6550: LD_INT 10
6552: DIVREAL
6553: ST_TO_ADDR
// p := p + 1 ;
6554: LD_ADDR_VAR 0 3
6558: PUSH
6559: LD_VAR 0 3
6563: PUSH
6564: LD_INT 1
6566: PLUS
6567: ST_TO_ADDR
// if p > 5 then
6568: LD_VAR 0 3
6572: PUSH
6573: LD_INT 5
6575: GREATER
6576: IFFALSE 6602
// begin p := 1 ;
6578: LD_ADDR_VAR 0 3
6582: PUSH
6583: LD_INT 1
6585: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
6586: LD_ADDR_VAR 0 2
6590: PUSH
6591: LD_EXP 23
6595: PUSH
6596: LD_EXP 24
6600: ARRAY
6601: ST_TO_ADDR
// end ; end ;
6602: GO 6360
6604: POP
6605: POP
// rng := rng + 1 ;
6606: LD_ADDR_EXP 24
6610: PUSH
6611: LD_EXP 24
6615: PUSH
6616: LD_INT 1
6618: PLUS
6619: ST_TO_ADDR
// if rng > queue_codes then
6620: LD_EXP 24
6624: PUSH
6625: LD_EXP 23
6629: GREATER
6630: IFFALSE 6640
// rng := 1 ;
6632: LD_ADDR_EXP 24
6636: PUSH
6637: LD_INT 1
6639: ST_TO_ADDR
// end ;
6640: PPOPN 4
6642: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
6643: LD_INT 25
6645: PUSH
6646: LD_INT 17
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: CALL_OW 69
6657: IFFALSE 6760
6659: GO 6661
6661: DISABLE
6662: LD_INT 0
6664: PPUSH
6665: PPUSH
// begin enable ;
6666: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
6667: LD_ADDR_VAR 0 1
6671: PUSH
6672: LD_INT 25
6674: PUSH
6675: LD_INT 17
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PPUSH
6682: CALL_OW 69
6686: PUSH
6687: FOR_IN
6688: IFFALSE 6758
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
6690: LD_ADDR_VAR 0 2
6694: PUSH
6695: LD_INT 81
6697: PUSH
6698: LD_EXP 8
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PPUSH
6707: CALL_OW 69
6711: PPUSH
6712: LD_VAR 0 1
6716: PPUSH
6717: CALL_OW 74
6721: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
6722: LD_VAR 0 1
6726: PPUSH
6727: LD_VAR 0 2
6731: PPUSH
6732: CALL_OW 296
6736: PUSH
6737: LD_INT 15
6739: LESS
6740: IFFALSE 6756
// ComAttackUnit ( i , un ) ;
6742: LD_VAR 0 1
6746: PPUSH
6747: LD_VAR 0 2
6751: PPUSH
6752: CALL_OW 115
// end ;
6756: GO 6687
6758: POP
6759: POP
// end ;
6760: PPOPN 2
6762: END
// every 0 0$01 trigger attackers marked 17 do var i ;
6763: LD_EXP 20
6767: IFFALSE 6861
6769: GO 6771
6771: DISABLE
6772: LD_INT 0
6774: PPUSH
// begin enable ;
6775: ENABLE
// if target = 0 then
6776: LD_EXP 25
6780: PUSH
6781: LD_INT 0
6783: EQUAL
6784: IFFALSE 6808
// target := FilterAllUnits ( [ f_enemy , bot_side ] ) ;
6786: LD_ADDR_EXP 25
6790: PUSH
6791: LD_INT 81
6793: PUSH
6794: LD_EXP 8
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: PPUSH
6803: CALL_OW 69
6807: ST_TO_ADDR
// for i in attackers do
6808: LD_ADDR_VAR 0 1
6812: PUSH
6813: LD_EXP 20
6817: PUSH
6818: FOR_IN
6819: IFFALSE 6859
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , target ] ) , i ) ) ;
6821: LD_VAR 0 1
6825: PPUSH
6826: LD_INT 22
6828: PUSH
6829: LD_EXP 25
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: PPUSH
6838: CALL_OW 69
6842: PPUSH
6843: LD_VAR 0 1
6847: PPUSH
6848: CALL_OW 74
6852: PPUSH
6853: CALL_OW 115
6857: GO 6818
6859: POP
6860: POP
// end ;
6861: PPOPN 1
6863: END
// every 0 0$01 trigger not attackers marked 17 do
6864: LD_EXP 20
6868: NOT
6869: IFFALSE 6878
6871: GO 6873
6873: DISABLE
// begin enable ;
6874: ENABLE
// disable ( 17 ) ;
6875: LD_INT 17
6877: DISABLE_MARKED
// end ;
6878: END
// every 3 3$00 trigger veh_counter <= attackers do var max , i , j , x ;
6879: LD_EXP 22
6883: PUSH
6884: LD_EXP 20
6888: LESSEQUAL
6889: IFFALSE 7247
6891: GO 6893
6893: DISABLE
6894: LD_INT 0
6896: PPUSH
6897: PPUSH
6898: PPUSH
6899: PPUSH
// begin enable ;
6900: ENABLE
// enable ( 17 ) ;
6901: LD_INT 17
6903: ENABLE_MARKED
// max := 1 ;
6904: LD_ADDR_VAR 0 1
6908: PUSH
6909: LD_INT 1
6911: ST_TO_ADDR
// for i = 1 to 8 do
6912: LD_ADDR_VAR 0 2
6916: PUSH
6917: DOUBLE
6918: LD_INT 1
6920: DEC
6921: ST_TO_ADDR
6922: LD_INT 8
6924: PUSH
6925: FOR_TO
6926: IFFALSE 6998
// if i <> bot_side then
6928: LD_VAR 0 2
6932: PUSH
6933: LD_EXP 8
6937: NONEQUAL
6938: IFFALSE 6996
// begin if max < FilterAllUnits ( [ f_side , i ] ) then
6940: LD_VAR 0 1
6944: PUSH
6945: LD_INT 22
6947: PUSH
6948: LD_VAR 0 2
6952: PUSH
6953: EMPTY
6954: LIST
6955: LIST
6956: PPUSH
6957: CALL_OW 69
6961: LESS
6962: IFFALSE 6996
// begin max := FilterAllUnits ( [ f_side , i ] ) ;
6964: LD_ADDR_VAR 0 1
6968: PUSH
6969: LD_INT 22
6971: PUSH
6972: LD_VAR 0 2
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PPUSH
6981: CALL_OW 69
6985: ST_TO_ADDR
// target := i ;
6986: LD_ADDR_EXP 25
6990: PUSH
6991: LD_VAR 0 2
6995: ST_TO_ADDR
// end ; end ;
6996: GO 6925
6998: POP
6999: POP
// att_counter := att_counter + 1 ;
7000: LD_ADDR_EXP 29
7004: PUSH
7005: LD_EXP 29
7009: PUSH
7010: LD_INT 1
7012: PLUS
7013: ST_TO_ADDR
// if att_counter mod [ 4 , 3 , 3 ] [ Difficulty ] = 0 and sup_attack then
7014: LD_EXP 29
7018: PUSH
7019: LD_INT 4
7021: PUSH
7022: LD_INT 3
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: LIST
7032: PUSH
7033: LD_OWVAR 67
7037: ARRAY
7038: MOD
7039: PUSH
7040: LD_INT 0
7042: EQUAL
7043: PUSH
7044: LD_EXP 36
7048: AND
7049: IFFALSE 7247
// begin x := 1 ;
7051: LD_ADDR_VAR 0 4
7055: PUSH
7056: LD_INT 1
7058: ST_TO_ADDR
// for j = 1 to 14 do
7059: LD_ADDR_VAR 0 3
7063: PUSH
7064: DOUBLE
7065: LD_INT 1
7067: DEC
7068: ST_TO_ADDR
7069: LD_INT 14
7071: PUSH
7072: FOR_TO
7073: IFFALSE 7245
// begin if GetClass ( sup_attack [ 1 ] [ 1 ] ) = class_desert_warior then
7075: LD_EXP 36
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PUSH
7084: LD_INT 1
7086: ARRAY
7087: PPUSH
7088: CALL_OW 257
7092: PUSH
7093: LD_INT 11
7095: EQUAL
7096: IFFALSE 7152
// begin PlaceHumanInUnit ( sup_attack [ 1 ] [ 1 ] , FilterAllUnits ( [ f_control , control_rider ] ) [ x ] ) ;
7098: LD_EXP 36
7102: PUSH
7103: LD_INT 1
7105: ARRAY
7106: PUSH
7107: LD_INT 1
7109: ARRAY
7110: PPUSH
7111: LD_INT 33
7113: PUSH
7114: LD_INT 4
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_VAR 0 4
7130: ARRAY
7131: PPUSH
7132: CALL_OW 52
// x := x + 1 ;
7136: LD_ADDR_VAR 0 4
7140: PUSH
7141: LD_VAR 0 4
7145: PUSH
7146: LD_INT 1
7148: PLUS
7149: ST_TO_ADDR
// end else
7150: GO 7201
// PlaceUnitXYR ( sup_attack [ 1 ] [ 1 ] , sup_attack [ 1 ] [ 2 ] , sup_attack [ 1 ] [ 3 ] , 8 , false ) ;
7152: LD_EXP 36
7156: PUSH
7157: LD_INT 1
7159: ARRAY
7160: PUSH
7161: LD_INT 1
7163: ARRAY
7164: PPUSH
7165: LD_EXP 36
7169: PUSH
7170: LD_INT 1
7172: ARRAY
7173: PUSH
7174: LD_INT 2
7176: ARRAY
7177: PPUSH
7178: LD_EXP 36
7182: PUSH
7183: LD_INT 1
7185: ARRAY
7186: PUSH
7187: LD_INT 3
7189: ARRAY
7190: PPUSH
7191: LD_INT 8
7193: PPUSH
7194: LD_INT 0
7196: PPUSH
7197: CALL_OW 50
// attackers := attackers ^ sup_attack [ 1 ] [ 1 ] ;
7201: LD_ADDR_EXP 20
7205: PUSH
7206: LD_EXP 20
7210: PUSH
7211: LD_EXP 36
7215: PUSH
7216: LD_INT 1
7218: ARRAY
7219: PUSH
7220: LD_INT 1
7222: ARRAY
7223: ADD
7224: ST_TO_ADDR
// sup_attack := Delete ( sup_attack , 1 ) ;
7225: LD_ADDR_EXP 36
7229: PUSH
7230: LD_EXP 36
7234: PPUSH
7235: LD_INT 1
7237: PPUSH
7238: CALL_OW 3
7242: ST_TO_ADDR
// end ;
7243: GO 7072
7245: POP
7246: POP
// end ; end ;
7247: PPOPN 4
7249: END
// every 0 0$01 trigger game_start and tick >= 20 20$00 do
7250: LD_EXP 9
7254: PUSH
7255: LD_OWVAR 1
7259: PUSH
7260: LD_INT 42000
7262: GREATEREQUAL
7263: AND
7264: IFFALSE 7283
7266: GO 7268
7268: DISABLE
// begin veh_counter := veh_counter + 1 ;
7269: LD_ADDR_EXP 22
7273: PUSH
7274: LD_EXP 22
7278: PUSH
7279: LD_INT 1
7281: PLUS
7282: ST_TO_ADDR
// end ;
7283: END
// every 0 0$01 trigger game_start and tick >= 40 40$00 do
7284: LD_EXP 9
7288: PUSH
7289: LD_OWVAR 1
7293: PUSH
7294: LD_INT 84000
7296: GREATEREQUAL
7297: AND
7298: IFFALSE 7317
7300: GO 7302
7302: DISABLE
// begin veh_counter := veh_counter + 2 ;
7303: LD_ADDR_EXP 22
7307: PUSH
7308: LD_EXP 22
7312: PUSH
7313: LD_INT 2
7315: PLUS
7316: ST_TO_ADDR
// end ;
7317: END
// every 0 0$01 trigger game_start and tick >= 60 60$00 do
7318: LD_EXP 9
7322: PUSH
7323: LD_OWVAR 1
7327: PUSH
7328: LD_INT 126000
7330: GREATEREQUAL
7331: AND
7332: IFFALSE 7351
7334: GO 7336
7336: DISABLE
// begin veh_counter := veh_counter + 3 ;
7337: LD_ADDR_EXP 22
7341: PUSH
7342: LD_EXP 22
7346: PUSH
7347: LD_INT 3
7349: PLUS
7350: ST_TO_ADDR
// end ;
7351: END
// every 0 0$03 trigger FilterUnitsInArea ( bridge2_protect , [ f_enemy , bot_side ] ) do var i ;
7352: LD_INT 24
7354: PPUSH
7355: LD_INT 81
7357: PUSH
7358: LD_EXP 8
7362: PUSH
7363: EMPTY
7364: LIST
7365: LIST
7366: PPUSH
7367: CALL_OW 70
7371: IFFALSE 7419
7373: GO 7375
7375: DISABLE
7376: LD_INT 0
7378: PPUSH
// begin for i = 1 to river_guard do
7379: LD_ADDR_VAR 0 1
7383: PUSH
7384: DOUBLE
7385: LD_INT 1
7387: DEC
7388: ST_TO_ADDR
7389: LD_EXP 33
7393: PUSH
7394: FOR_TO
7395: IFFALSE 7417
// ComMoveToArea ( river_guard [ i ] , bridge2_protect ) ;
7397: LD_EXP 33
7401: PUSH
7402: LD_VAR 0 1
7406: ARRAY
7407: PPUSH
7408: LD_INT 24
7410: PPUSH
7411: CALL_OW 113
7415: GO 7394
7417: POP
7418: POP
// end ;
7419: PPOPN 1
7421: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
7422: LD_INT 22
7424: PUSH
7425: LD_EXP 8
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: PUSH
7434: LD_INT 33
7436: PUSH
7437: LD_INT 2
7439: PUSH
7440: EMPTY
7441: LIST
7442: LIST
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PPUSH
7448: CALL_OW 69
7452: IFFALSE 7668
7454: GO 7456
7456: DISABLE
7457: LD_INT 0
7459: PPUSH
7460: PPUSH
7461: PPUSH
7462: PPUSH
7463: PPUSH
7464: PPUSH
7465: PPUSH
// begin enable ;
7466: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
7467: LD_ADDR_VAR 0 4
7471: PUSH
7472: LD_INT 22
7474: PUSH
7475: LD_EXP 8
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PUSH
7484: LD_INT 33
7486: PUSH
7487: LD_INT 2
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 3
7496: PUSH
7497: LD_INT 61
7499: PUSH
7500: EMPTY
7501: LIST
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: EMPTY
7508: LIST
7509: LIST
7510: LIST
7511: PPUSH
7512: CALL_OW 69
7516: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
7517: LD_ADDR_VAR 0 3
7521: PUSH
7522: LD_INT 22
7524: PUSH
7525: LD_EXP 8
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PUSH
7534: LD_INT 34
7536: PUSH
7537: LD_INT 31
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PPUSH
7548: CALL_OW 69
7552: ST_TO_ADDR
// best := 10 ;
7553: LD_ADDR_VAR 0 5
7557: PUSH
7558: LD_INT 10
7560: ST_TO_ADDR
// best_mechanic := - 1 ;
7561: LD_ADDR_VAR 0 6
7565: PUSH
7566: LD_INT 1
7568: NEG
7569: ST_TO_ADDR
// if vehs then
7570: LD_VAR 0 4
7574: IFFALSE 7668
// begin for j in cts do
7576: LD_ADDR_VAR 0 2
7580: PUSH
7581: LD_VAR 0 3
7585: PUSH
7586: FOR_IN
7587: IFFALSE 7648
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
7589: LD_ADDR_VAR 0 7
7593: PUSH
7594: LD_VAR 0 2
7598: PPUSH
7599: CALL 10940 0 1
7603: PPUSH
7604: CALL_OW 432
7608: ST_TO_ADDR
// if p < best then
7609: LD_VAR 0 7
7613: PUSH
7614: LD_VAR 0 5
7618: LESS
7619: IFFALSE 7646
// begin best := p ;
7621: LD_ADDR_VAR 0 5
7625: PUSH
7626: LD_VAR 0 7
7630: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
7631: LD_ADDR_VAR 0 6
7635: PUSH
7636: LD_VAR 0 2
7640: PPUSH
7641: CALL 10940 0 1
7645: ST_TO_ADDR
// end ; end ;
7646: GO 7586
7648: POP
7649: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
7650: LD_VAR 0 4
7654: PUSH
7655: LD_INT 1
7657: ARRAY
7658: PPUSH
7659: LD_VAR 0 6
7663: PPUSH
7664: CALL_OW 135
// end ; end ;
7668: PPOPN 7
7670: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
7671: GO 7673
7673: DISABLE
7674: LD_INT 0
7676: PPUSH
7677: PPUSH
7678: PPUSH
7679: PPUSH
7680: PPUSH
7681: PPUSH
7682: PPUSH
// begin enable ;
7683: ENABLE
// b := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7684: LD_ADDR_VAR 0 6
7688: PUSH
7689: LD_INT 17
7691: PPUSH
7692: LD_INT 22
7694: PUSH
7695: LD_EXP 8
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 21
7706: PUSH
7707: LD_INT 3
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: LD_INT 3
7716: PUSH
7717: LD_INT 24
7719: PUSH
7720: LD_INT 1000
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: LIST
7735: PPUSH
7736: CALL_OW 70
7740: ST_TO_ADDR
// h := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
7741: LD_ADDR_VAR 0 3
7745: PUSH
7746: LD_INT 17
7748: PPUSH
7749: LD_INT 22
7751: PUSH
7752: LD_EXP 8
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: PUSH
7761: LD_INT 2
7763: PUSH
7764: LD_INT 25
7766: PUSH
7767: LD_INT 1
7769: PUSH
7770: EMPTY
7771: LIST
7772: LIST
7773: PUSH
7774: LD_INT 25
7776: PUSH
7777: LD_INT 2
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: PUSH
7784: LD_INT 25
7786: PUSH
7787: LD_INT 3
7789: PUSH
7790: EMPTY
7791: LIST
7792: LIST
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: LIST
7798: LIST
7799: PUSH
7800: LD_INT 3
7802: PUSH
7803: LD_INT 24
7805: PUSH
7806: LD_INT 750
7808: PUSH
7809: EMPTY
7810: LIST
7811: LIST
7812: PUSH
7813: EMPTY
7814: LIST
7815: LIST
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: LIST
7821: PPUSH
7822: CALL_OW 70
7826: ST_TO_ADDR
// sci := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ^ UnitsInside ( ar_lab_main ) ;
7827: LD_ADDR_VAR 0 4
7831: PUSH
7832: LD_INT 17
7834: PPUSH
7835: LD_INT 22
7837: PUSH
7838: LD_EXP 8
7842: PUSH
7843: EMPTY
7844: LIST
7845: LIST
7846: PUSH
7847: LD_INT 25
7849: PUSH
7850: LD_INT 4
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PPUSH
7861: CALL_OW 70
7865: PUSH
7866: LD_INT 82
7868: PPUSH
7869: CALL_OW 313
7873: ADD
7874: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
7875: LD_ADDR_VAR 0 5
7879: PUSH
7880: LD_INT 22
7882: PUSH
7883: LD_EXP 8
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 25
7894: PUSH
7895: LD_INT 2
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: PPUSH
7906: CALL_OW 69
7910: ST_TO_ADDR
// if not h and not b then
7911: LD_VAR 0 3
7915: NOT
7916: PUSH
7917: LD_VAR 0 6
7921: NOT
7922: AND
7923: IFFALSE 8219
// begin if sci then
7925: LD_VAR 0 4
7929: IFFALSE 8072
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
7931: LD_VAR 0 4
7935: PPUSH
7936: LD_INT 3
7938: PUSH
7939: LD_INT 54
7941: PUSH
7942: EMPTY
7943: LIST
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PPUSH
7949: CALL_OW 72
7953: PUSH
7954: LD_INT 17
7956: PPUSH
7957: LD_INT 22
7959: PUSH
7960: LD_EXP 8
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: PUSH
7969: LD_INT 30
7971: PUSH
7972: LD_INT 8
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: PPUSH
7983: CALL_OW 70
7987: AND
7988: IFFALSE 8072
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
7990: LD_ADDR_VAR 0 2
7994: PUSH
7995: LD_VAR 0 4
7999: PPUSH
8000: LD_INT 3
8002: PUSH
8003: LD_INT 54
8005: PUSH
8006: EMPTY
8007: LIST
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: PUSH
8018: FOR_IN
8019: IFFALSE 8070
// ComEnterUnit ( j , FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
8021: LD_VAR 0 2
8025: PPUSH
8026: LD_INT 17
8028: PPUSH
8029: LD_INT 22
8031: PUSH
8032: LD_EXP 8
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: LD_INT 30
8043: PUSH
8044: LD_INT 8
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PPUSH
8055: CALL_OW 70
8059: PUSH
8060: LD_INT 1
8062: ARRAY
8063: PPUSH
8064: CALL_OW 120
8068: GO 8018
8070: POP
8071: POP
// if eng then
8072: LD_VAR 0 5
8076: IFFALSE 8219
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
8078: LD_VAR 0 5
8082: PPUSH
8083: LD_INT 3
8085: PUSH
8086: LD_INT 54
8088: PUSH
8089: EMPTY
8090: LIST
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PPUSH
8096: CALL_OW 72
8100: PUSH
8101: LD_INT 17
8103: PPUSH
8104: LD_INT 22
8106: PUSH
8107: LD_EXP 8
8111: PUSH
8112: EMPTY
8113: LIST
8114: LIST
8115: PUSH
8116: LD_INT 30
8118: PUSH
8119: LD_INT 1
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: PUSH
8126: EMPTY
8127: LIST
8128: LIST
8129: PPUSH
8130: CALL_OW 70
8134: AND
8135: IFFALSE 8219
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
8137: LD_ADDR_VAR 0 2
8141: PUSH
8142: LD_VAR 0 5
8146: PPUSH
8147: LD_INT 3
8149: PUSH
8150: LD_INT 54
8152: PUSH
8153: EMPTY
8154: LIST
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PPUSH
8160: CALL_OW 72
8164: PUSH
8165: FOR_IN
8166: IFFALSE 8217
// ComEnterUnit ( j , FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
8168: LD_VAR 0 2
8172: PPUSH
8173: LD_INT 17
8175: PPUSH
8176: LD_INT 22
8178: PUSH
8179: LD_EXP 8
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: PUSH
8188: LD_INT 30
8190: PUSH
8191: LD_INT 1
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: PUSH
8198: EMPTY
8199: LIST
8200: LIST
8201: PPUSH
8202: CALL_OW 70
8206: PUSH
8207: LD_INT 1
8209: ARRAY
8210: PPUSH
8211: CALL_OW 120
8215: GO 8165
8217: POP
8218: POP
// end ; p := 1 ;
8219: LD_ADDR_VAR 0 7
8223: PUSH
8224: LD_INT 1
8226: ST_TO_ADDR
// if b and eng then
8227: LD_VAR 0 6
8231: PUSH
8232: LD_VAR 0 5
8236: AND
8237: IFFALSE 8371
// for j in eng do
8239: LD_ADDR_VAR 0 2
8243: PUSH
8244: LD_VAR 0 5
8248: PUSH
8249: FOR_IN
8250: IFFALSE 8369
// begin if IsInUnit ( j ) then
8252: LD_VAR 0 2
8256: PPUSH
8257: CALL_OW 310
8261: IFFALSE 8274
// ComExitBuilding ( j ) else
8263: LD_VAR 0 2
8267: PPUSH
8268: CALL_OW 122
8272: GO 8367
// if not HasTask ( j ) and GetLives ( j ) > 750 then
8274: LD_VAR 0 2
8278: PPUSH
8279: CALL_OW 314
8283: NOT
8284: PUSH
8285: LD_VAR 0 2
8289: PPUSH
8290: CALL_OW 256
8294: PUSH
8295: LD_INT 750
8297: GREATER
8298: AND
8299: IFFALSE 8367
// begin if b > p then
8301: LD_VAR 0 6
8305: PUSH
8306: LD_VAR 0 7
8310: GREATER
8311: IFFALSE 8349
// begin ComRepairBuilding ( j , b [ p ] ) ;
8313: LD_VAR 0 2
8317: PPUSH
8318: LD_VAR 0 6
8322: PUSH
8323: LD_VAR 0 7
8327: ARRAY
8328: PPUSH
8329: CALL_OW 130
// p := p + 1 ;
8333: LD_ADDR_VAR 0 7
8337: PUSH
8338: LD_VAR 0 7
8342: PUSH
8343: LD_INT 1
8345: PLUS
8346: ST_TO_ADDR
// end else
8347: GO 8367
// ComRepairBuilding ( j , b [ 1 ] ) ;
8349: LD_VAR 0 2
8353: PPUSH
8354: LD_VAR 0 6
8358: PUSH
8359: LD_INT 1
8361: ARRAY
8362: PPUSH
8363: CALL_OW 130
// end ; end ;
8367: GO 8249
8369: POP
8370: POP
// if h and sci then
8371: LD_VAR 0 3
8375: PUSH
8376: LD_VAR 0 4
8380: AND
8381: IFFALSE 8520
// for i in h do
8383: LD_ADDR_VAR 0 1
8387: PUSH
8388: LD_VAR 0 3
8392: PUSH
8393: FOR_IN
8394: IFFALSE 8518
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
8396: LD_VAR 0 1
8400: PPUSH
8401: LD_INT 108
8403: PPUSH
8404: LD_INT 42
8406: PPUSH
8407: CALL_OW 297
8411: PUSH
8412: LD_INT 10
8414: GREATER
8415: IFFALSE 8434
// ComMoveXY ( i , 108 , 42 ) else
8417: LD_VAR 0 1
8421: PPUSH
8422: LD_INT 108
8424: PPUSH
8425: LD_INT 42
8427: PPUSH
8428: CALL_OW 111
8432: GO 8516
// begin for j in sci do
8434: LD_ADDR_VAR 0 2
8438: PUSH
8439: LD_VAR 0 4
8443: PUSH
8444: FOR_IN
8445: IFFALSE 8514
// begin if GetTag ( j ) > 0 then
8447: LD_VAR 0 2
8451: PPUSH
8452: CALL_OW 110
8456: PUSH
8457: LD_INT 0
8459: GREATER
8460: IFFALSE 8464
// continue ;
8462: GO 8444
// if IsInUnit ( j ) then
8464: LD_VAR 0 2
8468: PPUSH
8469: CALL_OW 310
8473: IFFALSE 8486
// ComExitBuilding ( j ) else
8475: LD_VAR 0 2
8479: PPUSH
8480: CALL_OW 122
8484: GO 8512
// if not HasTask ( j ) then
8486: LD_VAR 0 2
8490: PPUSH
8491: CALL_OW 314
8495: NOT
8496: IFFALSE 8512
// ComHeal ( j , h ) ;
8498: LD_VAR 0 2
8502: PPUSH
8503: LD_VAR 0 3
8507: PPUSH
8508: CALL_OW 128
// end ;
8512: GO 8444
8514: POP
8515: POP
// end ;
8516: GO 8393
8518: POP
8519: POP
// end ;
8520: PPOPN 7
8522: END
// every 0 0$01 trigger mines_list do var i , p ;
8523: LD_EXP 17
8527: IFFALSE 8753
8529: GO 8531
8531: DISABLE
8532: LD_INT 0
8534: PPUSH
8535: PPUSH
// begin enable ;
8536: ENABLE
// p := 1 ;
8537: LD_ADDR_VAR 0 2
8541: PUSH
8542: LD_INT 1
8544: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
8545: LD_ADDR_VAR 0 1
8549: PUSH
8550: DOUBLE
8551: LD_INT 1
8553: DEC
8554: ST_TO_ADDR
8555: LD_EXP 17
8559: PUSH
8560: LD_INT 2
8562: DIVREAL
8563: PUSH
8564: FOR_TO
8565: IFFALSE 8751
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
8567: LD_EXP 17
8571: PUSH
8572: LD_VAR 0 2
8576: ARRAY
8577: PPUSH
8578: LD_EXP 17
8582: PUSH
8583: LD_VAR 0 2
8587: PUSH
8588: LD_INT 1
8590: PLUS
8591: ARRAY
8592: PPUSH
8593: CALL_OW 428
8597: PUSH
8598: LD_INT 0
8600: GREATER
8601: IFFALSE 8735
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
8603: LD_EXP 17
8607: PUSH
8608: LD_VAR 0 2
8612: ARRAY
8613: PPUSH
8614: LD_EXP 17
8618: PUSH
8619: LD_VAR 0 2
8623: PUSH
8624: LD_INT 1
8626: PLUS
8627: ARRAY
8628: PPUSH
8629: CALL_OW 428
8633: PPUSH
8634: CALL_OW 255
8638: PUSH
8639: LD_EXP 8
8643: NONEQUAL
8644: IFFALSE 8735
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
8646: LD_EXP 17
8650: PUSH
8651: LD_VAR 0 2
8655: ARRAY
8656: PPUSH
8657: LD_EXP 17
8661: PUSH
8662: LD_VAR 0 2
8666: PUSH
8667: LD_INT 1
8669: PLUS
8670: ARRAY
8671: PPUSH
8672: LD_EXP 8
8676: PPUSH
8677: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
8681: LD_ADDR_EXP 17
8685: PUSH
8686: LD_EXP 17
8690: PPUSH
8691: LD_VAR 0 2
8695: PPUSH
8696: CALL_OW 3
8700: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
8701: LD_ADDR_EXP 17
8705: PUSH
8706: LD_EXP 17
8710: PPUSH
8711: LD_VAR 0 2
8715: PPUSH
8716: CALL_OW 3
8720: ST_TO_ADDR
// p := p - 2 ;
8721: LD_ADDR_VAR 0 2
8725: PUSH
8726: LD_VAR 0 2
8730: PUSH
8731: LD_INT 2
8733: MINUS
8734: ST_TO_ADDR
// end ; p := p + 2 ;
8735: LD_ADDR_VAR 0 2
8739: PUSH
8740: LD_VAR 0 2
8744: PUSH
8745: LD_INT 2
8747: PLUS
8748: ST_TO_ADDR
// end ;
8749: GO 8564
8751: POP
8752: POP
// end ;
8753: PPOPN 2
8755: END
// every 13 13$00 trigger FilterAllUnits ( [ [ f_enemy , bot_side ] , [ f_type , unit_building ] ] ) and apek do var i ;
8756: LD_INT 81
8758: PUSH
8759: LD_EXP 8
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: LD_INT 21
8770: PUSH
8771: LD_INT 3
8773: PUSH
8774: EMPTY
8775: LIST
8776: LIST
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PPUSH
8782: CALL_OW 69
8786: PUSH
8787: LD_EXP 34
8791: AND
8792: IFFALSE 8908
8794: GO 8796
8796: DISABLE
8797: LD_INT 0
8799: PPUSH
// begin enable ;
8800: ENABLE
// for i = 1 to 3 do
8801: LD_ADDR_VAR 0 1
8805: PUSH
8806: DOUBLE
8807: LD_INT 1
8809: DEC
8810: ST_TO_ADDR
8811: LD_INT 3
8813: PUSH
8814: FOR_TO
8815: IFFALSE 8906
// begin PlaceUnitArea ( apek [ i ] , ape_kami , false ) ;
8817: LD_EXP 34
8821: PUSH
8822: LD_VAR 0 1
8826: ARRAY
8827: PPUSH
8828: LD_INT 25
8830: PPUSH
8831: LD_INT 0
8833: PPUSH
8834: CALL_OW 49
// ComAttackUnit ( apek [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , apek [ i ] ) ) ;
8838: LD_EXP 34
8842: PUSH
8843: LD_VAR 0 1
8847: ARRAY
8848: PPUSH
8849: LD_INT 81
8851: PUSH
8852: LD_EXP 8
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: PPUSH
8861: CALL_OW 69
8865: PPUSH
8866: LD_EXP 34
8870: PUSH
8871: LD_VAR 0 1
8875: ARRAY
8876: PPUSH
8877: CALL_OW 74
8881: PPUSH
8882: CALL_OW 115
// apek := Delete ( apek , 1 ) ;
8886: LD_ADDR_EXP 34
8890: PUSH
8891: LD_EXP 34
8895: PPUSH
8896: LD_INT 1
8898: PPUSH
8899: CALL_OW 3
8903: ST_TO_ADDR
// end ;
8904: GO 8814
8906: POP
8907: POP
// end ;
8908: PPOPN 1
8910: END
// every 0 0$02 trigger GetSide ( ar_base_nort ) <> bot_side do
8911: LD_INT 55
8913: PPUSH
8914: CALL_OW 255
8918: PUSH
8919: LD_EXP 8
8923: NONEQUAL
8924: IFFALSE 9044
8926: GO 8928
8928: DISABLE
// begin MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
8929: LD_INT 55
8931: PPUSH
8932: CALL_OW 250
8936: PPUSH
8937: LD_INT 55
8939: PPUSH
8940: CALL_OW 251
8944: PPUSH
8945: LD_INT 1
8947: PPUSH
8948: CALL_OW 453
// MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
8952: LD_INT 55
8954: PPUSH
8955: CALL_OW 250
8959: PPUSH
8960: LD_INT 55
8962: PPUSH
8963: CALL_OW 251
8967: PPUSH
8968: LD_INT 1
8970: PPUSH
8971: CALL_OW 453
// MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
8975: LD_INT 55
8977: PPUSH
8978: CALL_OW 250
8982: PPUSH
8983: LD_INT 55
8985: PPUSH
8986: CALL_OW 251
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: CALL_OW 453
// MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
8998: LD_INT 55
9000: PPUSH
9001: CALL_OW 250
9005: PPUSH
9006: LD_INT 55
9008: PPUSH
9009: CALL_OW 251
9013: PPUSH
9014: LD_INT 1
9016: PPUSH
9017: CALL_OW 453
// MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
9021: LD_INT 55
9023: PPUSH
9024: CALL_OW 250
9028: PPUSH
9029: LD_INT 55
9031: PPUSH
9032: CALL_OW 251
9036: PPUSH
9037: LD_INT 1
9039: PPUSH
9040: CALL_OW 453
// end ;
9044: END
// every 0 0$03 do var i , p , skr , filter , dep ;
9045: GO 9047
9047: DISABLE
9048: LD_INT 0
9050: PPUSH
9051: PPUSH
9052: PPUSH
9053: PPUSH
9054: PPUSH
// begin enable ;
9055: ENABLE
// if not ar_collectors then
9056: LD_EXP 35
9060: NOT
9061: IFFALSE 9108
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) else
9063: LD_ADDR_VAR 0 4
9067: PUSH
9068: LD_INT 50
9070: PUSH
9071: EMPTY
9072: LIST
9073: PUSH
9074: LD_INT 22
9076: PUSH
9077: LD_EXP 8
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: PUSH
9086: LD_INT 25
9088: PUSH
9089: LD_INT 16
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: PUSH
9096: EMPTY
9097: LIST
9098: LIST
9099: LIST
9100: PPUSH
9101: CALL_OW 69
9105: ST_TO_ADDR
9106: GO 9118
// filter := ar_collectors ;
9108: LD_ADDR_VAR 0 4
9112: PUSH
9113: LD_EXP 35
9117: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9118: LD_ADDR_VAR 0 5
9122: PUSH
9123: LD_INT 22
9125: PUSH
9126: LD_EXP 8
9130: PUSH
9131: EMPTY
9132: LIST
9133: LIST
9134: PUSH
9135: LD_INT 2
9137: PUSH
9138: LD_INT 30
9140: PUSH
9141: LD_INT 0
9143: PUSH
9144: EMPTY
9145: LIST
9146: LIST
9147: PUSH
9148: LD_INT 30
9150: PUSH
9151: LD_INT 1
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL_OW 69
9171: ST_TO_ADDR
// skr := GetListOfCratesInArea ( collect_crates ) ;
9172: LD_ADDR_VAR 0 3
9176: PUSH
9177: LD_INT 15
9179: PPUSH
9180: CALL_OW 435
9184: ST_TO_ADDR
// if not filter then
9185: LD_VAR 0 4
9189: NOT
9190: IFFALSE 9194
// exit ;
9192: GO 9261
// if filter and skr then
9194: LD_VAR 0 4
9198: PUSH
9199: LD_VAR 0 3
9203: AND
9204: IFFALSE 9261
// for i = 1 to filter do
9206: LD_ADDR_VAR 0 1
9210: PUSH
9211: DOUBLE
9212: LD_INT 1
9214: DEC
9215: ST_TO_ADDR
9216: LD_VAR 0 4
9220: PUSH
9221: FOR_TO
9222: IFFALSE 9259
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
9224: LD_VAR 0 4
9228: PUSH
9229: LD_VAR 0 1
9233: ARRAY
9234: PPUSH
9235: LD_VAR 0 3
9239: PUSH
9240: LD_INT 1
9242: ARRAY
9243: PPUSH
9244: LD_VAR 0 3
9248: PUSH
9249: LD_INT 2
9251: ARRAY
9252: PPUSH
9253: CALL_OW 117
9257: GO 9221
9259: POP
9260: POP
// end ; end_of_file
9261: PPOPN 5
9263: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
9264: LD_INT 0
9266: PPUSH
9267: PPUSH
9268: PPUSH
9269: PPUSH
9270: PPUSH
9271: PPUSH
9272: PPUSH
9273: PPUSH
9274: PPUSH
// to_copy := [ ] ;
9275: LD_ADDR_VAR 0 5
9279: PUSH
9280: EMPTY
9281: ST_TO_ADDR
// for i = 1 to 8 do
9282: LD_ADDR_VAR 0 2
9286: PUSH
9287: DOUBLE
9288: LD_INT 1
9290: DEC
9291: ST_TO_ADDR
9292: LD_INT 8
9294: PUSH
9295: FOR_TO
9296: IFFALSE 10495
// begin if Side_Positions [ i ] then
9298: LD_EXP 2
9302: PUSH
9303: LD_VAR 0 2
9307: ARRAY
9308: IFFALSE 10493
// begin uc_side := i ;
9310: LD_ADDR_OWVAR 20
9314: PUSH
9315: LD_VAR 0 2
9319: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
9320: LD_ADDR_OWVAR 21
9324: PUSH
9325: LD_EXP 4
9329: PUSH
9330: LD_VAR 0 2
9334: ARRAY
9335: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
9336: LD_ADDR_VAR 0 6
9340: PUSH
9341: LD_EXP 7
9345: PUSH
9346: LD_EXP 2
9350: PUSH
9351: LD_VAR 0 2
9355: ARRAY
9356: ARRAY
9357: PUSH
9358: LD_INT 1
9360: ARRAY
9361: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
9362: LD_ADDR_VAR 0 7
9366: PUSH
9367: LD_EXP 7
9371: PUSH
9372: LD_EXP 2
9376: PUSH
9377: LD_VAR 0 2
9381: ARRAY
9382: ARRAY
9383: PUSH
9384: LD_INT 2
9386: ARRAY
9387: ST_TO_ADDR
// hc_importance := 100 ;
9388: LD_ADDR_OWVAR 32
9392: PUSH
9393: LD_INT 100
9395: ST_TO_ADDR
// if Multiplayer then
9396: LD_OWVAR 4
9400: IFFALSE 9458
// begin hc_name := mp_sides_players_names [ uc_side ] ;
9402: LD_ADDR_OWVAR 26
9406: PUSH
9407: LD_OWVAR 19
9411: PUSH
9412: LD_OWVAR 20
9416: ARRAY
9417: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
9418: LD_ADDR_OWVAR 33
9422: PUSH
9423: LD_STRING MULTIAVATARS
9425: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
9426: LD_ADDR_OWVAR 34
9430: PUSH
9431: LD_OWVAR 20
9435: PPUSH
9436: CALL_OW 525
9440: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
9441: LD_ADDR_OWVAR 27
9445: PUSH
9446: LD_OWVAR 20
9450: PPUSH
9451: CALL_OW 526
9455: ST_TO_ADDR
// end else
9456: GO 9490
// begin hc_name :=  ;
9458: LD_ADDR_OWVAR 26
9462: PUSH
9463: LD_STRING 
9465: ST_TO_ADDR
// hc_gallery :=  ;
9466: LD_ADDR_OWVAR 33
9470: PUSH
9471: LD_STRING 
9473: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
9474: LD_ADDR_OWVAR 27
9478: PUSH
9479: LD_INT 1
9481: PPUSH
9482: LD_INT 2
9484: PPUSH
9485: CALL_OW 12
9489: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
9490: LD_OWVAR 27
9494: PPUSH
9495: LD_INT 1
9497: PPUSH
9498: LD_EXP 11
9502: PPUSH
9503: CALL_OW 380
// un := CreateHuman ;
9507: LD_ADDR_VAR 0 4
9511: PUSH
9512: CALL_OW 44
9516: ST_TO_ADDR
// if not to_copy then
9517: LD_VAR 0 5
9521: NOT
9522: IFFALSE 9549
// to_copy := Replace ( to_copy , 1 , un ) else
9524: LD_ADDR_VAR 0 5
9528: PUSH
9529: LD_VAR 0 5
9533: PPUSH
9534: LD_INT 1
9536: PPUSH
9537: LD_VAR 0 4
9541: PPUSH
9542: CALL_OW 1
9546: ST_TO_ADDR
9547: GO 9625
// begin CopySkills ( to_copy [ 1 ] , un ) ;
9549: LD_VAR 0 5
9553: PUSH
9554: LD_INT 1
9556: ARRAY
9557: PPUSH
9558: LD_VAR 0 4
9562: PPUSH
9563: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
9567: LD_VAR 0 4
9571: PPUSH
9572: LD_INT 2
9574: PPUSH
9575: LD_VAR 0 5
9579: PUSH
9580: LD_INT 1
9582: ARRAY
9583: PPUSH
9584: LD_INT 2
9586: PPUSH
9587: CALL_OW 260
9591: PPUSH
9592: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
9596: LD_VAR 0 4
9600: PPUSH
9601: LD_INT 1
9603: PPUSH
9604: LD_VAR 0 5
9608: PUSH
9609: LD_INT 1
9611: ARRAY
9612: PPUSH
9613: LD_INT 1
9615: PPUSH
9616: CALL_OW 260
9620: PPUSH
9621: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
9625: LD_VAR 0 4
9629: PPUSH
9630: LD_VAR 0 6
9634: PPUSH
9635: LD_VAR 0 7
9639: PPUSH
9640: LD_INT 10
9642: PPUSH
9643: LD_INT 0
9645: PPUSH
9646: CALL_OW 50
// hc_importance := 0 ;
9650: LD_ADDR_OWVAR 32
9654: PUSH
9655: LD_INT 0
9657: ST_TO_ADDR
// hc_name :=  ;
9658: LD_ADDR_OWVAR 26
9662: PUSH
9663: LD_STRING 
9665: ST_TO_ADDR
// hc_gallery :=  ;
9666: LD_ADDR_OWVAR 33
9670: PUSH
9671: LD_STRING 
9673: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
9674: LD_ADDR_VAR 0 9
9678: PUSH
9679: LD_EXP 10
9683: PUSH
9684: LD_INT 1
9686: MINUS
9687: PUSH
9688: LD_INT 4
9690: DIVREAL
9691: ST_TO_ADDR
// c := 1 ;
9692: LD_ADDR_VAR 0 8
9696: PUSH
9697: LD_INT 1
9699: ST_TO_ADDR
// for j = 2 to number_of_people do
9700: LD_ADDR_VAR 0 3
9704: PUSH
9705: DOUBLE
9706: LD_INT 2
9708: DEC
9709: ST_TO_ADDR
9710: LD_EXP 10
9714: PUSH
9715: FOR_TO
9716: IFFALSE 9964
// begin PrepareHuman ( false , c , skill_level ) ;
9718: LD_INT 0
9720: PPUSH
9721: LD_VAR 0 8
9725: PPUSH
9726: LD_EXP 11
9730: PPUSH
9731: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
9735: LD_VAR 0 3
9739: PUSH
9740: LD_INT 1
9742: MINUS
9743: PUSH
9744: LD_VAR 0 9
9748: MOD
9749: PUSH
9750: LD_INT 0
9752: EQUAL
9753: IFFALSE 9769
// c := c + 1 ;
9755: LD_ADDR_VAR 0 8
9759: PUSH
9760: LD_VAR 0 8
9764: PUSH
9765: LD_INT 1
9767: PLUS
9768: ST_TO_ADDR
// un := CreateHuman ;
9769: LD_ADDR_VAR 0 4
9773: PUSH
9774: CALL_OW 44
9778: ST_TO_ADDR
// if to_copy < j then
9779: LD_VAR 0 5
9783: PUSH
9784: LD_VAR 0 3
9788: LESS
9789: IFFALSE 9818
// to_copy := Replace ( to_copy , j , un ) else
9791: LD_ADDR_VAR 0 5
9795: PUSH
9796: LD_VAR 0 5
9800: PPUSH
9801: LD_VAR 0 3
9805: PPUSH
9806: LD_VAR 0 4
9810: PPUSH
9811: CALL_OW 1
9815: ST_TO_ADDR
9816: GO 9900
// begin CopySkills ( to_copy [ j ] , un ) ;
9818: LD_VAR 0 5
9822: PUSH
9823: LD_VAR 0 3
9827: ARRAY
9828: PPUSH
9829: LD_VAR 0 4
9833: PPUSH
9834: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
9838: LD_VAR 0 4
9842: PPUSH
9843: LD_INT 2
9845: PPUSH
9846: LD_VAR 0 5
9850: PUSH
9851: LD_VAR 0 3
9855: ARRAY
9856: PPUSH
9857: LD_INT 2
9859: PPUSH
9860: CALL_OW 260
9864: PPUSH
9865: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
9869: LD_VAR 0 4
9873: PPUSH
9874: LD_INT 1
9876: PPUSH
9877: LD_VAR 0 5
9881: PUSH
9882: LD_VAR 0 3
9886: ARRAY
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: CALL_OW 260
9895: PPUSH
9896: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
9900: LD_VAR 0 4
9904: PPUSH
9905: LD_VAR 0 6
9909: PPUSH
9910: LD_VAR 0 7
9914: PPUSH
9915: LD_INT 10
9917: PPUSH
9918: LD_INT 0
9920: PPUSH
9921: CALL_OW 50
// if GetClass ( un ) = 3 and handicap < 2 then
9925: LD_VAR 0 4
9929: PPUSH
9930: CALL_OW 257
9934: PUSH
9935: LD_INT 3
9937: EQUAL
9938: PUSH
9939: LD_EXP 26
9943: PUSH
9944: LD_INT 2
9946: LESS
9947: AND
9948: IFFALSE 9962
// SetClass ( un , 1 ) ;
9950: LD_VAR 0 4
9954: PPUSH
9955: LD_INT 1
9957: PPUSH
9958: CALL_OW 336
// end ;
9962: GO 9715
9964: POP
9965: POP
// if handicap then
9966: LD_EXP 26
9970: IFFALSE 10493
// begin for j = 1 to 2 do
9972: LD_ADDR_VAR 0 3
9976: PUSH
9977: DOUBLE
9978: LD_INT 1
9980: DEC
9981: ST_TO_ADDR
9982: LD_INT 2
9984: PUSH
9985: FOR_TO
9986: IFFALSE 10070
// begin vc_chassis := us_medium_wheeled ;
9988: LD_ADDR_OWVAR 37
9992: PUSH
9993: LD_INT 2
9995: ST_TO_ADDR
// vc_engine := engine_siberite ;
9996: LD_ADDR_OWVAR 39
10000: PUSH
10001: LD_INT 3
10003: ST_TO_ADDR
// vc_control := control_computer ;
10004: LD_ADDR_OWVAR 38
10008: PUSH
10009: LD_INT 3
10011: ST_TO_ADDR
// vc_weapon := us_rocket_launcher ;
10012: LD_ADDR_OWVAR 40
10016: PUSH
10017: LD_INT 7
10019: ST_TO_ADDR
// un := CreateVehicle ;
10020: LD_ADDR_VAR 0 4
10024: PUSH
10025: CALL_OW 45
10029: ST_TO_ADDR
// rforce := Insert ( rforce , 1 , [ un , x , y ] ) ;
10030: LD_ADDR_EXP 27
10034: PUSH
10035: LD_EXP 27
10039: PPUSH
10040: LD_INT 1
10042: PPUSH
10043: LD_VAR 0 4
10047: PUSH
10048: LD_VAR 0 6
10052: PUSH
10053: LD_VAR 0 7
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: LIST
10062: PPUSH
10063: CALL_OW 2
10067: ST_TO_ADDR
// end ;
10068: GO 9985
10070: POP
10071: POP
// vc_chassis := us_medium_wheeled ;
10072: LD_ADDR_OWVAR 37
10076: PUSH
10077: LD_INT 2
10079: ST_TO_ADDR
// vc_engine := engine_siberite ;
10080: LD_ADDR_OWVAR 39
10084: PUSH
10085: LD_INT 3
10087: ST_TO_ADDR
// vc_control := control_computer ;
10088: LD_ADDR_OWVAR 38
10092: PUSH
10093: LD_INT 3
10095: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
10096: LD_ADDR_OWVAR 40
10100: PUSH
10101: LD_INT 12
10103: ST_TO_ADDR
// un := CreateVehicle ;
10104: LD_ADDR_VAR 0 4
10108: PUSH
10109: CALL_OW 45
10113: ST_TO_ADDR
// rforce := Insert ( rforce , 1 , [ un , x , y ] ) ;
10114: LD_ADDR_EXP 27
10118: PUSH
10119: LD_EXP 27
10123: PPUSH
10124: LD_INT 1
10126: PPUSH
10127: LD_VAR 0 4
10131: PUSH
10132: LD_VAR 0 6
10136: PUSH
10137: LD_VAR 0 7
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: LIST
10146: PPUSH
10147: CALL_OW 2
10151: ST_TO_ADDR
// for j = 1 to 3 do
10152: LD_ADDR_VAR 0 3
10156: PUSH
10157: DOUBLE
10158: LD_INT 1
10160: DEC
10161: ST_TO_ADDR
10162: LD_INT 3
10164: PUSH
10165: FOR_TO
10166: IFFALSE 10267
// begin vc_chassis := us_heavy_tracked ;
10168: LD_ADDR_OWVAR 37
10172: PUSH
10173: LD_INT 4
10175: ST_TO_ADDR
// vc_engine := engine_siberite ;
10176: LD_ADDR_OWVAR 39
10180: PUSH
10181: LD_INT 3
10183: ST_TO_ADDR
// vc_control := control_computer ;
10184: LD_ADDR_OWVAR 38
10188: PUSH
10189: LD_INT 3
10191: ST_TO_ADDR
// vc_weapon := [ us_heavy_gun , us_heavy_gun , us_laser ] [ j ] ;
10192: LD_ADDR_OWVAR 40
10196: PUSH
10197: LD_INT 6
10199: PUSH
10200: LD_INT 6
10202: PUSH
10203: LD_INT 9
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: LIST
10210: PUSH
10211: LD_VAR 0 3
10215: ARRAY
10216: ST_TO_ADDR
// un := CreateVehicle ;
10217: LD_ADDR_VAR 0 4
10221: PUSH
10222: CALL_OW 45
10226: ST_TO_ADDR
// rforce2 := Insert ( rforce2 , 1 , [ un , x , y ] ) ;
10227: LD_ADDR_EXP 28
10231: PUSH
10232: LD_EXP 28
10236: PPUSH
10237: LD_INT 1
10239: PPUSH
10240: LD_VAR 0 4
10244: PUSH
10245: LD_VAR 0 6
10249: PUSH
10250: LD_VAR 0 7
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: PPUSH
10260: CALL_OW 2
10264: ST_TO_ADDR
// end ;
10265: GO 10165
10267: POP
10268: POP
// if handicap = 1 then
10269: LD_EXP 26
10273: PUSH
10274: LD_INT 1
10276: EQUAL
10277: IFFALSE 10336
// begin vc_chassis := us_medium_tracked ;
10279: LD_ADDR_OWVAR 37
10283: PUSH
10284: LD_INT 3
10286: ST_TO_ADDR
// vc_engine := engine_solar ;
10287: LD_ADDR_OWVAR 39
10291: PUSH
10292: LD_INT 2
10294: ST_TO_ADDR
// vc_control := control_computer ;
10295: LD_ADDR_OWVAR 38
10299: PUSH
10300: LD_INT 3
10302: ST_TO_ADDR
// vc_weapon := us_radar ;
10303: LD_ADDR_OWVAR 40
10307: PUSH
10308: LD_INT 11
10310: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
10311: CALL_OW 45
10315: PPUSH
10316: LD_VAR 0 6
10320: PPUSH
10321: LD_VAR 0 7
10325: PPUSH
10326: LD_INT 13
10328: PPUSH
10329: LD_INT 0
10331: PPUSH
10332: CALL_OW 50
// end ; if handicap = 2 then
10336: LD_EXP 26
10340: PUSH
10341: LD_INT 2
10343: EQUAL
10344: IFFALSE 10493
// begin for j = 1 to 2 do
10346: LD_ADDR_VAR 0 3
10350: PUSH
10351: DOUBLE
10352: LD_INT 1
10354: DEC
10355: ST_TO_ADDR
10356: LD_INT 2
10358: PUSH
10359: FOR_TO
10360: IFFALSE 10434
// begin vc_chassis := us_medium_tracked ;
10362: LD_ADDR_OWVAR 37
10366: PUSH
10367: LD_INT 3
10369: ST_TO_ADDR
// vc_engine := engine_siberite ;
10370: LD_ADDR_OWVAR 39
10374: PUSH
10375: LD_INT 3
10377: ST_TO_ADDR
// vc_control := control_manual ;
10378: LD_ADDR_OWVAR 38
10382: PUSH
10383: LD_INT 1
10385: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ j ] ;
10386: LD_ADDR_OWVAR 40
10390: PUSH
10391: LD_INT 4
10393: PUSH
10394: LD_INT 5
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PUSH
10401: LD_VAR 0 3
10405: ARRAY
10406: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
10407: CALL_OW 45
10411: PPUSH
10412: LD_VAR 0 6
10416: PPUSH
10417: LD_VAR 0 7
10421: PPUSH
10422: LD_INT 13
10424: PPUSH
10425: LD_INT 0
10427: PPUSH
10428: CALL_OW 50
// end ;
10432: GO 10359
10434: POP
10435: POP
// vc_chassis := us_medium_tracked ;
10436: LD_ADDR_OWVAR 37
10440: PUSH
10441: LD_INT 3
10443: ST_TO_ADDR
// vc_engine := engine_solar ;
10444: LD_ADDR_OWVAR 39
10448: PUSH
10449: LD_INT 2
10451: ST_TO_ADDR
// vc_control := control_computer ;
10452: LD_ADDR_OWVAR 38
10456: PUSH
10457: LD_INT 3
10459: ST_TO_ADDR
// vc_weapon := us_radar ;
10460: LD_ADDR_OWVAR 40
10464: PUSH
10465: LD_INT 11
10467: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
10468: CALL_OW 45
10472: PPUSH
10473: LD_VAR 0 6
10477: PPUSH
10478: LD_VAR 0 7
10482: PPUSH
10483: LD_INT 13
10485: PPUSH
10486: LD_INT 0
10488: PPUSH
10489: CALL_OW 50
// end ; end ; end ; end ;
10493: GO 9295
10495: POP
10496: POP
// end ;
10497: LD_VAR 0 1
10501: RET
// export function AddApeman ( area ) ; begin
10502: LD_INT 0
10504: PPUSH
// uc_nation := 0 ;
10505: LD_ADDR_OWVAR 21
10509: PUSH
10510: LD_INT 0
10512: ST_TO_ADDR
// uc_side := 0 ;
10513: LD_ADDR_OWVAR 20
10517: PUSH
10518: LD_INT 0
10520: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
10521: LD_ADDR_OWVAR 35
10525: PUSH
10526: LD_INT 10
10528: NEG
10529: PPUSH
10530: LD_INT 15
10532: PPUSH
10533: CALL_OW 12
10537: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
10538: LD_INT 0
10540: PPUSH
10541: LD_INT 12
10543: PPUSH
10544: LD_INT 0
10546: PPUSH
10547: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
10551: LD_ADDR_OWVAR 29
10555: PUSH
10556: LD_INT 10
10558: PUSH
10559: LD_INT 12
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
10566: CALL_OW 44
10570: PPUSH
10571: LD_VAR 0 1
10575: PPUSH
10576: LD_INT 0
10578: PPUSH
10579: CALL_OW 49
// end ;
10583: LD_VAR 0 2
10587: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
10588: LD_INT 0
10590: PPUSH
10591: PPUSH
10592: PPUSH
10593: PPUSH
// r := 100 ;
10594: LD_ADDR_VAR 0 5
10598: PUSH
10599: LD_INT 100
10601: ST_TO_ADDR
// x := 0 ;
10602: LD_ADDR_VAR 0 6
10606: PUSH
10607: LD_INT 0
10609: ST_TO_ADDR
// while ( x < n ) do
10610: LD_VAR 0 6
10614: PUSH
10615: LD_VAR 0 2
10619: LESS
10620: IFFALSE 10935
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
10622: LD_ADDR_VAR 0 4
10626: PUSH
10627: DOUBLE
10628: LD_INT 1
10630: DEC
10631: ST_TO_ADDR
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_INT 0
10639: PPUSH
10640: CALL_OW 517
10644: PUSH
10645: LD_INT 1
10647: ARRAY
10648: PUSH
10649: FOR_TO
10650: IFFALSE 10931
// begin if r > 50 then
10652: LD_VAR 0 5
10656: PUSH
10657: LD_INT 50
10659: GREATER
10660: IFFALSE 10907
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
10662: LD_VAR 0 1
10666: PPUSH
10667: LD_INT 0
10669: PPUSH
10670: CALL_OW 517
10674: PUSH
10675: LD_INT 1
10677: ARRAY
10678: PUSH
10679: LD_VAR 0 4
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 1
10689: PPUSH
10690: LD_INT 0
10692: PPUSH
10693: CALL_OW 517
10697: PUSH
10698: LD_INT 2
10700: ARRAY
10701: PUSH
10702: LD_VAR 0 4
10706: ARRAY
10707: PPUSH
10708: CALL_OW 458
10712: NOT
10713: IFFALSE 10891
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
10715: LD_VAR 0 1
10719: PPUSH
10720: LD_INT 0
10722: PPUSH
10723: CALL_OW 517
10727: PUSH
10728: LD_INT 1
10730: ARRAY
10731: PUSH
10732: LD_VAR 0 4
10736: ARRAY
10737: PPUSH
10738: LD_VAR 0 1
10742: PPUSH
10743: LD_INT 0
10745: PPUSH
10746: CALL_OW 517
10750: PUSH
10751: LD_INT 2
10753: ARRAY
10754: PUSH
10755: LD_VAR 0 4
10759: ARRAY
10760: PPUSH
10761: LD_EXP 8
10765: PPUSH
10766: LD_INT 0
10768: PPUSH
10769: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
10773: LD_ADDR_EXP 17
10777: PUSH
10778: LD_EXP 17
10782: PPUSH
10783: LD_EXP 17
10787: PUSH
10788: LD_INT 1
10790: PLUS
10791: PPUSH
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_INT 0
10799: PPUSH
10800: CALL_OW 517
10804: PUSH
10805: LD_INT 1
10807: ARRAY
10808: PUSH
10809: LD_VAR 0 4
10813: ARRAY
10814: PPUSH
10815: CALL_OW 2
10819: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
10820: LD_ADDR_EXP 17
10824: PUSH
10825: LD_EXP 17
10829: PPUSH
10830: LD_EXP 17
10834: PUSH
10835: LD_INT 1
10837: PLUS
10838: PPUSH
10839: LD_VAR 0 1
10843: PPUSH
10844: LD_INT 0
10846: PPUSH
10847: CALL_OW 517
10851: PUSH
10852: LD_INT 2
10854: ARRAY
10855: PUSH
10856: LD_VAR 0 4
10860: ARRAY
10861: PPUSH
10862: CALL_OW 2
10866: ST_TO_ADDR
// r := 0 ;
10867: LD_ADDR_VAR 0 5
10871: PUSH
10872: LD_INT 0
10874: ST_TO_ADDR
// x := x + 1 ;
10875: LD_ADDR_VAR 0 6
10879: PUSH
10880: LD_VAR 0 6
10884: PUSH
10885: LD_INT 1
10887: PLUS
10888: ST_TO_ADDR
// end else
10889: GO 10905
// r := r + 35 ;
10891: LD_ADDR_VAR 0 5
10895: PUSH
10896: LD_VAR 0 5
10900: PUSH
10901: LD_INT 35
10903: PLUS
10904: ST_TO_ADDR
// end else
10905: GO 10929
// r := r + rand ( 10 , 25 ) ;
10907: LD_ADDR_VAR 0 5
10911: PUSH
10912: LD_VAR 0 5
10916: PUSH
10917: LD_INT 10
10919: PPUSH
10920: LD_INT 25
10922: PPUSH
10923: CALL_OW 12
10927: PLUS
10928: ST_TO_ADDR
// end ;
10929: GO 10649
10931: POP
10932: POP
10933: GO 10610
// end ;
10935: LD_VAR 0 3
10939: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10940: LD_INT 0
10942: PPUSH
10943: PPUSH
10944: PPUSH
// if not GetControl ( veh ) = control_manual then
10945: LD_VAR 0 1
10949: PPUSH
10950: CALL_OW 263
10954: PUSH
10955: LD_INT 1
10957: EQUAL
10958: NOT
10959: IFFALSE 10971
// result := false else
10961: LD_ADDR_VAR 0 2
10965: PUSH
10966: LD_INT 0
10968: ST_TO_ADDR
10969: GO 11116
// if veh in FilterAllUnits ( [ f_empty ] ) then
10971: LD_VAR 0 1
10975: PUSH
10976: LD_INT 58
10978: PUSH
10979: EMPTY
10980: LIST
10981: PPUSH
10982: CALL_OW 69
10986: IN
10987: IFFALSE 10999
// result := false else
10989: LD_ADDR_VAR 0 2
10993: PUSH
10994: LD_INT 0
10996: ST_TO_ADDR
10997: GO 11116
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10999: LD_ADDR_VAR 0 4
11003: PUSH
11004: LD_INT 22
11006: PUSH
11007: LD_VAR 0 1
11011: PPUSH
11012: CALL_OW 255
11016: PUSH
11017: EMPTY
11018: LIST
11019: LIST
11020: PUSH
11021: LD_INT 55
11023: PUSH
11024: EMPTY
11025: LIST
11026: PUSH
11027: EMPTY
11028: LIST
11029: LIST
11030: PPUSH
11031: CALL_OW 69
11035: ST_TO_ADDR
// if not filter then
11036: LD_VAR 0 4
11040: NOT
11041: IFFALSE 11053
// result := false else
11043: LD_ADDR_VAR 0 2
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
11051: GO 11116
// for i = 1 to filter do
11053: LD_ADDR_VAR 0 3
11057: PUSH
11058: DOUBLE
11059: LD_INT 1
11061: DEC
11062: ST_TO_ADDR
11063: LD_VAR 0 4
11067: PUSH
11068: FOR_TO
11069: IFFALSE 11114
// if IsDriver ( filter [ i ] ) = veh then
11071: LD_VAR 0 4
11075: PUSH
11076: LD_VAR 0 3
11080: ARRAY
11081: PPUSH
11082: CALL 11121 0 1
11086: PUSH
11087: LD_VAR 0 1
11091: EQUAL
11092: IFFALSE 11112
// begin result := filter [ i ] ;
11094: LD_ADDR_VAR 0 2
11098: PUSH
11099: LD_VAR 0 4
11103: PUSH
11104: LD_VAR 0 3
11108: ARRAY
11109: ST_TO_ADDR
// break ;
11110: GO 11114
// end ;
11112: GO 11068
11114: POP
11115: POP
// end ; end ;
11116: LD_VAR 0 2
11120: RET
// export function IsDriver ( unit ) ; begin
11121: LD_INT 0
11123: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
11124: LD_VAR 0 1
11128: PUSH
11129: LD_INT 55
11131: PUSH
11132: EMPTY
11133: LIST
11134: PPUSH
11135: CALL_OW 69
11139: IN
11140: IFFALSE 11159
// result := IsInUnit ( unit ) else
11142: LD_ADDR_VAR 0 2
11146: PUSH
11147: LD_VAR 0 1
11151: PPUSH
11152: CALL_OW 310
11156: ST_TO_ADDR
11157: GO 11167
// result := false ;
11159: LD_ADDR_VAR 0 2
11163: PUSH
11164: LD_INT 0
11166: ST_TO_ADDR
// end ; end_of_file
11167: LD_VAR 0 2
11171: RET
// export ExtraStrings ; export function ShowTimer ; var AllStrings ; begin
11172: LD_INT 0
11174: PPUSH
11175: PPUSH
// AllStrings := [ #Multi1x1-Time , tick ] ;
11176: LD_ADDR_VAR 0 2
11180: PUSH
11181: LD_STRING #Multi1x1-Time
11183: PUSH
11184: LD_OWVAR 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: ST_TO_ADDR
// if ( ExtraStrings ) then
11193: LD_EXP 37
11197: IFFALSE 11219
// AllStrings := AllStrings ^  ^ ExtraStrings ;
11199: LD_ADDR_VAR 0 2
11203: PUSH
11204: LD_VAR 0 2
11208: PUSH
11209: LD_STRING 
11211: ADD
11212: PUSH
11213: LD_EXP 37
11217: ADD
11218: ST_TO_ADDR
// Display_Strings := AllStrings ;
11219: LD_ADDR_OWVAR 47
11223: PUSH
11224: LD_VAR 0 2
11228: ST_TO_ADDR
// end ;
11229: LD_VAR 0 1
11233: RET
// every 0 0$1 do
11234: GO 11236
11236: DISABLE
// begin ShowTimer ;
11237: CALL 11172 0 0
// enable ;
11241: ENABLE
// end ;
11242: END
