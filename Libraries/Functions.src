// Functions.src from Sand of Siberia

Export Function PrepareUnit(ident, exist_mode, prefix);
var unit;
begin                                          

if exist_mode then
   unit := CreateCharacter(prefix&ident)
else
   unit := NewCharacter(ident);

result := unit;
End;


// Return's tech list by nation
// side
// nation
// state:
//       state_enabled 1
//       state_researched 2
//       state_disabled 0
//       all -1
Export Function GetTechNation(side, nation, state);
var i;
begin
if not side or not nation then
   exit;

case nation of
     nation_american: result := [35, 45, 46, 47, 82, 83, 84, 85, 86, 1, 2, 6, 15, 16, 7, 12, 13, 10, 14, 20, 21, 22, 25, 32, 27, 36, 69, 39, 34, 40, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 80, 82, 83, 84, 85, 86];
     nation_arabian: result := [35, 45, 46, 47, 82, 83, 84, 85, 87, 70, 1, 11, 3, 4, 5, 6, 15, 18, 7, 17, 8, 20, 21, 22, 72, 26, 69, 39, 40, 41, 42, 43, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 66, 67, 68, 81, 82, 83, 84, 85, 87];
     nation_russian: result := [46, 47, 1, 2, 82, 83, 84, 85, 86, 11, 9, 20, 19, 21, 24, 22, 25, 28, 29, 30, 31, 37, 38, 32, 27, 33, 69, 39, 34, 40, 71, 23, 44, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 63, 64, 65, 82, 83, 84, 85, 86];
end;

if state > -1 and state < 3 then
   for i in result do
       if GetTech(i, side) <> state then
          result := result diff i;
End;

Export Function TechCanBeResearch(side, tech);
var i, tmp;
begin
result := true;

tmp := GetTechTechsReq(tech);

if not tmp then
   exit;

for i in tmp do
    if GetTech(i, side) <> state_researched then
       begin
       result := false;
       exit;
       end;
End;

Export Function ComSpaceTimeShoot(unit);
var i, x, y, _x, _y, tmp, side, enemy, in_unit, tech_space, tech_time, missile;
begin
if not unit or GetClass(unit) <> class_bazooker then
   exit;

side := GetSide(unit);
tech_space := tech_spacanom;
tech_time := tech_taurad;

in_unit := IsInUnit(unit);

if GetType(in_unit) = unit_vehicle then
   exit;

tmp := FilterAllUnits([[f_enemy, side], [f_not, [f_type, unit_building]]]);

if not tmp then
   exit;

if in_unit then
   enemy := NearestUnitToUnit(tmp, in_unit)
else
   enemy := NearestUnitToUnit(tmp, unit);

if not enemy then
   exit;

if (in_unit and GetDistUnits(in_unit, enemy) > 13) or GetDistUnits(unit, enemy) > 12 then
   exit;

missile := [1];

if Researched(side, tech_space) then
   missile := Insert(missile, missile+1, 2);

if Researched(side, tech_time) and not Researched(GetSide(enemy), tech_time) then
   missile := Insert(missile, missile+1, 3);

if missile < 2 then
   exit;

x := GetX(enemy);
y := GetY(enemy);

_x := x + rand(-1, 1);
_y := y + rand(-1, 1);

if not ValidHex(_x, _y) then
   begin
   _x := x;
   _y := y;
   end;

i := rand(1, missile);

case i of
     1: ComAttackUnit(unit, enemy);
     2: ComSpaceShift(unit, _x, _y);
     3: ComTimeShift(unit, _x, _y);
end;

End;

Export Function ComStandNearbyBuilding(unit, building);
var i, x, y, _x, _y;
begin
if not unit or not building then
   exit;

x := GetX(building);
y := GetY(building);

for i = 0 to 5 do
    begin
    _x := ShiftX(x, i, 3);
    _y := ShiftY(y, i, 3);

    if not ValidHex(_x, _y) then
       continue;

    if HexInfo(_x, _y) = 0 then
       begin
       ComMoveXY(unit, _x, _y);
       exit;
       end;
    end;
End;

Export Function ScanBase(side, base_area);
begin
result := FilterUnitsInArea(base_area, [f_enemy, side]);
End;



Export Function AllowSpecClass(unit);
var side, nat, tech;
begin
result := false;
side := GetSide(unit);
nat := GetNation(unit);

case nat of
1: tech := tech_lassight;
2: tech := tech_mortar;
3: tech := tech_bazooka;
end;

if Researched(side, tech) then
   result := [class_sniper, class_mortar, class_bazooker][nat];
End;

Export Function DetonateMines(side, mines);
var i, tmp;
begin
if not mines then
   exit;

tmp := FilterAllUnits([[f_enemy, side], [f_not, [f_type, unit_building]]]);

for i in mines do
    begin

    if not MineAtPos(i[1], i[2]) then
       continue;

    if HexInfo(i[1], i[2]) in tmp then
       LaunchMineAtPos(i[1], i[2], side);
    end;

End;

Export Function Count(array);
var i;
begin
result := 0;

for i in array do
    if i then
       result := result + 1;
End;

Export Function IsEmpty(building);
begin
if not building then
   exit;

result := building in FilterAllUnits([[f_side, GetSide(building)], [f_empty]]);
End;

Export Function IsNotFull(building);
begin
if not building then
   exit;

result := UnitsInside(building) < 6;
End;

Export Function GetFacExt(factory);
var tmp, i, list;
begin
tmp := [];
list := [];

for i = 16 to 25 do
    tmp := tmp ^ FilterAllUnits([[[f_side, GetSide(factory)], [f_dist, factory, 6], [f_btype, i]]]);

for i = 1 to tmp do
    list := list ^ [[GetBType(tmp[i]), GetX(tmp[i]), GetY(tmp[i]), GetDir(tmp[i])]];

result := list;
End;

Export Function Produce(factory, chassis, engine, control, weapon);
var i, tmp, _chassis, _weapon, _engine, _control;
begin
if not factory then
   exit;

if control = control_apeman then
   begin
   tmp := UnitsInside(factory);

   if not UnitFilter(tmp, [f_class, class_apeman]) then
      control := control_manual;

   tmp := GetFacExt(factory);

   if tmp then
      begin
      for i in tmp do
          if i[1] = b_ext_radio then
             begin
             control := control_remote;
             break;
             end;
      end;
   end;

if CanBeConstructed(factory, chassis, engine, control, weapon) then
   begin
   result := [chassis, engine, control, weapon];
   exit;
   end;

_chassis := AvailableChassisList(factory);
_engine := AvailableEngineList(factory);
_control := AvailableControlList(factory);
_weapon := AvailableWeaponList(factory);

if not _chassis or not _engine or not _control or not _weapon then
   begin
   result := [chassis, engine, control, weapon];
   exit;
   end;

if not chassis in _chassis then
   chassis := _chassis[rand(1, _chassis)];

if not EngineCanBeMount(chassis, engine) then
   repeat
    engine := _engine[1];
    _engine := Delete(_engine, 1);
   until EngineCanBeMount(chassis, engine) or _engine = [];

if not control in _control then
   control := _control[rand(1, _control)];

if not WeaponCanBeMount(chassis, weapon) then
   repeat
    weapon := _weapon[1];
    _weapon := Delete(_weapon, 1);
   until WeaponCanBeMount(chassis, weapon) or _weapon = [];

result := [];

if CanBeConstructed(factory, chassis, engine, control, weapon) then
   result := [chassis, engine, control, weapon]; 
End;

Export Function EngineCanBeMount(chassis, engine);
begin
if not chassis or not engine then
   exit;

case engine of
engine_solar:
  result := [ar_hovercraft, ar_light_trike, ar_medium_trike,
             ar_half_tracked, us_light_wheeled, us_medium_wheeled,
             us_medium_tracked];
engine_combustion:
  result := [ar_hovercraft, ar_light_trike, ar_medium_trike,
             ar_half_tracked, us_light_wheeled, us_medium_wheeled,
             us_medium_tracked, us_heavy_tracked, us_morphling,
             ru_medium_wheeled, ru_heavy_wheeled, ru_medium_tracked,
             ru_heavy_tracked];
engine_siberite:
  result := [ar_medium_trike, ar_half_tracked, us_medium_wheeled,
             us_medium_tracked, us_heavy_tracked, us_morphling,
             ru_medium_wheeled, ru_medium_tracked, ru_heavy_wheeled,
             ru_heavy_tracked];
end;

result := (chassis in result);
End;

Export Function WeaponCanBeMount(chassis, weapon);
begin
if not chassis or not weapon then
   exit;

case weapon of
us_machine_gun: result := [us_light_wheeled, us_medium_wheeled, us_medium_tracked, us_heavy_tracked, us_morphling];
us_light_gun: result := [us_light_wheeled, us_medium_wheeled, us_medium_tracked, us_heavy_tracked, us_morphling];
us_radar: result := [us_light_wheeled, us_medium_wheeled, us_medium_tracked, us_heavy_tracked, us_morphling];
us_gatling_gun: result := [us_medium_wheeled, us_medium_tracked, us_heavy_tracked, us_morphling];
us_double_gun: result := [us_medium_wheeled, us_medium_tracked, us_heavy_tracked, us_morphling];
us_laser: result := [us_medium_wheeled, us_medium_tracked, us_heavy_tracked, us_morphling];
us_rocket_launcher:  result := [us_medium_wheeled, us_medium_tracked, us_heavy_tracked, us_morphling];
us_cargo_bay: result := [us_medium_wheeled, us_medium_tracked, us_heavy_tracked, us_morphling];
us_crane: result := [us_medium_wheeled, us_medium_tracked, us_heavy_tracked, us_morphling];
us_bulldozer: result := [us_heavy_tracked, us_morphling];
us_heavy_gun: result := [us_heavy_tracked, us_morphling];
us_double_laser: result := [us_heavy_tracked, us_morphling];
ar_multimissile_ballista: result := [ar_hovercraft, ar_light_trike, ar_medium_trike, ar_half_tracked];
ar_light_gun: result := [ar_hovercraft, ar_light_trike, ar_medium_trike, ar_half_tracked];
ar_double_machine_gun: result := [ar_hovercraft, ar_light_trike, ar_medium_trike, ar_half_tracked];
ar_radar: result := [ar_hovercraft, ar_light_trike, ar_medium_trike, ar_half_tracked];
ar_gatling_gun: result := [ar_medium_trike, ar_half_tracked];
ar_gun: result := [ar_medium_trike, ar_half_tracked];
ar_rocket_launcher: result := [ar_medium_trike, ar_half_tracked];
ar_selfpropelled_bomb: result := [ar_medium_trike, ar_half_tracked];
ar_control_tower: result := [ar_medium_trike, ar_half_tracked];
ar_flame_thrower: result := [ar_medium_trike, ar_half_tracked];
ru_heavy_machine_gun: result := [ru_medium_wheeled, ru_medium_tracked, ru_heavy_wheeled, ru_heavy_tracked];
ru_gatling_gun: result := [ru_medium_wheeled, ru_medium_tracked, ru_heavy_wheeled, ru_heavy_tracked];
ru_gun: result := [ru_medium_wheeled, ru_medium_tracked, ru_heavy_wheeled, ru_heavy_tracked];
ru_rocket_launcher: result := [ru_medium_wheeled, ru_medium_tracked, ru_heavy_wheeled, ru_heavy_tracked];
ru_time_lapser: result := [ru_medium_wheeled, ru_medium_tracked, ru_heavy_wheeled, ru_heavy_tracked];
ru_cargo_bay: result := [ru_medium_wheeled, ru_medium_tracked, ru_heavy_wheeled, ru_heavy_tracked];
ru_crane: result := [ru_medium_wheeled, ru_medium_tracked, ru_heavy_wheeled, ru_heavy_tracked];
ru_bulldozer: result := [ru_heavy_wheeled, ru_heavy_tracked];
ru_heavy_gun: result := [ru_heavy_wheeled, ru_heavy_tracked];
ru_rocket: result := [ru_heavy_wheeled, ru_heavy_tracked];
end;

result := (chassis in result);
End;

{
    Reindex
    * param array - array to reindex
    * param i_from - index number where reindex start
    * param i_to - index number where reindex stop
    * param direction - false -> DESC, true -> ASC
    * return array
}
Export Function Reindex(array, i_from, i_to, direction);
var i, j, k, d, tmp, length;
begin
result := array;

if not array or not i_from or not i_to or i_from > array or i_to > array then
   exit;

{
    [1*, 2, 3, 4*, 5] -> [5, 1, 2, 3, 4] -> [4, 5, 1, 2, 3] -> [3, 4, 5, 1, 2]
}


// calculated length i_from to i_to
if direction then // ASC
   begin
   d := 1;

   if i_from > i_to then
      length := (array - i_from) + i_to
     else
      length := i_to - i_from;

   end
  else // DESC
   begin
   d := -1;

   if i_from > i_to then
      length := i_from - i_to
    else
      length := (array - i_to) + i_from;

   end;

if not length then
   exit;

// SORT
tmp := array;

for i = 1 to length do
    begin

    for j = 1 to array do
        begin
        k := j+d;

        if k > array then
           k := 1;

        if not k then
           k := array;

        tmp := Replace(tmp, k, array[j]);
        end;

    array := tmp;
    end;

result := array;
End;

Export Function GetElementIndex(array, value);
var i;
begin
result := 0;

if not array or not value in array then
   exit;

for i = 1 to array do
    if value = array[i] then
       begin
       result := i;
       exit;
       end;
End;

Export Function PrepareVehicle(chassis, engine, control, weapon, fuel);
begin
vc_chassis := chassis;
vc_engine := engine;
vc_control := control;
vc_weapon := weapon;
vc_fuel_battery := fuel;
End;


Export Function WantPlant(unit);
var task;
begin
result := false;

task := GetTaskList(unit);

if task then
   if task[1][1] = 'p' then
      result := true;
End;

// arr - tablica
// pos - tablica pozycji
// value - nowa wartoœæ do wstawienia
Export Function ReplaceIn(arr, pos, value);
var i, tmp, s_arr;
begin
if pos < 1 then
   exit;

if pos = 1 then
   result := Replace(arr, pos[1], value)
    else
     begin
     tmp := arr;
     s_arr := [tmp];

     for i = 1 to pos-1 do
         begin
         tmp := tmp[pos[i]];
         s_arr := s_arr ^ [tmp];
         end;

     tmp := Replace(tmp, pos[pos], value);
     s_arr := Replace(s_arr, s_arr, tmp);

     for i = s_arr downto 2 do
         begin
         tmp := Replace(s_arr[i-1], pos[i-1], s_arr[i]);
         s_arr := Replace(s_arr, i-1, tmp);
         end;

     result := s_arr[1];
     end;

End;

Export Function ReplaceWith(list, pos1, pos2);
var i;
begin
if not list then
   exit;

i := list[pos1];

if not i then
   exit;

list := Replace(list, pos1, list[pos2]);
list := Replace(list, pos2, i);

result := list;
End;

Export Function SortByDistanceUnit(unit, list, asc, mode);
begin
result := SortByDistanceXY(GetX(unit), GetY(unit), list, asc, mode);
End;

{
SortByDistanceXY(x, y, list, asc)
- Sortuje jednostki zadane tablic¹ wg. dystansu od zadanego koordynatu
* x, y - koordynaty
* list - tablica jednostek
* asc - true -> rosn¹co | false -> malej¹co
* mode - true -> zwraca tylko liste jednostek | false -> zwraca liste i odleglosci
= array
}
Export Function SortByDistanceXY(x, y, list, asc, mode);
var i, j, tmp;
begin
if not list then
   exit;

result := [];

for i in list do
    begin
    tmp := GetDistUnitXY(i, x, y);

    if not result then
       result := [[i, tmp]]
     else
      begin
       if result[result][2] < tmp then
          result := Insert(result, result+1, [i, tmp])
       else
       for j = 1 to result do
           begin
           if tmp < result[j][2] then
              begin
              result := Insert(result, j, [i, tmp]);
              break;
              end;
           end;
      end;
    end;

if result and not asc then
   begin
   tmp := result;

   for i = tmp downto 1 do
       result := Replace(result, tmp - i + 1, tmp[i]);
   end;

tmp := [];

if mode then
   begin

   for i = 1 to result do
       tmp := Replace(tmp, i, result[i][1]);

   result := tmp;
   end;

End;
{
    DangerAtRange(unit, range)
    - Zwraca poziom 'niebezpieczeñstwa' dla jednostki w zadanym zasiêgu (domyœlnie: 10)
    * unit
    * range
    = array (H, V, B, X)

    amount: x              H      V     B       X
    class: ape | ape_en [   5,     3,    2  ] * x
    class: ape_kamikaze [ 100,    50,   75  ] * x
    class: ape_soldier  [  10,     5,    3  ] * x
    class: 2 | 3 | 4 -> [   3,     2,    1  ] * x
    class: 1         -> [  10,     5,    3  ] * x
    class: mortar    -> [  35,    35,   30  ] * x
    class: bazoka    -> [  20,    55,   40  ] * x
    class: sniper    -> [ 130,     5,    2  ] * x
    machine_guns     -> [  25,     5,    3  ] * x
    gatling_guns     -> [  40,    15,    5  ] * x
    light_guns       -> [   7,    25,    8  ] * x
    double_gun       -> [  14,    50,   16  ] * x
    heavy_guns       -> [  32,   120,   70  ] * x
    rockets          -> [  35.    20,   45  ] * x
    large rocket     -> [  67,    45,   75  ] * x
    flamethrower     -> [ 120,    30,   80  ] * x
    balista          -> [  40,     1,    1  ] * x
    self_pr_bomb     -> [  70,   200,  400  ] * x
    bio_bomb         -> [ 100,    12,   15  ] * x
    bulldozers       -> [  40,    10,   20  ] * x
    laser            -> [   5,    70,   20  ] * x
    db_laser         -> [  35,   110,   70  ] * x
    behemoth         -> [  80,    65,  100  ] * x

    + soldier_skill_bonus for human type units:
      r = basic * (skill_level * 1.15)
    + mechanic_skill_bonus for control_manual vehicles:
      r = basic + (skill * 4)
    + mechanic skill bonus for control_remote vehicles:
      r = basic + (skill * 3) / linked_vehs
    + computer upgrades bonus for control_computer vehicles:
      r = basic + (5 * upgrade_level)
    + remote upgrades bonus for control_remote vehicles:
      r = basic + (3 * upgrade_level)
    + bio upgrades bonus for control_apeman vehicles:
      r = basic + (6 * upgrade_level)
    + stimulant tech for human type units:
      r = basic * 1.8
    + weapon upgrade I for basic classes [1-4]:
      r = basic * 1.2
    + weapon upgrade II for special classes [5,7,9]:
      r = basic * 1.5;
    + weapon upgrade II for weapons [guns, rockets]:
      r = basic * 1.2;
    + weapon upgrade III for heavy weapons [heavy_gun, rockets, large_rockets, behemoths, self_pr_bombs]:
      r = basic * 1.2;
    + bio I upgrades bonus for human type units:
      r = basic * 1.1;
}
Export Function DangerAtRangeXY(side, x, y, range);
var i, j, tmp, points, bpoints;
begin
result := [0, 0, 0, []];

if not x or not y then
   exit;

if not range then
   range := 10;

// get enemy unit's in range
tmp := FilterAllUnits([[f_enemy, side], [f_distxy, x, y, range], [f_not, [f_type, unit_building]]]);

if not tmp then
   exit;

for i in tmp do
    begin
    points := [0, 0, 0];
    bpoints := 1;

    case GetType(i) of
    unit_human: begin
                // class soldier
                if GetClass(i) = 1 then
                   points := [10, 5, 3];
                // class eng|mech|sci
                if GetClass(i) in [2,3,4] then
                   points := [3, 2, 1];
                // class sniper
                if GetClass(i) = 5 then
                   points := [130, 5, 2];
                // class mortar
                if GetClass(i) = 8 then
                   points := [35, 35, 30];
                // class bazooka
                if GetClass(i) = 9 then
                   points := [20, 55, 40];
                // class apeman
                if GetClass(i) in [12, 16] then
                   points := [5, 3, 2];
                // class apeman_kamikaze
                if GetClass(i) = 17 then
                   points := [100, 50, 75];
                // class apeman soldier
                if GetClass(i) = 15 then
                   points := [10, 5, 3];
                // class tiger
                if GetClass(i) = 14 then
                   points := [10, 0, 0];
                // class sheik
                if GetClass(i) = 11 then
                   points := [30, 10, 5];


                // stimulat bonus
                if GetTech(side, tech_stimdrugs) = state_researched then
                   bpoints := bpoints * 1.8;
                // bonus I weapon upgrade
                if GetClass(i) in [1,2,3,4] and GetTech(side, tech_weap1) = state_researched then
                   bpoints := bpoints * 1.2;
                // bonus II weapon upgrade
                if GetClass(i) in [5,7,9] and GetTech(side, tech_weap2) = state_researched then
                   bpoints := bpoints * 1.5;
                // bonus bio upgrade
                if GetTech(side, tech_bio1) = state_researched then
                   bpoints := bpoints * 1.1;
                // skill level
                   bpoints := bpoints * (GetSkill(i, 1) * 1.15);
                end;
    unit_vehicle: begin
                  if GetWeapon(i) in [us_machine_gun, ru_heavy_machine_gun, ar_double_machine_gun] then
                     points := [25, 5, 3];
                  if GetWeapon(i) in [us_gatling_gun, ru_gatling_gun, ar_gatling_gun] then
                     points := [40, 15, 5];
                  if GetWeapon(i) in [us_light_gun, ar_light_gun] then
                     points := [7, 25, 8];
                  if GetWeapon(i) in [us_double_gun, ar_gun, ru_gun] then
                     points := [14, 50, 16];
                  if GetWeapon(i) in [us_heavy_gun, ru_heavy_gun] then
                     points := [32, 120, 70];
                  if GetWeapon(i) in [us_rocket_launcher, ar_rocket_launcher, ru_rocket_launcher] then
                     points := [35, 20, 45];
                  if GetWeapon(i) in [ru_rocket] then
                     points := [67, 45, 75];
                  if GetWeapon(i) in [ar_flame_thrower] then
                     points := [120, 30, 80];
                  if GetWeapon(i) in [ar_multimissile_ballista] then
                     points := [40, 1, 1];
                  if GetWeapon(i) in [ar_selfpropelled_bomb] then
                     points := [70, 200, 400];
                  if GetWeapon(i) in [us_bulldozer, ru_bulldozer] then
                     points := [40, 10, 20];
                  if GetWeapon(i) in [us_laser] then
                     points := [5, 70, 20];
                  if GetWeapon(i) in [us_double_laser] then
                     points := [35, 110, 70];
                  if GetChassis(i) = 25 then
                     points := [80, 65, 100];

                  if GetControl(i) = control_manual then
                     bpoints := bpoints * (GetSkill(IsDrivenBy(i), 3) * 4);
                  if GetControl(i) = control_remote then
                     begin
                     j := IsControledBy(i);

                     if j then
                        bpoints := bpoints * (GetSkill(j, 3) * 3);
                     end;
                  if GetWeapon(i) in [us_double_gun, us_heavy_gun, ru_heavy_gun, ru_gun, ru_rocket, ru_rocket_launcher, ar_rocket_launcher, us_rocket_launcher, ar_gun, ar_selfpropelled_bomb] and GetTech(side, tech_weap2) = state_researched then
                     bpoints := bpoints * 1.2;
                  if GetWeapon(i) in [us_heavy_gun, ru_heavy_gun, ru_rocket] then
                     bpoints := bpoints * 1.2;

                  end;
    unit_building: ;
    end;


    for j = 1 to 3 do
        result := Replace(result, j, result[j] + (points[j] * bpoints));
    end;

result := Replace(result, 4, tmp);
End;

Export Function DangerAtRange(unit, range);
begin
result := DangerAtRangeXY(GetSide(unit), GetX(unit), GetY(unit), range);
End;

Export Function DangerInArea(side, area);
begin
result := FilterUnitsInArea(area, [f_enemy, side]);
End;

Export Function IsExtension(b);
begin
result := b in [b_ext_stitch, b_ext_radar, b_ext_radio, b_ext_gun, b_ext_computer, b_ext_siberium, b_ext_noncombat, b_ext_track, b_ext_laser, b_ext_rocket];
End;

Export Function GetBaseBuildings(base, area, checkLink);
var tmp, i;
begin
result := [];
tmp := FilterUnitsInArea(area, [f_type, unit_building]);

if not tmp then
   exit;

if checkLink then
   begin
   for i in tmp do
       if GetBase(i) <> base then
          ComLinkToBase(base, i);
   end;

result := tmp;
End;

Export Function ComComplete(units, b);
var i;
begin
if not units then
   exit;

for i in units do
    if BuildingStatus(b) = bs_build then
       SetTaskList(i, [['h', GetX(b), GetY(b), b, 0, 0, 0]]);
End;

Export Function Connect(vehicle);
var i, t, mech, tmp, j;
begin
if not vehicle or not GetControl(vehicle) = control_remote then
   exit;

tmp := FilterAllUnits([[f_side, GetSide(vehicle)], [f_or, [f_btype, b_control_tower], [f_weapon, ar_control_tower]]]);

if not tmp then
   exit;

result := [];

for i in tmp do
    begin
    t := UnitsInside(i);

    if t then
       for j in t do
           result := Insert(result, result+1, j);
    end;

if not result then
   exit;

mech := result[1];

if result > 1 then
   for i = 2 to result do
       begin
       t := GetSkill(result[i], 3) - UnitsLinked(result[i]);

       if t >= (GetSkill(mech, 3) - UnitsLinked(mech)) then
          mech := result[i];
       end;

ComLinkTo(vehicle, mech);
End;

Export Function PrepareBase(base_dep, area, name, skill, sources, personel);
var i, j, d, b, f, x, un, base, side, nation, buildings, tmp;
begin
result := [];

if not GetBType(base_dep) in [b_depot, b_warehouse] then
   exit;

if name then
   SetBName(base_dep, name);

base := GetBase(base_dep);
side := GetSide(base_dep);
nation := GetNation(base_dep);

if sources then
   for i = 1 to 3 do
       AddResourceType(base, i, sources[i]);

buildings := GetBaseBuildings(base, area, true);

InitHc;
InitUc;

uc_side := side;
uc_nation := nation;


if buildings then
   begin
   tmp := UnitFilter(buildings, [f_or, [f_btype, b_oil_mine], [f_btype, b_siberite_mine]]);

   if tmp then
      for i in tmp do
          SetResourceVisibility(GetX(i), GetY(i), side);

   if UnitFilter(buildings, [f_or, [f_btype, b_bunker], [f_btype, b_turret]]) then
      begin
      for i in UnitFilter(buildings, [f_or, [f_btype, b_bunker], [f_btype, b_turret]]) do
          begin
          if not GetBWeapon(i) then
             PlaceWeaponTurret(i, GetTurretWeapon(i, area));
          end;
      end;

   for i = 1 to personel do
       begin

       if i > 4 then
          break;

       case i of
       1: f := UnitFilter(buildings, [[f_side, side], [f_empty], [f_or, [f_btype, b_bunker], [f_btype, b_armoury], [f_btype, b_barracks]]]);
       2: f := UnitFilter(buildings, [[f_side, side], [f_or, [f_btype, b_depot], [f_btype, b_warehouse]]]);
       3: f := UnitFilter(buildings, [[f_side, side], [f_or, [f_btype, b_workshop], [f_btype, b_factory]]]);
       4: f := UnitFilter(buildings, [[f_side, side], [f_or, [f_btype, b_lab], [f_btype, b_lab_half], [f_btype, b_lab_full]]]);
       end;

       // sort buildings - towers first
       if i = 1 then
          begin
          tmp := [];

          for j in f do
              if GetBType(j) = b_bunker then
                 tmp := Insert(tmp, 1, j)
              else
                 tmp := Insert(tmp, tmp+1, j);

          if tmp then
             f := tmp;
          end;

       x := personel[i];

       if x = -1 then
          begin

          for j in f do
              repeat
              InitHc;

              if GetBType(j) = b_barracks then
                 begin
                 if UnitsInside(j) < 3 then
                    PrepareHuman(false, [class_sniper, class_mortar, class_bazooker][nation], skill)
                   else
                    PrepareHuman(false, i, skill);
                 end
                  else
                 PrepareHuman(false, i, skill);

               un := CreateHuman;
               result := Insert(result, 1, un);
               PlaceHumanInUnit(un, j);
              until UnitsInside(j) = 6 or GetBType(j) in [b_bunker, b_breastwork];

          end
         else
          for j = 1 to x do
              begin
              InitHc;

              if not f then
                 begin
                 PrepareHuman(false, i, skill);

                 un := CreateHuman;
                 result := Insert(result, 1, un);
                 PlaceUnitXYR(un, GetX(base_dep), GetY(base_dep), 10, false);
                 continue;
                 end;

              if (UnitsInside(f[1]) and GetBType(f[1]) in [b_bunker, b_breastwork]) or
                 (UnitsInside(f[1]) = 6) then
                  f := Delete(f, 1);

              if not f then
                 begin
                 x := x + 2;
                 continue;
                 end;

              if GetBType(f[1]) = b_barracks then
                 begin
                 if UnitsInside(f[1]) < 3 then
                    PrepareHuman(false, [class_sniper, class_mortar, class_bazooker][nation], skill)
                   else
                    PrepareHuman(false, i, skill);
                 end
                  else
                 PrepareHuman(false, i, skill);

              un := CreateHuman;
              result := Insert(result, 1, un);
              PlaceHumanInUnit(un, f[1]);
              end;
       end;

    result := result ^ buildings;
    end
   else
    begin

    for i = 1 to personel do
        begin

        if i > 4 then
           break;

        x := personel[i];

        if x = -1 then
           continue;

        PrepareHuman(false, i, skill);
        un := CreateHuman;
        PlaceUnitXYR(un, GetX(base_dep), GetY(base_dep), 10, false);
        result := result ^ un;
        end;
    end;
End;

Export Function GetTurretWeapon(tower, area);
var hex, list, factories, base, i, j, x, y, nat, h, tmp, height, side, fac_list, weapon;
begin
result := false;

if not tower or not GetBType(tower) in [b_bunker, b_turret] then
   exit;

nat := GetNation(tower);
side := GetSide(tower);

x := GetX(tower);
y := GetY(tower);

if not x or not y then
   exit;

weapon := 0;
fac_list := [];
factories := UnitFilter(GetBaseBuildings(GetBase(tower), area, false), [f_btype, b_factory]);

if not factories then
   exit;

for i in factories do
    fac_list := fac_list union AvailableWeaponList(i);

if not fac_list then
   exit;

list := [
             [us_gatling_gun, us_double_gun, us_laser,
              us_double_laser, us_heavy_gun, us_rocket_launcher, us_radar],
             [ar_gun,
              ar_rocket_launcher, ar_flame_thrower, ar_radar],
             [ru_gatling_gun, ru_gun, ru_heavy_gun,
              ru_rocket_launcher, ru_rocket, ru_time_lapser]
        ][nat];

// filter list
for i in list do
    if not i in fac_list then
       list := list diff i;

if not list then
   exit;

// time lapsers
if nat = nation_russian and ru_time_lapser in list and GetTech(tech_lapser, side) = state_researched then
   begin
   if not FilterAllUnits([[f_side, side], [f_bweapon, ru_time_lapser], [f_dist, tower, 10]]) then
      weapon := ru_time_lapser;
   end;

// radar
if nat in [1,2] and (us_radar in list or ar_radar in list) and GetTech(tech_radar, side) = state_researched then
   begin
   if not FilterAllUnits([[f_side, side], [f_or, [f_bweapon, us_radar], [f_bweapon, ar_radar]], [f_dist, tower, 18]]) and
      FilterAllUnits([[[f_side, side], [f_or, [f_btype, b_bunker], [f_btype, b_turret]], [f_dist, tower, 12]]]) > 2 then
      weapon := [us_radar, ar_radar][nat];
   end;

// rocket_launcher
if not weapon and GetTech(tech_rocket, side) = state_researched and
   (us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list) then
   begin
   hex := GetHexInfo(x, y);

   if hex[1] then
      exit;

   height := hex[2];
   tmp := [0, 2, 3, 5];

   for i in tmp do
       begin
       j := [ShiftX(x, i, 5), ShiftY(y, i, 5)];

       if ValidHex(j[1], j[2]) then
          begin
          hex := GetHexInfo(j[1], j[2]);

          if hex[1] then
             continue;

          h := hex[2];

          if h+7 < height then
             begin
             weapon := [us_rocket_launcher, ar_rocket_launcher, ru_rocket_launcher][nat];
             break;
             end;
          end;
       end;
   end;

// group of weapons
if not weapon then
   begin
   list := list diff [us_radar, ar_radar, ru_time_lapser];

   if not list then
      exit;

   weapon := list[rand(1, list)];
   {tmp := FilterAllUnits([[f_side, side], [f_not, [f_bweapon, 0]]]);

   for i in tmp do
       list := list diff GetBWeapon(i);

   if list then
      weapon := list[rand(1, list)];}
   end;

if weapon then
   begin
   tmp := CostOfWeapon(weapon);
   j := GetBase(tower);

   if GetResourceType(j, mat_cans) >= tmp[1] and
      GetResourceType(j, mat_oil) >= tmp[2] and
      GetResourceType(j, mat_siberit) >= tmp[3] then
      result := weapon;
   end;
End;

Export Function CompareArray(array1, array2);
var i;
begin
result := true;

     if array1 = array2 then
        begin
        for i = 1 to array1 do
            if array1[i] <> array2[i] then
               begin
               result := false;
               break;
               end;
        end
         else
          result := false;
End;

Export Function CompareArrayValues(array1, array2);
var i;
begin
if not array1 or not array2 then
   exit;

result := true;

for i = 1 to array1 do
    if array1[i] <> array2[i] then
       begin
       result := false;
       break;
       end;
End;

Export Function VehicleCost(fac, list);
var cost, pom;
begin
pom := GetBase(fac);
cost := CostOfVehicle(list[1], list[2], list[3], list[4]);

result := GetResourceType(pom, mat_cans) >= cost[1] and
          GetResourceType(pom, mat_oil) >= cost[2] and
          GetResourceType(pom, mat_siberit) >= cost[3];
End;

Export Function UpgradeCost(building);
var pom, cost, btype;
begin
pom := GetBase(building);

if not pom then
   exit;

btype := GetBType(building);

if btype = b_armoury then
   btype := b_barracks;

if btype = b_depot then
   btype := b_warehouse;

if btype = b_workshop then
   btype := b_factory;

cost := CostOfBuilding(btype, GetNation(building));

result := GetResourceType(pom, mat_cans) >= cost[1] and
          GetResourceType(pom, mat_oil) >= cost[2] and
          GetResourceType(pom, mat_siberit) >= cost[3];
End;

Export Function UpgradeLabCost(building, btype);
var pom, cost;
begin
pom := GetBase(building);

if not pom then
   exit;

cost := CostOfBuilding(btype, GetNation(building));

result := GetResourceType(pom, mat_cans) >= cost[1] and
          GetResourceType(pom, mat_oil) >= cost[2] and
          GetResourceType(pom, mat_siberit) >= cost[3];
End;

Export Function TryClearPlaceForBuilding(btype, x, y, d, buildings, cleaners, parking);
var i, j, _x, _y, tmp, hexes, r, xy, dep, driver;
begin
result := false;

if not buildings or not btype or not x or not y then
   exit;

hexes := GetBuildingHexes(btype, x, y, d, GetNation(buildings[1]), 0);

if not hexes then
   exit;

dep := UnitFilter(buildings, [[f_side, GetSide(tmp)], [f_or, [f_btype, b_depot], [f_btype, b_warehouse]]]);

for i = 1 to hexes do
    begin
    tmp := HexInfo(hexes[i][1], hexes[i][2]);

    if IsEnvironment(hexes[i][1], hexes[i][2]) or not ValidHex(hexes[i][1], hexes[i][2]) or GetType(tmp) = unit_building then
       exit;

    if not tmp then
       continue;

    result := true;

    if cleaners and GetType(tmp) = unit_vehicle and GetControl(tmp) = control_manual then
       begin
       if IsDrivenBy(tmp) then
          continue;

       if UnitFilter(cleaners, [[f_not, [f_hastask]], [f_not, [f_driving]]]) then
          begin
          driver := UnitFilter(cleaners, [[f_not, [f_hastask]], [f_not, [f_driving]]])[1];

          if IsInUnit(driver) then
             ComExit(driver);

          AddComEnterUnit(driver, tmp);
          AddComMoveToArea(driver, parking);
          AddComExitVehicle(driver);
          end;

       continue;
       end;

    if not cleaners or not tmp in cleaners then
       begin          
       if dep then
          begin
          xy := [ShiftX(GetX(dep[1]), GetDir(dep[1]), 5), ShiftY(GetY(dep[1]), GetDir(dep[1]), 5)];

          if ValidHex(xy[1], xy[2]) then
             begin
             ComMoveXY(tmp, xy[1], xy[2]);
             continue;
             end;
          end;

       r := GetDir(tmp);

       if r = 5 then
          r := 0;

       for j = r to 5 do
           begin
           _x := ShiftX(GetX(tmp), j, 2);
           _y := ShiftY(GetY(tmp), j, 2);

           if ValidHex(_x, _y) and not HexInfo(_x, _y) then
              begin
              ComMoveXY(tmp, _x, _y);
              break;
              end; 
          end;
       end;
    end;
End;

{
  Check if specify building can be build
  Returns:
  0: Can't be build
  1: Can be build
}
Export Function CanBeBuilt(depot, btype, x, y, d);
var i, j, side, pom, cost, hexes, height, dist, hex;
begin
result := false;

if not depot or not GetBType(depot) in [b_depot, b_warehouse] or not btype or not d in [0, 1, 2, 3, 4, 5] or not ValidHex(x, y) then
   exit;

pom := GetBase(depot);
cost := CostOfBuilding(btype, GetNation(depot));

if not (GetResourceType(pom, mat_cans) >= cost[1] and
   GetResourceType(pom, mat_oil) >= cost[2] and
   GetResourceType(pom, mat_siberit) >= cost[3]) then
   exit;

//    MAX_DISTANCE 28 (26 in vanilla)
//    MAX_DISTANCE_BONUS 12

if GetBType(depot) = b_depot then
   dist := 28
  else
   dist := 36;

if GetDistUnitXY(depot, x, y) > dist then
   exit;

hexes := GetBuildingHexes(btype, x, y, d, GetNation(depot), 0);

if not hexes then
   exit;

hex := GetHexInfo(x, y);

if hex[1] then
   exit;

height := hex[2];

for i = 1 to hexes do
    begin

    if not ValidHex(hexes[i][1], hexes[i][2]) or
       HexInfo(hexes[i][1], hexes[i][2]) > 0 or
       IsEnvironment(hexes[i][1], hexes[i][2]) then
       exit;

    j := GetHexInfo(hexes[i][1], hexes[i][2]);

    if j[1] or j[2] > height+2 or j[2] < height-2 or
       not j[3] in [0, 8, 9, 10, 11, 12, 13, 16, 17, 18, 19, 20, 21] or
       not j[5] or not j[6] in [1, 2, 7, 9, 10, 11] then
       exit;

    end;

side := GetSide(depot);

if DangerAtRangeXY(side, x, y, 20)[4] then
   exit;

if btype in [b_oil_mine, b_siberite_mine] and not GetResourceVisibility(x, y, side) then
   exit;

result := true;
End;

{
GetHexInfo usage:
[istnieje, wysokoœæ, zbocze, woda (wysokosc?), typ, teren]

Wysokoœæ - Wysokoœæ danego hexu.
Zbocze - osobny numer dla ka¿dego kierunku i nachylenia
bia³e:
nachylenie 1 w kierunkach od 0 do 5:
8, 9, 10, 11, 12, 13
nachylenie 2 w kierunkach od 0 do 5:
16, 17, 18, 19, 20, 21
¿ó³te:
nachylenie 3 w kierunkach od 0 do 5:
24, 25, 26, 27, 28, 29
nachylenie 4 w kierunkach od 0 do 5:
32, 33, 34, 35, 36, 37
czerwone:
nachylenie 5 w kierunkach od 0 do 5:
40, 41, 42, 43, 44, 45
nachylenie 6 w kierunkach od 0 do 5:
48, 49, 50, 51, 52, 53

Woda - G³êbokoœæ, dla obu typów wód i bagna
typ - 1 dla wody i bagna lub stoków (chyba chodzi o hexy przez które jednostki musz¹ zwalniaæ), 0 dla p³askich hexów
Teren - w tej samej kolejnoœci co w edytorze:
1: earth 2: needles 3: don't enter 4: don't enter water 5: water
6: don't enter rock 7: rock 8: swamp 9: snee 10: road 11: bank
}

{
   Function by 0dd1
   Source: https://forum.original-war.net/viewtopic.php?f=42&t=5749
}
Export Function GetBuildingHexes(btype, x, y, dir, nation, mode);
var i, temp_list, temp_list2;
var fDepotAm0, fDepotAm1, fDepotAm2, fDepotAm3, fDepotAm4, fDepotAm5, fDepotAr0, fDepotAr1, fDepotAr2, fDepotAr3, fDepotAr4, fDepotAr5, fDepotRu0, fDepotRu1, fDepotRu2, fDepotRu3, fDepotRu4, fDepotRu5;
var fFactory0, fFactory1, fFactory2, fFactory3, fFactory4, fFactory5, fExt0, fExt1, fExt2, fExt3, fExt4, fExt5;
var fLab0, fLab1, fLab2, fLab3, fLab4, fLab5, fControlTower0, fControlTower1, fControlTower2, fControlTower3, fControlTower4, fControlTower5;
var fBarracks0, fBarracks1, fBarracks2, fBarracks3, fBarracks4, fBarracks5, fBunker0, fBunker1, fBunker2, fBunker3, fBunker4, fBunker5;
begin
     result = [];
     temp_list = [];

     if not dir in [0,1,2,3,4,5] or (btype in [b_depot,b_warehouse] and not nation in [nation_american,nation_arabian,nation_russian]) then
        exit;

     if btype in [b_lab,b_lab_half,b_lab_full,b_lab_biological,b_lab_computer,b_lab_opto,b_lab_siberium,b_lab_spacetime,b_lab_weapon] then
        btype = b_lab;

     if not mode in [0,1,2] or (not btype in [b_depot,b_warehouse,b_workshop,b_factory,b_lab,b_control_tower,b_armoury,b_barracks,b_breastwork, b_bunker, b_turret] and mode = 1) or (not btype in [b_workshop,b_factory] and mode = 2) then
        mode = 0;


     case mode of
          0: begin
                  // Building Hexes
                  fDepotAm0 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[1,2],[0,2],[-1,1],[1,3],[0,3],[-1,2]];
                  fDepotAm1 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[1,-1],[2,0],[2,1],[-1,1],[-2,0],[-2,-1],[-2,1],[-3,0],[-3,-1]];
                  fDepotAm2 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[2,1],[2,2],[1,2],[-2,-1],[-2,-2],[-2,-3],[-3,-2],[-3,-3]];
                  fDepotAm3 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[1,2],[0,2],[-1,1],[-1,-3],[0,-3],[1,-2]];
                  fDepotAm4 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[1,-1],[2,0],[2,1],[-1,1],[-2,0],[-2,-1],[2,-1],[3,0],[3,1]];
                  fDepotAm5 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[2,1],[2,2],[1,2],[-2,-1],[-2,-2],[3,2],[3,3],[2,3]];

                  fDepotAr0 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fDepotAr1 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fDepotAr2 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fDepotAr3 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fDepotAr4 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fDepotAr5 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];

                  fDepotRu0 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[-2,-3],[-1,-3],[1,-2],[2,-1]];
                  fDepotRu1 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[1,-2],[2,-1],[3,1],[3,2]];
                  fDepotRu2 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[3,1],[3,2],[2,3],[1,3]];
                  fDepotRu3 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[2,3],[1,3],[-1,2],[-2,1]];
                  fDepotRu4 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[-1,2],[-2,1],[-3,-1],[-3,-2]];
                  fDepotRu5 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[-2,-3],[-1,-3],[-3,-1],[-3,-2]];

                  fFactory0 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[1,2],[0,2],[-1,1],[-2,-1],[-2,-2],[-2,-3],[2,-1],[3,1],[1,3],[-1,2],[-3,-2]];
                  fFactory1 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[-1,1],[-2,0],[-2,-1],[-1,-3],[1,-2],[3,2],[2,3],[-2,1],[-3,-1]];
                  fFactory2 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,-1],[-2,-2],[-2,-3],[2,-1],[3,1],[1,3],[-1,2],[-3,-2]];
                  fFactory3 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-1,-3],[1,-2],[3,2],[2,3],[-2,1],[-3,-1]];
                  fFactory4 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[1,-1],[2,0],[2,1],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[-2,-3],[2,-1],[3,1],[1,3],[-1,2],[-3,-2]];
                  fFactory5 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,1],[2,2],[1,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[-1,-3],[1,-2],[3,2],[2,3],[-2,1],[-3,-1]];

                  fExt0 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[2,1],[-2,-1]];
                  fExt1 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[1,2]];
                  fExt2 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[1,-1],[-1,1]];
                  fExt3 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[2,1],[-2,-1]];
                  fExt4 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[1,2]];
                  fExt5 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[1,-1],[-1,1]];

                  fLab0 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[-2,-3],[2,-1],[3,0],[3,1],[3,2],[3,3],[2,3],[-2,1],[-3,0],[-3,-1],[-3,-2],[-3,-3]];
                  fLab1 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,-1],[-2,-2],[-2,-3],[-1,-3],[0,-3],[1,-2],[3,2],[3,3],[2,3],[1,3],[0,3],[-1,2],[-3,-2],[-3,-3]];
                  fLab2 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-1,-3],[0,-3],[1,-2],[2,-1],[3,0],[3,1],[1,3],[0,3],[-1,2],[-2,1],[-3,0],[-3,-1]];
                  fLab3 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[-1,1],[-2,0],[-2,-1],[-2,-2],[-2,-3],[2,-1],[3,0],[3,1],[3,2],[3,3],[2,3],[-2,1],[-3,0],[-3,-1],[-3,-2],[-3,-3]];
                  fLab4 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,-1],[-2,-2],[-2,-3],[-1,-3],[0,-3],[1,-2],[3,2],[3,3],[2,3],[1,3],[0,3],[-1,2],[-3,-2],[-3,-3]];
                  fLab5 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-1,-3],[0,-3],[1,-2],[2,-1],[3,0],[3,1],[1,3],[0,3],[-1,2],[-2,1],[-3,0],[-3,-1]];

                  fControlTower0 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[-2,-1],[-2,-2]];
                  fControlTower1 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1]];
                  fControlTower2 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[1,-1],[2,0],[2,1],[2,2],[1,2]];
                  fControlTower3 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[2,1],[2,2],[1,2],[0,2],[-1,1]];
                  fControlTower4 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[1,2],[0,2],[-1,1],[-2,0],[-2,-1]];
                  fControlTower5 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[-1,1],[-2,0],[-2,-1],[-2,-2]];

                  fBarracks0 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fBarracks1 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fBarracks2 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fBarracks3 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fBarracks4 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  fBarracks5 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1],[-1,-2],[0,-2],[1,-1],[2,0],[2,1],[2,2],[1,2],[0,2],[-1,1],[-2,0],[-2,-1],[-2,-2]];
                  
                  fBunker0 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1]];
                  fBunker1 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1]];
                  fBunker2 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1]];
                  fBunker3 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1]];
                  fBunker4 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1]];
                  fBunker5 = [[0,0],[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1]];
             end;

          1: begin
                  // Exits
                  fDepotAm0 = [[-1,-3],[0,-3],[1,-2]];
                  fDepotAm1 = [[2,-1],[3,0],[3,1]];
                  fDepotAm2 = [[3,2],[3,3],[2,3]];
                  fDepotAm3 = [[1,3],[0,3],[-1,2]];
                  fDepotAm4 = [[-2,1],[-3,0],[-3,-1]];
                  fDepotAm5 = [[-2,-3],[-3,-2],[-3,-3]];

                  fDepotAr0 = [[-1,-3],[0,-3],[1,-2]];
                  fDepotAr1 = [[2,-1],[3,0],[3,1]];
                  fDepotAr2 = [[3,2],[3,3],[2,3]];
                  fDepotAr3 = [[1,3],[0,3],[-1,2]];
                  fDepotAr4 = [[-2,1],[-3,0],[-3,-1]];
                  fDepotAr5 = [[-2,-3],[-3,-2],[-3,-3]];

                  fDepotRu0 = [[0,-3],[-1,-4],[1,-3]];
                  fDepotRu1 = [[3,0],[3,-1],[4,1]];
                  fDepotRu2 = [[3,3],[4,3],[3,4]];
                  fDepotRu3 = [[0,3],[1,4],[-1,3]];
                  fDepotRu4 = [[-3,0],[-3,1],[-4,-1]];
                  fDepotRu5 = [[-3,-3],[-3,-4],[-4,-3]];

                  fFactory0 = [[-1,-3],[0,-3],[1,-2],[-1,-4],[0,-4],[1,-3],[-1,-5],[0,-5],[1,-4],[-1,-6],[0,-6],[1,-5]];
                  fFactory1 = [[2,-1],[3,0],[3,1],[3,-1],[4,0],[4,1],[4,-1],[5,0],[5,1],[5,-1],[6,0],[6,1]];
                  fFactory2 = [[3,2],[3,3],[2,3],[4,3],[4,4],[3,4],[5,4],[5,5],[4,5],[6,5],[6,6],[5,6]];
                  fFactory3 = [[1,3],[0,3],[-1,2],[1,4],[0,4],[-1,3],[1,5],[0,5],[-1,4],[1,6],[0,6],[-1,5]];
                  fFactory4 = [[-2,1],[-3,0],[-3,-1],[-3,1],[-4,0],[-4,-1],[-4,1],[-5,0],[-5,-1],[-5,1],[-6,0],[-6,-1]];
                  fFactory5 = [[-2,-3],[-3,-2],[-3,-3],[-3,-4],[-4,-3],[-4,-4],[-4,-5],[-5,-4],[-5,-5],[-5,-6],[-6,-5],[-6,-6]];
                  
                  fLab0 = [[0,-2],[-1,-3],[1,-2]];
                  fLab1 = [[2,0],[2,-1],[3,1]];
                  fLab2 = [[2,2],[3,2],[2,3]];
                  fLab3 = [[0,2],[1,3],[-1,2]];
                  fLab4 = [[-2,0],[-2,1],[-3,-1]];
                  fLab5 = [[-2,-2],[-2,-3],[-3,-2]];
                 
                  fControlTower0 = [[-2,-3],[-1,-3]];
                  fControlTower1 = [[1,-2],[2,-1]];
                  fControlTower2 = [[3,1],[3,2]];
                  fControlTower3 = [[2,3],[1,3]];
                  fControlTower4 = [[-1,2],[-2,1]];
                  fControlTower5 = [[-3,-1],[-3,-2]];

                  fBarracks0 = [[-1,-3],[0,-3],[1,-2]];
                  fBarracks1 = [[2,-1],[3,0],[3,1]];
                  fBarracks2 = [[3,2],[3,3],[2,3]];
                  fBarracks3 = [[1,3],[0,3],[-1,2]];
                  fBarracks4 = [[-2,1],[-3,0],[-3,-1]];
                  fBarracks5 = [[-2,-3],[-3,-2],[-3,-3]];

                  fBunker0 = [[-1,-2],[0,-2],[1,-1]];
                  fBunker1 = [[1,-1],[2,0],[2,1]];
                  fBunker2 = [[2,1],[2,2],[1,2]];
                  fBunker3 = [[1,2],[0,2],[-1,1]];
                  fBunker4 = [[-1,1],[-2,0],[-2,-1]];
                  fBunker5 = [[-1,-2],[-2,-1],[-2,-2]];
             end;

          2: begin
                  // Extensions
                  fFactory0 = [[4,0],[4,-1],[5,0],[5,1],[4,1],[3,0],[3,-1],[3,-2],[5,2],[3,3],[3,2],[4,3],[4,4],[3,4],[2,3],[2,2],[4,2],[2,4],[0,4],[0,3],[1,4],[1,5],[0,5],[-1,4],[-1,3],[2,5],[-2,3],[-3,0],[-3,-1],[-2,0],[-2,1],[-3,1],[-4,0],[-4,-1],[-4,-2],[-2,2],[-4,-4],[-4,-5],[-3,-4],[-3,-3],[-4,-3],[-5,-4],[-5,-5],[-3,-5],[-5,-3]];
                  fFactory1 = [[4,4],[4,3],[5,4],[5,5],[4,5],[3,4],[3,3],[5,3],[3,5],[0,3],[0,2],[1,3],[1,4],[0,4],[-1,3],[-1,2],[2,4],[-2,2],[-4,0],[-4,-1],[-3,0],[-3,1],[-4,1],[-5,0],[-5,-1],[-5,-2],[-3,2],[-3,-3],[-3,-4],[-2,-3],[-2,-2],[-3,-2],[-4,-3],[-4,-4],[-2,-4],[-4,-2],[0,-4],[0,-5],[1,-4],[1,-3],[0,-3],[-1,-4],[-1,-5],[2,-3],[-2,-5]];
                  fFactory2 = [[0,4],[0,3],[1,4],[1,5],[0,5],[-1,4],[-1,3],[2,5],[-2,3],[-3,0],[-3,-1],[-2,0],[-2,1],[-3,1],[-4,0],[-4,-1],[-4,-2],[-2,2],[-4,-4],[-4,-5],[-3,-4],[-3,-3],[-4,-3],[-5,-4],[-5,-5],[-3,-5],[-5,-3],[0,-3],[0,-4],[1,-3],[1,-2],[0,-2],[-1,-3],[-1,-4],[2,-2],[-2,-4],[4,0],[4,-1],[5,0],[5,1],[4,1],[3,0],[3,-1],[3,-2],[5,2]];
                  fFactory3 = [[-4,0],[-4,-1],[-3,0],[-3,1],[-4,1],[-5,0],[-5,-1],[-5,-2],[-3,2],[-3,-3],[-3,-4],[-2,-3],[-2,-2],[-3,-2],[-4,-3],[-4,-4],[-2,-4],[-4,-2],[0,-4],[0,-5],[1,-4],[1,-3],[0,-3],[-1,-4],[-1,-5],[2,-3],[-2,-5],[3,0],[3,-1],[4,0],[4,1],[3,1],[2,0],[2,-1],[2,-2],[4,2],[4,4],[4,3],[5,4],[5,5],[4,5],[3,4],[3,3],[5,3],[3,5]];
                  fFactory4 = [[-4,-4],[-4,-5],[-3,-4],[-3,-3],[-4,-3],[-5,-4],[-5,-5],[-3,-5],[-5,-3],[0,-3],[0,-4],[1,-3],[1,-2],[0,-2],[-1,-3],[-1,-4],[2,-2],[-2,-4],[4,0],[4,-1],[5,0],[5,1],[4,1],[3,0],[3,-1],[3,-2],[5,2],[3,3],[3,2],[4,3],[4,4],[3,4],[2,3],[2,2],[4,2],[2,4],[0,4],[0,3],[1,4],[1,5],[0,5],[-1,4],[-1,3],[2,5],[-2,3]];
                  fFactory5 = [[0,-4],[0,-5],[1,-4],[1,-3],[0,-3],[-1,-4],[-1,-5],[2,-3],[-2,-5],[3,0],[3,-1],[4,0],[4,1],[3,1],[2,0],[2,-1],[2,-2],[4,2],[4,4],[4,3],[5,4],[5,5],[4,5],[3,4],[3,3],[5,3],[3,5],[0,3],[0,2],[1,3],[1,4],[0,4],[-1,3],[-1,2],[2,4],[-2,2],[-4,0],[-4,-1],[-3,0],[-3,1],[-4,1],[-5,0],[-5,-1],[-5,-2],[-3,2]];
             end;
     end;         


     case btype of
          b_depot, b_warehouse: case nation of
                                     nation_american: temp_list = [fDepotAm0, fDepotAm1, fDepotAm2, fDepotAm3, fDepotAm4, fDepotAm5][dir+1];
                                     nation_arabian: temp_list = [fDepotAr0, fDepotAr1, fDepotAr2, fDepotAr3, fDepotAr4, fDepotAr5][dir+1];
                                     nation_russian: temp_list = [fDepotRu0, fDepotRu1, fDepotRu2, fDepotRu3, fDepotRu4, fDepotRu5][dir+1];
                                end;                             

          b_workshop,b_factory: temp_list = [fFactory0, fFactory1, fFactory2, fFactory3, fFactory4, fFactory5][dir+1];

          b_ext_track,b_ext_gun,b_ext_rocket,b_ext_noncombat,b_ext_radio,
          b_ext_radar,b_ext_siberium,b_ext_stitch,b_ext_computer,b_ext_laser: temp_list = [fExt0, fExt1, fExt2, fExt3, fExt4, fExt5][dir+1];

          b_lab, b_lab_half, b_lab_full,
          b_lab_biological, b_lab_computer, b_lab_opto,
          b_lab_siberium, b_lab_spacetime, b_lab_weapon: temp_list = [fLab0, fLab1, fLab2, fLab3, fLab4, fLab5][dir+1];

          b_control_tower: temp_list = [fControlTower0, fControlTower1, fControlTower2, fControlTower3, fControlTower4, fControlTower5][dir+1];

          b_armoury,b_barracks,
          b_teleport, b_behemoth: temp_list = [fBarracks0, fBarracks1, fBarracks2, fBarracks3, fBarracks4, fBarracks5][dir+1];

          b_breastwork, b_bunker, b_turret,
          b_solar_power,b_oil_power,b_siberite_power,
          b_oil_mine, b_siberite_mine: temp_list = [fBunker0, fBunker1, fBunker2, fBunker3, fBunker4, fBunker5][dir+1];
     end;


     temp_list2 = [];
     for i in temp_list do
         temp_list2 = temp_list2 ^ [[i[1] + x, i[2] + y]];

     result = temp_list2;
End;

Export Function EnemyInRange(unit, dist);
begin
result := DangerAtRangeXY(GetSide(unit), GetX(unit), GetY(unit), dist)[4];
End;

// DEPRECATED IN MULTIPLAYER
Export Function PlayerSeeMe(unit);
begin
result := See(your_side, unit);
End;

Export Function ReverseDir(unit);
begin
if not unit then
   exit;

result := (GetDir(unit) + 3) mod 6;
End;


// hexes: [ [x1, y1], [x2, y2], ..]
Export Function GetClosestHex(unit, hexes);
var i, dist, tmp, hex;
begin
if not hexes then
   exit;

dist := 9999;

for i = 1 to hexes do
    begin
    if GetDistUnitXY(unit, hexes[i][1], hexes[i][2]) < dist then
       begin
       hex := hexes[i];
       dist := GetDistUnitXY(unit, hexes[i][1], hexes[i][2]);
       end;
    end;

result := hex;
End;

Export Function ComAutodestruct(unit);
var i;
begin
if not unit or not unit in FilterAllUnits([[f_type, unit_vehicle], [f_nation, 2]]) then
   exit;

for i = 1 to 3 do
    MineExplosion(GetX(unit), GetY(unit), 1);
End;

Export Function AttackHovercraft(unit, enemy_unit);
var i, j, tmp, x, y;
begin
if not unit or not enemy_unit or HasTask(unit) then
   exit;

x := GetX(enemy_unit);
y := GetY(enemy_unit);

if not x or not y then
   exit;

tmp := [ [ShiftX(x, 0, 4), ShiftY(y, 0, 4)],
         [ShiftX(x, 1, 4), ShiftY(y, 1, 4)],
         [ShiftX(x, 2, 4), ShiftY(y, 2, 4)],
         [ShiftX(x, 3, 4), ShiftY(y, 3, 4)],
         [ShiftX(x, 4, 4), ShiftY(y, 4, 4)],
         [ShiftX(x, 5, 4), ShiftY(y, 5, 4)]];

for i = tmp downto 1 do
    if not ValidHex(tmp[i][1], tmp[i][2]) or HexInfo(tmp[i][1], tmp[i][2]) <> 0 then
       tmp := Delete(tmp, i);

j := GetClosestHex(unit, tmp);

ComMoveXY(unit, j[1], j[2]);
End;


Export Function PrepareNature(birds, tigers, apemans, enchidnas, horses, mastodonts, fishes, nat_area, wat_area);
var i, animal;
begin
uc_side = 0;
uc_nation = 0;

InitHc_All();
InitVc;

if mastodonts then
   for i = 1 to mastodonts do
       begin
       vc_chassis := 31;
       vc_control := control_rider;
       animal := CreateVehicle;
       PlaceUnitInArea(animal, nat_area, false);
       end;

if horses then
   for i = 1 to horses do
       begin
       hc_class := 21;
       hc_gallery := '';

       animal := CreateHuman;
       PlaceUnitInArea(animal, nat_area, false);
       end;

if birds then
   for i = 1 to birds do
       begin
       hc_class = 18;
       hc_gallery = '';

       animal := CreateHuman;
       PlaceUnitInArea(animal, nat_area, false);
       end;

if tigers then
   for i = 1 to tigers do
       begin
       hc_class = class_tiger;
       hc_gallery = '';
       hc_agressivity = Rand(-7, 7);

       animal := CreateHuman;
       PlaceUnitInArea(animal, nat_area, false);
       end;

if apemans then
   for i = 1 to apemans do
       begin
       hc_class = class_apeman;
       hc_gallery = '';
       hc_agressivity = rand(-5, 5);
       hc_skills := [rand(1, 3), rand(1, 3), 0, 0];

       animal := CreateHuman;
       PlaceUnitInArea(animal, nat_area, false);
       end;


if enchidnas then
   for i = 1 to enchidnas do
       begin
       hc_class = 13;
       hc_gallery = '';

       animal := CreateHuman;
       PlaceUnitInArea(animal, nat_area, false);
       end;


if fishes then
   for i = 1 to fishes do
       begin
       hc_class = 20;
       hc_gallery = '';

       animal := CreateHuman;
       PlaceUnitInArea(animal, wat_area, false);
       end;

End;

Export Function WantHeal(sci, unit);
begin
if GetTaskList(sci) > 0 then
   begin
   if GetTaskList(sci)[1][1] = 'l' and GetTaskList(sci)[1][4] = unit then
      result := true
       else
        result := false;
   end
    else
     result := false;
End;

Export Function HealTarget(sci);
begin
if not sci then
   exit;

result := 0;

if GetTaskList(sci) then
   if GetTaskList(sci)[1][1] = 'l' then
      result := GetTaskList(sci)[1][4];
End;





// DEPRECATED
Export Function _ScanBase(base_units);
var i, t, tmp;
begin
if not base_units then
   exit;

result := false;

tmp := UnitFilter(base_units, [f_type, unit_building]);

if not tmp then
   exit;

for i in tmp do
    begin
    result := EnemyInRange(i, 22);

    if result then
       exit;
    end;
End;

Export Function FilterByTag(units, tag);
var i;
begin
if not units then
   exit;

result := [];

for i in units do
    if GetTag(i) = tag then
       result := Insert(result, result+1, i);
End;

Export Function IsDriver(un);
begin
result := un in FilterAllUnits([f_driving]);
End;

Export Function GetFacExtXYD(x, y, d);
var list;
begin
list := [];

     Case d of
     0: begin
        list := [[x-4, y-4, 2], [x-3, y, 1], [x+4, y, 4], [x+3, y+3, 5], [x, y+4, 0]];
        end;
     1: begin
        list := [[x, y-4, 3], [x-3, y-3, 2], [x-4, y, 1], [x, y+3, 0], [x+4, y+4, 5]];
        end;
     2: begin
        list := [[x, y-3, 3], [x+4, y, 4], [x, y+4, 0], [x-3, y, 1], [x-4, y-4, 2]];
        end;
     3: begin
        list := [[x+3, y, 4], [x+4, y+4, 5], [x-4, y, 1], [x, y-4, 3], [x-3, y-3, 2]];
        end;
     4: begin
        list := [[x, y+4, 0], [x+3, y+3, 5], [x+4, y, 4], [x, y-3, 3], [x-4, y-4, 2]];
        end;
     5: begin
        list := [[x-4, y, 1], [x, y-4, 3], [x+4, y+4, 5], [x+3, y, 4], [x, y+3, 0]];
        end;
     End;

result := list;
End;

Export Function SortBySkill(units, class);
var i, tmp;
begin
if not units or not class in [1, 2, 3, 4] then
   exit;

tmp := [];

for i in units do
    tmp := Insert(tmp, tmp+1, GetSkill(i, class));

if not tmp then
   exit;

result := SortListByListDesc(units, tmp);
End;

Export Function UnitGoingToBuilding(unit, building);
var x, y;
begin
result := false;

x := GetX(building);
y := GetY(building);

if not building or not x or not y then
   exit;

if GetTaskList(unit) then
   begin
   if 'e' = GetTaskList(unit)[1][1] and
        x = GetTaskList(unit)[1][2] and
        y = GetTaskList(unit)[1][3] then
        result := true
   end;
End;

Export Function UnitGoingToXY(unit, x, y);
begin
result := false;

if GetTaskList(unit) then
   begin
   if 'M' = GetTaskList(unit)[1][1] and
        x = GetTaskList(unit)[1][2] and
        y = GetTaskList(unit)[1][3] then
        result := true;
   end;
End;

Export Function PlaceUnitInArea(unit, area, mode);
var i, tmp, hex;
begin
if not unit or not area then
   exit;

tmp := AreaToList(area, i);

for i = 1 to tmp[1] do
    begin
    hex := [tmp[1][i], tmp[2][i]];

    if HexInfo(hex[1], hex[2]) = 0 then
       begin
       PlaceUnitXY(unit, hex[1], hex[2], mode);
       result := IsPlaced(unit);
       exit;
       end;
    end;
End;

Export Function BuildingsListDump(side);
var i, tmp;
begin
if not side or side > 8 then
   exit;

tmp := FilterAllUnits([[f_side, side], [f_type, unit_building]]);

if not tmp then
   exit;


enable_addtolog := true;

AddToLog('[');

for i in tmp do
    begin
    AddToLog('[' & GetBType(i) & ', ' & GetX(i) & ', ' & GetY(i) & ', ' & GetDir(i) & ', ' & GetLabKind(i, 1) & ', ' & GetLabKind(i, 2) & '],');
    end;

AddToLog('];');
End;

Export Function Crates(area, rate, min, max);
var i, r, time, amount;
begin
if not area or not rate or not max then
   exit;

while 1 do
   begin
   amount := GetResourceArea(area, mat_cans) * 10;
   r := rate / 10;
   time := 1$00;

   if amount < min then
      r := r * 2
   else if amount > max then
      r := r / 2;

   time := time / r;

   if time < 0 then
      time := time * -1;

   wait(time);
   wait(rand(0$01, 0$25));

   CreateCratesArea(rand(1, 5), area, true);
   end;
End;

Export Function UpgradeTurretsWeapon(turrets, factories);
var i, j, k, nat, weapon, weapons, list;
begin
if not turrets or not factories then
   exit;

list := [
            [
                [us_double_gun, us_heavy_gun],
                [us_machine_gun, us_gatling_gun],
                [us_light_gun, us_double_gun]
            ],
            [
                [ar_double_machine_gun, ar_gatling_gun],
                [ar_light_gun, ar_gun]
            ],
            [
                [ru_heavy_machine_gun, ru_gatling_gun],
                [ru_gun, ru_heavy_gun],
                [ru_rocket_launcher, ru_rocket]
            ],
        ];

result := [];

for i in turrets do
    begin
    nat := GetNation(i);
    weapon := 0;

    if not nat then
       continue;

    for j in list[nat] do
        if GetBWeapon(i) = j[1] then
           begin
           weapon := j[2];
           break;
           end;

    if not weapon then
       continue;

    for k in factories do
        begin
        weapons := AvailableWeaponList(k);

        if not weapons then
           continue;

        if weapon in weapons then
           begin
           result := [i, weapon];
           exit;
           end;
        end;

    end;

End;

Export Function RevealMapOnXY(x, y, side, range);
begin
if not side or side > 8 then
   exit;

if not range then
   range := -12;

PlaceSeeing(x, y, side, range);
RemoveSeeing(x, y, side);
End;

Export function Video(mode);
begin
ingame_video = mode;
interface_hidden = mode;
End;

Export Function Join(array, element);
begin
result := Replace(array, array + 1, element);
End;

Export Function JoinUnion(array, element);
begin
result := array union element;
End;

Export Function GetBehemoths(side);
begin
result := FilterAllUnits([[f_side, side], [f_chassis, 25]]);
End;

Export Function Shuffle(array);
var i, index;
begin
result := [];

if not array then
   exit;

Randomize;

for i = array downto 1 do
    begin
    index := rand(1, array);
    result := Insert(result, result + 1, array[index]);
    array := Delete(array, index);
    end;
End;

Export Function GetBaseMaterials(base);
begin
result := [0, 0, 0];

if not base then
   exit;

result := [
   GetResourceType(base, mat_cans),
   GetResourceType(base, mat_oil),
   GetResourceType(base, mat_siberit)
];
End;

Export Function ShrinkArray(array, size);
var i;
begin
result := array;

if size > 0 then
   for i := array downto size do
       result := Delete(result, result);
End;

Export Function ComExit(unit);
var tmp;
begin
if not IsInUnit(unit) then
   exit;

tmp := IsInUnit(unit);

if GetType(tmp) = unit_vehicle then
   ComExitVehicle(unit)
else
   ComExitBuilding(unit);

result := tmp;
End;

Export Function ComExitAll(units);
var i;
begin
if not units then
   exit;

for i in units do
    ComExit(i);
End;

Export Function ResetHc;
begin
InitHc;
hc_importance := 0;
End;

Export Function PointBetweenXY(x1, y1, x2, y2);
var _x, _y;
begin
_x := (x1 + x2) div 2;

if _x < 0 then
   _x := _x * -1;

_y := (y1 + y2) div 2;

if _y < 0 then
   _y := _y * -1;

result := [_x, _y];
End;

Export Function NotGoToAreaUnit(unit, area, goAway);
var x, y, task;
begin
task := GetTaskList(unit);

if not task and not IsInArea(unit, area) then
   exit;

if IsInArea(unit, area) then
   begin
   ComMoveToArea(unit, goAway);
   exit;
   end;

if task[1][1] <> 'M' then
   exit;

x := task[1][2];
y := task[1][3];

if InArea(x, y, area) then
   ComStop(unit);
End;

Export Function Abs(value);
begin
result := value;

if value < 0 then
   result := value * -1;
End;

Export Function ComMoveToNearbyEntrance(unit, building);
var x, _x, y, _y, d, r, i;
begin
if not unit or not building then
   exit;

x := GetX(building);
y := GetY(building);
d := GetDir(building);

r := 4;

for i := 1 to 5 do
    begin
    _x := ShiftX(x, d, r + i);
    _y := ShiftY(y, d, r + i);

    if ValidHex(_x, _y) and not GetType(HexInfo(_x, _y)) in [unit_building, unit_vehicle] then
       begin
       ComMoveXY(unit, _x, _y);
       result := [_x, _y];
       exit;
       end;
    end;
End;

// Return ID of unit from side1 which attacked side2
Export Function SideAttackedSide(side1, side2);
var i, un;
begin
result := 0;

if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
   exit;

for i in FilterAllUnits([f_side, side2]) do
    begin
    un := UnitShoot(i);

    if GetSide(un) = side1 then
       begin
       result := un;
       exit;
       end;
    end;
End;

Export Function GetCargoBay(units);
begin
result := UnitFilter(units, [f_or, [f_weapon, us_cargo_bay],
                                   [f_weapon, ru_cargo_bay],
                                   [f_weapon, ar_cargo_bay],
                                   [f_weapon, ru_big_cargo_bay]]);
End;




