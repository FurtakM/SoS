// Sand of Siberia
// Weapons Logic
// by Serpent
// 14-11-2020
Export Function SOS_UnitDestroyed(un);
var i, eff, side;
begin
if GetWeapon(un) = ar_bio_bomb then
   begin
   // upgrade for 3 bio
   if GetTech(tech_bio3, GetSide(un)) = state_researched then
      eff := 70
   else
      eff := 30;

   ArtContamination(GetX(un), GetY(un), eff);
   end;
End;

Export Function SOS_UnitExtraDestroyed(un, killerSide, killerUnit);
begin

End;

Export Function SOS_Command(cmd);
begin

End;

Export Function SOS_TargetableSAIL(cmd, unit, selectedUnit, x, y);
begin
if cmd = 254 and GetWeapon(unit) = us_hack and GetControl(selectedUnit) = control_computer then
   HackDestroyVehicle(unit, selectedUnit);
if cmd = 255 and GetWeapon(unit) in [us_bulldozer, ru_bulldozer] and ValidHex(x, y) then
   CutTreeXYR(unit, x, y, 12);
End;

Function CutTreeXYR(bulldozer, x, y, r);
var i, min_x, min_y, max_x, max_y, _x, _y, list;
begin
if not bulldozer or not ValidHex(x, y) or not r then
   exit;

list := [];

if x - r < 0 then
   min_x := 0
else
   min_x := x - r;

if y - r < 0 then
   min_y := 0
else
   min_y := y - r;

max_x := x + r;
max_y := y + r;

for _x = min_x to max_x do
    for _y = min_y to max_y do
        begin
        if not ValidHex(_x, _y) then
           continue;

        if IsEnvironment(_x, _y) and IsEnvironmentDestroyable(_x, _y) then
           list := Insert(list, list + 1, [_x, _y]);
        end;

if not list then
   exit;

for i in list do
    AddTaskList(bulldozer, [['M', i[1], i[2], 0, 0, 0, 0]]);
End;

// us_hack script
Export initHack, hackTanks, hackTanksCaptured, hackLimit, hackDist, hackCounter;
Every 0$1 trigger not initHack do
begin
initHack := true;
hackTanks := [];
hackTanksCaptured := [];
hackLimit := 3;
hackDist := 12;
hackCounter := [];
End;

Every 0$1 trigger initHack and FilterAllUnits([f_weapon, us_hack]) do
var i, tmp;
begin
enable;

for i in FilterAllUnits([f_weapon, us_hack]) do
    begin
    if not i in hackTanks then
       begin
       hackTanks := Replace(hackTanks, hackTanks + 1, i);
       hackTanksCaptured := Replace(hackTanksCaptured, hackTanksCaptured + 1, []);
       hackCounter := Replace(hackCounter, hackCounter + 1, []);
       end;

    if not IsOk(i) then
       begin
       HackUnlinkAll(i);
       continue;
       end;

    HackCheckCapturedStatus(i);

    tmp := FilterAllUnits([[f_enemy, GetSide(i)], [f_control, control_computer], [f_dist, i, hackDist], [f_ok]]);

    if not tmp then
       continue;

    HackLink(i, tmp);
    end;
End;

Function HackUnlinkAll(hack);
var i, index;
begin
if not hack in hackTanks then
   exit;

index := GetElementIndex(hackTanks, hack);

if hackTanksCaptured[index] then
   begin
   for i in hackTanksCaptured[index] do
       SetSide(i[1], i[2]);

   hackTanksCaptured := Replace(hackTanksCaptured, index, []);
   SetUnitDisplayNumber(hack, 0);
   end;
End;

Function HackLink(hack, vehicles);
var i, index;
begin
if not hack in hackTanks or not vehicles then
   exit;

vehicles := SortByDistanceUnit(hack, vehicles, true, true);
index := GetElementIndex(hackTanks, hack);

if hackTanksCaptured[index] < hackLimit then
   begin
   for i := 1 to vehicles do
       begin
       if hackTanksCaptured[index] = hackLimit then
          break;

       hackCounter := Replace(hackCounter, index, hackCounter[index] + 1);
       hackTanksCaptured := ReplaceIn(hackTanksCaptured, [index, hackTanksCaptured[index] + 1], [vehicles[i], GetSide(vehicles[i])]);
       SetSide(vehicles[i], GetSide(hack));
       ComStop(vehicles[i]);
       end;
   end;

SetUnitDisplayNumber(hack, hackTanksCaptured[index] + 0);
End;

Function HackCheckCapturedStatus(hack);
var i, index, tmp;
begin
if not hack in hackTanks then
   exit;

index := GetElementIndex(hackTanks, hack);

for i := hackTanksCaptured[index] downto 1 do
    begin
    tmp := hackTanksCaptured[index][i];

    if not IsOk(tmp[1]) or GetSide(tmp[1]) <> GetSide(hack) then
       begin
       if IsPlaced(tmp[1]) and GetSide(tmp[1]) = GetSide(hack) then
          SetSide(tmp[1], tmp[2]);

       hackTanksCaptured := Replace(hackTanksCaptured, index, Delete(hackTanksCaptured[index], i));
       end;
    end;

SetUnitDisplayNumber(hack, hackTanksCaptured[index] + 0);
End;

Export Function HackDestroyVehicle(hack, vehicle);
var i, index, tmp;
begin
if not hack in hackTanks then
   exit;

index := GetElementIndex(hackTanks, hack);

for i := 1 to hackTanksCaptured[index] do
    if hackTanksCaptured[index][i][1] = vehicle then
       KillUnit(vehicle);
End;