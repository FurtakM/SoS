Export function Multiplayer_UnitDestroyed(un);
var i, ape, tag, class, area, nation, side, tmp;
begin
if GetType(un) = unit_vehicle then
   exit;

side := GetSide(un);

if mpGameType in [GameTypeSurvival, GameTypeSurvivalHardcore] then
   if GetBType(un) in [b_depot, b_warehouse] then
      begin
      for i in FilterAllUnits([[f_side, side], [f_or, [f_type, unit_human], [f_control, control_computer]]]) do
          KillUnit(i);
      end;

if mpGameType = GameTypeSurvivalHardcore then
   if un in mpCommanders then
      begin
      for i in FilterAllUnits([[f_side, side], [f_or, [f_type, unit_human], [f_control, control_computer]]]) do
          KillUnit(i);
      end;

if GetClass(un) in [class_apeman, class_apeman_kamikaze, class_apeman_soldier, class_apeman_engineer] or GetControl(un) = control_apeman then
   begin
   tag := 0;

   for i := 1 to 8 do
       if un in mpApePosIndex[i] then
          begin
          tag := i;
          break;
          end;

   if not tag then
      exit;

   area := mpApemansArea[mpSidePositions[tag]];

   if not area then
      exit;

   wait(7$00 + (((un mod 5) + 1) * 0$20));

   repeat
    wait(10);
   until not mpBlockRespThread;

   mpBlockRespThread := true;

   PrepareApeman(0);
   ape := CreateHuman;
   mpApePosIndex := Replace(mpApePosIndex, tag, Join(mpApePosIndex[tag], ape));
   PlaceUnitArea(ape, area, false);

   wait(10);

   mpBlockRespThread := false;
   end;

if GetType(un) = unit_human and GetNation(un) > nation_nature then
   begin
   if not mpRespawn then
      exit;

   if not MultiplayerSideAlive(side) and not HasPowerByGameType(mpGameType, side) then
      exit;

   side := GetSide(un);
   nation := GetNation(un);
   class := GetClass(un);

   if class > 4 then
      class := 1;   
   
   repeat
    wait(10);
   until not mpBlockRespThread;

   mpBlockRespThread := true;

   uc_side := side;
   uc_nation := nation;

   PrepareHuman(false, class, 2);

   un := CreateHuman;       

   mpRespawnPull := Replace(mpRespawnPull, side, Replace(mpRespawnPull[side], mpRespawnPull[side] + 1, un));

   wait(10);

   mpBlockRespThread := false;
   end;
End;

Export function Multiplayer_VehicleConstruction_ApeConsumed(factory, un);
var i, tag, area, ape;
begin
tag := 0;

for i := 1 to 8 do
    if un in mpApePosIndex[i] then
       begin
       tag := i;
       break;
       end;

if not tag then
   exit;

area := mpApemansArea[mpSidePositions[tag]];

if not area then
   exit;

wait(7$00 + (((un mod 5) + 1) * 0$20));

repeat
 wait(10);
until not mpBlockRespThread;

mpBlockRespThread := true;

PrepareApeman(0);
ape := CreateHuman;
mpApePosIndex := Replace(mpApePosIndex, tag, Join(mpApePosIndex[tag], ape));
PlaceUnitArea(ape, area, false);

wait(10);

mpBlockRespThread := false;
End;

Export function Multiplayer_BuildingComplete(building);
begin
if GetBType(building) in [b_depot, b_warehouse] then
   SetBName(building, '@' & GetSide(building));
End;

Export function Multiplayer_BuildingCaptured(building, oldSide, unit);
var i;
begin
if mpGameType in [GameTypeSurvival, GameTypeSurvivalHardcore] and GetBType(building) in [b_depot, b_warehouse] then
   begin
   SetSide(building, oldSide);
   KillUnit(building);

   for i in FilterAllUnits([[f_side, oldSide], [f_type, unit_human]]) do
       KillUnit(i);

   exit;
   end;

if GetBType(building) in [b_depot, b_warehouse] then
   SetBName(building, '@' & GetSide(building));
End;

Export function Multiplayer_OilExtracted(building, side, base, amount);
var i, value;
begin
if mpGameType <> GameTypeFamine then
   exit;

for i := 1 to mpGlobalOilDeposits do
    begin
    if HexInfo(mpGlobalOilDeposits[i][1], mpGlobalOilDeposits[i][2]) = building then
       begin
       value := mpGlobalOilDeposits[i][3]; 
       value := value - amount;

       mpGlobalOilDeposits := Replace(mpGlobalOilDeposits, i, Replace(mpGlobalOilDeposits[i], 3, value));

       if side in [your_side, 9] then
          SetUnitDisplayNumber(building, value);

       if value <= 0 then
          begin
          RemoveDepositXY(mpGlobalOilDeposits[i][1], mpGlobalOilDeposits[i][2]);
          KillUnit(building);
          exit;
          end;
       end;
    end;
End;

Export function Multiplayer_SibExtracted(building, side, base, amount);
var i, value;
begin
if mpGameType <> GameTypeFamine then
   exit;

for i := 1 to mpGlobalSibDeposits do
    begin
    if HexInfo(mpGlobalSibDeposits[i][1], mpGlobalSibDeposits[i][2]) = building then
       begin
       value := mpGlobalSibDeposits[i][3];
       value := value - amount;

       mpGlobalSibDeposits := Replace(mpGlobalSibDeposits, i, Replace(mpGlobalSibDeposits[i], 3, value));

       if side in [your_side, 9] then
          SetUnitDisplayNumber(building, value);

       if value <= 0 then
          begin
          RemoveDepositXY(mpGlobalSibDeposits[i][1], mpGlobalSibDeposits[i][2]);
          KillUnit(building);
          exit;
          end;
       end;
    end;
End;

Export function Multiplayer_VehicleConstructionStarted(factory, chassis, engine, control, weapon);
var side;
begin
side := GetSide(factory);

if weapon = ar_miner and FilterAllUnits([[f_side, side], [f_weapon, ar_miner]]) > 0 then
   begin
   ComCancel(factory);

   if side = your_side then
      HintSpec('VehLimit', 2);
   end;
End;

Export function Multiplayer_VehicleCaptured(newId, oldId, oldSide, unit);
var i, j;
begin
if GetWeapon(newId) = ar_miner and GetControl(newId) = control_manual then
   begin
   for i := 1 to Count(minersList) do
       begin
       if minersList[i] = oldId then
          begin
          for j := 1 to minerMinesList[i] do
              RemoveMineXY(minerMinesList[i][j][1], minerMinesList[i][j][2]);

          minerMinesList := Delete(minerMinesList, i);
          break;
          end;
       end;

   minersList := minersList diff oldId;

   if FilterAllUnits([[f_side, GetSide(unit)], [f_weapon, ar_miner]]) > 1 then
      begin
      ComExit(unit);
      SetSide(newId, oldSide);
      exit;
      end;   

   minersList := Replace(minersList, minersList + 1, newId);
   minerMinesList := Replace(minerMinesList, minerMinesList + 1, []);
   end;
End;


